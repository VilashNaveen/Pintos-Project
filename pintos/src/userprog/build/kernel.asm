
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020058 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020058:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002005d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002005f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020060:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020062:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020064:	66 05 00 04          	add    $0x400,%ax
c0020068:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002006a:	66 3d 00 00          	cmp    $0x0,%ax
c002006e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020070:	76 06                	jbe    c0020078 <start+0x20>
	mov $0x10000, %eax
c0020072:	66 b8 00 00          	mov    $0x0,%ax
c0020076:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020078:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002007c:	67 66 a3 5e 01       	addr16 mov %ax,0x15e
c0020081:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c0020083:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020085:	a8 02                	test   $0x2,%al
	jnz 1b
c0020087:	75 fa                	jne    c0020083 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c0020089:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c002008b:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c002008d:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c002008f:	a8 02                	test   $0x2,%al
	jnz 1b
c0020091:	75 fa                	jne    c002008d <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c0020093:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c0020095:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c0020097:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020099:	a8 02                	test   $0x2,%al
	jnz 1b
c002009b:	75 fa                	jne    c0020097 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c002009d:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200a2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200a5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200a8:	66 b9 00 04          	mov    $0x400,%cx
c00200ac:	00 00                	add    %al,(%eax)
	rep stosl
c00200ae:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200b1:	66 b8 07 00          	mov    $0x7,%ax
c00200b5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200b7:	66 b9 11 00          	mov    $0x11,%cx
c00200bb:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200bd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200c0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200c7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200c8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200cb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200d2:	00 e2                	add    %ah,%dl
	loop 1b
c00200d4:	eb b8                	jmp    c002008e <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200d6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200d8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200da:	66 b8 07 00          	mov    $0x7,%ax
c00200de:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c00200e0:	66 b9 00 40          	mov    $0x4000,%cx
c00200e4:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200e6:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e9:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c00200f0:	66 
	addw $4, %di
	addl $0x1000, %eax
c00200f1:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c00200f6:	e2 f1                	loop   c00200e9 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c00200f8:	66 b8 00 f0          	mov    $0xf000,%ax
c00200fc:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c00200fe:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020101:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020102:	67 66 0f 01 15       	lgdtw  (%di)
c0020107:	58                   	pop    %eax
c0020108:	01 00                	add    %eax,(%eax)
c002010a:	00 0f                	add    %cl,(%edi)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002010c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002010e:	66 0d 05 00          	or     $0x5,%ax
c0020112:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020118:	ea 1f 01 02 c0 08 00 	ljmp   $0x8,$0xc002011f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002011f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020123:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020125:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020127:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020129:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002012b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002012d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020133:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020138:	e8 79 01 00 00       	call   c00202b6 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002013d:	eb fe                	jmp    c002013d <start+0xe5>
	...

c0020140 <gdt>:
	...
c0020148:	ff                   	(bad)  
c0020149:	ff 00                	incl   (%eax)
c002014b:	00 00                	add    %al,(%eax)
c002014d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020154:	00                   	.byte 0x0
c0020155:	92                   	xchg   %eax,%edx
c0020156:	cf                   	iret   
	...

c0020158 <gdtdesc>:
c0020158:	17                   	pop    %ss
c0020159:	00 40 01             	add    %al,0x1(%eax)
c002015c:	02 c0                	add    %al,%al

c002015e <init_ram_pages>:
c002015e:	00 00                	add    %al,(%eax)
	...

c0020162 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0020162:	55                   	push   %ebp
c0020163:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0020165:	8b 45 08             	mov    0x8(%ebp),%eax
c0020168:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002016d:	5d                   	pop    %ebp
c002016e:	c3                   	ret    

c002016f <is_kernel_vaddr>:
}

/* Returns true if VADDR is a kernel virtual address. */
static inline bool
is_kernel_vaddr (const void *vaddr) 
{
c002016f:	55                   	push   %ebp
c0020170:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c0020172:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0020179:	0f 97 c0             	seta   %al
}
c002017c:	5d                   	pop    %ebp
c002017d:	c3                   	ret    

c002017e <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c002017e:	55                   	push   %ebp
c002017f:	89 e5                	mov    %esp,%ebp
c0020181:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0020184:	8b 45 08             	mov    0x8(%ebp),%eax
c0020187:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002018c:	76 1e                	jbe    c00201ac <ptov+0x2e>
c002018e:	83 ec 0c             	sub    $0xc,%esp
c0020191:	68 60 fd 02 c0       	push   $0xc002fd60
c0020196:	68 7b fd 02 c0       	push   $0xc002fd7b
c002019b:	68 24 03 03 c0       	push   $0xc0030324
c00201a0:	6a 4a                	push   $0x4a
c00201a2:	68 92 fd 02 c0       	push   $0xc002fd92
c00201a7:	e8 f1 99 00 00       	call   c0029b9d <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c00201ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00201af:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00201b4:	c9                   	leave  
c00201b5:	c3                   	ret    

c00201b6 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c00201b6:	55                   	push   %ebp
c00201b7:	89 e5                	mov    %esp,%ebp
c00201b9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c00201bc:	ff 75 08             	pushl  0x8(%ebp)
c00201bf:	e8 ab ff ff ff       	call   c002016f <is_kernel_vaddr>
c00201c4:	83 c4 04             	add    $0x4,%esp
c00201c7:	84 c0                	test   %al,%al
c00201c9:	75 1e                	jne    c00201e9 <vtop+0x33>
c00201cb:	83 ec 0c             	sub    $0xc,%esp
c00201ce:	68 a8 fd 02 c0       	push   $0xc002fda8
c00201d3:	68 7b fd 02 c0       	push   $0xc002fd7b
c00201d8:	68 4c 03 03 c0       	push   $0xc003034c
c00201dd:	6a 54                	push   $0x54
c00201df:	68 92 fd 02 c0       	push   $0xc002fd92
c00201e4:	e8 b4 99 00 00       	call   c0029b9d <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00201e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00201ec:	05 00 00 00 40       	add    $0x40000000,%eax
}
c00201f1:	c9                   	leave  
c00201f2:	c3                   	ret    

c00201f3 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c00201f3:	55                   	push   %ebp
c00201f4:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c00201f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00201f9:	c1 e8 0c             	shr    $0xc,%eax
c00201fc:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0020201:	5d                   	pop    %ebp
c0020202:	c3                   	ret    

c0020203 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c0020203:	55                   	push   %ebp
c0020204:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c0020206:	8b 45 08             	mov    0x8(%ebp),%eax
c0020209:	c1 e8 16             	shr    $0x16,%eax
}
c002020c:	5d                   	pop    %ebp
c002020d:	c3                   	ret    

c002020e <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c002020e:	55                   	push   %ebp
c002020f:	89 e5                	mov    %esp,%ebp
c0020211:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c0020214:	ff 75 08             	pushl  0x8(%ebp)
c0020217:	e8 46 ff ff ff       	call   c0020162 <pg_ofs>
c002021c:	83 c4 04             	add    $0x4,%esp
c002021f:	85 c0                	test   %eax,%eax
c0020221:	74 1e                	je     c0020241 <pde_create+0x33>
c0020223:	83 ec 0c             	sub    $0xc,%esp
c0020226:	68 c0 fd 02 c0       	push   $0xc002fdc0
c002022b:	68 7b fd 02 c0       	push   $0xc002fd7b
c0020230:	68 2c 03 03 c0       	push   $0xc003032c
c0020235:	6a 48                	push   $0x48
c0020237:	68 d1 fd 02 c0       	push   $0xc002fdd1
c002023c:	e8 5c 99 00 00       	call   c0029b9d <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020241:	83 ec 0c             	sub    $0xc,%esp
c0020244:	ff 75 08             	pushl  0x8(%ebp)
c0020247:	e8 6a ff ff ff       	call   c00201b6 <vtop>
c002024c:	83 c4 10             	add    $0x10,%esp
c002024f:	83 c8 07             	or     $0x7,%eax
}
c0020252:	c9                   	leave  
c0020253:	c3                   	ret    

c0020254 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c0020254:	55                   	push   %ebp
c0020255:	89 e5                	mov    %esp,%ebp
c0020257:	83 ec 18             	sub    $0x18,%esp
c002025a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002025d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c0020260:	ff 75 08             	pushl  0x8(%ebp)
c0020263:	e8 fa fe ff ff       	call   c0020162 <pg_ofs>
c0020268:	83 c4 04             	add    $0x4,%esp
c002026b:	85 c0                	test   %eax,%eax
c002026d:	74 1e                	je     c002028d <pte_create_kernel+0x39>
c002026f:	83 ec 0c             	sub    $0xc,%esp
c0020272:	68 e5 fd 02 c0       	push   $0xc002fde5
c0020277:	68 7b fd 02 c0       	push   $0xc002fd7b
c002027c:	68 38 03 03 c0       	push   $0xc0030338
c0020281:	6a 58                	push   $0x58
c0020283:	68 d1 fd 02 c0       	push   $0xc002fdd1
c0020288:	e8 10 99 00 00       	call   c0029b9d <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002028d:	83 ec 0c             	sub    $0xc,%esp
c0020290:	ff 75 08             	pushl  0x8(%ebp)
c0020293:	e8 1e ff ff ff       	call   c00201b6 <vtop>
c0020298:	83 c4 10             	add    $0x10,%esp
c002029b:	89 c2                	mov    %eax,%edx
c002029d:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c00202a1:	74 07                	je     c00202aa <pte_create_kernel+0x56>
c00202a3:	b8 02 00 00 00       	mov    $0x2,%eax
c00202a8:	eb 05                	jmp    c00202af <pte_create_kernel+0x5b>
c00202aa:	b8 00 00 00 00       	mov    $0x0,%eax
c00202af:	09 d0                	or     %edx,%eax
c00202b1:	83 c8 01             	or     $0x1,%eax
}
c00202b4:	c9                   	leave  
c00202b5:	c3                   	ret    

c00202b6 <pintos_init>:
int pintos_init (void) NO_RETURN;
void readline(char[], size_t);
/* Pintos main entry point. */
int
pintos_init (void)
{
c00202b6:	55                   	push   %ebp
c00202b7:	89 e5                	mov    %esp,%ebp
c00202b9:	83 ec 18             	sub    $0x18,%esp
  char **argv;

  /* Clear BSS. */  
  bss_init ();
c00202bc:	e8 f6 02 00 00       	call   c00205b7 <bss_init>

  /* Break command line into arguments and parse options. */
  argv = read_command_line ();
c00202c1:	e8 56 04 00 00       	call   c002071c <read_command_line>
c00202c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  argv = parse_options (argv);
c00202c9:	83 ec 0c             	sub    $0xc,%esp
c00202cc:	ff 75 f4             	pushl  -0xc(%ebp)
c00202cf:	e8 78 05 00 00       	call   c002084c <parse_options>
c00202d4:	83 c4 10             	add    $0x10,%esp
c00202d7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00202da:	e8 b7 09 00 00       	call   c0020c96 <thread_init>
  console_init ();  
c00202df:	e8 32 ba 00 00       	call   c002bd16 <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
          init_ram_pages * PGSIZE / 1024);
c00202e4:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00202e9:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00202ec:	c1 e8 0a             	shr    $0xa,%eax
c00202ef:	83 ec 08             	sub    $0x8,%esp
c00202f2:	50                   	push   %eax
c00202f3:	68 f8 fd 02 c0       	push   $0xc002fdf8
c00202f8:	e8 e1 74 00 00       	call   c00277de <printf>
c00202fd:	83 c4 10             	add    $0x10,%esp

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c0020300:	a1 80 81 03 c0       	mov    0xc0038180,%eax
c0020305:	83 ec 0c             	sub    $0xc,%esp
c0020308:	50                   	push   %eax
c0020309:	e8 e7 32 00 00       	call   c00235f5 <palloc_init>
c002030e:	83 c4 10             	add    $0x10,%esp
  malloc_init ();
c0020311:	e8 ee 36 00 00       	call   c0023a04 <malloc_init>
  paging_init ();
c0020316:	e8 c6 02 00 00       	call   c00205e1 <paging_init>

  /* Segmentation. */
#ifdef USERPROG
  tss_init ();
c002031b:	e8 66 df 00 00       	call   c002e286 <tss_init>
  gdt_init ();
c0020320:	e8 8e dc 00 00       	call   c002dfb3 <gdt_init>
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c0020325:	e8 81 16 00 00       	call   c00219ab <intr_init>
  timer_init ();
c002032a:	e8 92 3e 00 00       	call   c00241c1 <timer_init>
  kbd_init ();
c002032f:	e8 82 44 00 00       	call   c00247b6 <kbd_init>
  input_init ();
c0020334:	e8 fa 66 00 00       	call   c0026a33 <input_init>
#ifdef USERPROG
  exception_init ();
c0020339:	e8 e5 cf 00 00       	call   c002d323 <exception_init>
  syscall_init ();
c002033e:	e8 fb d2 00 00       	call   c002d63e <syscall_init>
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c0020343:	e8 ed 09 00 00       	call   c0020d35 <thread_start>
  serial_init_queue ();
c0020348:	e8 31 4c 00 00       	call   c0024f7e <serial_init_queue>
  timer_calibrate ();
c002034d:	e8 a0 3e 00 00       	call   c00241f2 <timer_calibrate>

#ifdef FILESYS
  /* Initialize file system. */
  ide_init ();
c0020352:	e8 05 5a 00 00       	call   c0025d5c <ide_init>
  locate_block_devices ();
c0020357:	e8 30 08 00 00       	call   c0020b8c <locate_block_devices>
  filesys_init (format_filesys);
c002035c:	a0 20 8a 03 c0       	mov    0xc0038a20,%al
c0020361:	0f b6 c0             	movzbl %al,%eax
c0020364:	83 ec 0c             	sub    $0xc,%esp
c0020367:	50                   	push   %eax
c0020368:	e8 ca df 00 00       	call   c002e337 <filesys_init>
c002036d:	83 c4 10             	add    $0x10,%esp
#endif

  printf ("Boot complete.\n");
c0020370:	83 ec 0c             	sub    $0xc,%esp
c0020373:	68 1b fe 02 c0       	push   $0xc002fe1b
c0020378:	e8 f2 ba 00 00       	call   c002be6f <puts>
c002037d:	83 c4 10             	add    $0x10,%esp
  
  if (*argv != NULL) {
c0020380:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020383:	8b 00                	mov    (%eax),%eax
c0020385:	85 c0                	test   %eax,%eax
c0020387:	74 13                	je     c002039c <pintos_init+0xe6>
    /* Run actions specified on kernel command line. */
    run_actions (argv);
c0020389:	83 ec 0c             	sub    $0xc,%esp
c002038c:	ff 75 f4             	pushl  -0xc(%ebp)
c002038f:	e8 f9 06 00 00       	call   c0020a8d <run_actions>
c0020394:	83 c4 10             	add    $0x10,%esp
c0020397:	e9 7d 01 00 00       	jmp    c0020519 <pintos_init+0x263>
  } else {

    while(1) {
    	printf("CS2042> ");
c002039c:	83 ec 0c             	sub    $0xc,%esp
c002039f:	68 2a fe 02 c0       	push   $0xc002fe2a
c00203a4:	e8 35 74 00 00       	call   c00277de <printf>
c00203a9:	83 c4 10             	add    $0x10,%esp
    	char line[10];
    	readline (line, 10);
c00203ac:	83 ec 08             	sub    $0x8,%esp
c00203af:	6a 0a                	push   $0xa
c00203b1:	8d 45 ea             	lea    -0x16(%ebp),%eax
c00203b4:	50                   	push   %eax
c00203b5:	e8 69 01 00 00       	call   c0020523 <readline>
c00203ba:	83 c4 10             	add    $0x10,%esp
    	
    	if (strcmp(line,"whoami") == 0) { 
c00203bd:	83 ec 08             	sub    $0x8,%esp
c00203c0:	68 33 fe 02 c0       	push   $0xc002fe33
c00203c5:	8d 45 ea             	lea    -0x16(%ebp),%eax
c00203c8:	50                   	push   %eax
c00203c9:	e8 0c 88 00 00       	call   c0028bda <strcmp>
c00203ce:	83 c4 10             	add    $0x10,%esp
c00203d1:	85 c0                	test   %eax,%eax
c00203d3:	75 12                	jne    c00203e7 <pintos_init+0x131>
    		printf("Vilash Naveen : 210413G \n") ;
c00203d5:	83 ec 0c             	sub    $0xc,%esp
c00203d8:	68 3a fe 02 c0       	push   $0xc002fe3a
c00203dd:	e8 8d ba 00 00       	call   c002be6f <puts>
c00203e2:	83 c4 10             	add    $0x10,%esp
c00203e5:	eb b5                	jmp    c002039c <pintos_init+0xe6>
    	} else if (strcmp(line,"shutdown") == 0) {
c00203e7:	83 ec 08             	sub    $0x8,%esp
c00203ea:	68 53 fe 02 c0       	push   $0xc002fe53
c00203ef:	8d 45 ea             	lea    -0x16(%ebp),%eax
c00203f2:	50                   	push   %eax
c00203f3:	e8 e2 87 00 00       	call   c0028bda <strcmp>
c00203f8:	83 c4 10             	add    $0x10,%esp
c00203fb:	85 c0                	test   %eax,%eax
c00203fd:	75 1a                	jne    c0020419 <pintos_init+0x163>
    		printf("Shutting Down...\n") ; shutdown(); thread_exit();
c00203ff:	83 ec 0c             	sub    $0xc,%esp
c0020402:	68 5c fe 02 c0       	push   $0xc002fe5c
c0020407:	e8 63 ba 00 00       	call   c002be6f <puts>
c002040c:	83 c4 10             	add    $0x10,%esp
c002040f:	e8 1d 6e 00 00       	call   c0027231 <shutdown>
c0020414:	e8 1d 0d 00 00       	call   c0021136 <thread_exit>
    	} else if (strcmp(line,"time") == 0) {
c0020419:	83 ec 08             	sub    $0x8,%esp
c002041c:	68 6d fe 02 c0       	push   $0xc002fe6d
c0020421:	8d 45 ea             	lea    -0x16(%ebp),%eax
c0020424:	50                   	push   %eax
c0020425:	e8 b0 87 00 00       	call   c0028bda <strcmp>
c002042a:	83 c4 10             	add    $0x10,%esp
c002042d:	85 c0                	test   %eax,%eax
c002042f:	75 1b                	jne    c002044c <pintos_init+0x196>
    		printf("Number of seconds since Unix epoch - %lu s\n", rtc_get_time());
c0020431:	e8 6c 6b 00 00       	call   c0026fa2 <rtc_get_time>
c0020436:	83 ec 08             	sub    $0x8,%esp
c0020439:	50                   	push   %eax
c002043a:	68 74 fe 02 c0       	push   $0xc002fe74
c002043f:	e8 9a 73 00 00       	call   c00277de <printf>
c0020444:	83 c4 10             	add    $0x10,%esp
c0020447:	e9 50 ff ff ff       	jmp    c002039c <pintos_init+0xe6>
    	} else if (strcmp(line,"ram") == 0) {
c002044c:	83 ec 08             	sub    $0x8,%esp
c002044f:	68 a0 fe 02 c0       	push   $0xc002fea0
c0020454:	8d 45 ea             	lea    -0x16(%ebp),%eax
c0020457:	50                   	push   %eax
c0020458:	e8 7d 87 00 00       	call   c0028bda <strcmp>
c002045d:	83 c4 10             	add    $0x10,%esp
c0020460:	85 c0                	test   %eax,%eax
c0020462:	75 21                	jne    c0020485 <pintos_init+0x1cf>
    		printf("Available RAM - %u KB\n", init_ram_pages * PGSIZE / 1024);
c0020464:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c0020469:	c1 e0 0c             	shl    $0xc,%eax
c002046c:	c1 e8 0a             	shr    $0xa,%eax
c002046f:	83 ec 08             	sub    $0x8,%esp
c0020472:	50                   	push   %eax
c0020473:	68 a4 fe 02 c0       	push   $0xc002fea4
c0020478:	e8 61 73 00 00       	call   c00277de <printf>
c002047d:	83 c4 10             	add    $0x10,%esp
c0020480:	e9 17 ff ff ff       	jmp    c002039c <pintos_init+0xe6>
    	} else if (strcmp(line,"thread") == 0) {
c0020485:	83 ec 08             	sub    $0x8,%esp
c0020488:	68 bb fe 02 c0       	push   $0xc002febb
c002048d:	8d 45 ea             	lea    -0x16(%ebp),%eax
c0020490:	50                   	push   %eax
c0020491:	e8 44 87 00 00       	call   c0028bda <strcmp>
c0020496:	83 c4 10             	add    $0x10,%esp
c0020499:	85 c0                	test   %eax,%eax
c002049b:	75 0a                	jne    c00204a7 <pintos_init+0x1f1>
    		thread_print_stats();
c002049d:	e8 70 09 00 00       	call   c0020e12 <thread_print_stats>
c00204a2:	e9 f5 fe ff ff       	jmp    c002039c <pintos_init+0xe6>
    	} else if (strcmp(line,"priority") == 0) {
c00204a7:	83 ec 08             	sub    $0x8,%esp
c00204aa:	68 c2 fe 02 c0       	push   $0xc002fec2
c00204af:	8d 45 ea             	lea    -0x16(%ebp),%eax
c00204b2:	50                   	push   %eax
c00204b3:	e8 22 87 00 00       	call   c0028bda <strcmp>
c00204b8:	83 c4 10             	add    $0x10,%esp
c00204bb:	85 c0                	test   %eax,%eax
c00204bd:	75 1b                	jne    c00204da <pintos_init+0x224>
    		printf("Priority of the current thread is %d\n", thread_get_priority());
c00204bf:	e8 89 0e 00 00       	call   c002134d <thread_get_priority>
c00204c4:	83 ec 08             	sub    $0x8,%esp
c00204c7:	50                   	push   %eax
c00204c8:	68 cc fe 02 c0       	push   $0xc002fecc
c00204cd:	e8 0c 73 00 00       	call   c00277de <printf>
c00204d2:	83 c4 10             	add    $0x10,%esp
c00204d5:	e9 c2 fe ff ff       	jmp    c002039c <pintos_init+0xe6>
    	} else if (strcmp(line,"exit") == 0) {
c00204da:	83 ec 08             	sub    $0x8,%esp
c00204dd:	68 f2 fe 02 c0       	push   $0xc002fef2
c00204e2:	8d 45 ea             	lea    -0x16(%ebp),%eax
c00204e5:	50                   	push   %eax
c00204e6:	e8 ef 86 00 00       	call   c0028bda <strcmp>
c00204eb:	83 c4 10             	add    $0x10,%esp
c00204ee:	85 c0                	test   %eax,%eax
c00204f0:	75 12                	jne    c0020504 <pintos_init+0x24e>
    		printf("Exiting Shell...\n");
c00204f2:	83 ec 0c             	sub    $0xc,%esp
c00204f5:	68 f7 fe 02 c0       	push   $0xc002fef7
c00204fa:	e8 70 b9 00 00       	call   c002be6f <puts>
c00204ff:	83 c4 10             	add    $0x10,%esp
c0020502:	eb 15                	jmp    c0020519 <pintos_init+0x263>
    		break;
    	} else {
    		printf("Unknown Command!\n");
c0020504:	83 ec 0c             	sub    $0xc,%esp
c0020507:	68 08 ff 02 c0       	push   $0xc002ff08
c002050c:	e8 5e b9 00 00       	call   c002be6f <puts>
c0020511:	83 c4 10             	add    $0x10,%esp
    while(1) {
c0020514:	e9 83 fe ff ff       	jmp    c002039c <pintos_init+0xe6>
    	}
    } 
  }
  shutdown(); 
c0020519:	e8 13 6d 00 00       	call   c0027231 <shutdown>
  thread_exit();
c002051e:	e8 13 0c 00 00       	call   c0021136 <thread_exit>

c0020523 <readline>:
}

void readline(char line[], size_t size) {
c0020523:	55                   	push   %ebp
c0020524:	89 e5                	mov    %esp,%ebp
c0020526:	83 ec 18             	sub    $0x18,%esp
	char c;
	char* pos = line;
c0020529:	8b 45 08             	mov    0x8(%ebp),%eax
c002052c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	while ((c = input_getc()) != '\r'){
c002052f:	eb 63                	jmp    c0020594 <readline+0x71>
	  if (pos >= line + size - 1) {
c0020531:	8b 45 0c             	mov    0xc(%ebp),%eax
c0020534:	8d 50 ff             	lea    -0x1(%eax),%edx
c0020537:	8b 45 08             	mov    0x8(%ebp),%eax
c002053a:	01 d0                	add    %edx,%eax
c002053c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002053f:	77 12                	ja     c0020553 <readline+0x30>
	    printf("\nMaximum input size exceeded\n");
c0020541:	83 ec 0c             	sub    $0xc,%esp
c0020544:	68 19 ff 02 c0       	push   $0xc002ff19
c0020549:	e8 21 b9 00 00       	call   c002be6f <puts>
c002054e:	83 c4 10             	add    $0x10,%esp
	    return;
c0020551:	eb 62                	jmp    c00205b5 <readline+0x92>
	  } else {
	    if (c != '\b') {
c0020553:	80 7d f3 08          	cmpb   $0x8,-0xd(%ebp)
c0020557:	74 20                	je     c0020579 <readline+0x56>
	    printf("%c",c);
c0020559:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
c002055d:	83 ec 0c             	sub    $0xc,%esp
c0020560:	50                   	push   %eax
c0020561:	e8 8e b9 00 00       	call   c002bef4 <putchar>
c0020566:	83 c4 10             	add    $0x10,%esp
	    *pos++ = c;
c0020569:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002056c:	8d 50 01             	lea    0x1(%eax),%edx
c002056f:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0020572:	8a 55 f3             	mov    -0xd(%ebp),%dl
c0020575:	88 10                	mov    %dl,(%eax)
c0020577:	eb 1b                	jmp    c0020594 <readline+0x71>
	    } else {
	      if (pos > line){
c0020579:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002057c:	3b 45 08             	cmp    0x8(%ebp),%eax
c002057f:	76 13                	jbe    c0020594 <readline+0x71>
		printf("\b \b");
c0020581:	83 ec 0c             	sub    $0xc,%esp
c0020584:	68 36 ff 02 c0       	push   $0xc002ff36
c0020589:	e8 50 72 00 00       	call   c00277de <printf>
c002058e:	83 c4 10             	add    $0x10,%esp
		pos--;
c0020591:	ff 4d f4             	decl   -0xc(%ebp)
	while ((c = input_getc()) != '\r'){
c0020594:	e8 38 65 00 00       	call   c0026ad1 <input_getc>
c0020599:	88 45 f3             	mov    %al,-0xd(%ebp)
c002059c:	80 7d f3 0d          	cmpb   $0xd,-0xd(%ebp)
c00205a0:	75 8f                	jne    c0020531 <readline+0xe>
	      }
	    }
	  }
	}
	*pos = '\0';
c00205a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00205a5:	c6 00 00             	movb   $0x0,(%eax)
	printf("\n");
c00205a8:	83 ec 0c             	sub    $0xc,%esp
c00205ab:	6a 0a                	push   $0xa
c00205ad:	e8 42 b9 00 00       	call   c002bef4 <putchar>
c00205b2:	83 c4 10             	add    $0x10,%esp
}
c00205b5:	c9                   	leave  
c00205b6:	c3                   	ret    

c00205b7 <bss_init>:

   The start and end of the BSS segment is recorded by the
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
c00205b7:	55                   	push   %ebp
c00205b8:	89 e5                	mov    %esp,%ebp
c00205ba:	83 ec 08             	sub    $0x8,%esp
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c00205bd:	ba 09 a9 03 c0       	mov    $0xc003a909,%edx
c00205c2:	b8 04 8a 03 c0       	mov    $0xc0038a04,%eax
c00205c7:	29 c2                	sub    %eax,%edx
c00205c9:	89 d0                	mov    %edx,%eax
c00205cb:	83 ec 04             	sub    $0x4,%esp
c00205ce:	50                   	push   %eax
c00205cf:	6a 00                	push   $0x0
c00205d1:	68 04 8a 03 c0       	push   $0xc0038a04
c00205d6:	e8 dc 89 00 00       	call   c0028fb7 <memset>
c00205db:	83 c4 10             	add    $0x10,%esp
}
c00205de:	90                   	nop
c00205df:	c9                   	leave  
c00205e0:	c3                   	ret    

c00205e1 <paging_init>:
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */
static void
paging_init (void)
{
c00205e1:	55                   	push   %ebp
c00205e2:	89 e5                	mov    %esp,%ebp
c00205e4:	53                   	push   %ebx
c00205e5:	83 ec 24             	sub    $0x24,%esp
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00205e8:	83 ec 0c             	sub    $0xc,%esp
c00205eb:	6a 03                	push   $0x3
c00205ed:	e8 7d 31 00 00       	call   c002376f <palloc_get_page>
c00205f2:	83 c4 10             	add    $0x10,%esp
c00205f5:	a3 00 a9 03 c0       	mov    %eax,0xc003a900
c00205fa:	a1 00 a9 03 c0       	mov    0xc003a900,%eax
c00205ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pt = NULL;
c0020602:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (page = 0; page < init_ram_pages; page++)
c0020609:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0020610:	e9 df 00 00 00       	jmp    c00206f4 <paging_init+0x113>
    {
      uintptr_t paddr = page * PGSIZE;
c0020615:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020618:	c1 e0 0c             	shl    $0xc,%eax
c002061b:	89 45 e8             	mov    %eax,-0x18(%ebp)
      char *vaddr = ptov (paddr);
c002061e:	83 ec 0c             	sub    $0xc,%esp
c0020621:	ff 75 e8             	pushl  -0x18(%ebp)
c0020624:	e8 55 fb ff ff       	call   c002017e <ptov>
c0020629:	83 c4 10             	add    $0x10,%esp
c002062c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      size_t pde_idx = pd_no (vaddr);
c002062f:	83 ec 0c             	sub    $0xc,%esp
c0020632:	ff 75 e4             	pushl  -0x1c(%ebp)
c0020635:	e8 c9 fb ff ff       	call   c0020203 <pd_no>
c002063a:	83 c4 10             	add    $0x10,%esp
c002063d:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t pte_idx = pt_no (vaddr);
c0020640:	83 ec 0c             	sub    $0xc,%esp
c0020643:	ff 75 e4             	pushl  -0x1c(%ebp)
c0020646:	e8 a8 fb ff ff       	call   c00201f3 <pt_no>
c002064b:	83 c4 10             	add    $0x10,%esp
c002064e:	89 45 dc             	mov    %eax,-0x24(%ebp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020651:	81 7d e4 00 00 02 c0 	cmpl   $0xc0020000,-0x1c(%ebp)
c0020658:	72 10                	jb     c002066a <paging_init+0x89>
c002065a:	81 7d e4 00 40 03 c0 	cmpl   $0xc0034000,-0x1c(%ebp)
c0020661:	73 07                	jae    c002066a <paging_init+0x89>
c0020663:	b8 01 00 00 00       	mov    $0x1,%eax
c0020668:	eb 05                	jmp    c002066f <paging_init+0x8e>
c002066a:	b8 00 00 00 00       	mov    $0x0,%eax
c002066f:	88 45 db             	mov    %al,-0x25(%ebp)
c0020672:	80 65 db 01          	andb   $0x1,-0x25(%ebp)

      if (pd[pde_idx] == 0)
c0020676:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020679:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020680:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020683:	01 d0                	add    %edx,%eax
c0020685:	8b 00                	mov    (%eax),%eax
c0020687:	85 c0                	test   %eax,%eax
c0020689:	75 30                	jne    c00206bb <paging_init+0xda>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002068b:	83 ec 0c             	sub    $0xc,%esp
c002068e:	6a 03                	push   $0x3
c0020690:	e8 da 30 00 00       	call   c002376f <palloc_get_page>
c0020695:	83 c4 10             	add    $0x10,%esp
c0020698:	89 45 f4             	mov    %eax,-0xc(%ebp)
          pd[pde_idx] = pde_create (pt);
c002069b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002069e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00206a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00206a8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c00206ab:	83 ec 0c             	sub    $0xc,%esp
c00206ae:	ff 75 f4             	pushl  -0xc(%ebp)
c00206b1:	e8 58 fb ff ff       	call   c002020e <pde_create>
c00206b6:	83 c4 10             	add    $0x10,%esp
c00206b9:	89 03                	mov    %eax,(%ebx)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c00206bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00206be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00206c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00206c8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c00206cb:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
c00206cf:	85 c0                	test   %eax,%eax
c00206d1:	0f 95 c0             	setne  %al
c00206d4:	83 f0 01             	xor    $0x1,%eax
c00206d7:	0f b6 c0             	movzbl %al,%eax
c00206da:	83 e0 01             	and    $0x1,%eax
c00206dd:	0f b6 c0             	movzbl %al,%eax
c00206e0:	83 ec 08             	sub    $0x8,%esp
c00206e3:	50                   	push   %eax
c00206e4:	ff 75 e4             	pushl  -0x1c(%ebp)
c00206e7:	e8 68 fb ff ff       	call   c0020254 <pte_create_kernel>
c00206ec:	83 c4 10             	add    $0x10,%esp
c00206ef:	89 03                	mov    %eax,(%ebx)
  for (page = 0; page < init_ram_pages; page++)
c00206f1:	ff 45 f0             	incl   -0x10(%ebp)
c00206f4:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00206f9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00206fc:	0f 82 13 ff ff ff    	jb     c0020615 <paging_init+0x34>
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c0020702:	a1 00 a9 03 c0       	mov    0xc003a900,%eax
c0020707:	83 ec 0c             	sub    $0xc,%esp
c002070a:	50                   	push   %eax
c002070b:	e8 a6 fa ff ff       	call   c00201b6 <vtop>
c0020710:	83 c4 10             	add    $0x10,%esp
c0020713:	0f 22 d8             	mov    %eax,%cr3
}
c0020716:	90                   	nop
c0020717:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002071a:	c9                   	leave  
c002071b:	c3                   	ret    

c002071c <read_command_line>:

/* Breaks the kernel command line into words and returns them as
   an argv-like array. */
static char **
read_command_line (void) 
{
c002071c:	55                   	push   %ebp
c002071d:	89 e5                	mov    %esp,%ebp
c002071f:	83 ec 18             	sub    $0x18,%esp
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c0020722:	83 ec 0c             	sub    $0xc,%esp
c0020725:	68 3a 7d 00 00       	push   $0x7d3a
c002072a:	e8 4f fa ff ff       	call   c002017e <ptov>
c002072f:	83 c4 10             	add    $0x10,%esp
c0020732:	8b 00                	mov    (%eax),%eax
c0020734:	89 45 ec             	mov    %eax,-0x14(%ebp)
  p = ptov (LOADER_ARGS);
c0020737:	83 ec 0c             	sub    $0xc,%esp
c002073a:	68 3e 7d 00 00       	push   $0x7d3e
c002073f:	e8 3a fa ff ff       	call   c002017e <ptov>
c0020744:	83 c4 10             	add    $0x10,%esp
c0020747:	89 45 f4             	mov    %eax,-0xc(%ebp)
  end = p + LOADER_ARGS_LEN;
c002074a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002074d:	83 e8 80             	sub    $0xffffff80,%eax
c0020750:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for (i = 0; i < argc; i++) 
c0020753:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002075a:	eb 4e                	jmp    c00207aa <read_command_line+0x8e>
    {
      if (p >= end)
c002075c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002075f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0020762:	72 19                	jb     c002077d <read_command_line+0x61>
        PANIC ("command line overflow");
c0020764:	68 3a ff 02 c0       	push   $0xc002ff3a
c0020769:	68 54 03 03 c0       	push   $0xc0030354
c002076e:	68 03 01 00 00       	push   $0x103
c0020773:	68 50 ff 02 c0       	push   $0xc002ff50
c0020778:	e8 20 94 00 00       	call   c0029b9d <debug_panic>

      argv[i] = p;
c002077d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020780:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0020783:	89 14 85 40 8a 03 c0 	mov    %edx,-0x3ffc75c0(,%eax,4)
      p += strnlen (p, end - p) + 1;
c002078a:	8b 55 e8             	mov    -0x18(%ebp),%edx
c002078d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020790:	29 c2                	sub    %eax,%edx
c0020792:	89 d0                	mov    %edx,%eax
c0020794:	83 ec 08             	sub    $0x8,%esp
c0020797:	50                   	push   %eax
c0020798:	ff 75 f4             	pushl  -0xc(%ebp)
c002079b:	e8 bd 88 00 00       	call   c002905d <strnlen>
c00207a0:	83 c4 10             	add    $0x10,%esp
c00207a3:	40                   	inc    %eax
c00207a4:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < argc; i++) 
c00207a7:	ff 45 f0             	incl   -0x10(%ebp)
c00207aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00207ad:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00207b0:	7c aa                	jl     c002075c <read_command_line+0x40>
    }
  argv[argc] = NULL;
c00207b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00207b5:	c7 04 85 40 8a 03 c0 	movl   $0x0,-0x3ffc75c0(,%eax,4)
c00207bc:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c00207c0:	83 ec 0c             	sub    $0xc,%esp
c00207c3:	68 65 ff 02 c0       	push   $0xc002ff65
c00207c8:	e8 11 70 00 00       	call   c00277de <printf>
c00207cd:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00207d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00207d7:	eb 57                	jmp    c0020830 <read_command_line+0x114>
    if (strchr (argv[i], ' ') == NULL)
c00207d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00207dc:	8b 04 85 40 8a 03 c0 	mov    -0x3ffc75c0(,%eax,4),%eax
c00207e3:	83 ec 08             	sub    $0x8,%esp
c00207e6:	6a 20                	push   $0x20
c00207e8:	50                   	push   %eax
c00207e9:	e8 ee 84 00 00       	call   c0028cdc <strchr>
c00207ee:	83 c4 10             	add    $0x10,%esp
c00207f1:	85 c0                	test   %eax,%eax
c00207f3:	75 1d                	jne    c0020812 <read_command_line+0xf6>
      printf (" %s", argv[i]);
c00207f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00207f8:	8b 04 85 40 8a 03 c0 	mov    -0x3ffc75c0(,%eax,4),%eax
c00207ff:	83 ec 08             	sub    $0x8,%esp
c0020802:	50                   	push   %eax
c0020803:	68 7a ff 02 c0       	push   $0xc002ff7a
c0020808:	e8 d1 6f 00 00       	call   c00277de <printf>
c002080d:	83 c4 10             	add    $0x10,%esp
c0020810:	eb 1b                	jmp    c002082d <read_command_line+0x111>
    else
      printf (" '%s'", argv[i]);
c0020812:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020815:	8b 04 85 40 8a 03 c0 	mov    -0x3ffc75c0(,%eax,4),%eax
c002081c:	83 ec 08             	sub    $0x8,%esp
c002081f:	50                   	push   %eax
c0020820:	68 7e ff 02 c0       	push   $0xc002ff7e
c0020825:	e8 b4 6f 00 00       	call   c00277de <printf>
c002082a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c002082d:	ff 45 f0             	incl   -0x10(%ebp)
c0020830:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020833:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020836:	7c a1                	jl     c00207d9 <read_command_line+0xbd>
  printf ("\n");
c0020838:	83 ec 0c             	sub    $0xc,%esp
c002083b:	6a 0a                	push   $0xa
c002083d:	e8 b2 b6 00 00       	call   c002bef4 <putchar>
c0020842:	83 c4 10             	add    $0x10,%esp

  return argv;
c0020845:	b8 40 8a 03 c0       	mov    $0xc0038a40,%eax
}
c002084a:	c9                   	leave  
c002084b:	c3                   	ret    

c002084c <parse_options>:

/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
c002084c:	55                   	push   %ebp
c002084d:	89 e5                	mov    %esp,%ebp
c002084f:	83 ec 18             	sub    $0x18,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020852:	e9 b6 01 00 00       	jmp    c0020a0d <parse_options+0x1c1>
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020857:	8b 45 08             	mov    0x8(%ebp),%eax
c002085a:	8b 00                	mov    (%eax),%eax
c002085c:	83 ec 04             	sub    $0x4,%esp
c002085f:	8d 55 ec             	lea    -0x14(%ebp),%edx
c0020862:	52                   	push   %edx
c0020863:	68 84 ff 02 c0       	push   $0xc002ff84
c0020868:	50                   	push   %eax
c0020869:	e8 3b 86 00 00       	call   c0028ea9 <strtok_r>
c002086e:	83 c4 10             	add    $0x10,%esp
c0020871:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char *value = strtok_r (NULL, "", &save_ptr);
c0020874:	83 ec 04             	sub    $0x4,%esp
c0020877:	8d 45 ec             	lea    -0x14(%ebp),%eax
c002087a:	50                   	push   %eax
c002087b:	68 86 ff 02 c0       	push   $0xc002ff86
c0020880:	6a 00                	push   $0x0
c0020882:	e8 22 86 00 00       	call   c0028ea9 <strtok_r>
c0020887:	83 c4 10             	add    $0x10,%esp
c002088a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      
      if (!strcmp (name, "-h"))
c002088d:	83 ec 08             	sub    $0x8,%esp
c0020890:	68 87 ff 02 c0       	push   $0xc002ff87
c0020895:	ff 75 f4             	pushl  -0xc(%ebp)
c0020898:	e8 3d 83 00 00       	call   c0028bda <strcmp>
c002089d:	83 c4 10             	add    $0x10,%esp
c00208a0:	85 c0                	test   %eax,%eax
c00208a2:	75 0a                	jne    c00208ae <parse_options+0x62>
        usage ();
c00208a4:	e8 c8 02 00 00       	call   c0020b71 <usage>
c00208a9:	e9 5b 01 00 00       	jmp    c0020a09 <parse_options+0x1bd>
      else if (!strcmp (name, "-q"))
c00208ae:	83 ec 08             	sub    $0x8,%esp
c00208b1:	68 8a ff 02 c0       	push   $0xc002ff8a
c00208b6:	ff 75 f4             	pushl  -0xc(%ebp)
c00208b9:	e8 1c 83 00 00       	call   c0028bda <strcmp>
c00208be:	83 c4 10             	add    $0x10,%esp
c00208c1:	85 c0                	test   %eax,%eax
c00208c3:	75 12                	jne    c00208d7 <parse_options+0x8b>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c00208c5:	83 ec 0c             	sub    $0xc,%esp
c00208c8:	6a 01                	push   $0x1
c00208ca:	e8 86 69 00 00       	call   c0027255 <shutdown_configure>
c00208cf:	83 c4 10             	add    $0x10,%esp
c00208d2:	e9 32 01 00 00       	jmp    c0020a09 <parse_options+0x1bd>
      else if (!strcmp (name, "-r"))
c00208d7:	83 ec 08             	sub    $0x8,%esp
c00208da:	68 8d ff 02 c0       	push   $0xc002ff8d
c00208df:	ff 75 f4             	pushl  -0xc(%ebp)
c00208e2:	e8 f3 82 00 00       	call   c0028bda <strcmp>
c00208e7:	83 c4 10             	add    $0x10,%esp
c00208ea:	85 c0                	test   %eax,%eax
c00208ec:	75 12                	jne    c0020900 <parse_options+0xb4>
        shutdown_configure (SHUTDOWN_REBOOT);
c00208ee:	83 ec 0c             	sub    $0xc,%esp
c00208f1:	6a 02                	push   $0x2
c00208f3:	e8 5d 69 00 00       	call   c0027255 <shutdown_configure>
c00208f8:	83 c4 10             	add    $0x10,%esp
c00208fb:	e9 09 01 00 00       	jmp    c0020a09 <parse_options+0x1bd>
#ifdef FILESYS
      else if (!strcmp (name, "-f"))
c0020900:	83 ec 08             	sub    $0x8,%esp
c0020903:	68 90 ff 02 c0       	push   $0xc002ff90
c0020908:	ff 75 f4             	pushl  -0xc(%ebp)
c002090b:	e8 ca 82 00 00       	call   c0028bda <strcmp>
c0020910:	83 c4 10             	add    $0x10,%esp
c0020913:	85 c0                	test   %eax,%eax
c0020915:	75 0c                	jne    c0020923 <parse_options+0xd7>
        format_filesys = true;
c0020917:	c6 05 20 8a 03 c0 01 	movb   $0x1,0xc0038a20
c002091e:	e9 e6 00 00 00       	jmp    c0020a09 <parse_options+0x1bd>
      else if (!strcmp (name, "-filesys"))
c0020923:	83 ec 08             	sub    $0x8,%esp
c0020926:	68 93 ff 02 c0       	push   $0xc002ff93
c002092b:	ff 75 f4             	pushl  -0xc(%ebp)
c002092e:	e8 a7 82 00 00       	call   c0028bda <strcmp>
c0020933:	83 c4 10             	add    $0x10,%esp
c0020936:	85 c0                	test   %eax,%eax
c0020938:	75 0d                	jne    c0020947 <parse_options+0xfb>
        filesys_bdev_name = value;
c002093a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002093d:	a3 24 8a 03 c0       	mov    %eax,0xc0038a24
c0020942:	e9 c2 00 00 00       	jmp    c0020a09 <parse_options+0x1bd>
      else if (!strcmp (name, "-scratch"))
c0020947:	83 ec 08             	sub    $0x8,%esp
c002094a:	68 9c ff 02 c0       	push   $0xc002ff9c
c002094f:	ff 75 f4             	pushl  -0xc(%ebp)
c0020952:	e8 83 82 00 00       	call   c0028bda <strcmp>
c0020957:	83 c4 10             	add    $0x10,%esp
c002095a:	85 c0                	test   %eax,%eax
c002095c:	75 0d                	jne    c002096b <parse_options+0x11f>
        scratch_bdev_name = value;
c002095e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020961:	a3 28 8a 03 c0       	mov    %eax,0xc0038a28
c0020966:	e9 9e 00 00 00       	jmp    c0020a09 <parse_options+0x1bd>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c002096b:	83 ec 08             	sub    $0x8,%esp
c002096e:	68 a5 ff 02 c0       	push   $0xc002ffa5
c0020973:	ff 75 f4             	pushl  -0xc(%ebp)
c0020976:	e8 5f 82 00 00       	call   c0028bda <strcmp>
c002097b:	83 c4 10             	add    $0x10,%esp
c002097e:	85 c0                	test   %eax,%eax
c0020980:	75 1c                	jne    c002099e <parse_options+0x152>
        random_init (atoi (value));
c0020982:	83 ec 0c             	sub    $0xc,%esp
c0020985:	ff 75 f0             	pushl  -0x10(%ebp)
c0020988:	e8 50 7c 00 00       	call   c00285dd <atoi>
c002098d:	83 c4 10             	add    $0x10,%esp
c0020990:	83 ec 0c             	sub    $0xc,%esp
c0020993:	50                   	push   %eax
c0020994:	e8 e7 6b 00 00       	call   c0027580 <random_init>
c0020999:	83 c4 10             	add    $0x10,%esp
c002099c:	eb 6b                	jmp    c0020a09 <parse_options+0x1bd>
      else if (!strcmp (name, "-mlfqs"))
c002099e:	83 ec 08             	sub    $0x8,%esp
c00209a1:	68 a9 ff 02 c0       	push   $0xc002ffa9
c00209a6:	ff 75 f4             	pushl  -0xc(%ebp)
c00209a9:	e8 2c 82 00 00       	call   c0028bda <strcmp>
c00209ae:	83 c4 10             	add    $0x10,%esp
c00209b1:	85 c0                	test   %eax,%eax
c00209b3:	75 09                	jne    c00209be <parse_options+0x172>
        thread_mlfqs = true;
c00209b5:	c6 05 08 a9 03 c0 01 	movb   $0x1,0xc003a908
c00209bc:	eb 4b                	jmp    c0020a09 <parse_options+0x1bd>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
c00209be:	83 ec 08             	sub    $0x8,%esp
c00209c1:	68 b0 ff 02 c0       	push   $0xc002ffb0
c00209c6:	ff 75 f4             	pushl  -0xc(%ebp)
c00209c9:	e8 0c 82 00 00       	call   c0028bda <strcmp>
c00209ce:	83 c4 10             	add    $0x10,%esp
c00209d1:	85 c0                	test   %eax,%eax
c00209d3:	75 15                	jne    c00209ea <parse_options+0x19e>
        user_page_limit = atoi (value);
c00209d5:	83 ec 0c             	sub    $0xc,%esp
c00209d8:	ff 75 f0             	pushl  -0x10(%ebp)
c00209db:	e8 fd 7b 00 00       	call   c00285dd <atoi>
c00209e0:	83 c4 10             	add    $0x10,%esp
c00209e3:	a3 80 81 03 c0       	mov    %eax,0xc0038180
c00209e8:	eb 1f                	jmp    c0020a09 <parse_options+0x1bd>
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c00209ea:	83 ec 0c             	sub    $0xc,%esp
c00209ed:	ff 75 f4             	pushl  -0xc(%ebp)
c00209f0:	68 b4 ff 02 c0       	push   $0xc002ffb4
c00209f5:	68 68 03 03 c0       	push   $0xc0030368
c00209fa:	68 3c 01 00 00       	push   $0x13c
c00209ff:	68 50 ff 02 c0       	push   $0xc002ff50
c0020a04:	e8 94 91 00 00       	call   c0029b9d <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020a09:	83 45 08 04          	addl   $0x4,0x8(%ebp)
c0020a0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0020a10:	8b 00                	mov    (%eax),%eax
c0020a12:	85 c0                	test   %eax,%eax
c0020a14:	74 0f                	je     c0020a25 <parse_options+0x1d9>
c0020a16:	8b 45 08             	mov    0x8(%ebp),%eax
c0020a19:	8b 00                	mov    (%eax),%eax
c0020a1b:	8a 00                	mov    (%eax),%al
c0020a1d:	3c 2d                	cmp    $0x2d,%al
c0020a1f:	0f 84 32 fe ff ff    	je     c0020857 <parse_options+0xb>
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c0020a25:	e8 78 65 00 00       	call   c0026fa2 <rtc_get_time>
c0020a2a:	83 ec 0c             	sub    $0xc,%esp
c0020a2d:	50                   	push   %eax
c0020a2e:	e8 4d 6b 00 00       	call   c0027580 <random_init>
c0020a33:	83 c4 10             	add    $0x10,%esp
  
  return argv;
c0020a36:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0020a39:	c9                   	leave  
c0020a3a:	c3                   	ret    

c0020a3b <run_task>:

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020a3b:	55                   	push   %ebp
c0020a3c:	89 e5                	mov    %esp,%ebp
c0020a3e:	83 ec 18             	sub    $0x18,%esp
  const char *task = argv[1];
c0020a41:	8b 45 08             	mov    0x8(%ebp),%eax
c0020a44:	8b 40 04             	mov    0x4(%eax),%eax
c0020a47:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Executing '%s':\n", task);
c0020a4a:	83 ec 08             	sub    $0x8,%esp
c0020a4d:	ff 75 f4             	pushl  -0xc(%ebp)
c0020a50:	68 da ff 02 c0       	push   $0xc002ffda
c0020a55:	e8 84 6d 00 00       	call   c00277de <printf>
c0020a5a:	83 c4 10             	add    $0x10,%esp
#ifdef USERPROG
  process_wait (process_execute (task));
c0020a5d:	83 ec 0c             	sub    $0xc,%esp
c0020a60:	ff 75 f4             	pushl  -0xc(%ebp)
c0020a63:	e8 78 b5 00 00       	call   c002bfe0 <process_execute>
c0020a68:	83 c4 10             	add    $0x10,%esp
c0020a6b:	83 ec 0c             	sub    $0xc,%esp
c0020a6e:	50                   	push   %eax
c0020a6f:	e8 d7 b6 00 00       	call   c002c14b <process_wait>
c0020a74:	83 c4 10             	add    $0x10,%esp
#else
  run_test (task);
#endif
  printf ("Execution of '%s' complete.\n", task);
c0020a77:	83 ec 08             	sub    $0x8,%esp
c0020a7a:	ff 75 f4             	pushl  -0xc(%ebp)
c0020a7d:	68 eb ff 02 c0       	push   $0xc002ffeb
c0020a82:	e8 57 6d 00 00       	call   c00277de <printf>
c0020a87:	83 c4 10             	add    $0x10,%esp
}
c0020a8a:	90                   	nop
c0020a8b:	c9                   	leave  
c0020a8c:	c3                   	ret    

c0020a8d <run_actions>:

/* Executes all of the actions specified in ARGV[]
   up to the null pointer sentinel. */
static void
run_actions (char **argv) 
{
c0020a8d:	55                   	push   %ebp
c0020a8e:	89 e5                	mov    %esp,%ebp
c0020a90:	83 ec 18             	sub    $0x18,%esp
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c0020a93:	e9 c9 00 00 00       	jmp    c0020b61 <run_actions+0xd4>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c0020a98:	c7 45 f4 a0 03 03 c0 	movl   $0xc00303a0,-0xc(%ebp)
        if (a->name == NULL)
c0020a9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020aa2:	8b 00                	mov    (%eax),%eax
c0020aa4:	85 c0                	test   %eax,%eax
c0020aa6:	75 22                	jne    c0020aca <run_actions+0x3d>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c0020aa8:	8b 45 08             	mov    0x8(%ebp),%eax
c0020aab:	8b 00                	mov    (%eax),%eax
c0020aad:	83 ec 0c             	sub    $0xc,%esp
c0020ab0:	50                   	push   %eax
c0020ab1:	68 08 00 03 c0       	push   $0xc0030008
c0020ab6:	68 f4 03 03 c0       	push   $0xc00303f4
c0020abb:	68 7e 01 00 00       	push   $0x17e
c0020ac0:	68 50 ff 02 c0       	push   $0xc002ff50
c0020ac5:	e8 d3 90 00 00       	call   c0029b9d <debug_panic>
        else if (!strcmp (*argv, a->name))
c0020aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020acd:	8b 10                	mov    (%eax),%edx
c0020acf:	8b 45 08             	mov    0x8(%ebp),%eax
c0020ad2:	8b 00                	mov    (%eax),%eax
c0020ad4:	83 ec 08             	sub    $0x8,%esp
c0020ad7:	52                   	push   %edx
c0020ad8:	50                   	push   %eax
c0020ad9:	e8 fc 80 00 00       	call   c0028bda <strcmp>
c0020ade:	83 c4 10             	add    $0x10,%esp
c0020ae1:	85 c0                	test   %eax,%eax
c0020ae3:	74 06                	je     c0020aeb <run_actions+0x5e>
      for (a = actions; ; a++)
c0020ae5:	83 45 f4 0c          	addl   $0xc,-0xc(%ebp)
        if (a->name == NULL)
c0020ae9:	eb b4                	jmp    c0020a9f <run_actions+0x12>
          break;
c0020aeb:	90                   	nop

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020aec:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0020af3:	eb 44                	jmp    c0020b39 <run_actions+0xac>
        if (argv[i] == NULL)
c0020af5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020af8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020aff:	8b 45 08             	mov    0x8(%ebp),%eax
c0020b02:	01 d0                	add    %edx,%eax
c0020b04:	8b 00                	mov    (%eax),%eax
c0020b06:	85 c0                	test   %eax,%eax
c0020b08:	75 2c                	jne    c0020b36 <run_actions+0xa9>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c0020b0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020b0d:	8b 40 04             	mov    0x4(%eax),%eax
c0020b10:	8d 50 ff             	lea    -0x1(%eax),%edx
c0020b13:	8b 45 08             	mov    0x8(%ebp),%eax
c0020b16:	8b 00                	mov    (%eax),%eax
c0020b18:	83 ec 08             	sub    $0x8,%esp
c0020b1b:	52                   	push   %edx
c0020b1c:	50                   	push   %eax
c0020b1d:	68 30 00 03 c0       	push   $0xc0030030
c0020b22:	68 f4 03 03 c0       	push   $0xc00303f4
c0020b27:	68 85 01 00 00       	push   $0x185
c0020b2c:	68 50 ff 02 c0       	push   $0xc002ff50
c0020b31:	e8 67 90 00 00       	call   c0029b9d <debug_panic>
      for (i = 1; i < a->argc; i++)
c0020b36:	ff 45 f0             	incl   -0x10(%ebp)
c0020b39:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020b3c:	8b 40 04             	mov    0x4(%eax),%eax
c0020b3f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0020b42:	7f b1                	jg     c0020af5 <run_actions+0x68>

      /* Invoke action and advance. */
      a->function (argv);
c0020b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020b47:	8b 40 08             	mov    0x8(%eax),%eax
c0020b4a:	83 ec 0c             	sub    $0xc,%esp
c0020b4d:	ff 75 08             	pushl  0x8(%ebp)
c0020b50:	ff d0                	call   *%eax
c0020b52:	83 c4 10             	add    $0x10,%esp
      argv += a->argc;
c0020b55:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020b58:	8b 40 04             	mov    0x4(%eax),%eax
c0020b5b:	c1 e0 02             	shl    $0x2,%eax
c0020b5e:	01 45 08             	add    %eax,0x8(%ebp)
  while (*argv != NULL)
c0020b61:	8b 45 08             	mov    0x8(%ebp),%eax
c0020b64:	8b 00                	mov    (%eax),%eax
c0020b66:	85 c0                	test   %eax,%eax
c0020b68:	0f 85 2a ff ff ff    	jne    c0020a98 <run_actions+0xb>
    }
  
}
c0020b6e:	90                   	nop
c0020b6f:	c9                   	leave  
c0020b70:	c3                   	ret    

c0020b71 <usage>:

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
c0020b71:	55                   	push   %ebp
c0020b72:	89 e5                	mov    %esp,%ebp
c0020b74:	83 ec 08             	sub    $0x8,%esp
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020b77:	83 ec 0c             	sub    $0xc,%esp
c0020b7a:	68 54 00 03 c0       	push   $0xc0030054
c0020b7f:	e8 eb b2 00 00       	call   c002be6f <puts>
c0020b84:	83 c4 10             	add    $0x10,%esp

#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c0020b87:	e8 5d 67 00 00       	call   c00272e9 <shutdown_power_off>

c0020b8c <locate_block_devices>:

#ifdef FILESYS
/* Figure out what block devices to cast in the various Pintos roles. */
static void
locate_block_devices (void)
{
c0020b8c:	55                   	push   %ebp
c0020b8d:	89 e5                	mov    %esp,%ebp
c0020b8f:	83 ec 08             	sub    $0x8,%esp
  locate_block_device (BLOCK_FILESYS, filesys_bdev_name);
c0020b92:	a1 24 8a 03 c0       	mov    0xc0038a24,%eax
c0020b97:	83 ec 08             	sub    $0x8,%esp
c0020b9a:	50                   	push   %eax
c0020b9b:	6a 01                	push   $0x1
c0020b9d:	e8 19 00 00 00       	call   c0020bbb <locate_block_device>
c0020ba2:	83 c4 10             	add    $0x10,%esp
  locate_block_device (BLOCK_SCRATCH, scratch_bdev_name);
c0020ba5:	a1 28 8a 03 c0       	mov    0xc0038a28,%eax
c0020baa:	83 ec 08             	sub    $0x8,%esp
c0020bad:	50                   	push   %eax
c0020bae:	6a 02                	push   $0x2
c0020bb0:	e8 06 00 00 00       	call   c0020bbb <locate_block_device>
c0020bb5:	83 c4 10             	add    $0x10,%esp
#ifdef VM
  locate_block_device (BLOCK_SWAP, swap_bdev_name);
#endif
}
c0020bb8:	90                   	nop
c0020bb9:	c9                   	leave  
c0020bba:	c3                   	ret    

c0020bbb <locate_block_device>:
   block device with the given NAME, if NAME is non-null,
   otherwise the first block device in probe order of type
   ROLE. */
static void
locate_block_device (enum block_type role, const char *name)
{
c0020bbb:	55                   	push   %ebp
c0020bbc:	89 e5                	mov    %esp,%ebp
c0020bbe:	53                   	push   %ebx
c0020bbf:	83 ec 14             	sub    $0x14,%esp
  struct block *block = NULL;
c0020bc2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (name != NULL)
c0020bc9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0020bcd:	74 36                	je     c0020c05 <locate_block_device+0x4a>
    {
      block = block_get_by_name (name);
c0020bcf:	83 ec 0c             	sub    $0xc,%esp
c0020bd2:	ff 75 0c             	pushl  0xc(%ebp)
c0020bd5:	e8 86 48 00 00       	call   c0025460 <block_get_by_name>
c0020bda:	83 c4 10             	add    $0x10,%esp
c0020bdd:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (block == NULL)
c0020be0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020be4:	75 56                	jne    c0020c3c <locate_block_device+0x81>
        PANIC ("No such block device \"%s\"", name);
c0020be6:	83 ec 0c             	sub    $0xc,%esp
c0020be9:	ff 75 0c             	pushl  0xc(%ebp)
c0020bec:	68 fb 02 03 c0       	push   $0xc00302fb
c0020bf1:	68 00 04 03 c0       	push   $0xc0030400
c0020bf6:	68 cb 01 00 00       	push   $0x1cb
c0020bfb:	68 50 ff 02 c0       	push   $0xc002ff50
c0020c00:	e8 98 8f 00 00       	call   c0029b9d <debug_panic>
    }
  else
    {
      for (block = block_first (); block != NULL; block = block_next (block))
c0020c05:	e8 0f 48 00 00       	call   c0025419 <block_first>
c0020c0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020c0d:	eb 24                	jmp    c0020c33 <locate_block_device+0x78>
        if (block_type (block) == role)
c0020c0f:	83 ec 0c             	sub    $0xc,%esp
c0020c12:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c15:	e8 e3 49 00 00       	call   c00255fd <block_type>
c0020c1a:	83 c4 10             	add    $0x10,%esp
c0020c1d:	3b 45 08             	cmp    0x8(%ebp),%eax
c0020c20:	74 19                	je     c0020c3b <locate_block_device+0x80>
      for (block = block_first (); block != NULL; block = block_next (block))
c0020c22:	83 ec 0c             	sub    $0xc,%esp
c0020c25:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c28:	e8 10 48 00 00       	call   c002543d <block_next>
c0020c2d:	83 c4 10             	add    $0x10,%esp
c0020c30:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020c33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020c37:	75 d6                	jne    c0020c0f <locate_block_device+0x54>
c0020c39:	eb 01                	jmp    c0020c3c <locate_block_device+0x81>
          break;
c0020c3b:	90                   	nop
    }

  if (block != NULL)
c0020c3c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020c40:	74 41                	je     c0020c83 <locate_block_device+0xc8>
    {
      printf ("%s: using %s\n", block_type_name (role), block_name (block));
c0020c42:	83 ec 0c             	sub    $0xc,%esp
c0020c45:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c48:	e8 a5 49 00 00       	call   c00255f2 <block_name>
c0020c4d:	83 c4 10             	add    $0x10,%esp
c0020c50:	89 c3                	mov    %eax,%ebx
c0020c52:	83 ec 0c             	sub    $0xc,%esp
c0020c55:	ff 75 08             	pushl  0x8(%ebp)
c0020c58:	e8 16 47 00 00       	call   c0025373 <block_type_name>
c0020c5d:	83 c4 10             	add    $0x10,%esp
c0020c60:	83 ec 04             	sub    $0x4,%esp
c0020c63:	53                   	push   %ebx
c0020c64:	50                   	push   %eax
c0020c65:	68 15 03 03 c0       	push   $0xc0030315
c0020c6a:	e8 6f 6b 00 00       	call   c00277de <printf>
c0020c6f:	83 c4 10             	add    $0x10,%esp
      block_set_role (role, block);
c0020c72:	83 ec 08             	sub    $0x8,%esp
c0020c75:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c78:	ff 75 08             	pushl  0x8(%ebp)
c0020c7b:	e8 5f 47 00 00       	call   c00253df <block_set_role>
c0020c80:	83 c4 10             	add    $0x10,%esp
    }
}
c0020c83:	90                   	nop
c0020c84:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020c87:	c9                   	leave  
c0020c88:	c3                   	ret    

c0020c89 <pg_round_down>:
static inline void *pg_round_up (const void *va) {
  return (void *) (((uintptr_t) va + PGSIZE - 1) & ~PGMASK);
}

/* Round down to nearest page boundary. */
static inline void *pg_round_down (const void *va) {
c0020c89:	55                   	push   %ebp
c0020c8a:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c0020c8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c8f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c0020c94:	5d                   	pop    %ebp
c0020c95:	c3                   	ret    

c0020c96 <thread_init>:
   thread_create().

   It is not safe to call thread_current() until this function
   finishes. */
void thread_init(void)
{
c0020c96:	55                   	push   %ebp
c0020c97:	89 e5                	mov    %esp,%ebp
c0020c99:	53                   	push   %ebx
c0020c9a:	83 ec 04             	sub    $0x4,%esp
  ASSERT(intr_get_level() == INTR_OFF);
c0020c9d:	e8 80 0c 00 00       	call   c0021922 <intr_get_level>
c0020ca2:	85 c0                	test   %eax,%eax
c0020ca4:	74 1e                	je     c0020cc4 <thread_init+0x2e>
c0020ca6:	83 ec 0c             	sub    $0xc,%esp
c0020ca9:	68 14 04 03 c0       	push   $0xc0030414
c0020cae:	68 31 04 03 c0       	push   $0xc0030431
c0020cb3:	68 cc 05 03 c0       	push   $0xc00305cc
c0020cb8:	6a 5c                	push   $0x5c
c0020cba:	68 48 04 03 c0       	push   $0xc0030448
c0020cbf:	e8 d9 8e 00 00       	call   c0029b9d <debug_panic>

  lock_init(&tid_lock);
c0020cc4:	83 ec 0c             	sub    $0xc,%esp
c0020cc7:	68 a0 8b 03 c0       	push   $0xc0038ba0
c0020ccc:	e8 7d 23 00 00       	call   c002304e <lock_init>
c0020cd1:	83 c4 10             	add    $0x10,%esp
  list_init(&ready_list);
c0020cd4:	83 ec 0c             	sub    $0xc,%esp
c0020cd7:	68 60 8b 03 c0       	push   $0xc0038b60
c0020cdc:	e8 2d 91 00 00       	call   c0029e0e <list_init>
c0020ce1:	83 c4 10             	add    $0x10,%esp
  list_init(&all_list);
c0020ce4:	83 ec 0c             	sub    $0xc,%esp
c0020ce7:	68 70 8b 03 c0       	push   $0xc0038b70
c0020cec:	e8 1d 91 00 00       	call   c0029e0e <list_init>
c0020cf1:	83 c4 10             	add    $0x10,%esp

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread();
c0020cf4:	e8 ff 06 00 00       	call   c00213f8 <running_thread>
c0020cf9:	a3 84 8b 03 c0       	mov    %eax,0xc0038b84
  init_thread(initial_thread, "main", PRI_DEFAULT);
c0020cfe:	a1 84 8b 03 c0       	mov    0xc0038b84,%eax
c0020d03:	83 ec 04             	sub    $0x4,%esp
c0020d06:	6a 1f                	push   $0x1f
c0020d08:	68 5f 04 03 c0       	push   $0xc003045f
c0020d0d:	50                   	push   %eax
c0020d0e:	e8 24 07 00 00       	call   c0021437 <init_thread>
c0020d13:	83 c4 10             	add    $0x10,%esp
  initial_thread->status = THREAD_RUNNING;
c0020d16:	a1 84 8b 03 c0       	mov    0xc0038b84,%eax
c0020d1b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  initial_thread->tid = allocate_tid();
c0020d22:	8b 1d 84 8b 03 c0    	mov    0xc0038b84,%ebx
c0020d28:	e8 85 0a 00 00       	call   c00217b2 <allocate_tid>
c0020d2d:	89 03                	mov    %eax,(%ebx)
}
c0020d2f:	90                   	nop
c0020d30:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020d33:	c9                   	leave  
c0020d34:	c3                   	ret    

c0020d35 <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void thread_start(void)
{
c0020d35:	55                   	push   %ebp
c0020d36:	89 e5                	mov    %esp,%ebp
c0020d38:	83 ec 28             	sub    $0x28,%esp
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init(&idle_started, 0);
c0020d3b:	83 ec 08             	sub    $0x8,%esp
c0020d3e:	6a 00                	push   $0x0
c0020d40:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020d43:	50                   	push   %eax
c0020d44:	e8 4d 20 00 00       	call   c0022d96 <sema_init>
c0020d49:	83 c4 10             	add    $0x10,%esp
  thread_create("idle", PRI_MIN, idle, &idle_started);
c0020d4c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020d4f:	50                   	push   %eax
c0020d50:	68 81 13 02 c0       	push   $0xc0021381
c0020d55:	6a 00                	push   $0x0
c0020d57:	68 64 04 03 c0       	push   $0xc0030464
c0020d5c:	e8 fc 00 00 00       	call   c0020e5d <thread_create>
c0020d61:	83 c4 10             	add    $0x10,%esp

  /* Start preemptive thread scheduling. */
  intr_enable();
c0020d64:	e8 f0 0b 00 00       	call   c0021959 <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down(&idle_started);
c0020d69:	83 ec 0c             	sub    $0xc,%esp
c0020d6c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020d6f:	50                   	push   %eax
c0020d70:	e8 68 20 00 00       	call   c0022ddd <sema_down>
c0020d75:	83 c4 10             	add    $0x10,%esp
}
c0020d78:	90                   	nop
c0020d79:	c9                   	leave  
c0020d7a:	c3                   	ret    

c0020d7b <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void thread_tick(void)
{
c0020d7b:	55                   	push   %ebp
c0020d7c:	89 e5                	mov    %esp,%ebp
c0020d7e:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current();
c0020d81:	e8 30 03 00 00       	call   c00210b6 <thread_current>
c0020d86:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Update statistics. */
  if (t == idle_thread)
c0020d89:	a1 80 8b 03 c0       	mov    0xc0038b80,%eax
c0020d8e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020d91:	75 1e                	jne    c0020db1 <thread_tick+0x36>
    idle_ticks++;
c0020d93:	a1 c0 8b 03 c0       	mov    0xc0038bc0,%eax
c0020d98:	8b 15 c4 8b 03 c0    	mov    0xc0038bc4,%edx
c0020d9e:	83 c0 01             	add    $0x1,%eax
c0020da1:	83 d2 00             	adc    $0x0,%edx
c0020da4:	a3 c0 8b 03 c0       	mov    %eax,0xc0038bc0
c0020da9:	89 15 c4 8b 03 c0    	mov    %edx,0xc0038bc4
c0020daf:	eb 44                	jmp    c0020df5 <thread_tick+0x7a>
#ifdef USERPROG
  else if (t->pagedir != NULL)
c0020db1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020db4:	8b 40 30             	mov    0x30(%eax),%eax
c0020db7:	85 c0                	test   %eax,%eax
c0020db9:	74 1e                	je     c0020dd9 <thread_tick+0x5e>
    user_ticks++;
c0020dbb:	a1 d0 8b 03 c0       	mov    0xc0038bd0,%eax
c0020dc0:	8b 15 d4 8b 03 c0    	mov    0xc0038bd4,%edx
c0020dc6:	83 c0 01             	add    $0x1,%eax
c0020dc9:	83 d2 00             	adc    $0x0,%edx
c0020dcc:	a3 d0 8b 03 c0       	mov    %eax,0xc0038bd0
c0020dd1:	89 15 d4 8b 03 c0    	mov    %edx,0xc0038bd4
c0020dd7:	eb 1c                	jmp    c0020df5 <thread_tick+0x7a>
#endif
  else
    kernel_ticks++;
c0020dd9:	a1 c8 8b 03 c0       	mov    0xc0038bc8,%eax
c0020dde:	8b 15 cc 8b 03 c0    	mov    0xc0038bcc,%edx
c0020de4:	83 c0 01             	add    $0x1,%eax
c0020de7:	83 d2 00             	adc    $0x0,%edx
c0020dea:	a3 c8 8b 03 c0       	mov    %eax,0xc0038bc8
c0020def:	89 15 cc 8b 03 c0    	mov    %edx,0xc0038bcc

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c0020df5:	a1 d8 8b 03 c0       	mov    0xc0038bd8,%eax
c0020dfa:	40                   	inc    %eax
c0020dfb:	a3 d8 8b 03 c0       	mov    %eax,0xc0038bd8
c0020e00:	a1 d8 8b 03 c0       	mov    0xc0038bd8,%eax
c0020e05:	83 f8 03             	cmp    $0x3,%eax
c0020e08:	76 05                	jbe    c0020e0f <thread_tick+0x94>
    intr_yield_on_return();
c0020e0a:	e8 5f 0e 00 00       	call   c0021c6e <intr_yield_on_return>
}
c0020e0f:	90                   	nop
c0020e10:	c9                   	leave  
c0020e11:	c3                   	ret    

c0020e12 <thread_print_stats>:

/* Prints thread statistics. */
void thread_print_stats(void)
{
c0020e12:	55                   	push   %ebp
c0020e13:	89 e5                	mov    %esp,%ebp
c0020e15:	57                   	push   %edi
c0020e16:	56                   	push   %esi
c0020e17:	53                   	push   %ebx
c0020e18:	83 ec 0c             	sub    $0xc,%esp
  printf("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020e1b:	8b 35 d0 8b 03 c0    	mov    0xc0038bd0,%esi
c0020e21:	8b 3d d4 8b 03 c0    	mov    0xc0038bd4,%edi
c0020e27:	8b 0d c8 8b 03 c0    	mov    0xc0038bc8,%ecx
c0020e2d:	8b 1d cc 8b 03 c0    	mov    0xc0038bcc,%ebx
c0020e33:	a1 c0 8b 03 c0       	mov    0xc0038bc0,%eax
c0020e38:	8b 15 c4 8b 03 c0    	mov    0xc0038bc4,%edx
c0020e3e:	83 ec 04             	sub    $0x4,%esp
c0020e41:	57                   	push   %edi
c0020e42:	56                   	push   %esi
c0020e43:	53                   	push   %ebx
c0020e44:	51                   	push   %ecx
c0020e45:	52                   	push   %edx
c0020e46:	50                   	push   %eax
c0020e47:	68 6c 04 03 c0       	push   $0xc003046c
c0020e4c:	e8 8d 69 00 00       	call   c00277de <printf>
c0020e51:	83 c4 20             	add    $0x20,%esp
         idle_ticks, kernel_ticks, user_ticks);
}
c0020e54:	90                   	nop
c0020e55:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0020e58:	5b                   	pop    %ebx
c0020e59:	5e                   	pop    %esi
c0020e5a:	5f                   	pop    %edi
c0020e5b:	5d                   	pop    %ebp
c0020e5c:	c3                   	ret    

c0020e5d <thread_create>:
   The code provided sets the new thread's `priority' member to
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t thread_create(const char *name, int priority,
                    thread_func *function, void *aux)
{
c0020e5d:	55                   	push   %ebp
c0020e5e:	89 e5                	mov    %esp,%ebp
c0020e60:	83 ec 28             	sub    $0x28,%esp
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;
  enum intr_level previous_level;

  ASSERT(function != NULL);
c0020e63:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020e67:	75 21                	jne    c0020e8a <thread_create+0x2d>
c0020e69:	83 ec 0c             	sub    $0xc,%esp
c0020e6c:	68 a9 04 03 c0       	push   $0xc00304a9
c0020e71:	68 31 04 03 c0       	push   $0xc0030431
c0020e76:	68 d8 05 03 c0       	push   $0xc00305d8
c0020e7b:	68 ae 00 00 00       	push   $0xae
c0020e80:	68 48 04 03 c0       	push   $0xc0030448
c0020e85:	e8 13 8d 00 00       	call   c0029b9d <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page(PAL_ZERO);
c0020e8a:	83 ec 0c             	sub    $0xc,%esp
c0020e8d:	6a 02                	push   $0x2
c0020e8f:	e8 db 28 00 00       	call   c002376f <palloc_get_page>
c0020e94:	83 c4 10             	add    $0x10,%esp
c0020e97:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (t == NULL)
c0020e9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020e9e:	75 0a                	jne    c0020eaa <thread_create+0x4d>
    return TID_ERROR;
c0020ea0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0020ea5:	e9 ea 00 00 00       	jmp    c0020f94 <thread_create+0x137>

  /* Initialize thread. */
  init_thread(t, name, priority);
c0020eaa:	83 ec 04             	sub    $0x4,%esp
c0020ead:	ff 75 0c             	pushl  0xc(%ebp)
c0020eb0:	ff 75 08             	pushl  0x8(%ebp)
c0020eb3:	ff 75 f4             	pushl  -0xc(%ebp)
c0020eb6:	e8 7c 05 00 00       	call   c0021437 <init_thread>
c0020ebb:	83 c4 10             	add    $0x10,%esp
  tid = t->tid = allocate_tid();
c0020ebe:	e8 ef 08 00 00       	call   c00217b2 <allocate_tid>
c0020ec3:	89 c2                	mov    %eax,%edx
c0020ec5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ec8:	89 10                	mov    %edx,(%eax)
c0020eca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ecd:	8b 00                	mov    (%eax),%eax
c0020ecf:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Disable interrupts to ensure atomicity while
 preparing the thread's stack for the first run.
 This ensures that intermediate values for the 'stack'
 member cannot be observed. */
  previous_level = intr_disable();
c0020ed2:	e8 c0 0a 00 00       	call   c0021997 <intr_disable>
c0020ed7:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame(t, sizeof *kf);
c0020eda:	83 ec 08             	sub    $0x8,%esp
c0020edd:	6a 0c                	push   $0xc
c0020edf:	ff 75 f4             	pushl  -0xc(%ebp)
c0020ee2:	e8 9e 06 00 00       	call   c0021585 <alloc_frame>
c0020ee7:	83 c4 10             	add    $0x10,%esp
c0020eea:	89 45 e8             	mov    %eax,-0x18(%ebp)
  kf->eip = NULL;
c0020eed:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020ef0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0020ef6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020ef9:	8b 55 10             	mov    0x10(%ebp),%edx
c0020efc:	89 50 04             	mov    %edx,0x4(%eax)
  kf->aux = aux;
c0020eff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020f02:	8b 55 14             	mov    0x14(%ebp),%edx
c0020f05:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame(t, sizeof *ef);
c0020f08:	83 ec 08             	sub    $0x8,%esp
c0020f0b:	6a 04                	push   $0x4
c0020f0d:	ff 75 f4             	pushl  -0xc(%ebp)
c0020f10:	e8 70 06 00 00       	call   c0021585 <alloc_frame>
c0020f15:	83 c4 10             	add    $0x10,%esp
c0020f18:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ef->eip = (void (*)(void))kernel_thread;
c0020f1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020f1e:	c7 00 b3 13 02 c0    	movl   $0xc00213b3,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame(t, sizeof *sf);
c0020f24:	83 ec 08             	sub    $0x8,%esp
c0020f27:	6a 1c                	push   $0x1c
c0020f29:	ff 75 f4             	pushl  -0xc(%ebp)
c0020f2c:	e8 54 06 00 00       	call   c0021585 <alloc_frame>
c0020f31:	83 c4 10             	add    $0x10,%esp
c0020f34:	89 45 e0             	mov    %eax,-0x20(%ebp)
  sf->eip = switch_entry;
c0020f37:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020f3a:	c7 40 10 f8 18 02 c0 	movl   $0xc00218f8,0x10(%eax)
  sf->ebp = 0;
c0020f41:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020f44:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  /* Restore previous interrupt level and update the parent
and child information for the new thread. */
  intr_set_level(previous_level);
c0020f4b:	83 ec 0c             	sub    $0xc,%esp
c0020f4e:	ff 75 ec             	pushl  -0x14(%ebp)
c0020f51:	e8 e9 09 00 00       	call   c002193f <intr_set_level>
c0020f56:	83 c4 10             	add    $0x10,%esp

  t->parent = thread_tid();
c0020f59:	e8 c9 01 00 00       	call   c0021127 <thread_tid>
c0020f5e:	89 c2                	mov    %eax,%edx
c0020f60:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020f63:	89 50 6c             	mov    %edx,0x6c(%eax)

  /* Add child process information and store it in the new thread */
  struct child_process *child_process = add_child(t->tid);
c0020f66:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020f69:	8b 00                	mov    (%eax),%eax
c0020f6b:	83 ec 0c             	sub    $0xc,%esp
c0020f6e:	50                   	push   %eax
c0020f6f:	e8 7a 08 00 00       	call   c00217ee <add_child>
c0020f74:	83 c4 10             	add    $0x10,%esp
c0020f77:	89 45 dc             	mov    %eax,-0x24(%ebp)
  t->child_process = child_process;
c0020f7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020f7d:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0020f80:	89 50 70             	mov    %edx,0x70(%eax)

  /* Add to run queue. */
  thread_unblock(t);
c0020f83:	83 ec 0c             	sub    $0xc,%esp
c0020f86:	ff 75 f4             	pushl  -0xc(%ebp)
c0020f89:	e8 79 00 00 00       	call   c0021007 <thread_unblock>
c0020f8e:	83 c4 10             	add    $0x10,%esp

  return tid;
c0020f91:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0020f94:	c9                   	leave  
c0020f95:	c3                   	ret    

c0020f96 <thread_block>:

   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void thread_block(void)
{
c0020f96:	55                   	push   %ebp
c0020f97:	89 e5                	mov    %esp,%ebp
c0020f99:	83 ec 08             	sub    $0x8,%esp
  ASSERT(!intr_context());
c0020f9c:	e8 c3 0c 00 00       	call   c0021c64 <intr_context>
c0020fa1:	83 f0 01             	xor    $0x1,%eax
c0020fa4:	84 c0                	test   %al,%al
c0020fa6:	75 21                	jne    c0020fc9 <thread_block+0x33>
c0020fa8:	83 ec 0c             	sub    $0xc,%esp
c0020fab:	68 ba 04 03 c0       	push   $0xc00304ba
c0020fb0:	68 31 04 03 c0       	push   $0xc0030431
c0020fb5:	68 e8 05 03 c0       	push   $0xc00305e8
c0020fba:	68 e6 00 00 00       	push   $0xe6
c0020fbf:	68 48 04 03 c0       	push   $0xc0030448
c0020fc4:	e8 d4 8b 00 00       	call   c0029b9d <debug_panic>
  ASSERT(intr_get_level() == INTR_OFF);
c0020fc9:	e8 54 09 00 00       	call   c0021922 <intr_get_level>
c0020fce:	85 c0                	test   %eax,%eax
c0020fd0:	74 21                	je     c0020ff3 <thread_block+0x5d>
c0020fd2:	83 ec 0c             	sub    $0xc,%esp
c0020fd5:	68 14 04 03 c0       	push   $0xc0030414
c0020fda:	68 31 04 03 c0       	push   $0xc0030431
c0020fdf:	68 e8 05 03 c0       	push   $0xc00305e8
c0020fe4:	68 e7 00 00 00       	push   $0xe7
c0020fe9:	68 48 04 03 c0       	push   $0xc0030448
c0020fee:	e8 aa 8b 00 00       	call   c0029b9d <debug_panic>

  thread_current()->status = THREAD_BLOCKED;
c0020ff3:	e8 be 00 00 00       	call   c00210b6 <thread_current>
c0020ff8:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule();
c0020fff:	e8 dc 06 00 00       	call   c00216e0 <schedule>
}
c0021004:	90                   	nop
c0021005:	c9                   	leave  
c0021006:	c3                   	ret    

c0021007 <thread_unblock>:
   This function does not preempt the running thread.  This can
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void thread_unblock(struct thread *t)
{
c0021007:	55                   	push   %ebp
c0021008:	89 e5                	mov    %esp,%ebp
c002100a:	83 ec 18             	sub    $0x18,%esp
  enum intr_level previous_level;

  ASSERT(is_thread(t));
c002100d:	83 ec 0c             	sub    $0xc,%esp
c0021010:	ff 75 08             	pushl  0x8(%ebp)
c0021013:	e8 f8 03 00 00       	call   c0021410 <is_thread>
c0021018:	83 c4 10             	add    $0x10,%esp
c002101b:	84 c0                	test   %al,%al
c002101d:	75 21                	jne    c0021040 <thread_unblock+0x39>
c002101f:	83 ec 0c             	sub    $0xc,%esp
c0021022:	68 ca 04 03 c0       	push   $0xc00304ca
c0021027:	68 31 04 03 c0       	push   $0xc0030431
c002102c:	68 f8 05 03 c0       	push   $0xc00305f8
c0021031:	68 f9 00 00 00       	push   $0xf9
c0021036:	68 48 04 03 c0       	push   $0xc0030448
c002103b:	e8 5d 8b 00 00       	call   c0029b9d <debug_panic>

  previous_level = intr_disable();
c0021040:	e8 52 09 00 00       	call   c0021997 <intr_disable>
c0021045:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT(t->status == THREAD_BLOCKED);
c0021048:	8b 45 08             	mov    0x8(%ebp),%eax
c002104b:	8b 40 04             	mov    0x4(%eax),%eax
c002104e:	83 f8 02             	cmp    $0x2,%eax
c0021051:	74 21                	je     c0021074 <thread_unblock+0x6d>
c0021053:	83 ec 0c             	sub    $0xc,%esp
c0021056:	68 d7 04 03 c0       	push   $0xc00304d7
c002105b:	68 31 04 03 c0       	push   $0xc0030431
c0021060:	68 f8 05 03 c0       	push   $0xc00305f8
c0021065:	68 fc 00 00 00       	push   $0xfc
c002106a:	68 48 04 03 c0       	push   $0xc0030448
c002106f:	e8 29 8b 00 00       	call   c0029b9d <debug_panic>
  list_push_back(&ready_list, &t->elem);
c0021074:	8b 45 08             	mov    0x8(%ebp),%eax
c0021077:	83 c0 28             	add    $0x28,%eax
c002107a:	83 ec 08             	sub    $0x8,%esp
c002107d:	50                   	push   %eax
c002107e:	68 60 8b 03 c0       	push   $0xc0038b60
c0021083:	e8 66 91 00 00       	call   c002a1ee <list_push_back>
c0021088:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_READY;
c002108b:	8b 45 08             	mov    0x8(%ebp),%eax
c002108e:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  intr_set_level(previous_level);
c0021095:	83 ec 0c             	sub    $0xc,%esp
c0021098:	ff 75 f4             	pushl  -0xc(%ebp)
c002109b:	e8 9f 08 00 00       	call   c002193f <intr_set_level>
c00210a0:	83 c4 10             	add    $0x10,%esp
}
c00210a3:	90                   	nop
c00210a4:	c9                   	leave  
c00210a5:	c3                   	ret    

c00210a6 <thread_name>:

/* Returns the name of the running thread. */
const char *
thread_name(void)
{
c00210a6:	55                   	push   %ebp
c00210a7:	89 e5                	mov    %esp,%ebp
c00210a9:	83 ec 08             	sub    $0x8,%esp
  return thread_current()->name;
c00210ac:	e8 05 00 00 00       	call   c00210b6 <thread_current>
c00210b1:	83 c0 08             	add    $0x8,%eax
}
c00210b4:	c9                   	leave  
c00210b5:	c3                   	ret    

c00210b6 <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current(void)
{
c00210b6:	55                   	push   %ebp
c00210b7:	89 e5                	mov    %esp,%ebp
c00210b9:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = running_thread();
c00210bc:	e8 37 03 00 00       	call   c00213f8 <running_thread>
c00210c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT(is_thread(t));
c00210c4:	83 ec 0c             	sub    $0xc,%esp
c00210c7:	ff 75 f4             	pushl  -0xc(%ebp)
c00210ca:	e8 41 03 00 00       	call   c0021410 <is_thread>
c00210cf:	83 c4 10             	add    $0x10,%esp
c00210d2:	84 c0                	test   %al,%al
c00210d4:	75 21                	jne    c00210f7 <thread_current+0x41>
c00210d6:	83 ec 0c             	sub    $0xc,%esp
c00210d9:	68 ca 04 03 c0       	push   $0xc00304ca
c00210de:	68 31 04 03 c0       	push   $0xc0030431
c00210e3:	68 08 06 03 c0       	push   $0xc0030608
c00210e8:	68 16 01 00 00       	push   $0x116
c00210ed:	68 48 04 03 c0       	push   $0xc0030448
c00210f2:	e8 a6 8a 00 00       	call   c0029b9d <debug_panic>
  ASSERT(t->status == THREAD_RUNNING);
c00210f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00210fa:	8b 40 04             	mov    0x4(%eax),%eax
c00210fd:	85 c0                	test   %eax,%eax
c00210ff:	74 21                	je     c0021122 <thread_current+0x6c>
c0021101:	83 ec 0c             	sub    $0xc,%esp
c0021104:	68 f3 04 03 c0       	push   $0xc00304f3
c0021109:	68 31 04 03 c0       	push   $0xc0030431
c002110e:	68 08 06 03 c0       	push   $0xc0030608
c0021113:	68 17 01 00 00       	push   $0x117
c0021118:	68 48 04 03 c0       	push   $0xc0030448
c002111d:	e8 7b 8a 00 00       	call   c0029b9d <debug_panic>

  return t;
c0021122:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0021125:	c9                   	leave  
c0021126:	c3                   	ret    

c0021127 <thread_tid>:

/* Returns the running thread's tid. */
tid_t thread_tid(void)
{
c0021127:	55                   	push   %ebp
c0021128:	89 e5                	mov    %esp,%ebp
c002112a:	83 ec 08             	sub    $0x8,%esp
  return thread_current()->tid;
c002112d:	e8 84 ff ff ff       	call   c00210b6 <thread_current>
c0021132:	8b 00                	mov    (%eax),%eax
}
c0021134:	c9                   	leave  
c0021135:	c3                   	ret    

c0021136 <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void thread_exit(void)
{
c0021136:	55                   	push   %ebp
c0021137:	89 e5                	mov    %esp,%ebp
c0021139:	83 ec 18             	sub    $0x18,%esp

  ASSERT(!intr_context());
c002113c:	e8 23 0b 00 00       	call   c0021c64 <intr_context>
c0021141:	83 f0 01             	xor    $0x1,%eax
c0021144:	84 c0                	test   %al,%al
c0021146:	75 21                	jne    c0021169 <thread_exit+0x33>
c0021148:	83 ec 0c             	sub    $0xc,%esp
c002114b:	68 ba 04 03 c0       	push   $0xc00304ba
c0021150:	68 31 04 03 c0       	push   $0xc0030431
c0021155:	68 18 06 03 c0       	push   $0xc0030618
c002115a:	68 27 01 00 00       	push   $0x127
c002115f:	68 48 04 03 c0       	push   $0xc0030448
c0021164:	e8 34 8a 00 00       	call   c0029b9d <debug_panic>

#ifdef USERPROG
  process_exit();
c0021169:	e8 56 b0 00 00       	call   c002c1c4 <process_exit>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable();
c002116e:	e8 24 08 00 00       	call   c0021997 <intr_disable>

  struct thread *t = thread_current();
c0021173:	e8 3e ff ff ff       	call   c00210b6 <thread_current>
c0021178:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct list_elem *e;
  struct list_elem *next;

  for (e = list_begin(&t->lock_list); e != list_end(&t->lock_list); e = next)
c002117b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002117e:	83 c0 4c             	add    $0x4c,%eax
c0021181:	83 ec 0c             	sub    $0xc,%esp
c0021184:	50                   	push   %eax
c0021185:	e8 d9 8c 00 00       	call   c0029e63 <list_begin>
c002118a:	83 c4 10             	add    $0x10,%esp
c002118d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0021190:	eb 43                	jmp    c00211d5 <thread_exit+0x9f>
  {
    next = list_next(e);
c0021192:	83 ec 0c             	sub    $0xc,%esp
c0021195:	ff 75 f4             	pushl  -0xc(%ebp)
c0021198:	e8 f8 8c 00 00       	call   c0029e95 <list_next>
c002119d:	83 c4 10             	add    $0x10,%esp
c00211a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    struct lock *lock_ptr = list_entry(e, struct lock, elem);
c00211a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00211a6:	83 c0 04             	add    $0x4,%eax
c00211a9:	83 e8 1c             	sub    $0x1c,%eax
c00211ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
    lock_release(lock_ptr);
c00211af:	83 ec 0c             	sub    $0xc,%esp
c00211b2:	ff 75 e8             	pushl  -0x18(%ebp)
c00211b5:	e8 5f 20 00 00       	call   c0023219 <lock_release>
c00211ba:	83 c4 10             	add    $0x10,%esp
    list_remove(&lock_ptr->elem);
c00211bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00211c0:	83 c0 18             	add    $0x18,%eax
c00211c3:	83 ec 0c             	sub    $0xc,%esp
c00211c6:	50                   	push   %eax
c00211c7:	e8 48 90 00 00       	call   c002a214 <list_remove>
c00211cc:	83 c4 10             	add    $0x10,%esp
  for (e = list_begin(&t->lock_list); e != list_end(&t->lock_list); e = next)
c00211cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00211d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00211d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00211d8:	83 c0 4c             	add    $0x4c,%eax
c00211db:	83 ec 0c             	sub    $0xc,%esp
c00211de:	50                   	push   %eax
c00211df:	e8 fb 8c 00 00       	call   c0029edf <list_end>
c00211e4:	83 c4 10             	add    $0x10,%esp
c00211e7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00211ea:	75 a6                	jne    c0021192 <thread_exit+0x5c>
  }

  list_remove(&thread_current()->allelem);
c00211ec:	e8 c5 fe ff ff       	call   c00210b6 <thread_current>
c00211f1:	83 c0 20             	add    $0x20,%eax
c00211f4:	83 ec 0c             	sub    $0xc,%esp
c00211f7:	50                   	push   %eax
c00211f8:	e8 17 90 00 00       	call   c002a214 <list_remove>
c00211fd:	83 c4 10             	add    $0x10,%esp
  thread_current()->status = THREAD_DYING;
c0021200:	e8 b1 fe ff ff       	call   c00210b6 <thread_current>
c0021205:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule();
c002120c:	e8 cf 04 00 00       	call   c00216e0 <schedule>
  NOT_REACHED();
c0021211:	68 10 05 03 c0       	push   $0xc0030510
c0021216:	68 18 06 03 c0       	push   $0xc0030618
c002121b:	68 41 01 00 00       	push   $0x141
c0021220:	68 48 04 03 c0       	push   $0xc0030448
c0021225:	e8 73 89 00 00       	call   c0029b9d <debug_panic>

c002122a <thread_yield>:
}

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void thread_yield(void)
{
c002122a:	55                   	push   %ebp
c002122b:	89 e5                	mov    %esp,%ebp
c002122d:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = thread_current();
c0021230:	e8 81 fe ff ff       	call   c00210b6 <thread_current>
c0021235:	89 45 f4             	mov    %eax,-0xc(%ebp)
  enum intr_level previous_level;

  ASSERT(!intr_context());
c0021238:	e8 27 0a 00 00       	call   c0021c64 <intr_context>
c002123d:	83 f0 01             	xor    $0x1,%eax
c0021240:	84 c0                	test   %al,%al
c0021242:	75 21                	jne    c0021265 <thread_yield+0x3b>
c0021244:	83 ec 0c             	sub    $0xc,%esp
c0021247:	68 ba 04 03 c0       	push   $0xc00304ba
c002124c:	68 31 04 03 c0       	push   $0xc0030431
c0021251:	68 24 06 03 c0       	push   $0xc0030624
c0021256:	68 4b 01 00 00       	push   $0x14b
c002125b:	68 48 04 03 c0       	push   $0xc0030448
c0021260:	e8 38 89 00 00       	call   c0029b9d <debug_panic>

  previous_level = intr_disable();
c0021265:	e8 2d 07 00 00       	call   c0021997 <intr_disable>
c002126a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (cur != idle_thread)
c002126d:	a1 80 8b 03 c0       	mov    0xc0038b80,%eax
c0021272:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0021275:	74 17                	je     c002128e <thread_yield+0x64>
    list_push_back(&ready_list, &cur->elem);
c0021277:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002127a:	83 c0 28             	add    $0x28,%eax
c002127d:	83 ec 08             	sub    $0x8,%esp
c0021280:	50                   	push   %eax
c0021281:	68 60 8b 03 c0       	push   $0xc0038b60
c0021286:	e8 63 8f 00 00       	call   c002a1ee <list_push_back>
c002128b:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c002128e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021291:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  schedule();
c0021298:	e8 43 04 00 00       	call   c00216e0 <schedule>
  intr_set_level(previous_level);
c002129d:	83 ec 0c             	sub    $0xc,%esp
c00212a0:	ff 75 f0             	pushl  -0x10(%ebp)
c00212a3:	e8 97 06 00 00       	call   c002193f <intr_set_level>
c00212a8:	83 c4 10             	add    $0x10,%esp
}
c00212ab:	90                   	nop
c00212ac:	c9                   	leave  
c00212ad:	c3                   	ret    

c00212ae <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void thread_foreach(thread_action_func *func, void *aux)
{
c00212ae:	55                   	push   %ebp
c00212af:	89 e5                	mov    %esp,%ebp
c00212b1:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT(intr_get_level() == INTR_OFF);
c00212b4:	e8 69 06 00 00       	call   c0021922 <intr_get_level>
c00212b9:	85 c0                	test   %eax,%eax
c00212bb:	74 21                	je     c00212de <thread_foreach+0x30>
c00212bd:	83 ec 0c             	sub    $0xc,%esp
c00212c0:	68 14 04 03 c0       	push   $0xc0030414
c00212c5:	68 31 04 03 c0       	push   $0xc0030431
c00212ca:	68 34 06 03 c0       	push   $0xc0030634
c00212cf:	68 5b 01 00 00       	push   $0x15b
c00212d4:	68 48 04 03 c0       	push   $0xc0030448
c00212d9:	e8 bf 88 00 00       	call   c0029b9d <debug_panic>

  for (e = list_begin(&all_list); e != list_end(&all_list);
c00212de:	83 ec 0c             	sub    $0xc,%esp
c00212e1:	68 70 8b 03 c0       	push   $0xc0038b70
c00212e6:	e8 78 8b 00 00       	call   c0029e63 <list_begin>
c00212eb:	83 c4 10             	add    $0x10,%esp
c00212ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00212f1:	eb 2e                	jmp    c0021321 <thread_foreach+0x73>
       e = list_next(e))
  {
    struct thread *t = list_entry(e, struct thread, allelem);
c00212f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00212f6:	83 c0 04             	add    $0x4,%eax
c00212f9:	83 e8 24             	sub    $0x24,%eax
c00212fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    func(t, aux);
c00212ff:	83 ec 08             	sub    $0x8,%esp
c0021302:	ff 75 0c             	pushl  0xc(%ebp)
c0021305:	ff 75 f0             	pushl  -0x10(%ebp)
c0021308:	8b 45 08             	mov    0x8(%ebp),%eax
c002130b:	ff d0                	call   *%eax
c002130d:	83 c4 10             	add    $0x10,%esp
       e = list_next(e))
c0021310:	83 ec 0c             	sub    $0xc,%esp
c0021313:	ff 75 f4             	pushl  -0xc(%ebp)
c0021316:	e8 7a 8b 00 00       	call   c0029e95 <list_next>
c002131b:	83 c4 10             	add    $0x10,%esp
c002131e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin(&all_list); e != list_end(&all_list);
c0021321:	83 ec 0c             	sub    $0xc,%esp
c0021324:	68 70 8b 03 c0       	push   $0xc0038b70
c0021329:	e8 b1 8b 00 00       	call   c0029edf <list_end>
c002132e:	83 c4 10             	add    $0x10,%esp
c0021331:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0021334:	75 bd                	jne    c00212f3 <thread_foreach+0x45>
  }
}
c0021336:	90                   	nop
c0021337:	c9                   	leave  
c0021338:	c3                   	ret    

c0021339 <thread_set_priority>:

/* Sets the current thread's priority to NEW_PRIORITY. */
void thread_set_priority(int new_priority)
{
c0021339:	55                   	push   %ebp
c002133a:	89 e5                	mov    %esp,%ebp
c002133c:	83 ec 08             	sub    $0x8,%esp
  thread_current()->priority = new_priority;
c002133f:	e8 72 fd ff ff       	call   c00210b6 <thread_current>
c0021344:	8b 55 08             	mov    0x8(%ebp),%edx
c0021347:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c002134a:	90                   	nop
c002134b:	c9                   	leave  
c002134c:	c3                   	ret    

c002134d <thread_get_priority>:

/* Returns the current thread's priority. */
int thread_get_priority(void)
{
c002134d:	55                   	push   %ebp
c002134e:	89 e5                	mov    %esp,%ebp
c0021350:	83 ec 08             	sub    $0x8,%esp
  return thread_current()->priority;
c0021353:	e8 5e fd ff ff       	call   c00210b6 <thread_current>
c0021358:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002135b:	c9                   	leave  
c002135c:	c3                   	ret    

c002135d <thread_set_nice>:

/* Sets the current thread's nice value to NICE. */
void thread_set_nice(int nice UNUSED)
{
c002135d:	55                   	push   %ebp
c002135e:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
}
c0021360:	90                   	nop
c0021361:	5d                   	pop    %ebp
c0021362:	c3                   	ret    

c0021363 <thread_get_nice>:

/* Returns the current thread's nice value. */
int thread_get_nice(void)
{
c0021363:	55                   	push   %ebp
c0021364:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0021366:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002136b:	5d                   	pop    %ebp
c002136c:	c3                   	ret    

c002136d <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int thread_get_load_avg(void)
{
c002136d:	55                   	push   %ebp
c002136e:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0021370:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0021375:	5d                   	pop    %ebp
c0021376:	c3                   	ret    

c0021377 <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int thread_get_recent_cpu(void)
{
c0021377:	55                   	push   %ebp
c0021378:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c002137a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002137f:	5d                   	pop    %ebp
c0021380:	c3                   	ret    

c0021381 <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle(void *idle_started_ UNUSED)
{
c0021381:	55                   	push   %ebp
c0021382:	89 e5                	mov    %esp,%ebp
c0021384:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *idle_started = idle_started_;
c0021387:	8b 45 08             	mov    0x8(%ebp),%eax
c002138a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  idle_thread = thread_current();
c002138d:	e8 24 fd ff ff       	call   c00210b6 <thread_current>
c0021392:	a3 80 8b 03 c0       	mov    %eax,0xc0038b80
  semaphore_up(idle_started);
c0021397:	83 ec 0c             	sub    $0xc,%esp
c002139a:	ff 75 f4             	pushl  -0xc(%ebp)
c002139d:	e8 45 1b 00 00       	call   c0022ee7 <semaphore_up>
c00213a2:	83 c4 10             	add    $0x10,%esp

  for (;;)
  {
    /* Let someone else run. */
    intr_disable();
c00213a5:	e8 ed 05 00 00       	call   c0021997 <intr_disable>
    thread_block();
c00213aa:	e8 e7 fb ff ff       	call   c0020f96 <thread_block>
       one to occur, wasting as much as one clock tick worth of
       time.

       See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
       7.11.1 "HLT Instruction". */
    asm volatile("sti; hlt"
c00213af:	fb                   	sti    
c00213b0:	f4                   	hlt    
    intr_disable();
c00213b1:	eb f2                	jmp    c00213a5 <idle+0x24>

c00213b3 <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread(thread_func *function, void *aux)
{
c00213b3:	55                   	push   %ebp
c00213b4:	89 e5                	mov    %esp,%ebp
c00213b6:	83 ec 08             	sub    $0x8,%esp
  ASSERT(function != NULL);
c00213b9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00213bd:	75 21                	jne    c00213e0 <kernel_thread+0x2d>
c00213bf:	83 ec 0c             	sub    $0xc,%esp
c00213c2:	68 a9 04 03 c0       	push   $0xc00304a9
c00213c7:	68 31 04 03 c0       	push   $0xc0030431
c00213cc:	68 44 06 03 c0       	push   $0xc0030644
c00213d1:	68 b9 01 00 00       	push   $0x1b9
c00213d6:	68 48 04 03 c0       	push   $0xc0030448
c00213db:	e8 bd 87 00 00       	call   c0029b9d <debug_panic>

  intr_enable(); /* The scheduler runs with interrupts off. */
c00213e0:	e8 74 05 00 00       	call   c0021959 <intr_enable>
  function(aux); /* Execute the thread function. */
c00213e5:	83 ec 0c             	sub    $0xc,%esp
c00213e8:	ff 75 0c             	pushl  0xc(%ebp)
c00213eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00213ee:	ff d0                	call   *%eax
c00213f0:	83 c4 10             	add    $0x10,%esp
  thread_exit(); /* If function() returns, kill the thread. */
c00213f3:	e8 3e fd ff ff       	call   c0021136 <thread_exit>

c00213f8 <running_thread>:
}

/* Returns the running thread. */
struct thread *
running_thread(void)
{
c00213f8:	55                   	push   %ebp
c00213f9:	89 e5                	mov    %esp,%ebp
c00213fb:	83 ec 10             	sub    $0x10,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm("mov %%esp, %0"
c00213fe:	89 e0                	mov    %esp,%eax
c0021400:	89 45 fc             	mov    %eax,-0x4(%ebp)
      : "=g"(esp));
  return pg_round_down(esp);
c0021403:	ff 75 fc             	pushl  -0x4(%ebp)
c0021406:	e8 7e f8 ff ff       	call   c0020c89 <pg_round_down>
c002140b:	83 c4 04             	add    $0x4,%esp
}
c002140e:	c9                   	leave  
c002140f:	c3                   	ret    

c0021410 <is_thread>:

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread(struct thread *t)
{
c0021410:	55                   	push   %ebp
c0021411:	89 e5                	mov    %esp,%ebp
  return t != NULL && t->magic == THREAD_MAGIC;
c0021413:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021417:	74 14                	je     c002142d <is_thread+0x1d>
c0021419:	8b 45 08             	mov    0x8(%ebp),%eax
c002141c:	8b 40 34             	mov    0x34(%eax),%eax
c002141f:	3d 4b bf 6a cd       	cmp    $0xcd6abf4b,%eax
c0021424:	75 07                	jne    c002142d <is_thread+0x1d>
c0021426:	b8 01 00 00 00       	mov    $0x1,%eax
c002142b:	eb 05                	jmp    c0021432 <is_thread+0x22>
c002142d:	b8 00 00 00 00       	mov    $0x0,%eax
c0021432:	83 e0 01             	and    $0x1,%eax
}
c0021435:	5d                   	pop    %ebp
c0021436:	c3                   	ret    

c0021437 <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread(struct thread *t, const char *name, int priority)
{
c0021437:	55                   	push   %ebp
c0021438:	89 e5                	mov    %esp,%ebp
c002143a:	83 ec 08             	sub    $0x8,%esp
  ASSERT(t != NULL);
c002143d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021441:	75 21                	jne    c0021464 <init_thread+0x2d>
c0021443:	83 ec 0c             	sub    $0xc,%esp
c0021446:	68 32 05 03 c0       	push   $0xc0030532
c002144b:	68 31 04 03 c0       	push   $0xc0030431
c0021450:	68 54 06 03 c0       	push   $0xc0030654
c0021455:	68 db 01 00 00       	push   $0x1db
c002145a:	68 48 04 03 c0       	push   $0xc0030448
c002145f:	e8 39 87 00 00       	call   c0029b9d <debug_panic>
  ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
c0021464:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0021468:	78 06                	js     c0021470 <init_thread+0x39>
c002146a:	83 7d 10 3f          	cmpl   $0x3f,0x10(%ebp)
c002146e:	7e 21                	jle    c0021491 <init_thread+0x5a>
c0021470:	83 ec 0c             	sub    $0xc,%esp
c0021473:	68 3c 05 03 c0       	push   $0xc003053c
c0021478:	68 31 04 03 c0       	push   $0xc0030431
c002147d:	68 54 06 03 c0       	push   $0xc0030654
c0021482:	68 dc 01 00 00       	push   $0x1dc
c0021487:	68 48 04 03 c0       	push   $0xc0030448
c002148c:	e8 0c 87 00 00       	call   c0029b9d <debug_panic>
  ASSERT(name != NULL);
c0021491:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0021495:	75 21                	jne    c00214b8 <init_thread+0x81>
c0021497:	83 ec 0c             	sub    $0xc,%esp
c002149a:	68 67 05 03 c0       	push   $0xc0030567
c002149f:	68 31 04 03 c0       	push   $0xc0030431
c00214a4:	68 54 06 03 c0       	push   $0xc0030654
c00214a9:	68 dd 01 00 00       	push   $0x1dd
c00214ae:	68 48 04 03 c0       	push   $0xc0030448
c00214b3:	e8 e5 86 00 00       	call   c0029b9d <debug_panic>

  memset(t, 0, sizeof *t);
c00214b8:	83 ec 04             	sub    $0x4,%esp
c00214bb:	6a 78                	push   $0x78
c00214bd:	6a 00                	push   $0x0
c00214bf:	ff 75 08             	pushl  0x8(%ebp)
c00214c2:	e8 f0 7a 00 00       	call   c0028fb7 <memset>
c00214c7:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_BLOCKED;
c00214ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00214cd:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  strlcpy(t->name, name, sizeof t->name);
c00214d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00214d7:	83 c0 08             	add    $0x8,%eax
c00214da:	83 ec 04             	sub    $0x4,%esp
c00214dd:	6a 10                	push   $0x10
c00214df:	ff 75 0c             	pushl  0xc(%ebp)
c00214e2:	50                   	push   %eax
c00214e3:	e8 a2 7b 00 00       	call   c002908a <strlcpy>
c00214e8:	83 c4 10             	add    $0x10,%esp
  t->stack = (uint8_t *)t + PGSIZE;
c00214eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00214ee:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c00214f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00214f7:	89 50 18             	mov    %edx,0x18(%eax)
  t->priority = priority;
c00214fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00214fd:	8b 55 10             	mov    0x10(%ebp),%edx
c0021500:	89 50 1c             	mov    %edx,0x1c(%eax)
  t->magic = THREAD_MAGIC;
c0021503:	8b 45 08             	mov    0x8(%ebp),%eax
c0021506:	c7 40 34 4b bf 6a cd 	movl   $0xcd6abf4b,0x34(%eax)
  list_push_back(&all_list, &t->allelem);
c002150d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021510:	83 c0 20             	add    $0x20,%eax
c0021513:	83 ec 08             	sub    $0x8,%esp
c0021516:	50                   	push   %eax
c0021517:	68 70 8b 03 c0       	push   $0xc0038b70
c002151c:	e8 cd 8c 00 00       	call   c002a1ee <list_push_back>
c0021521:	83 c4 10             	add    $0x10,%esp
  list_init(&t->file_name_list);
c0021524:	8b 45 08             	mov    0x8(%ebp),%eax
c0021527:	83 c0 38             	add    $0x38,%eax
c002152a:	83 ec 0c             	sub    $0xc,%esp
c002152d:	50                   	push   %eax
c002152e:	e8 db 88 00 00       	call   c0029e0e <list_init>
c0021533:	83 c4 10             	add    $0x10,%esp
  list_init(&t->child_process_list);
c0021536:	8b 45 08             	mov    0x8(%ebp),%eax
c0021539:	83 c0 5c             	add    $0x5c,%eax
c002153c:	83 ec 0c             	sub    $0xc,%esp
c002153f:	50                   	push   %eax
c0021540:	e8 c9 88 00 00       	call   c0029e0e <list_init>
c0021545:	83 c4 10             	add    $0x10,%esp
  list_init(&t->lock_list);
c0021548:	8b 45 08             	mov    0x8(%ebp),%eax
c002154b:	83 c0 4c             	add    $0x4c,%eax
c002154e:	83 ec 0c             	sub    $0xc,%esp
c0021551:	50                   	push   %eax
c0021552:	e8 b7 88 00 00       	call   c0029e0e <list_init>
c0021557:	83 c4 10             	add    $0x10,%esp
  t->fd = 2;
c002155a:	8b 45 08             	mov    0x8(%ebp),%eax
c002155d:	c7 40 48 02 00 00 00 	movl   $0x2,0x48(%eax)
  t->child_process = NULL;
c0021564:	8b 45 08             	mov    0x8(%ebp),%eax
c0021567:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
  t->parent = -1;
c002156e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021571:	c7 40 6c ff ff ff ff 	movl   $0xffffffff,0x6c(%eax)
  t->executable = NULL;
c0021578:	8b 45 08             	mov    0x8(%ebp),%eax
c002157b:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
}
c0021582:	90                   	nop
c0021583:	c9                   	leave  
c0021584:	c3                   	ret    

c0021585 <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame(struct thread *t, size_t size)
{
c0021585:	55                   	push   %ebp
c0021586:	89 e5                	mov    %esp,%ebp
c0021588:	83 ec 08             	sub    $0x8,%esp
  /* Stack data is always allocated in word-size units. */
  ASSERT(is_thread(t));
c002158b:	ff 75 08             	pushl  0x8(%ebp)
c002158e:	e8 7d fe ff ff       	call   c0021410 <is_thread>
c0021593:	83 c4 04             	add    $0x4,%esp
c0021596:	84 c0                	test   %al,%al
c0021598:	75 21                	jne    c00215bb <alloc_frame+0x36>
c002159a:	83 ec 0c             	sub    $0xc,%esp
c002159d:	68 ca 04 03 c0       	push   $0xc00304ca
c00215a2:	68 31 04 03 c0       	push   $0xc0030431
c00215a7:	68 60 06 03 c0       	push   $0xc0030660
c00215ac:	68 f5 01 00 00       	push   $0x1f5
c00215b1:	68 48 04 03 c0       	push   $0xc0030448
c00215b6:	e8 e2 85 00 00       	call   c0029b9d <debug_panic>
  ASSERT(size % sizeof(uint32_t) == 0);
c00215bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00215be:	83 e0 03             	and    $0x3,%eax
c00215c1:	85 c0                	test   %eax,%eax
c00215c3:	74 21                	je     c00215e6 <alloc_frame+0x61>
c00215c5:	83 ec 0c             	sub    $0xc,%esp
c00215c8:	68 74 05 03 c0       	push   $0xc0030574
c00215cd:	68 31 04 03 c0       	push   $0xc0030431
c00215d2:	68 60 06 03 c0       	push   $0xc0030660
c00215d7:	68 f6 01 00 00       	push   $0x1f6
c00215dc:	68 48 04 03 c0       	push   $0xc0030448
c00215e1:	e8 b7 85 00 00       	call   c0029b9d <debug_panic>

  t->stack -= size;
c00215e6:	8b 45 08             	mov    0x8(%ebp),%eax
c00215e9:	8b 40 18             	mov    0x18(%eax),%eax
c00215ec:	8b 55 0c             	mov    0xc(%ebp),%edx
c00215ef:	f7 da                	neg    %edx
c00215f1:	01 c2                	add    %eax,%edx
c00215f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00215f6:	89 50 18             	mov    %edx,0x18(%eax)
  return t->stack;
c00215f9:	8b 45 08             	mov    0x8(%ebp),%eax
c00215fc:	8b 40 18             	mov    0x18(%eax),%eax
}
c00215ff:	c9                   	leave  
c0021600:	c3                   	ret    

c0021601 <next_thread_to_run>:
   empty.  (If the running thread can continue running, then it
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run(void)
{
c0021601:	55                   	push   %ebp
c0021602:	89 e5                	mov    %esp,%ebp
c0021604:	83 ec 08             	sub    $0x8,%esp
  if (list_empty(&ready_list))
c0021607:	83 ec 0c             	sub    $0xc,%esp
c002160a:	68 60 8b 03 c0       	push   $0xc0038b60
c002160f:	e8 81 8d 00 00       	call   c002a395 <list_empty>
c0021614:	83 c4 10             	add    $0x10,%esp
c0021617:	84 c0                	test   %al,%al
c0021619:	74 07                	je     c0021622 <next_thread_to_run+0x21>
    return idle_thread;
c002161b:	a1 80 8b 03 c0       	mov    0xc0038b80,%eax
c0021620:	eb 16                	jmp    c0021638 <next_thread_to_run+0x37>
  else
    return list_entry(list_pop_front(&ready_list), struct thread, elem);
c0021622:	83 ec 0c             	sub    $0xc,%esp
c0021625:	68 60 8b 03 c0       	push   $0xc0038b60
c002162a:	e8 3e 8c 00 00       	call   c002a26d <list_pop_front>
c002162f:	83 c4 10             	add    $0x10,%esp
c0021632:	83 c0 04             	add    $0x4,%eax
c0021635:	83 e8 2c             	sub    $0x2c,%eax
}
c0021638:	c9                   	leave  
c0021639:	c3                   	ret    

c002163a <thread_schedule_tail>:
   added at the end of the function.

   After this function and its caller returns, the thread switch
   is complete. */
void thread_schedule_tail(struct thread *prev)
{
c002163a:	55                   	push   %ebp
c002163b:	89 e5                	mov    %esp,%ebp
c002163d:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread();
c0021640:	e8 b3 fd ff ff       	call   c00213f8 <running_thread>
c0021645:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT(intr_get_level() == INTR_OFF);
c0021648:	e8 d5 02 00 00       	call   c0021922 <intr_get_level>
c002164d:	85 c0                	test   %eax,%eax
c002164f:	74 21                	je     c0021672 <thread_schedule_tail+0x38>
c0021651:	83 ec 0c             	sub    $0xc,%esp
c0021654:	68 14 04 03 c0       	push   $0xc0030414
c0021659:	68 31 04 03 c0       	push   $0xc0030431
c002165e:	68 6c 06 03 c0       	push   $0xc003066c
c0021663:	68 1e 02 00 00       	push   $0x21e
c0021668:	68 48 04 03 c0       	push   $0xc0030448
c002166d:	e8 2b 85 00 00       	call   c0029b9d <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c0021672:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021675:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

  /* Start new time slice. */
  thread_ticks = 0;
c002167c:	c7 05 d8 8b 03 c0 00 	movl   $0x0,0xc0038bd8
c0021683:	00 00 00 

#ifdef USERPROG
  /* Activate the new address space. */
  process_activate();
c0021686:	e8 04 ac 00 00       	call   c002c28f <process_activate>
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread)
c002168b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002168f:	74 4c                	je     c00216dd <thread_schedule_tail+0xa3>
c0021691:	8b 45 08             	mov    0x8(%ebp),%eax
c0021694:	8b 40 04             	mov    0x4(%eax),%eax
c0021697:	83 f8 03             	cmp    $0x3,%eax
c002169a:	75 41                	jne    c00216dd <thread_schedule_tail+0xa3>
c002169c:	a1 84 8b 03 c0       	mov    0xc0038b84,%eax
c00216a1:	39 45 08             	cmp    %eax,0x8(%ebp)
c00216a4:	74 37                	je     c00216dd <thread_schedule_tail+0xa3>
  {
    ASSERT(prev != cur);
c00216a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00216a9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00216ac:	75 21                	jne    c00216cf <thread_schedule_tail+0x95>
c00216ae:	83 ec 0c             	sub    $0xc,%esp
c00216b1:	68 91 05 03 c0       	push   $0xc0030591
c00216b6:	68 31 04 03 c0       	push   $0xc0030431
c00216bb:	68 6c 06 03 c0       	push   $0xc003066c
c00216c0:	68 32 02 00 00       	push   $0x232
c00216c5:	68 48 04 03 c0       	push   $0xc0030448
c00216ca:	e8 ce 84 00 00       	call   c0029b9d <debug_panic>
    palloc_free_page(prev);
c00216cf:	83 ec 0c             	sub    $0xc,%esp
c00216d2:	ff 75 08             	pushl  0x8(%ebp)
c00216d5:	e8 ed 21 00 00       	call   c00238c7 <palloc_free_page>
c00216da:	83 c4 10             	add    $0x10,%esp
  }
}
c00216dd:	90                   	nop
c00216de:	c9                   	leave  
c00216df:	c3                   	ret    

c00216e0 <schedule>:

   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule(void)
{
c00216e0:	55                   	push   %ebp
c00216e1:	89 e5                	mov    %esp,%ebp
c00216e3:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread();
c00216e6:	e8 0d fd ff ff       	call   c00213f8 <running_thread>
c00216eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread *next = next_thread_to_run();
c00216ee:	e8 0e ff ff ff       	call   c0021601 <next_thread_to_run>
c00216f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread *prev = NULL;
c00216f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  ASSERT(intr_get_level() == INTR_OFF);
c00216fd:	e8 20 02 00 00       	call   c0021922 <intr_get_level>
c0021702:	85 c0                	test   %eax,%eax
c0021704:	74 21                	je     c0021727 <schedule+0x47>
c0021706:	83 ec 0c             	sub    $0xc,%esp
c0021709:	68 14 04 03 c0       	push   $0xc0030414
c002170e:	68 31 04 03 c0       	push   $0xc0030431
c0021713:	68 84 06 03 c0       	push   $0xc0030684
c0021718:	68 45 02 00 00       	push   $0x245
c002171d:	68 48 04 03 c0       	push   $0xc0030448
c0021722:	e8 76 84 00 00       	call   c0029b9d <debug_panic>
  ASSERT(cur->status != THREAD_RUNNING);
c0021727:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002172a:	8b 40 04             	mov    0x4(%eax),%eax
c002172d:	85 c0                	test   %eax,%eax
c002172f:	75 21                	jne    c0021752 <schedule+0x72>
c0021731:	83 ec 0c             	sub    $0xc,%esp
c0021734:	68 9d 05 03 c0       	push   $0xc003059d
c0021739:	68 31 04 03 c0       	push   $0xc0030431
c002173e:	68 84 06 03 c0       	push   $0xc0030684
c0021743:	68 46 02 00 00       	push   $0x246
c0021748:	68 48 04 03 c0       	push   $0xc0030448
c002174d:	e8 4b 84 00 00       	call   c0029b9d <debug_panic>
  ASSERT(is_thread(next));
c0021752:	83 ec 0c             	sub    $0xc,%esp
c0021755:	ff 75 ec             	pushl  -0x14(%ebp)
c0021758:	e8 b3 fc ff ff       	call   c0021410 <is_thread>
c002175d:	83 c4 10             	add    $0x10,%esp
c0021760:	84 c0                	test   %al,%al
c0021762:	75 21                	jne    c0021785 <schedule+0xa5>
c0021764:	83 ec 0c             	sub    $0xc,%esp
c0021767:	68 bb 05 03 c0       	push   $0xc00305bb
c002176c:	68 31 04 03 c0       	push   $0xc0030431
c0021771:	68 84 06 03 c0       	push   $0xc0030684
c0021776:	68 47 02 00 00       	push   $0x247
c002177b:	68 48 04 03 c0       	push   $0xc0030448
c0021780:	e8 18 84 00 00       	call   c0029b9d <debug_panic>

  if (cur != next)
c0021785:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021788:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002178b:	74 14                	je     c00217a1 <schedule+0xc1>
    prev = switch_threads(cur, next);
c002178d:	83 ec 08             	sub    $0x8,%esp
c0021790:	ff 75 ec             	pushl  -0x14(%ebp)
c0021793:	ff 75 f0             	pushl  -0x10(%ebp)
c0021796:	e8 40 01 00 00       	call   c00218db <switch_threads>
c002179b:	83 c4 10             	add    $0x10,%esp
c002179e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread_schedule_tail(prev);
c00217a1:	83 ec 0c             	sub    $0xc,%esp
c00217a4:	ff 75 f4             	pushl  -0xc(%ebp)
c00217a7:	e8 8e fe ff ff       	call   c002163a <thread_schedule_tail>
c00217ac:	83 c4 10             	add    $0x10,%esp
}
c00217af:	90                   	nop
c00217b0:	c9                   	leave  
c00217b1:	c3                   	ret    

c00217b2 <allocate_tid>:

/* Returns a tid to use for a new thread. */
static tid_t
allocate_tid(void)
{
c00217b2:	55                   	push   %ebp
c00217b3:	89 e5                	mov    %esp,%ebp
c00217b5:	83 ec 18             	sub    $0x18,%esp
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire(&tid_lock);
c00217b8:	83 ec 0c             	sub    $0xc,%esp
c00217bb:	68 a0 8b 03 c0       	push   $0xc0038ba0
c00217c0:	e8 d6 18 00 00       	call   c002309b <lock_acquire>
c00217c5:	83 c4 10             	add    $0x10,%esp
  tid = next_tid++;
c00217c8:	a1 88 81 03 c0       	mov    0xc0038188,%eax
c00217cd:	8d 50 01             	lea    0x1(%eax),%edx
c00217d0:	89 15 88 81 03 c0    	mov    %edx,0xc0038188
c00217d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lock_release(&tid_lock);
c00217d9:	83 ec 0c             	sub    $0xc,%esp
c00217dc:	68 a0 8b 03 c0       	push   $0xc0038ba0
c00217e1:	e8 33 1a 00 00       	call   c0023219 <lock_release>
c00217e6:	83 c4 10             	add    $0x10,%esp

  return tid;
c00217e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00217ec:	c9                   	leave  
c00217ed:	c3                   	ret    

c00217ee <add_child>:
   Used by switch.S, which can't figure it out on its own. */
uint32_t thread_stack_ofs = offsetof(struct thread, stack);

// Function to add a child process to the current thread's list of child processes
struct child_process *add_child(int pid)
{
c00217ee:	55                   	push   %ebp
c00217ef:	89 e5                	mov    %esp,%ebp
c00217f1:	53                   	push   %ebx
c00217f2:	83 ec 14             	sub    $0x14,%esp
  struct child_process *child = (struct child_process *)malloc(sizeof(struct child_process));
c00217f5:	83 ec 0c             	sub    $0xc,%esp
c00217f8:	6a 44                	push   $0x44
c00217fa:	e8 bb 22 00 00       	call   c0023aba <malloc>
c00217ff:	83 c4 10             	add    $0x10,%esp
c0021802:	89 45 f4             	mov    %eax,-0xc(%ebp)
  child->pid = pid;
c0021805:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021808:	8b 55 08             	mov    0x8(%ebp),%edx
c002180b:	89 10                	mov    %edx,(%eax)
  child->load_status = NOT_LOADED;
c002180d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021810:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  child->wait = 0;
c0021817:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002181a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  child->exit = 0;
c0021821:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021824:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  sema_init(&child->load_semaphore, 0);
c002182b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002182e:	83 c0 14             	add    $0x14,%eax
c0021831:	83 ec 08             	sub    $0x8,%esp
c0021834:	6a 00                	push   $0x0
c0021836:	50                   	push   %eax
c0021837:	e8 5a 15 00 00       	call   c0022d96 <sema_init>
c002183c:	83 c4 10             	add    $0x10,%esp
  sema_init(&child->exit_sema, 0);
c002183f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021842:	83 c0 28             	add    $0x28,%eax
c0021845:	83 ec 08             	sub    $0x8,%esp
c0021848:	6a 00                	push   $0x0
c002184a:	50                   	push   %eax
c002184b:	e8 46 15 00 00       	call   c0022d96 <sema_init>
c0021850:	83 c4 10             	add    $0x10,%esp
  list_push_back(&thread_current()->child_process_list, &child->elem);
c0021853:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021856:	8d 58 3c             	lea    0x3c(%eax),%ebx
c0021859:	e8 58 f8 ff ff       	call   c00210b6 <thread_current>
c002185e:	83 c0 5c             	add    $0x5c,%eax
c0021861:	83 ec 08             	sub    $0x8,%esp
c0021864:	53                   	push   %ebx
c0021865:	50                   	push   %eax
c0021866:	e8 83 89 00 00       	call   c002a1ee <list_push_back>
c002186b:	83 c4 10             	add    $0x10,%esp
  return child;
c002186e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0021871:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021874:	c9                   	leave  
c0021875:	c3                   	ret    

c0021876 <check_thread_active>:

// Function to check if a thread with the given pid is still active
int check_thread_active(int pid)
{
c0021876:	55                   	push   %ebp
c0021877:	89 e5                	mov    %esp,%ebp
c0021879:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *elem;
  for (elem = list_begin(&all_list); elem != list_end(&all_list); elem = list_next(elem))
c002187c:	83 ec 0c             	sub    $0xc,%esp
c002187f:	68 70 8b 03 c0       	push   $0xc0038b70
c0021884:	e8 da 85 00 00       	call   c0029e63 <list_begin>
c0021889:	83 c4 10             	add    $0x10,%esp
c002188c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002188f:	eb 2e                	jmp    c00218bf <check_thread_active+0x49>
  {
    struct thread *t = list_entry(elem, struct thread, allelem);
c0021891:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021894:	83 c0 04             	add    $0x4,%eax
c0021897:	83 e8 24             	sub    $0x24,%eax
c002189a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (t->tid == pid)
c002189d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00218a0:	8b 00                	mov    (%eax),%eax
c00218a2:	3b 45 08             	cmp    0x8(%ebp),%eax
c00218a5:	75 07                	jne    c00218ae <check_thread_active+0x38>
      return 1;
c00218a7:	b8 01 00 00 00       	mov    $0x1,%eax
c00218ac:	eb 2b                	jmp    c00218d9 <check_thread_active+0x63>
  for (elem = list_begin(&all_list); elem != list_end(&all_list); elem = list_next(elem))
c00218ae:	83 ec 0c             	sub    $0xc,%esp
c00218b1:	ff 75 f4             	pushl  -0xc(%ebp)
c00218b4:	e8 dc 85 00 00       	call   c0029e95 <list_next>
c00218b9:	83 c4 10             	add    $0x10,%esp
c00218bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00218bf:	83 ec 0c             	sub    $0xc,%esp
c00218c2:	68 70 8b 03 c0       	push   $0xc0038b70
c00218c7:	e8 13 86 00 00       	call   c0029edf <list_end>
c00218cc:	83 c4 10             	add    $0x10,%esp
c00218cf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00218d2:	75 bd                	jne    c0021891 <check_thread_active+0x1b>
  }
  return 0;
c00218d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00218d9:	c9                   	leave  
c00218da:	c3                   	ret    

c00218db <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c00218db:	53                   	push   %ebx
	pushl %ebp
c00218dc:	55                   	push   %ebp
	pushl %esi
c00218dd:	56                   	push   %esi
	pushl %edi
c00218de:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c00218df:	8b 15 84 81 03 c0    	mov    0xc0038184,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c00218e5:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c00218e9:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c00218ec:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c00218f0:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c00218f3:	5f                   	pop    %edi
	popl %esi
c00218f4:	5e                   	pop    %esi
	popl %ebp
c00218f5:	5d                   	pop    %ebp
	popl %ebx
c00218f6:	5b                   	pop    %ebx
        ret
c00218f7:	c3                   	ret    

c00218f8 <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c00218f8:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c00218fb:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c00218fc:	e8 39 fd ff ff       	call   c002163a <thread_schedule_tail>
	addl $4, %esp
c0021901:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021904:	c3                   	ret    

c0021905 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0021905:	55                   	push   %ebp
c0021906:	89 e5                	mov    %esp,%ebp
c0021908:	83 ec 08             	sub    $0x8,%esp
c002190b:	8b 45 08             	mov    0x8(%ebp),%eax
c002190e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0021911:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0021915:	88 55 f8             	mov    %dl,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021918:	8a 45 f8             	mov    -0x8(%ebp),%al
c002191b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002191e:	ee                   	out    %al,(%dx)
}
c002191f:	90                   	nop
c0021920:	c9                   	leave  
c0021921:	c3                   	ret    

c0021922 <intr_get_level>:
static void unexpected_interrupt (const struct intr_frame *);

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
c0021922:	55                   	push   %ebp
c0021923:	89 e5                	mov    %esp,%ebp
c0021925:	83 ec 10             	sub    $0x10,%esp

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021928:	9c                   	pushf  
c0021929:	58                   	pop    %eax
c002192a:	89 45 fc             	mov    %eax,-0x4(%ebp)

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c002192d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0021930:	25 00 02 00 00       	and    $0x200,%eax
c0021935:	85 c0                	test   %eax,%eax
c0021937:	0f 95 c0             	setne  %al
c002193a:	0f b6 c0             	movzbl %al,%eax
}
c002193d:	c9                   	leave  
c002193e:	c3                   	ret    

c002193f <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c002193f:	55                   	push   %ebp
c0021940:	89 e5                	mov    %esp,%ebp
c0021942:	83 ec 08             	sub    $0x8,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021945:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0021949:	75 07                	jne    c0021952 <intr_set_level+0x13>
c002194b:	e8 09 00 00 00       	call   c0021959 <intr_enable>
c0021950:	eb 05                	jmp    c0021957 <intr_set_level+0x18>
c0021952:	e8 40 00 00 00       	call   c0021997 <intr_disable>
}
c0021957:	c9                   	leave  
c0021958:	c3                   	ret    

c0021959 <intr_enable>:

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c0021959:	55                   	push   %ebp
c002195a:	89 e5                	mov    %esp,%ebp
c002195c:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_get_level ();
c002195f:	e8 be ff ff ff       	call   c0021922 <intr_get_level>
c0021964:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (!intr_context ());
c0021967:	e8 f8 02 00 00       	call   c0021c64 <intr_context>
c002196c:	83 f0 01             	xor    $0x1,%eax
c002196f:	84 c0                	test   %al,%al
c0021971:	75 1e                	jne    c0021991 <intr_enable+0x38>
c0021973:	83 ec 0c             	sub    $0xc,%esp
c0021976:	68 90 06 03 c0       	push   $0xc0030690
c002197b:	68 a1 06 03 c0       	push   $0xc00306a1
c0021980:	68 a0 0a 03 c0       	push   $0xc0030aa0
c0021985:	6a 5b                	push   $0x5b
c0021987:	68 b8 06 03 c0       	push   $0xc00306b8
c002198c:	e8 0c 82 00 00       	call   c0029b9d <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c0021991:	fb                   	sti    

  return old_level;
c0021992:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0021995:	c9                   	leave  
c0021996:	c3                   	ret    

c0021997 <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
c0021997:	55                   	push   %ebp
c0021998:	89 e5                	mov    %esp,%ebp
c002199a:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level = intr_get_level ();
c002199d:	e8 80 ff ff ff       	call   c0021922 <intr_get_level>
c00219a2:	89 45 fc             	mov    %eax,-0x4(%ebp)

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c00219a5:	fa                   	cli    

  return old_level;
c00219a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00219a9:	c9                   	leave  
c00219aa:	c3                   	ret    

c00219ab <intr_init>:

/* Initializes the interrupt system. */
void
intr_init (void)
{
c00219ab:	55                   	push   %ebp
c00219ac:	89 e5                	mov    %esp,%ebp
c00219ae:	83 ec 18             	sub    $0x18,%esp
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();
c00219b1:	e8 f2 02 00 00       	call   c0021ca8 <pic_init>

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c00219b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00219bd:	eb 2c                	jmp    c00219eb <intr_init+0x40>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c00219bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00219c2:	8b 04 85 8c 81 03 c0 	mov    -0x3ffc7e74(,%eax,4),%eax
c00219c9:	83 ec 08             	sub    $0x8,%esp
c00219cc:	6a 00                	push   $0x0
c00219ce:	50                   	push   %eax
c00219cf:	e8 ce 04 00 00       	call   c0021ea2 <make_intr_gate>
c00219d4:	83 c4 10             	add    $0x10,%esp
c00219d7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00219da:	89 04 cd e0 8b 03 c0 	mov    %eax,-0x3ffc7420(,%ecx,8)
c00219e1:	89 14 cd e4 8b 03 c0 	mov    %edx,-0x3ffc741c(,%ecx,8)
  for (i = 0; i < INTR_CNT; i++)
c00219e8:	ff 45 f4             	incl   -0xc(%ebp)
c00219eb:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c00219f2:	7e cb                	jle    c00219bf <intr_init+0x14>

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c00219f4:	83 ec 08             	sub    $0x8,%esp
c00219f7:	68 e0 8b 03 c0       	push   $0xc0038be0
c00219fc:	68 ff 07 00 00       	push   $0x7ff
c0021a01:	e8 d2 04 00 00       	call   c0021ed8 <make_idtr_operand>
c0021a06:	83 c4 10             	add    $0x10,%esp
c0021a09:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0021a0c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021a0f:	0f 01 5d e8          	lidtl  -0x18(%ebp)

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c0021a13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0021a1a:	eb 11                	jmp    c0021a2d <intr_init+0x82>
    intr_names[i] = "unknown";
c0021a1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021a1f:	c7 04 85 e0 97 03 c0 	movl   $0xc00306d2,-0x3ffc6820(,%eax,4)
c0021a26:	d2 06 03 c0 
  for (i = 0; i < INTR_CNT; i++)
c0021a2a:	ff 45 f4             	incl   -0xc(%ebp)
c0021a2d:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c0021a34:	7e e6                	jle    c0021a1c <intr_init+0x71>
  intr_names[0] = "#DE Divide Error";
c0021a36:	c7 05 e0 97 03 c0 da 	movl   $0xc00306da,0xc00397e0
c0021a3d:	06 03 c0 
  intr_names[1] = "#DB Debug Exception";
c0021a40:	c7 05 e4 97 03 c0 eb 	movl   $0xc00306eb,0xc00397e4
c0021a47:	06 03 c0 
  intr_names[2] = "NMI Interrupt";
c0021a4a:	c7 05 e8 97 03 c0 ff 	movl   $0xc00306ff,0xc00397e8
c0021a51:	06 03 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c0021a54:	c7 05 ec 97 03 c0 0d 	movl   $0xc003070d,0xc00397ec
c0021a5b:	07 03 c0 
  intr_names[4] = "#OF Overflow Exception";
c0021a5e:	c7 05 f0 97 03 c0 26 	movl   $0xc0030726,0xc00397f0
c0021a65:	07 03 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021a68:	c7 05 f4 97 03 c0 40 	movl   $0xc0030740,0xc00397f4
c0021a6f:	07 03 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c0021a72:	c7 05 f8 97 03 c0 63 	movl   $0xc0030763,0xc00397f8
c0021a79:	07 03 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c0021a7c:	c7 05 fc 97 03 c0 80 	movl   $0xc0030780,0xc00397fc
c0021a83:	07 03 c0 
  intr_names[8] = "#DF Double Fault Exception";
c0021a86:	c7 05 00 98 03 c0 a3 	movl   $0xc00307a3,0xc0039800
c0021a8d:	07 03 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c0021a90:	c7 05 04 98 03 c0 be 	movl   $0xc00307be,0xc0039804
c0021a97:	07 03 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c0021a9a:	c7 05 08 98 03 c0 da 	movl   $0xc00307da,0xc0039808
c0021aa1:	07 03 c0 
  intr_names[11] = "#NP Segment Not Present";
c0021aa4:	c7 05 0c 98 03 c0 f4 	movl   $0xc00307f4,0xc003980c
c0021aab:	07 03 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c0021aae:	c7 05 10 98 03 c0 0c 	movl   $0xc003080c,0xc0039810
c0021ab5:	08 03 c0 
  intr_names[13] = "#GP General Protection Exception";
c0021ab8:	c7 05 14 98 03 c0 28 	movl   $0xc0030828,0xc0039814
c0021abf:	08 03 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c0021ac2:	c7 05 18 98 03 c0 49 	movl   $0xc0030849,0xc0039818
c0021ac9:	08 03 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c0021acc:	c7 05 20 98 03 c0 64 	movl   $0xc0030864,0xc0039820
c0021ad3:	08 03 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c0021ad6:	c7 05 24 98 03 c0 85 	movl   $0xc0030885,0xc0039824
c0021add:	08 03 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c0021ae0:	c7 05 28 98 03 c0 a3 	movl   $0xc00308a3,0xc0039828
c0021ae7:	08 03 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021aea:	c7 05 2c 98 03 c0 c0 	movl   $0xc00308c0,0xc003982c
c0021af1:	08 03 c0 
}
c0021af4:	90                   	nop
c0021af5:	c9                   	leave  
c0021af6:	c3                   	ret    

c0021af7 <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c0021af7:	55                   	push   %ebp
c0021af8:	89 e5                	mov    %esp,%ebp
c0021afa:	53                   	push   %ebx
c0021afb:	83 ec 14             	sub    $0x14,%esp
c0021afe:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b01:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_handlers[vec_no] == NULL);
c0021b04:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021b08:	8b 04 85 e0 93 03 c0 	mov    -0x3ffc6c20(,%eax,4),%eax
c0021b0f:	85 c0                	test   %eax,%eax
c0021b11:	74 21                	je     c0021b34 <register_handler+0x3d>
c0021b13:	83 ec 0c             	sub    $0xc,%esp
c0021b16:	68 e2 08 03 c0       	push   $0xc00308e2
c0021b1b:	68 a1 06 03 c0       	push   $0xc00306a1
c0021b20:	68 ac 0a 03 c0       	push   $0xc0030aac
c0021b25:	68 a8 00 00 00       	push   $0xa8
c0021b2a:	68 b8 06 03 c0       	push   $0xc00306b8
c0021b2f:	e8 69 80 00 00       	call   c0029b9d <debug_panic>
  if (level == INTR_ON)
c0021b34:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0021b38:	75 2e                	jne    c0021b68 <register_handler+0x71>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021b3a:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021b3e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021b42:	8b 04 85 8c 81 03 c0 	mov    -0x3ffc7e74(,%eax,4),%eax
c0021b49:	83 ec 08             	sub    $0x8,%esp
c0021b4c:	ff 75 0c             	pushl  0xc(%ebp)
c0021b4f:	50                   	push   %eax
c0021b50:	e8 68 03 00 00       	call   c0021ebd <make_trap_gate>
c0021b55:	83 c4 10             	add    $0x10,%esp
c0021b58:	89 04 dd e0 8b 03 c0 	mov    %eax,-0x3ffc7420(,%ebx,8)
c0021b5f:	89 14 dd e4 8b 03 c0 	mov    %edx,-0x3ffc741c(,%ebx,8)
c0021b66:	eb 2c                	jmp    c0021b94 <register_handler+0x9d>
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0021b68:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021b6c:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021b70:	8b 04 85 8c 81 03 c0 	mov    -0x3ffc7e74(,%eax,4),%eax
c0021b77:	83 ec 08             	sub    $0x8,%esp
c0021b7a:	ff 75 0c             	pushl  0xc(%ebp)
c0021b7d:	50                   	push   %eax
c0021b7e:	e8 1f 03 00 00       	call   c0021ea2 <make_intr_gate>
c0021b83:	83 c4 10             	add    $0x10,%esp
c0021b86:	89 04 dd e0 8b 03 c0 	mov    %eax,-0x3ffc7420(,%ebx,8)
c0021b8d:	89 14 dd e4 8b 03 c0 	mov    %edx,-0x3ffc741c(,%ebx,8)
  intr_handlers[vec_no] = handler;
c0021b94:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021b98:	8b 55 14             	mov    0x14(%ebp),%edx
c0021b9b:	89 14 85 e0 93 03 c0 	mov    %edx,-0x3ffc6c20(,%eax,4)
  intr_names[vec_no] = name;
c0021ba2:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021ba6:	8b 55 18             	mov    0x18(%ebp),%edx
c0021ba9:	89 14 85 e0 97 03 c0 	mov    %edx,-0x3ffc6820(,%eax,4)
}
c0021bb0:	90                   	nop
c0021bb1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021bb4:	c9                   	leave  
c0021bb5:	c3                   	ret    

c0021bb6 <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c0021bb6:	55                   	push   %ebp
c0021bb7:	89 e5                	mov    %esp,%ebp
c0021bb9:	83 ec 18             	sub    $0x18,%esp
c0021bbc:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bbf:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021bc2:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021bc6:	76 06                	jbe    c0021bce <intr_register_ext+0x18>
c0021bc8:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0021bcc:	76 21                	jbe    c0021bef <intr_register_ext+0x39>
c0021bce:	83 ec 0c             	sub    $0xc,%esp
c0021bd1:	68 00 09 03 c0       	push   $0xc0030900
c0021bd6:	68 a1 06 03 c0       	push   $0xc00306a1
c0021bdb:	68 c0 0a 03 c0       	push   $0xc0030ac0
c0021be0:	68 b8 00 00 00       	push   $0xb8
c0021be5:	68 b8 06 03 c0       	push   $0xc00306b8
c0021bea:	e8 ae 7f 00 00       	call   c0029b9d <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0021bef:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021bf3:	83 ec 0c             	sub    $0xc,%esp
c0021bf6:	ff 75 10             	pushl  0x10(%ebp)
c0021bf9:	ff 75 0c             	pushl  0xc(%ebp)
c0021bfc:	6a 00                	push   $0x0
c0021bfe:	6a 00                	push   $0x0
c0021c00:	50                   	push   %eax
c0021c01:	e8 f1 fe ff ff       	call   c0021af7 <register_handler>
c0021c06:	83 c4 20             	add    $0x20,%esp
}
c0021c09:	90                   	nop
c0021c0a:	c9                   	leave  
c0021c0b:	c3                   	ret    

c0021c0c <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c0021c0c:	55                   	push   %ebp
c0021c0d:	89 e5                	mov    %esp,%ebp
c0021c0f:	83 ec 18             	sub    $0x18,%esp
c0021c12:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c15:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021c18:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021c1c:	76 27                	jbe    c0021c45 <intr_register_int+0x39>
c0021c1e:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0021c22:	77 21                	ja     c0021c45 <intr_register_int+0x39>
c0021c24:	83 ec 0c             	sub    $0xc,%esp
c0021c27:	68 24 09 03 c0       	push   $0xc0030924
c0021c2c:	68 a1 06 03 c0       	push   $0xc00306a1
c0021c31:	68 d4 0a 03 c0       	push   $0xc0030ad4
c0021c36:	68 cd 00 00 00       	push   $0xcd
c0021c3b:	68 b8 06 03 c0       	push   $0xc00306b8
c0021c40:	e8 58 7f 00 00       	call   c0029b9d <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c0021c45:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021c49:	83 ec 0c             	sub    $0xc,%esp
c0021c4c:	ff 75 18             	pushl  0x18(%ebp)
c0021c4f:	ff 75 14             	pushl  0x14(%ebp)
c0021c52:	ff 75 10             	pushl  0x10(%ebp)
c0021c55:	ff 75 0c             	pushl  0xc(%ebp)
c0021c58:	50                   	push   %eax
c0021c59:	e8 99 fe ff ff       	call   c0021af7 <register_handler>
c0021c5e:	83 c4 20             	add    $0x20,%esp
}
c0021c61:	90                   	nop
c0021c62:	c9                   	leave  
c0021c63:	c3                   	ret    

c0021c64 <intr_context>:

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
c0021c64:	55                   	push   %ebp
c0021c65:	89 e5                	mov    %esp,%ebp
  return in_external_intr;
c0021c67:	a0 e0 9f 03 c0       	mov    0xc0039fe0,%al
}
c0021c6c:	5d                   	pop    %ebp
c0021c6d:	c3                   	ret    

c0021c6e <intr_yield_on_return>:
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c0021c6e:	55                   	push   %ebp
c0021c6f:	89 e5                	mov    %esp,%ebp
c0021c71:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_context ());
c0021c74:	e8 eb ff ff ff       	call   c0021c64 <intr_context>
c0021c79:	84 c0                	test   %al,%al
c0021c7b:	75 21                	jne    c0021c9e <intr_yield_on_return+0x30>
c0021c7d:	83 ec 0c             	sub    $0xc,%esp
c0021c80:	68 43 09 03 c0       	push   $0xc0030943
c0021c85:	68 a1 06 03 c0       	push   $0xc00306a1
c0021c8a:	68 e8 0a 03 c0       	push   $0xc0030ae8
c0021c8f:	68 e0 00 00 00       	push   $0xe0
c0021c94:	68 b8 06 03 c0       	push   $0xc00306b8
c0021c99:	e8 ff 7e 00 00       	call   c0029b9d <debug_panic>
  yield_on_return = true;
c0021c9e:	c6 05 e1 9f 03 c0 01 	movb   $0x1,0xc0039fe1
}
c0021ca5:	90                   	nop
c0021ca6:	c9                   	leave  
c0021ca7:	c3                   	ret    

c0021ca8 <pic_init>:
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
c0021ca8:	55                   	push   %ebp
c0021ca9:	89 e5                	mov    %esp,%ebp
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
c0021cab:	68 ff 00 00 00       	push   $0xff
c0021cb0:	6a 21                	push   $0x21
c0021cb2:	e8 4e fc ff ff       	call   c0021905 <outb>
c0021cb7:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0xff);
c0021cba:	68 ff 00 00 00       	push   $0xff
c0021cbf:	68 a1 00 00 00       	push   $0xa1
c0021cc4:	e8 3c fc ff ff       	call   c0021905 <outb>
c0021cc9:	83 c4 08             	add    $0x8,%esp

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021ccc:	6a 11                	push   $0x11
c0021cce:	6a 20                	push   $0x20
c0021cd0:	e8 30 fc ff ff       	call   c0021905 <outb>
c0021cd5:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
c0021cd8:	6a 20                	push   $0x20
c0021cda:	6a 21                	push   $0x21
c0021cdc:	e8 24 fc ff ff       	call   c0021905 <outb>
c0021ce1:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
c0021ce4:	6a 04                	push   $0x4
c0021ce6:	6a 21                	push   $0x21
c0021ce8:	e8 18 fc ff ff       	call   c0021905 <outb>
c0021ced:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0021cf0:	6a 01                	push   $0x1
c0021cf2:	6a 21                	push   $0x21
c0021cf4:	e8 0c fc ff ff       	call   c0021905 <outb>
c0021cf9:	83 c4 08             	add    $0x8,%esp

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021cfc:	6a 11                	push   $0x11
c0021cfe:	68 a0 00 00 00       	push   $0xa0
c0021d03:	e8 fd fb ff ff       	call   c0021905 <outb>
c0021d08:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
c0021d0b:	6a 28                	push   $0x28
c0021d0d:	68 a1 00 00 00       	push   $0xa1
c0021d12:	e8 ee fb ff ff       	call   c0021905 <outb>
c0021d17:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
c0021d1a:	6a 02                	push   $0x2
c0021d1c:	68 a1 00 00 00       	push   $0xa1
c0021d21:	e8 df fb ff ff       	call   c0021905 <outb>
c0021d26:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0021d29:	6a 01                	push   $0x1
c0021d2b:	68 a1 00 00 00       	push   $0xa1
c0021d30:	e8 d0 fb ff ff       	call   c0021905 <outb>
c0021d35:	83 c4 08             	add    $0x8,%esp

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
c0021d38:	6a 00                	push   $0x0
c0021d3a:	6a 21                	push   $0x21
c0021d3c:	e8 c4 fb ff ff       	call   c0021905 <outb>
c0021d41:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x00);
c0021d44:	6a 00                	push   $0x0
c0021d46:	68 a1 00 00 00       	push   $0xa1
c0021d4b:	e8 b5 fb ff ff       	call   c0021905 <outb>
c0021d50:	83 c4 08             	add    $0x8,%esp
}
c0021d53:	90                   	nop
c0021d54:	c9                   	leave  
c0021d55:	c3                   	ret    

c0021d56 <pic_end_of_interrupt>:
/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
c0021d56:	55                   	push   %ebp
c0021d57:	89 e5                	mov    %esp,%ebp
c0021d59:	83 ec 08             	sub    $0x8,%esp
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021d5c:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0021d60:	7e 06                	jle    c0021d68 <pic_end_of_interrupt+0x12>
c0021d62:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0021d66:	7e 21                	jle    c0021d89 <pic_end_of_interrupt+0x33>
c0021d68:	83 ec 0c             	sub    $0xc,%esp
c0021d6b:	68 53 09 03 c0       	push   $0xc0030953
c0021d70:	68 a1 06 03 c0       	push   $0xc00306a1
c0021d75:	68 00 0b 03 c0       	push   $0xc0030b00
c0021d7a:	68 0b 01 00 00       	push   $0x10b
c0021d7f:	68 b8 06 03 c0       	push   $0xc00306b8
c0021d84:	e8 14 7e 00 00       	call   c0029b9d <debug_panic>

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);
c0021d89:	83 ec 08             	sub    $0x8,%esp
c0021d8c:	6a 20                	push   $0x20
c0021d8e:	6a 20                	push   $0x20
c0021d90:	e8 70 fb ff ff       	call   c0021905 <outb>
c0021d95:	83 c4 10             	add    $0x10,%esp

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c0021d98:	83 7d 08 27          	cmpl   $0x27,0x8(%ebp)
c0021d9c:	7e 12                	jle    c0021db0 <pic_end_of_interrupt+0x5a>
    outb (0xa0, 0x20);
c0021d9e:	83 ec 08             	sub    $0x8,%esp
c0021da1:	6a 20                	push   $0x20
c0021da3:	68 a0 00 00 00       	push   $0xa0
c0021da8:	e8 58 fb ff ff       	call   c0021905 <outb>
c0021dad:	83 c4 10             	add    $0x10,%esp
}
c0021db0:	90                   	nop
c0021db1:	c9                   	leave  
c0021db2:	c3                   	ret    

c0021db3 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c0021db3:	55                   	push   %ebp
c0021db4:	89 e5                	mov    %esp,%ebp
c0021db6:	57                   	push   %edi
c0021db7:	56                   	push   %esi
c0021db8:	53                   	push   %ebx
c0021db9:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c0021dbc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021dc0:	75 21                	jne    c0021de3 <make_gate+0x30>
c0021dc2:	83 ec 0c             	sub    $0xc,%esp
c0021dc5:	68 6d 09 03 c0       	push   $0xc003096d
c0021dca:	68 a1 06 03 c0       	push   $0xc00306a1
c0021dcf:	68 18 0b 03 c0       	push   $0xc0030b18
c0021dd4:	68 2a 01 00 00       	push   $0x12a
c0021dd9:	68 b8 06 03 c0       	push   $0xc00306b8
c0021dde:	e8 ba 7d 00 00       	call   c0029b9d <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c0021de3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0021de7:	78 06                	js     c0021def <make_gate+0x3c>
c0021de9:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0021ded:	7e 21                	jle    c0021e10 <make_gate+0x5d>
c0021def:	83 ec 0c             	sub    $0xc,%esp
c0021df2:	68 7e 09 03 c0       	push   $0xc003097e
c0021df7:	68 a1 06 03 c0       	push   $0xc00306a1
c0021dfc:	68 18 0b 03 c0       	push   $0xc0030b18
c0021e01:	68 2b 01 00 00       	push   $0x12b
c0021e06:	68 b8 06 03 c0       	push   $0xc00306b8
c0021e0b:	e8 8d 7d 00 00       	call   c0029b9d <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021e10:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0021e14:	78 06                	js     c0021e1c <make_gate+0x69>
c0021e16:	83 7d 10 0f          	cmpl   $0xf,0x10(%ebp)
c0021e1a:	7e 21                	jle    c0021e3d <make_gate+0x8a>
c0021e1c:	83 ec 0c             	sub    $0xc,%esp
c0021e1f:	68 93 09 03 c0       	push   $0xc0030993
c0021e24:	68 a1 06 03 c0       	push   $0xc00306a1
c0021e29:	68 18 0b 03 c0       	push   $0xc0030b18
c0021e2e:	68 2c 01 00 00       	push   $0x12c
c0021e33:	68 b8 06 03 c0       	push   $0xc00306b8
c0021e38:	e8 60 7d 00 00       	call   c0029b9d <debug_panic>

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021e3d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021e40:	0f b7 c0             	movzwl %ax,%eax
c0021e43:	0d 00 00 08 00       	or     $0x80000,%eax
c0021e48:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021e4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0021e4e:	25 00 00 ff ff       	and    $0xffff0000,%eax
c0021e53:	89 c2                	mov    %eax,%edx
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c0021e55:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021e58:	c1 e0 0d             	shl    $0xd,%eax
c0021e5b:	09 c2                	or     %eax,%edx
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c0021e5d:	8b 45 10             	mov    0x10(%ebp),%eax
c0021e60:	c1 e0 08             	shl    $0x8,%eax
c0021e63:	09 d0                	or     %edx,%eax
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021e65:	80 cc 80             	or     $0x80,%ah
c0021e68:	89 45 e0             	mov    %eax,-0x20(%ebp)

  return e0 | ((uint64_t) e1 << 32);
c0021e6b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0021e6e:	bf 00 00 00 00       	mov    $0x0,%edi
c0021e73:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0021e76:	ba 00 00 00 00       	mov    $0x0,%edx
c0021e7b:	89 c2                	mov    %eax,%edx
c0021e7d:	b8 00 00 00 00       	mov    $0x0,%eax
c0021e82:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0021e85:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0021e88:	89 f0                	mov    %esi,%eax
c0021e8a:	0b 45 d0             	or     -0x30(%ebp),%eax
c0021e8d:	89 c1                	mov    %eax,%ecx
c0021e8f:	89 f8                	mov    %edi,%eax
c0021e91:	0b 45 d4             	or     -0x2c(%ebp),%eax
c0021e94:	89 c3                	mov    %eax,%ebx
c0021e96:	89 c8                	mov    %ecx,%eax
c0021e98:	89 da                	mov    %ebx,%edx
}
c0021e9a:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0021e9d:	5b                   	pop    %ebx
c0021e9e:	5e                   	pop    %esi
c0021e9f:	5f                   	pop    %edi
c0021ea0:	5d                   	pop    %ebp
c0021ea1:	c3                   	ret    

c0021ea2 <make_intr_gate>:

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
c0021ea2:	55                   	push   %ebp
c0021ea3:	89 e5                	mov    %esp,%ebp
c0021ea5:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 14);
c0021ea8:	83 ec 04             	sub    $0x4,%esp
c0021eab:	6a 0e                	push   $0xe
c0021ead:	ff 75 0c             	pushl  0xc(%ebp)
c0021eb0:	ff 75 08             	pushl  0x8(%ebp)
c0021eb3:	e8 fb fe ff ff       	call   c0021db3 <make_gate>
c0021eb8:	83 c4 10             	add    $0x10,%esp
}
c0021ebb:	c9                   	leave  
c0021ebc:	c3                   	ret    

c0021ebd <make_trap_gate>:

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
c0021ebd:	55                   	push   %ebp
c0021ebe:	89 e5                	mov    %esp,%ebp
c0021ec0:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 15);
c0021ec3:	83 ec 04             	sub    $0x4,%esp
c0021ec6:	6a 0f                	push   $0xf
c0021ec8:	ff 75 0c             	pushl  0xc(%ebp)
c0021ecb:	ff 75 08             	pushl  0x8(%ebp)
c0021ece:	e8 e0 fe ff ff       	call   c0021db3 <make_gate>
c0021ed3:	83 c4 10             	add    $0x10,%esp
}
c0021ed6:	c9                   	leave  
c0021ed7:	c3                   	ret    

c0021ed8 <make_idtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
c0021ed8:	55                   	push   %ebp
c0021ed9:	89 e5                	mov    %esp,%ebp
c0021edb:	57                   	push   %edi
c0021edc:	56                   	push   %esi
c0021edd:	53                   	push   %ebx
c0021ede:	83 ec 14             	sub    $0x14,%esp
c0021ee1:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ee4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021ee8:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0021eec:	89 c6                	mov    %eax,%esi
c0021eee:	bf 00 00 00 00       	mov    $0x0,%edi
c0021ef3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021ef6:	ba 00 00 00 00       	mov    $0x0,%edx
c0021efb:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021eff:	c1 e0 10             	shl    $0x10,%eax
c0021f02:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0021f05:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0021f08:	89 f0                	mov    %esi,%eax
c0021f0a:	0b 45 e0             	or     -0x20(%ebp),%eax
c0021f0d:	89 c1                	mov    %eax,%ecx
c0021f0f:	89 f8                	mov    %edi,%eax
c0021f11:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0021f14:	89 c3                	mov    %eax,%ebx
c0021f16:	89 c8                	mov    %ecx,%eax
c0021f18:	89 da                	mov    %ebx,%edx
}
c0021f1a:	83 c4 14             	add    $0x14,%esp
c0021f1d:	5b                   	pop    %ebx
c0021f1e:	5e                   	pop    %esi
c0021f1f:	5f                   	pop    %edi
c0021f20:	5d                   	pop    %ebp
c0021f21:	c3                   	ret    

c0021f22 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021f22:	55                   	push   %ebp
c0021f23:	89 e5                	mov    %esp,%ebp
c0021f25:	83 ec 18             	sub    $0x18,%esp

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021f28:	8b 45 08             	mov    0x8(%ebp),%eax
c0021f2b:	8b 40 30             	mov    0x30(%eax),%eax
c0021f2e:	83 f8 1f             	cmp    $0x1f,%eax
c0021f31:	76 12                	jbe    c0021f45 <intr_handler+0x23>
c0021f33:	8b 45 08             	mov    0x8(%ebp),%eax
c0021f36:	8b 40 30             	mov    0x30(%eax),%eax
c0021f39:	83 f8 2f             	cmp    $0x2f,%eax
c0021f3c:	77 07                	ja     c0021f45 <intr_handler+0x23>
c0021f3e:	b8 01 00 00 00       	mov    $0x1,%eax
c0021f43:	eb 05                	jmp    c0021f4a <intr_handler+0x28>
c0021f45:	b8 00 00 00 00       	mov    $0x0,%eax
c0021f4a:	88 45 f7             	mov    %al,-0x9(%ebp)
c0021f4d:	80 65 f7 01          	andb   $0x1,-0x9(%ebp)
  if (external) 
c0021f51:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021f55:	74 65                	je     c0021fbc <intr_handler+0x9a>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021f57:	e8 c6 f9 ff ff       	call   c0021922 <intr_get_level>
c0021f5c:	85 c0                	test   %eax,%eax
c0021f5e:	74 21                	je     c0021f81 <intr_handler+0x5f>
c0021f60:	83 ec 0c             	sub    $0xc,%esp
c0021f63:	68 ab 09 03 c0       	push   $0xc00309ab
c0021f68:	68 a1 06 03 c0       	push   $0xc00306a1
c0021f6d:	68 24 0b 03 c0       	push   $0xc0030b24
c0021f72:	68 65 01 00 00       	push   $0x165
c0021f77:	68 b8 06 03 c0       	push   $0xc00306b8
c0021f7c:	e8 1c 7c 00 00       	call   c0029b9d <debug_panic>
      ASSERT (!intr_context ());
c0021f81:	e8 de fc ff ff       	call   c0021c64 <intr_context>
c0021f86:	83 f0 01             	xor    $0x1,%eax
c0021f89:	84 c0                	test   %al,%al
c0021f8b:	75 21                	jne    c0021fae <intr_handler+0x8c>
c0021f8d:	83 ec 0c             	sub    $0xc,%esp
c0021f90:	68 90 06 03 c0       	push   $0xc0030690
c0021f95:	68 a1 06 03 c0       	push   $0xc00306a1
c0021f9a:	68 24 0b 03 c0       	push   $0xc0030b24
c0021f9f:	68 66 01 00 00       	push   $0x166
c0021fa4:	68 b8 06 03 c0       	push   $0xc00306b8
c0021fa9:	e8 ef 7b 00 00       	call   c0029b9d <debug_panic>

      in_external_intr = true;
c0021fae:	c6 05 e0 9f 03 c0 01 	movb   $0x1,0xc0039fe0
      yield_on_return = false;
c0021fb5:	c6 05 e1 9f 03 c0 00 	movb   $0x0,0xc0039fe1
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0021fbc:	8b 45 08             	mov    0x8(%ebp),%eax
c0021fbf:	8b 40 30             	mov    0x30(%eax),%eax
c0021fc2:	8b 04 85 e0 93 03 c0 	mov    -0x3ffc6c20(,%eax,4),%eax
c0021fc9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (handler != NULL)
c0021fcc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0021fd0:	74 10                	je     c0021fe2 <intr_handler+0xc0>
    handler (frame);
c0021fd2:	83 ec 0c             	sub    $0xc,%esp
c0021fd5:	ff 75 08             	pushl  0x8(%ebp)
c0021fd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021fdb:	ff d0                	call   *%eax
c0021fdd:	83 c4 10             	add    $0x10,%esp
c0021fe0:	eb 24                	jmp    c0022006 <intr_handler+0xe4>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0021fe2:	8b 45 08             	mov    0x8(%ebp),%eax
c0021fe5:	8b 40 30             	mov    0x30(%eax),%eax
c0021fe8:	83 f8 27             	cmp    $0x27,%eax
c0021feb:	74 19                	je     c0022006 <intr_handler+0xe4>
c0021fed:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ff0:	8b 40 30             	mov    0x30(%eax),%eax
c0021ff3:	83 f8 2f             	cmp    $0x2f,%eax
c0021ff6:	74 0e                	je     c0022006 <intr_handler+0xe4>
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);
c0021ff8:	83 ec 0c             	sub    $0xc,%esp
c0021ffb:	ff 75 08             	pushl  0x8(%ebp)
c0021ffe:	e8 87 00 00 00       	call   c002208a <unexpected_interrupt>
c0022003:	83 c4 10             	add    $0x10,%esp

  /* Complete the processing of an external interrupt. */
  if (external) 
c0022006:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c002200a:	74 7b                	je     c0022087 <intr_handler+0x165>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c002200c:	e8 11 f9 ff ff       	call   c0021922 <intr_get_level>
c0022011:	85 c0                	test   %eax,%eax
c0022013:	74 21                	je     c0022036 <intr_handler+0x114>
c0022015:	83 ec 0c             	sub    $0xc,%esp
c0022018:	68 ab 09 03 c0       	push   $0xc00309ab
c002201d:	68 a1 06 03 c0       	push   $0xc00306a1
c0022022:	68 24 0b 03 c0       	push   $0xc0030b24
c0022027:	68 7c 01 00 00       	push   $0x17c
c002202c:	68 b8 06 03 c0       	push   $0xc00306b8
c0022031:	e8 67 7b 00 00       	call   c0029b9d <debug_panic>
      ASSERT (intr_context ());
c0022036:	e8 29 fc ff ff       	call   c0021c64 <intr_context>
c002203b:	84 c0                	test   %al,%al
c002203d:	75 21                	jne    c0022060 <intr_handler+0x13e>
c002203f:	83 ec 0c             	sub    $0xc,%esp
c0022042:	68 43 09 03 c0       	push   $0xc0030943
c0022047:	68 a1 06 03 c0       	push   $0xc00306a1
c002204c:	68 24 0b 03 c0       	push   $0xc0030b24
c0022051:	68 7d 01 00 00       	push   $0x17d
c0022056:	68 b8 06 03 c0       	push   $0xc00306b8
c002205b:	e8 3d 7b 00 00       	call   c0029b9d <debug_panic>

      in_external_intr = false;
c0022060:	c6 05 e0 9f 03 c0 00 	movb   $0x0,0xc0039fe0
      pic_end_of_interrupt (frame->vec_no); 
c0022067:	8b 45 08             	mov    0x8(%ebp),%eax
c002206a:	8b 40 30             	mov    0x30(%eax),%eax
c002206d:	83 ec 0c             	sub    $0xc,%esp
c0022070:	50                   	push   %eax
c0022071:	e8 e0 fc ff ff       	call   c0021d56 <pic_end_of_interrupt>
c0022076:	83 c4 10             	add    $0x10,%esp

      if (yield_on_return) 
c0022079:	a0 e1 9f 03 c0       	mov    0xc0039fe1,%al
c002207e:	84 c0                	test   %al,%al
c0022080:	74 05                	je     c0022087 <intr_handler+0x165>
        thread_yield (); 
c0022082:	e8 a3 f1 ff ff       	call   c002122a <thread_yield>
    }
}
c0022087:	90                   	nop
c0022088:	c9                   	leave  
c0022089:	c3                   	ret    

c002208a <unexpected_interrupt>:

/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
c002208a:	55                   	push   %ebp
c002208b:	89 e5                	mov    %esp,%ebp
c002208d:	83 ec 18             	sub    $0x18,%esp
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0022090:	8b 45 08             	mov    0x8(%ebp),%eax
c0022093:	8b 40 30             	mov    0x30(%eax),%eax
c0022096:	8b 14 85 e0 9b 03 c0 	mov    -0x3ffc6420(,%eax,4),%edx
c002209d:	42                   	inc    %edx
c002209e:	89 14 85 e0 9b 03 c0 	mov    %edx,-0x3ffc6420(,%eax,4)
c00220a5:	8b 04 85 e0 9b 03 c0 	mov    -0x3ffc6420(,%eax,4),%eax
c00220ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c00220af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00220b2:	48                   	dec    %eax
c00220b3:	23 45 f4             	and    -0xc(%ebp),%eax
c00220b6:	85 c0                	test   %eax,%eax
c00220b8:	75 25                	jne    c00220df <unexpected_interrupt+0x55>
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
c00220ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00220bd:	8b 40 30             	mov    0x30(%eax),%eax
    printf ("Unexpected interrupt %#04x (%s)\n",
c00220c0:	8b 14 85 e0 97 03 c0 	mov    -0x3ffc6820(,%eax,4),%edx
c00220c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00220ca:	8b 40 30             	mov    0x30(%eax),%eax
c00220cd:	83 ec 04             	sub    $0x4,%esp
c00220d0:	52                   	push   %edx
c00220d1:	50                   	push   %eax
c00220d2:	68 cc 09 03 c0       	push   $0xc00309cc
c00220d7:	e8 02 57 00 00       	call   c00277de <printf>
c00220dc:	83 c4 10             	add    $0x10,%esp
}
c00220df:	90                   	nop
c00220e0:	c9                   	leave  
c00220e1:	c3                   	ret    

c00220e2 <intr_dump_frame>:

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c00220e2:	55                   	push   %ebp
c00220e3:	89 e5                	mov    %esp,%ebp
c00220e5:	53                   	push   %ebx
c00220e6:	83 ec 14             	sub    $0x14,%esp
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c00220e9:	0f 20 d0             	mov    %cr2,%eax
c00220ec:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c00220ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00220f2:	8b 48 3c             	mov    0x3c(%eax),%ecx
          f->vec_no, intr_names[f->vec_no], f->eip);
c00220f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00220f8:	8b 40 30             	mov    0x30(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c00220fb:	8b 14 85 e0 97 03 c0 	mov    -0x3ffc6820(,%eax,4),%edx
c0022102:	8b 45 08             	mov    0x8(%ebp),%eax
c0022105:	8b 40 30             	mov    0x30(%eax),%eax
c0022108:	51                   	push   %ecx
c0022109:	52                   	push   %edx
c002210a:	50                   	push   %eax
c002210b:	68 f0 09 03 c0       	push   $0xc00309f0
c0022110:	e8 c9 56 00 00       	call   c00277de <printf>
c0022115:	83 c4 10             	add    $0x10,%esp
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0022118:	8b 45 08             	mov    0x8(%ebp),%eax
c002211b:	8b 40 34             	mov    0x34(%eax),%eax
c002211e:	83 ec 04             	sub    $0x4,%esp
c0022121:	50                   	push   %eax
c0022122:	ff 75 f4             	pushl  -0xc(%ebp)
c0022125:	68 10 0a 03 c0       	push   $0xc0030a10
c002212a:	e8 af 56 00 00       	call   c00277de <printf>
c002212f:	83 c4 10             	add    $0x10,%esp
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0022132:	8b 45 08             	mov    0x8(%ebp),%eax
c0022135:	8b 58 14             	mov    0x14(%eax),%ebx
c0022138:	8b 45 08             	mov    0x8(%ebp),%eax
c002213b:	8b 48 18             	mov    0x18(%eax),%ecx
c002213e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022141:	8b 50 10             	mov    0x10(%eax),%edx
c0022144:	8b 45 08             	mov    0x8(%ebp),%eax
c0022147:	8b 40 1c             	mov    0x1c(%eax),%eax
c002214a:	83 ec 0c             	sub    $0xc,%esp
c002214d:	53                   	push   %ebx
c002214e:	51                   	push   %ecx
c002214f:	52                   	push   %edx
c0022150:	50                   	push   %eax
c0022151:	68 28 0a 03 c0       	push   $0xc0030a28
c0022156:	e8 83 56 00 00       	call   c00277de <printf>
c002215b:	83 c4 20             	add    $0x20,%esp
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c002215e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022161:	8b 48 08             	mov    0x8(%eax),%ecx
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c0022164:	8b 45 08             	mov    0x8(%ebp),%eax
c0022167:	8b 40 48             	mov    0x48(%eax),%eax
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c002216a:	89 c3                	mov    %eax,%ebx
c002216c:	8b 45 08             	mov    0x8(%ebp),%eax
c002216f:	8b 10                	mov    (%eax),%edx
c0022171:	8b 45 08             	mov    0x8(%ebp),%eax
c0022174:	8b 40 04             	mov    0x4(%eax),%eax
c0022177:	83 ec 0c             	sub    $0xc,%esp
c002217a:	51                   	push   %ecx
c002217b:	53                   	push   %ebx
c002217c:	52                   	push   %edx
c002217d:	50                   	push   %eax
c002217e:	68 50 0a 03 c0       	push   $0xc0030a50
c0022183:	e8 56 56 00 00       	call   c00277de <printf>
c0022188:	83 c4 20             	add    $0x20,%esp
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
c002218b:	8b 45 08             	mov    0x8(%ebp),%eax
c002218e:	8b 40 4c             	mov    0x4c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0022191:	0f b7 d8             	movzwl %ax,%ebx
          f->cs, f->ds, f->es, f->ss);
c0022194:	8b 45 08             	mov    0x8(%ebp),%eax
c0022197:	8b 40 28             	mov    0x28(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c002219a:	0f b7 c8             	movzwl %ax,%ecx
          f->cs, f->ds, f->es, f->ss);
c002219d:	8b 45 08             	mov    0x8(%ebp),%eax
c00221a0:	8b 40 2c             	mov    0x2c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c00221a3:	0f b7 d0             	movzwl %ax,%edx
          f->cs, f->ds, f->es, f->ss);
c00221a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00221a9:	8b 40 40             	mov    0x40(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c00221ac:	0f b7 c0             	movzwl %ax,%eax
c00221af:	83 ec 0c             	sub    $0xc,%esp
c00221b2:	53                   	push   %ebx
c00221b3:	51                   	push   %ecx
c00221b4:	52                   	push   %edx
c00221b5:	50                   	push   %eax
c00221b6:	68 78 0a 03 c0       	push   $0xc0030a78
c00221bb:	e8 1e 56 00 00       	call   c00277de <printf>
c00221c0:	83 c4 20             	add    $0x20,%esp
}
c00221c3:	90                   	nop
c00221c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00221c7:	c9                   	leave  
c00221c8:	c3                   	ret    

c00221c9 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c00221c9:	55                   	push   %ebp
c00221ca:	89 e5                	mov    %esp,%ebp
c00221cc:	83 ec 04             	sub    $0x4,%esp
c00221cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00221d2:	88 45 fc             	mov    %al,-0x4(%ebp)
  return intr_names[vec];
c00221d5:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00221d9:	8b 04 85 e0 97 03 c0 	mov    -0x3ffc6820(,%eax,4),%eax
}
c00221e0:	c9                   	leave  
c00221e1:	c3                   	ret    

c00221e2 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c00221e2:	1e                   	push   %ds
	pushl %es
c00221e3:	06                   	push   %es
	pushl %fs
c00221e4:	0f a0                	push   %fs
	pushl %gs
c00221e6:	0f a8                	push   %gs
	pushal
c00221e8:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c00221e9:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c00221ea:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c00221ef:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c00221f1:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c00221f3:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c00221f7:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c00221f8:	e8 25 fd ff ff       	call   c0021f22 <intr_handler>
	addl $4, %esp
c00221fd:	83 c4 04             	add    $0x4,%esp

c0022200 <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0022200:	61                   	popa   
	popl %gs
c0022201:	0f a9                	pop    %gs
	popl %fs
c0022203:	0f a1                	pop    %fs
	popl %es
c0022205:	07                   	pop    %es
	popl %ds
c0022206:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0022207:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c002220a:	cf                   	iret   

c002220b <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c002220b:	55                   	push   %ebp
c002220c:	6a 00                	push   $0x0
c002220e:	6a 00                	push   $0x0
c0022210:	eb d0                	jmp    c00221e2 <intr_entry>

c0022212 <intr01_stub>:
c0022212:	55                   	push   %ebp
c0022213:	6a 00                	push   $0x0
c0022215:	6a 01                	push   $0x1
c0022217:	eb c9                	jmp    c00221e2 <intr_entry>

c0022219 <intr02_stub>:
c0022219:	55                   	push   %ebp
c002221a:	6a 00                	push   $0x0
c002221c:	6a 02                	push   $0x2
c002221e:	eb c2                	jmp    c00221e2 <intr_entry>

c0022220 <intr03_stub>:
c0022220:	55                   	push   %ebp
c0022221:	6a 00                	push   $0x0
c0022223:	6a 03                	push   $0x3
c0022225:	eb bb                	jmp    c00221e2 <intr_entry>

c0022227 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0022227:	55                   	push   %ebp
c0022228:	6a 00                	push   $0x0
c002222a:	6a 04                	push   $0x4
c002222c:	eb b4                	jmp    c00221e2 <intr_entry>

c002222e <intr05_stub>:
c002222e:	55                   	push   %ebp
c002222f:	6a 00                	push   $0x0
c0022231:	6a 05                	push   $0x5
c0022233:	eb ad                	jmp    c00221e2 <intr_entry>

c0022235 <intr06_stub>:
c0022235:	55                   	push   %ebp
c0022236:	6a 00                	push   $0x0
c0022238:	6a 06                	push   $0x6
c002223a:	eb a6                	jmp    c00221e2 <intr_entry>

c002223c <intr07_stub>:
c002223c:	55                   	push   %ebp
c002223d:	6a 00                	push   $0x0
c002223f:	6a 07                	push   $0x7
c0022241:	eb 9f                	jmp    c00221e2 <intr_entry>

c0022243 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0022243:	ff 34 24             	pushl  (%esp)
c0022246:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002224a:	6a 08                	push   $0x8
c002224c:	eb 94                	jmp    c00221e2 <intr_entry>

c002224e <intr09_stub>:
c002224e:	55                   	push   %ebp
c002224f:	6a 00                	push   $0x0
c0022251:	6a 09                	push   $0x9
c0022253:	eb 8d                	jmp    c00221e2 <intr_entry>

c0022255 <intr0a_stub>:
c0022255:	ff 34 24             	pushl  (%esp)
c0022258:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002225c:	6a 0a                	push   $0xa
c002225e:	eb 82                	jmp    c00221e2 <intr_entry>

c0022260 <intr0b_stub>:
c0022260:	ff 34 24             	pushl  (%esp)
c0022263:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022267:	6a 0b                	push   $0xb
c0022269:	e9 74 ff ff ff       	jmp    c00221e2 <intr_entry>

c002226e <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c002226e:	55                   	push   %ebp
c002226f:	6a 00                	push   $0x0
c0022271:	6a 0c                	push   $0xc
c0022273:	e9 6a ff ff ff       	jmp    c00221e2 <intr_entry>

c0022278 <intr0d_stub>:
c0022278:	ff 34 24             	pushl  (%esp)
c002227b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002227f:	6a 0d                	push   $0xd
c0022281:	e9 5c ff ff ff       	jmp    c00221e2 <intr_entry>

c0022286 <intr0e_stub>:
c0022286:	ff 34 24             	pushl  (%esp)
c0022289:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002228d:	6a 0e                	push   $0xe
c002228f:	e9 4e ff ff ff       	jmp    c00221e2 <intr_entry>

c0022294 <intr0f_stub>:
c0022294:	55                   	push   %ebp
c0022295:	6a 00                	push   $0x0
c0022297:	6a 0f                	push   $0xf
c0022299:	e9 44 ff ff ff       	jmp    c00221e2 <intr_entry>

c002229e <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c002229e:	55                   	push   %ebp
c002229f:	6a 00                	push   $0x0
c00222a1:	6a 10                	push   $0x10
c00222a3:	e9 3a ff ff ff       	jmp    c00221e2 <intr_entry>

c00222a8 <intr11_stub>:
c00222a8:	ff 34 24             	pushl  (%esp)
c00222ab:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00222af:	6a 11                	push   $0x11
c00222b1:	e9 2c ff ff ff       	jmp    c00221e2 <intr_entry>

c00222b6 <intr12_stub>:
c00222b6:	55                   	push   %ebp
c00222b7:	6a 00                	push   $0x0
c00222b9:	6a 12                	push   $0x12
c00222bb:	e9 22 ff ff ff       	jmp    c00221e2 <intr_entry>

c00222c0 <intr13_stub>:
c00222c0:	55                   	push   %ebp
c00222c1:	6a 00                	push   $0x0
c00222c3:	6a 13                	push   $0x13
c00222c5:	e9 18 ff ff ff       	jmp    c00221e2 <intr_entry>

c00222ca <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c00222ca:	55                   	push   %ebp
c00222cb:	6a 00                	push   $0x0
c00222cd:	6a 14                	push   $0x14
c00222cf:	e9 0e ff ff ff       	jmp    c00221e2 <intr_entry>

c00222d4 <intr15_stub>:
c00222d4:	55                   	push   %ebp
c00222d5:	6a 00                	push   $0x0
c00222d7:	6a 15                	push   $0x15
c00222d9:	e9 04 ff ff ff       	jmp    c00221e2 <intr_entry>

c00222de <intr16_stub>:
c00222de:	55                   	push   %ebp
c00222df:	6a 00                	push   $0x0
c00222e1:	6a 16                	push   $0x16
c00222e3:	e9 fa fe ff ff       	jmp    c00221e2 <intr_entry>

c00222e8 <intr17_stub>:
c00222e8:	55                   	push   %ebp
c00222e9:	6a 00                	push   $0x0
c00222eb:	6a 17                	push   $0x17
c00222ed:	e9 f0 fe ff ff       	jmp    c00221e2 <intr_entry>

c00222f2 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c00222f2:	ff 34 24             	pushl  (%esp)
c00222f5:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00222f9:	6a 18                	push   $0x18
c00222fb:	e9 e2 fe ff ff       	jmp    c00221e2 <intr_entry>

c0022300 <intr19_stub>:
c0022300:	55                   	push   %ebp
c0022301:	6a 00                	push   $0x0
c0022303:	6a 19                	push   $0x19
c0022305:	e9 d8 fe ff ff       	jmp    c00221e2 <intr_entry>

c002230a <intr1a_stub>:
c002230a:	ff 34 24             	pushl  (%esp)
c002230d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022311:	6a 1a                	push   $0x1a
c0022313:	e9 ca fe ff ff       	jmp    c00221e2 <intr_entry>

c0022318 <intr1b_stub>:
c0022318:	ff 34 24             	pushl  (%esp)
c002231b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002231f:	6a 1b                	push   $0x1b
c0022321:	e9 bc fe ff ff       	jmp    c00221e2 <intr_entry>

c0022326 <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0022326:	55                   	push   %ebp
c0022327:	6a 00                	push   $0x0
c0022329:	6a 1c                	push   $0x1c
c002232b:	e9 b2 fe ff ff       	jmp    c00221e2 <intr_entry>

c0022330 <intr1d_stub>:
c0022330:	ff 34 24             	pushl  (%esp)
c0022333:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022337:	6a 1d                	push   $0x1d
c0022339:	e9 a4 fe ff ff       	jmp    c00221e2 <intr_entry>

c002233e <intr1e_stub>:
c002233e:	ff 34 24             	pushl  (%esp)
c0022341:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022345:	6a 1e                	push   $0x1e
c0022347:	e9 96 fe ff ff       	jmp    c00221e2 <intr_entry>

c002234c <intr1f_stub>:
c002234c:	55                   	push   %ebp
c002234d:	6a 00                	push   $0x0
c002234f:	6a 1f                	push   $0x1f
c0022351:	e9 8c fe ff ff       	jmp    c00221e2 <intr_entry>

c0022356 <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0022356:	55                   	push   %ebp
c0022357:	6a 00                	push   $0x0
c0022359:	6a 20                	push   $0x20
c002235b:	e9 82 fe ff ff       	jmp    c00221e2 <intr_entry>

c0022360 <intr21_stub>:
c0022360:	55                   	push   %ebp
c0022361:	6a 00                	push   $0x0
c0022363:	6a 21                	push   $0x21
c0022365:	e9 78 fe ff ff       	jmp    c00221e2 <intr_entry>

c002236a <intr22_stub>:
c002236a:	55                   	push   %ebp
c002236b:	6a 00                	push   $0x0
c002236d:	6a 22                	push   $0x22
c002236f:	e9 6e fe ff ff       	jmp    c00221e2 <intr_entry>

c0022374 <intr23_stub>:
c0022374:	55                   	push   %ebp
c0022375:	6a 00                	push   $0x0
c0022377:	6a 23                	push   $0x23
c0022379:	e9 64 fe ff ff       	jmp    c00221e2 <intr_entry>

c002237e <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c002237e:	55                   	push   %ebp
c002237f:	6a 00                	push   $0x0
c0022381:	6a 24                	push   $0x24
c0022383:	e9 5a fe ff ff       	jmp    c00221e2 <intr_entry>

c0022388 <intr25_stub>:
c0022388:	55                   	push   %ebp
c0022389:	6a 00                	push   $0x0
c002238b:	6a 25                	push   $0x25
c002238d:	e9 50 fe ff ff       	jmp    c00221e2 <intr_entry>

c0022392 <intr26_stub>:
c0022392:	55                   	push   %ebp
c0022393:	6a 00                	push   $0x0
c0022395:	6a 26                	push   $0x26
c0022397:	e9 46 fe ff ff       	jmp    c00221e2 <intr_entry>

c002239c <intr27_stub>:
c002239c:	55                   	push   %ebp
c002239d:	6a 00                	push   $0x0
c002239f:	6a 27                	push   $0x27
c00223a1:	e9 3c fe ff ff       	jmp    c00221e2 <intr_entry>

c00223a6 <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c00223a6:	55                   	push   %ebp
c00223a7:	6a 00                	push   $0x0
c00223a9:	6a 28                	push   $0x28
c00223ab:	e9 32 fe ff ff       	jmp    c00221e2 <intr_entry>

c00223b0 <intr29_stub>:
c00223b0:	55                   	push   %ebp
c00223b1:	6a 00                	push   $0x0
c00223b3:	6a 29                	push   $0x29
c00223b5:	e9 28 fe ff ff       	jmp    c00221e2 <intr_entry>

c00223ba <intr2a_stub>:
c00223ba:	55                   	push   %ebp
c00223bb:	6a 00                	push   $0x0
c00223bd:	6a 2a                	push   $0x2a
c00223bf:	e9 1e fe ff ff       	jmp    c00221e2 <intr_entry>

c00223c4 <intr2b_stub>:
c00223c4:	55                   	push   %ebp
c00223c5:	6a 00                	push   $0x0
c00223c7:	6a 2b                	push   $0x2b
c00223c9:	e9 14 fe ff ff       	jmp    c00221e2 <intr_entry>

c00223ce <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c00223ce:	55                   	push   %ebp
c00223cf:	6a 00                	push   $0x0
c00223d1:	6a 2c                	push   $0x2c
c00223d3:	e9 0a fe ff ff       	jmp    c00221e2 <intr_entry>

c00223d8 <intr2d_stub>:
c00223d8:	55                   	push   %ebp
c00223d9:	6a 00                	push   $0x0
c00223db:	6a 2d                	push   $0x2d
c00223dd:	e9 00 fe ff ff       	jmp    c00221e2 <intr_entry>

c00223e2 <intr2e_stub>:
c00223e2:	55                   	push   %ebp
c00223e3:	6a 00                	push   $0x0
c00223e5:	6a 2e                	push   $0x2e
c00223e7:	e9 f6 fd ff ff       	jmp    c00221e2 <intr_entry>

c00223ec <intr2f_stub>:
c00223ec:	55                   	push   %ebp
c00223ed:	6a 00                	push   $0x0
c00223ef:	6a 2f                	push   $0x2f
c00223f1:	e9 ec fd ff ff       	jmp    c00221e2 <intr_entry>

c00223f6 <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c00223f6:	55                   	push   %ebp
c00223f7:	6a 00                	push   $0x0
c00223f9:	6a 30                	push   $0x30
c00223fb:	e9 e2 fd ff ff       	jmp    c00221e2 <intr_entry>

c0022400 <intr31_stub>:
c0022400:	55                   	push   %ebp
c0022401:	6a 00                	push   $0x0
c0022403:	6a 31                	push   $0x31
c0022405:	e9 d8 fd ff ff       	jmp    c00221e2 <intr_entry>

c002240a <intr32_stub>:
c002240a:	55                   	push   %ebp
c002240b:	6a 00                	push   $0x0
c002240d:	6a 32                	push   $0x32
c002240f:	e9 ce fd ff ff       	jmp    c00221e2 <intr_entry>

c0022414 <intr33_stub>:
c0022414:	55                   	push   %ebp
c0022415:	6a 00                	push   $0x0
c0022417:	6a 33                	push   $0x33
c0022419:	e9 c4 fd ff ff       	jmp    c00221e2 <intr_entry>

c002241e <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c002241e:	55                   	push   %ebp
c002241f:	6a 00                	push   $0x0
c0022421:	6a 34                	push   $0x34
c0022423:	e9 ba fd ff ff       	jmp    c00221e2 <intr_entry>

c0022428 <intr35_stub>:
c0022428:	55                   	push   %ebp
c0022429:	6a 00                	push   $0x0
c002242b:	6a 35                	push   $0x35
c002242d:	e9 b0 fd ff ff       	jmp    c00221e2 <intr_entry>

c0022432 <intr36_stub>:
c0022432:	55                   	push   %ebp
c0022433:	6a 00                	push   $0x0
c0022435:	6a 36                	push   $0x36
c0022437:	e9 a6 fd ff ff       	jmp    c00221e2 <intr_entry>

c002243c <intr37_stub>:
c002243c:	55                   	push   %ebp
c002243d:	6a 00                	push   $0x0
c002243f:	6a 37                	push   $0x37
c0022441:	e9 9c fd ff ff       	jmp    c00221e2 <intr_entry>

c0022446 <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0022446:	55                   	push   %ebp
c0022447:	6a 00                	push   $0x0
c0022449:	6a 38                	push   $0x38
c002244b:	e9 92 fd ff ff       	jmp    c00221e2 <intr_entry>

c0022450 <intr39_stub>:
c0022450:	55                   	push   %ebp
c0022451:	6a 00                	push   $0x0
c0022453:	6a 39                	push   $0x39
c0022455:	e9 88 fd ff ff       	jmp    c00221e2 <intr_entry>

c002245a <intr3a_stub>:
c002245a:	55                   	push   %ebp
c002245b:	6a 00                	push   $0x0
c002245d:	6a 3a                	push   $0x3a
c002245f:	e9 7e fd ff ff       	jmp    c00221e2 <intr_entry>

c0022464 <intr3b_stub>:
c0022464:	55                   	push   %ebp
c0022465:	6a 00                	push   $0x0
c0022467:	6a 3b                	push   $0x3b
c0022469:	e9 74 fd ff ff       	jmp    c00221e2 <intr_entry>

c002246e <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c002246e:	55                   	push   %ebp
c002246f:	6a 00                	push   $0x0
c0022471:	6a 3c                	push   $0x3c
c0022473:	e9 6a fd ff ff       	jmp    c00221e2 <intr_entry>

c0022478 <intr3d_stub>:
c0022478:	55                   	push   %ebp
c0022479:	6a 00                	push   $0x0
c002247b:	6a 3d                	push   $0x3d
c002247d:	e9 60 fd ff ff       	jmp    c00221e2 <intr_entry>

c0022482 <intr3e_stub>:
c0022482:	55                   	push   %ebp
c0022483:	6a 00                	push   $0x0
c0022485:	6a 3e                	push   $0x3e
c0022487:	e9 56 fd ff ff       	jmp    c00221e2 <intr_entry>

c002248c <intr3f_stub>:
c002248c:	55                   	push   %ebp
c002248d:	6a 00                	push   $0x0
c002248f:	6a 3f                	push   $0x3f
c0022491:	e9 4c fd ff ff       	jmp    c00221e2 <intr_entry>

c0022496 <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0022496:	55                   	push   %ebp
c0022497:	6a 00                	push   $0x0
c0022499:	6a 40                	push   $0x40
c002249b:	e9 42 fd ff ff       	jmp    c00221e2 <intr_entry>

c00224a0 <intr41_stub>:
c00224a0:	55                   	push   %ebp
c00224a1:	6a 00                	push   $0x0
c00224a3:	6a 41                	push   $0x41
c00224a5:	e9 38 fd ff ff       	jmp    c00221e2 <intr_entry>

c00224aa <intr42_stub>:
c00224aa:	55                   	push   %ebp
c00224ab:	6a 00                	push   $0x0
c00224ad:	6a 42                	push   $0x42
c00224af:	e9 2e fd ff ff       	jmp    c00221e2 <intr_entry>

c00224b4 <intr43_stub>:
c00224b4:	55                   	push   %ebp
c00224b5:	6a 00                	push   $0x0
c00224b7:	6a 43                	push   $0x43
c00224b9:	e9 24 fd ff ff       	jmp    c00221e2 <intr_entry>

c00224be <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c00224be:	55                   	push   %ebp
c00224bf:	6a 00                	push   $0x0
c00224c1:	6a 44                	push   $0x44
c00224c3:	e9 1a fd ff ff       	jmp    c00221e2 <intr_entry>

c00224c8 <intr45_stub>:
c00224c8:	55                   	push   %ebp
c00224c9:	6a 00                	push   $0x0
c00224cb:	6a 45                	push   $0x45
c00224cd:	e9 10 fd ff ff       	jmp    c00221e2 <intr_entry>

c00224d2 <intr46_stub>:
c00224d2:	55                   	push   %ebp
c00224d3:	6a 00                	push   $0x0
c00224d5:	6a 46                	push   $0x46
c00224d7:	e9 06 fd ff ff       	jmp    c00221e2 <intr_entry>

c00224dc <intr47_stub>:
c00224dc:	55                   	push   %ebp
c00224dd:	6a 00                	push   $0x0
c00224df:	6a 47                	push   $0x47
c00224e1:	e9 fc fc ff ff       	jmp    c00221e2 <intr_entry>

c00224e6 <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c00224e6:	55                   	push   %ebp
c00224e7:	6a 00                	push   $0x0
c00224e9:	6a 48                	push   $0x48
c00224eb:	e9 f2 fc ff ff       	jmp    c00221e2 <intr_entry>

c00224f0 <intr49_stub>:
c00224f0:	55                   	push   %ebp
c00224f1:	6a 00                	push   $0x0
c00224f3:	6a 49                	push   $0x49
c00224f5:	e9 e8 fc ff ff       	jmp    c00221e2 <intr_entry>

c00224fa <intr4a_stub>:
c00224fa:	55                   	push   %ebp
c00224fb:	6a 00                	push   $0x0
c00224fd:	6a 4a                	push   $0x4a
c00224ff:	e9 de fc ff ff       	jmp    c00221e2 <intr_entry>

c0022504 <intr4b_stub>:
c0022504:	55                   	push   %ebp
c0022505:	6a 00                	push   $0x0
c0022507:	6a 4b                	push   $0x4b
c0022509:	e9 d4 fc ff ff       	jmp    c00221e2 <intr_entry>

c002250e <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c002250e:	55                   	push   %ebp
c002250f:	6a 00                	push   $0x0
c0022511:	6a 4c                	push   $0x4c
c0022513:	e9 ca fc ff ff       	jmp    c00221e2 <intr_entry>

c0022518 <intr4d_stub>:
c0022518:	55                   	push   %ebp
c0022519:	6a 00                	push   $0x0
c002251b:	6a 4d                	push   $0x4d
c002251d:	e9 c0 fc ff ff       	jmp    c00221e2 <intr_entry>

c0022522 <intr4e_stub>:
c0022522:	55                   	push   %ebp
c0022523:	6a 00                	push   $0x0
c0022525:	6a 4e                	push   $0x4e
c0022527:	e9 b6 fc ff ff       	jmp    c00221e2 <intr_entry>

c002252c <intr4f_stub>:
c002252c:	55                   	push   %ebp
c002252d:	6a 00                	push   $0x0
c002252f:	6a 4f                	push   $0x4f
c0022531:	e9 ac fc ff ff       	jmp    c00221e2 <intr_entry>

c0022536 <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0022536:	55                   	push   %ebp
c0022537:	6a 00                	push   $0x0
c0022539:	6a 50                	push   $0x50
c002253b:	e9 a2 fc ff ff       	jmp    c00221e2 <intr_entry>

c0022540 <intr51_stub>:
c0022540:	55                   	push   %ebp
c0022541:	6a 00                	push   $0x0
c0022543:	6a 51                	push   $0x51
c0022545:	e9 98 fc ff ff       	jmp    c00221e2 <intr_entry>

c002254a <intr52_stub>:
c002254a:	55                   	push   %ebp
c002254b:	6a 00                	push   $0x0
c002254d:	6a 52                	push   $0x52
c002254f:	e9 8e fc ff ff       	jmp    c00221e2 <intr_entry>

c0022554 <intr53_stub>:
c0022554:	55                   	push   %ebp
c0022555:	6a 00                	push   $0x0
c0022557:	6a 53                	push   $0x53
c0022559:	e9 84 fc ff ff       	jmp    c00221e2 <intr_entry>

c002255e <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c002255e:	55                   	push   %ebp
c002255f:	6a 00                	push   $0x0
c0022561:	6a 54                	push   $0x54
c0022563:	e9 7a fc ff ff       	jmp    c00221e2 <intr_entry>

c0022568 <intr55_stub>:
c0022568:	55                   	push   %ebp
c0022569:	6a 00                	push   $0x0
c002256b:	6a 55                	push   $0x55
c002256d:	e9 70 fc ff ff       	jmp    c00221e2 <intr_entry>

c0022572 <intr56_stub>:
c0022572:	55                   	push   %ebp
c0022573:	6a 00                	push   $0x0
c0022575:	6a 56                	push   $0x56
c0022577:	e9 66 fc ff ff       	jmp    c00221e2 <intr_entry>

c002257c <intr57_stub>:
c002257c:	55                   	push   %ebp
c002257d:	6a 00                	push   $0x0
c002257f:	6a 57                	push   $0x57
c0022581:	e9 5c fc ff ff       	jmp    c00221e2 <intr_entry>

c0022586 <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c0022586:	55                   	push   %ebp
c0022587:	6a 00                	push   $0x0
c0022589:	6a 58                	push   $0x58
c002258b:	e9 52 fc ff ff       	jmp    c00221e2 <intr_entry>

c0022590 <intr59_stub>:
c0022590:	55                   	push   %ebp
c0022591:	6a 00                	push   $0x0
c0022593:	6a 59                	push   $0x59
c0022595:	e9 48 fc ff ff       	jmp    c00221e2 <intr_entry>

c002259a <intr5a_stub>:
c002259a:	55                   	push   %ebp
c002259b:	6a 00                	push   $0x0
c002259d:	6a 5a                	push   $0x5a
c002259f:	e9 3e fc ff ff       	jmp    c00221e2 <intr_entry>

c00225a4 <intr5b_stub>:
c00225a4:	55                   	push   %ebp
c00225a5:	6a 00                	push   $0x0
c00225a7:	6a 5b                	push   $0x5b
c00225a9:	e9 34 fc ff ff       	jmp    c00221e2 <intr_entry>

c00225ae <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c00225ae:	55                   	push   %ebp
c00225af:	6a 00                	push   $0x0
c00225b1:	6a 5c                	push   $0x5c
c00225b3:	e9 2a fc ff ff       	jmp    c00221e2 <intr_entry>

c00225b8 <intr5d_stub>:
c00225b8:	55                   	push   %ebp
c00225b9:	6a 00                	push   $0x0
c00225bb:	6a 5d                	push   $0x5d
c00225bd:	e9 20 fc ff ff       	jmp    c00221e2 <intr_entry>

c00225c2 <intr5e_stub>:
c00225c2:	55                   	push   %ebp
c00225c3:	6a 00                	push   $0x0
c00225c5:	6a 5e                	push   $0x5e
c00225c7:	e9 16 fc ff ff       	jmp    c00221e2 <intr_entry>

c00225cc <intr5f_stub>:
c00225cc:	55                   	push   %ebp
c00225cd:	6a 00                	push   $0x0
c00225cf:	6a 5f                	push   $0x5f
c00225d1:	e9 0c fc ff ff       	jmp    c00221e2 <intr_entry>

c00225d6 <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c00225d6:	55                   	push   %ebp
c00225d7:	6a 00                	push   $0x0
c00225d9:	6a 60                	push   $0x60
c00225db:	e9 02 fc ff ff       	jmp    c00221e2 <intr_entry>

c00225e0 <intr61_stub>:
c00225e0:	55                   	push   %ebp
c00225e1:	6a 00                	push   $0x0
c00225e3:	6a 61                	push   $0x61
c00225e5:	e9 f8 fb ff ff       	jmp    c00221e2 <intr_entry>

c00225ea <intr62_stub>:
c00225ea:	55                   	push   %ebp
c00225eb:	6a 00                	push   $0x0
c00225ed:	6a 62                	push   $0x62
c00225ef:	e9 ee fb ff ff       	jmp    c00221e2 <intr_entry>

c00225f4 <intr63_stub>:
c00225f4:	55                   	push   %ebp
c00225f5:	6a 00                	push   $0x0
c00225f7:	6a 63                	push   $0x63
c00225f9:	e9 e4 fb ff ff       	jmp    c00221e2 <intr_entry>

c00225fe <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c00225fe:	55                   	push   %ebp
c00225ff:	6a 00                	push   $0x0
c0022601:	6a 64                	push   $0x64
c0022603:	e9 da fb ff ff       	jmp    c00221e2 <intr_entry>

c0022608 <intr65_stub>:
c0022608:	55                   	push   %ebp
c0022609:	6a 00                	push   $0x0
c002260b:	6a 65                	push   $0x65
c002260d:	e9 d0 fb ff ff       	jmp    c00221e2 <intr_entry>

c0022612 <intr66_stub>:
c0022612:	55                   	push   %ebp
c0022613:	6a 00                	push   $0x0
c0022615:	6a 66                	push   $0x66
c0022617:	e9 c6 fb ff ff       	jmp    c00221e2 <intr_entry>

c002261c <intr67_stub>:
c002261c:	55                   	push   %ebp
c002261d:	6a 00                	push   $0x0
c002261f:	6a 67                	push   $0x67
c0022621:	e9 bc fb ff ff       	jmp    c00221e2 <intr_entry>

c0022626 <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c0022626:	55                   	push   %ebp
c0022627:	6a 00                	push   $0x0
c0022629:	6a 68                	push   $0x68
c002262b:	e9 b2 fb ff ff       	jmp    c00221e2 <intr_entry>

c0022630 <intr69_stub>:
c0022630:	55                   	push   %ebp
c0022631:	6a 00                	push   $0x0
c0022633:	6a 69                	push   $0x69
c0022635:	e9 a8 fb ff ff       	jmp    c00221e2 <intr_entry>

c002263a <intr6a_stub>:
c002263a:	55                   	push   %ebp
c002263b:	6a 00                	push   $0x0
c002263d:	6a 6a                	push   $0x6a
c002263f:	e9 9e fb ff ff       	jmp    c00221e2 <intr_entry>

c0022644 <intr6b_stub>:
c0022644:	55                   	push   %ebp
c0022645:	6a 00                	push   $0x0
c0022647:	6a 6b                	push   $0x6b
c0022649:	e9 94 fb ff ff       	jmp    c00221e2 <intr_entry>

c002264e <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c002264e:	55                   	push   %ebp
c002264f:	6a 00                	push   $0x0
c0022651:	6a 6c                	push   $0x6c
c0022653:	e9 8a fb ff ff       	jmp    c00221e2 <intr_entry>

c0022658 <intr6d_stub>:
c0022658:	55                   	push   %ebp
c0022659:	6a 00                	push   $0x0
c002265b:	6a 6d                	push   $0x6d
c002265d:	e9 80 fb ff ff       	jmp    c00221e2 <intr_entry>

c0022662 <intr6e_stub>:
c0022662:	55                   	push   %ebp
c0022663:	6a 00                	push   $0x0
c0022665:	6a 6e                	push   $0x6e
c0022667:	e9 76 fb ff ff       	jmp    c00221e2 <intr_entry>

c002266c <intr6f_stub>:
c002266c:	55                   	push   %ebp
c002266d:	6a 00                	push   $0x0
c002266f:	6a 6f                	push   $0x6f
c0022671:	e9 6c fb ff ff       	jmp    c00221e2 <intr_entry>

c0022676 <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c0022676:	55                   	push   %ebp
c0022677:	6a 00                	push   $0x0
c0022679:	6a 70                	push   $0x70
c002267b:	e9 62 fb ff ff       	jmp    c00221e2 <intr_entry>

c0022680 <intr71_stub>:
c0022680:	55                   	push   %ebp
c0022681:	6a 00                	push   $0x0
c0022683:	6a 71                	push   $0x71
c0022685:	e9 58 fb ff ff       	jmp    c00221e2 <intr_entry>

c002268a <intr72_stub>:
c002268a:	55                   	push   %ebp
c002268b:	6a 00                	push   $0x0
c002268d:	6a 72                	push   $0x72
c002268f:	e9 4e fb ff ff       	jmp    c00221e2 <intr_entry>

c0022694 <intr73_stub>:
c0022694:	55                   	push   %ebp
c0022695:	6a 00                	push   $0x0
c0022697:	6a 73                	push   $0x73
c0022699:	e9 44 fb ff ff       	jmp    c00221e2 <intr_entry>

c002269e <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c002269e:	55                   	push   %ebp
c002269f:	6a 00                	push   $0x0
c00226a1:	6a 74                	push   $0x74
c00226a3:	e9 3a fb ff ff       	jmp    c00221e2 <intr_entry>

c00226a8 <intr75_stub>:
c00226a8:	55                   	push   %ebp
c00226a9:	6a 00                	push   $0x0
c00226ab:	6a 75                	push   $0x75
c00226ad:	e9 30 fb ff ff       	jmp    c00221e2 <intr_entry>

c00226b2 <intr76_stub>:
c00226b2:	55                   	push   %ebp
c00226b3:	6a 00                	push   $0x0
c00226b5:	6a 76                	push   $0x76
c00226b7:	e9 26 fb ff ff       	jmp    c00221e2 <intr_entry>

c00226bc <intr77_stub>:
c00226bc:	55                   	push   %ebp
c00226bd:	6a 00                	push   $0x0
c00226bf:	6a 77                	push   $0x77
c00226c1:	e9 1c fb ff ff       	jmp    c00221e2 <intr_entry>

c00226c6 <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c00226c6:	55                   	push   %ebp
c00226c7:	6a 00                	push   $0x0
c00226c9:	6a 78                	push   $0x78
c00226cb:	e9 12 fb ff ff       	jmp    c00221e2 <intr_entry>

c00226d0 <intr79_stub>:
c00226d0:	55                   	push   %ebp
c00226d1:	6a 00                	push   $0x0
c00226d3:	6a 79                	push   $0x79
c00226d5:	e9 08 fb ff ff       	jmp    c00221e2 <intr_entry>

c00226da <intr7a_stub>:
c00226da:	55                   	push   %ebp
c00226db:	6a 00                	push   $0x0
c00226dd:	6a 7a                	push   $0x7a
c00226df:	e9 fe fa ff ff       	jmp    c00221e2 <intr_entry>

c00226e4 <intr7b_stub>:
c00226e4:	55                   	push   %ebp
c00226e5:	6a 00                	push   $0x0
c00226e7:	6a 7b                	push   $0x7b
c00226e9:	e9 f4 fa ff ff       	jmp    c00221e2 <intr_entry>

c00226ee <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c00226ee:	55                   	push   %ebp
c00226ef:	6a 00                	push   $0x0
c00226f1:	6a 7c                	push   $0x7c
c00226f3:	e9 ea fa ff ff       	jmp    c00221e2 <intr_entry>

c00226f8 <intr7d_stub>:
c00226f8:	55                   	push   %ebp
c00226f9:	6a 00                	push   $0x0
c00226fb:	6a 7d                	push   $0x7d
c00226fd:	e9 e0 fa ff ff       	jmp    c00221e2 <intr_entry>

c0022702 <intr7e_stub>:
c0022702:	55                   	push   %ebp
c0022703:	6a 00                	push   $0x0
c0022705:	6a 7e                	push   $0x7e
c0022707:	e9 d6 fa ff ff       	jmp    c00221e2 <intr_entry>

c002270c <intr7f_stub>:
c002270c:	55                   	push   %ebp
c002270d:	6a 00                	push   $0x0
c002270f:	6a 7f                	push   $0x7f
c0022711:	e9 cc fa ff ff       	jmp    c00221e2 <intr_entry>

c0022716 <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c0022716:	55                   	push   %ebp
c0022717:	6a 00                	push   $0x0
c0022719:	68 80 00 00 00       	push   $0x80
c002271e:	e9 bf fa ff ff       	jmp    c00221e2 <intr_entry>

c0022723 <intr81_stub>:
c0022723:	55                   	push   %ebp
c0022724:	6a 00                	push   $0x0
c0022726:	68 81 00 00 00       	push   $0x81
c002272b:	e9 b2 fa ff ff       	jmp    c00221e2 <intr_entry>

c0022730 <intr82_stub>:
c0022730:	55                   	push   %ebp
c0022731:	6a 00                	push   $0x0
c0022733:	68 82 00 00 00       	push   $0x82
c0022738:	e9 a5 fa ff ff       	jmp    c00221e2 <intr_entry>

c002273d <intr83_stub>:
c002273d:	55                   	push   %ebp
c002273e:	6a 00                	push   $0x0
c0022740:	68 83 00 00 00       	push   $0x83
c0022745:	e9 98 fa ff ff       	jmp    c00221e2 <intr_entry>

c002274a <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c002274a:	55                   	push   %ebp
c002274b:	6a 00                	push   $0x0
c002274d:	68 84 00 00 00       	push   $0x84
c0022752:	e9 8b fa ff ff       	jmp    c00221e2 <intr_entry>

c0022757 <intr85_stub>:
c0022757:	55                   	push   %ebp
c0022758:	6a 00                	push   $0x0
c002275a:	68 85 00 00 00       	push   $0x85
c002275f:	e9 7e fa ff ff       	jmp    c00221e2 <intr_entry>

c0022764 <intr86_stub>:
c0022764:	55                   	push   %ebp
c0022765:	6a 00                	push   $0x0
c0022767:	68 86 00 00 00       	push   $0x86
c002276c:	e9 71 fa ff ff       	jmp    c00221e2 <intr_entry>

c0022771 <intr87_stub>:
c0022771:	55                   	push   %ebp
c0022772:	6a 00                	push   $0x0
c0022774:	68 87 00 00 00       	push   $0x87
c0022779:	e9 64 fa ff ff       	jmp    c00221e2 <intr_entry>

c002277e <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c002277e:	55                   	push   %ebp
c002277f:	6a 00                	push   $0x0
c0022781:	68 88 00 00 00       	push   $0x88
c0022786:	e9 57 fa ff ff       	jmp    c00221e2 <intr_entry>

c002278b <intr89_stub>:
c002278b:	55                   	push   %ebp
c002278c:	6a 00                	push   $0x0
c002278e:	68 89 00 00 00       	push   $0x89
c0022793:	e9 4a fa ff ff       	jmp    c00221e2 <intr_entry>

c0022798 <intr8a_stub>:
c0022798:	55                   	push   %ebp
c0022799:	6a 00                	push   $0x0
c002279b:	68 8a 00 00 00       	push   $0x8a
c00227a0:	e9 3d fa ff ff       	jmp    c00221e2 <intr_entry>

c00227a5 <intr8b_stub>:
c00227a5:	55                   	push   %ebp
c00227a6:	6a 00                	push   $0x0
c00227a8:	68 8b 00 00 00       	push   $0x8b
c00227ad:	e9 30 fa ff ff       	jmp    c00221e2 <intr_entry>

c00227b2 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c00227b2:	55                   	push   %ebp
c00227b3:	6a 00                	push   $0x0
c00227b5:	68 8c 00 00 00       	push   $0x8c
c00227ba:	e9 23 fa ff ff       	jmp    c00221e2 <intr_entry>

c00227bf <intr8d_stub>:
c00227bf:	55                   	push   %ebp
c00227c0:	6a 00                	push   $0x0
c00227c2:	68 8d 00 00 00       	push   $0x8d
c00227c7:	e9 16 fa ff ff       	jmp    c00221e2 <intr_entry>

c00227cc <intr8e_stub>:
c00227cc:	55                   	push   %ebp
c00227cd:	6a 00                	push   $0x0
c00227cf:	68 8e 00 00 00       	push   $0x8e
c00227d4:	e9 09 fa ff ff       	jmp    c00221e2 <intr_entry>

c00227d9 <intr8f_stub>:
c00227d9:	55                   	push   %ebp
c00227da:	6a 00                	push   $0x0
c00227dc:	68 8f 00 00 00       	push   $0x8f
c00227e1:	e9 fc f9 ff ff       	jmp    c00221e2 <intr_entry>

c00227e6 <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c00227e6:	55                   	push   %ebp
c00227e7:	6a 00                	push   $0x0
c00227e9:	68 90 00 00 00       	push   $0x90
c00227ee:	e9 ef f9 ff ff       	jmp    c00221e2 <intr_entry>

c00227f3 <intr91_stub>:
c00227f3:	55                   	push   %ebp
c00227f4:	6a 00                	push   $0x0
c00227f6:	68 91 00 00 00       	push   $0x91
c00227fb:	e9 e2 f9 ff ff       	jmp    c00221e2 <intr_entry>

c0022800 <intr92_stub>:
c0022800:	55                   	push   %ebp
c0022801:	6a 00                	push   $0x0
c0022803:	68 92 00 00 00       	push   $0x92
c0022808:	e9 d5 f9 ff ff       	jmp    c00221e2 <intr_entry>

c002280d <intr93_stub>:
c002280d:	55                   	push   %ebp
c002280e:	6a 00                	push   $0x0
c0022810:	68 93 00 00 00       	push   $0x93
c0022815:	e9 c8 f9 ff ff       	jmp    c00221e2 <intr_entry>

c002281a <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c002281a:	55                   	push   %ebp
c002281b:	6a 00                	push   $0x0
c002281d:	68 94 00 00 00       	push   $0x94
c0022822:	e9 bb f9 ff ff       	jmp    c00221e2 <intr_entry>

c0022827 <intr95_stub>:
c0022827:	55                   	push   %ebp
c0022828:	6a 00                	push   $0x0
c002282a:	68 95 00 00 00       	push   $0x95
c002282f:	e9 ae f9 ff ff       	jmp    c00221e2 <intr_entry>

c0022834 <intr96_stub>:
c0022834:	55                   	push   %ebp
c0022835:	6a 00                	push   $0x0
c0022837:	68 96 00 00 00       	push   $0x96
c002283c:	e9 a1 f9 ff ff       	jmp    c00221e2 <intr_entry>

c0022841 <intr97_stub>:
c0022841:	55                   	push   %ebp
c0022842:	6a 00                	push   $0x0
c0022844:	68 97 00 00 00       	push   $0x97
c0022849:	e9 94 f9 ff ff       	jmp    c00221e2 <intr_entry>

c002284e <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c002284e:	55                   	push   %ebp
c002284f:	6a 00                	push   $0x0
c0022851:	68 98 00 00 00       	push   $0x98
c0022856:	e9 87 f9 ff ff       	jmp    c00221e2 <intr_entry>

c002285b <intr99_stub>:
c002285b:	55                   	push   %ebp
c002285c:	6a 00                	push   $0x0
c002285e:	68 99 00 00 00       	push   $0x99
c0022863:	e9 7a f9 ff ff       	jmp    c00221e2 <intr_entry>

c0022868 <intr9a_stub>:
c0022868:	55                   	push   %ebp
c0022869:	6a 00                	push   $0x0
c002286b:	68 9a 00 00 00       	push   $0x9a
c0022870:	e9 6d f9 ff ff       	jmp    c00221e2 <intr_entry>

c0022875 <intr9b_stub>:
c0022875:	55                   	push   %ebp
c0022876:	6a 00                	push   $0x0
c0022878:	68 9b 00 00 00       	push   $0x9b
c002287d:	e9 60 f9 ff ff       	jmp    c00221e2 <intr_entry>

c0022882 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c0022882:	55                   	push   %ebp
c0022883:	6a 00                	push   $0x0
c0022885:	68 9c 00 00 00       	push   $0x9c
c002288a:	e9 53 f9 ff ff       	jmp    c00221e2 <intr_entry>

c002288f <intr9d_stub>:
c002288f:	55                   	push   %ebp
c0022890:	6a 00                	push   $0x0
c0022892:	68 9d 00 00 00       	push   $0x9d
c0022897:	e9 46 f9 ff ff       	jmp    c00221e2 <intr_entry>

c002289c <intr9e_stub>:
c002289c:	55                   	push   %ebp
c002289d:	6a 00                	push   $0x0
c002289f:	68 9e 00 00 00       	push   $0x9e
c00228a4:	e9 39 f9 ff ff       	jmp    c00221e2 <intr_entry>

c00228a9 <intr9f_stub>:
c00228a9:	55                   	push   %ebp
c00228aa:	6a 00                	push   $0x0
c00228ac:	68 9f 00 00 00       	push   $0x9f
c00228b1:	e9 2c f9 ff ff       	jmp    c00221e2 <intr_entry>

c00228b6 <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c00228b6:	55                   	push   %ebp
c00228b7:	6a 00                	push   $0x0
c00228b9:	68 a0 00 00 00       	push   $0xa0
c00228be:	e9 1f f9 ff ff       	jmp    c00221e2 <intr_entry>

c00228c3 <intra1_stub>:
c00228c3:	55                   	push   %ebp
c00228c4:	6a 00                	push   $0x0
c00228c6:	68 a1 00 00 00       	push   $0xa1
c00228cb:	e9 12 f9 ff ff       	jmp    c00221e2 <intr_entry>

c00228d0 <intra2_stub>:
c00228d0:	55                   	push   %ebp
c00228d1:	6a 00                	push   $0x0
c00228d3:	68 a2 00 00 00       	push   $0xa2
c00228d8:	e9 05 f9 ff ff       	jmp    c00221e2 <intr_entry>

c00228dd <intra3_stub>:
c00228dd:	55                   	push   %ebp
c00228de:	6a 00                	push   $0x0
c00228e0:	68 a3 00 00 00       	push   $0xa3
c00228e5:	e9 f8 f8 ff ff       	jmp    c00221e2 <intr_entry>

c00228ea <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c00228ea:	55                   	push   %ebp
c00228eb:	6a 00                	push   $0x0
c00228ed:	68 a4 00 00 00       	push   $0xa4
c00228f2:	e9 eb f8 ff ff       	jmp    c00221e2 <intr_entry>

c00228f7 <intra5_stub>:
c00228f7:	55                   	push   %ebp
c00228f8:	6a 00                	push   $0x0
c00228fa:	68 a5 00 00 00       	push   $0xa5
c00228ff:	e9 de f8 ff ff       	jmp    c00221e2 <intr_entry>

c0022904 <intra6_stub>:
c0022904:	55                   	push   %ebp
c0022905:	6a 00                	push   $0x0
c0022907:	68 a6 00 00 00       	push   $0xa6
c002290c:	e9 d1 f8 ff ff       	jmp    c00221e2 <intr_entry>

c0022911 <intra7_stub>:
c0022911:	55                   	push   %ebp
c0022912:	6a 00                	push   $0x0
c0022914:	68 a7 00 00 00       	push   $0xa7
c0022919:	e9 c4 f8 ff ff       	jmp    c00221e2 <intr_entry>

c002291e <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c002291e:	55                   	push   %ebp
c002291f:	6a 00                	push   $0x0
c0022921:	68 a8 00 00 00       	push   $0xa8
c0022926:	e9 b7 f8 ff ff       	jmp    c00221e2 <intr_entry>

c002292b <intra9_stub>:
c002292b:	55                   	push   %ebp
c002292c:	6a 00                	push   $0x0
c002292e:	68 a9 00 00 00       	push   $0xa9
c0022933:	e9 aa f8 ff ff       	jmp    c00221e2 <intr_entry>

c0022938 <intraa_stub>:
c0022938:	55                   	push   %ebp
c0022939:	6a 00                	push   $0x0
c002293b:	68 aa 00 00 00       	push   $0xaa
c0022940:	e9 9d f8 ff ff       	jmp    c00221e2 <intr_entry>

c0022945 <intrab_stub>:
c0022945:	55                   	push   %ebp
c0022946:	6a 00                	push   $0x0
c0022948:	68 ab 00 00 00       	push   $0xab
c002294d:	e9 90 f8 ff ff       	jmp    c00221e2 <intr_entry>

c0022952 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022952:	55                   	push   %ebp
c0022953:	6a 00                	push   $0x0
c0022955:	68 ac 00 00 00       	push   $0xac
c002295a:	e9 83 f8 ff ff       	jmp    c00221e2 <intr_entry>

c002295f <intrad_stub>:
c002295f:	55                   	push   %ebp
c0022960:	6a 00                	push   $0x0
c0022962:	68 ad 00 00 00       	push   $0xad
c0022967:	e9 76 f8 ff ff       	jmp    c00221e2 <intr_entry>

c002296c <intrae_stub>:
c002296c:	55                   	push   %ebp
c002296d:	6a 00                	push   $0x0
c002296f:	68 ae 00 00 00       	push   $0xae
c0022974:	e9 69 f8 ff ff       	jmp    c00221e2 <intr_entry>

c0022979 <intraf_stub>:
c0022979:	55                   	push   %ebp
c002297a:	6a 00                	push   $0x0
c002297c:	68 af 00 00 00       	push   $0xaf
c0022981:	e9 5c f8 ff ff       	jmp    c00221e2 <intr_entry>

c0022986 <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c0022986:	55                   	push   %ebp
c0022987:	6a 00                	push   $0x0
c0022989:	68 b0 00 00 00       	push   $0xb0
c002298e:	e9 4f f8 ff ff       	jmp    c00221e2 <intr_entry>

c0022993 <intrb1_stub>:
c0022993:	55                   	push   %ebp
c0022994:	6a 00                	push   $0x0
c0022996:	68 b1 00 00 00       	push   $0xb1
c002299b:	e9 42 f8 ff ff       	jmp    c00221e2 <intr_entry>

c00229a0 <intrb2_stub>:
c00229a0:	55                   	push   %ebp
c00229a1:	6a 00                	push   $0x0
c00229a3:	68 b2 00 00 00       	push   $0xb2
c00229a8:	e9 35 f8 ff ff       	jmp    c00221e2 <intr_entry>

c00229ad <intrb3_stub>:
c00229ad:	55                   	push   %ebp
c00229ae:	6a 00                	push   $0x0
c00229b0:	68 b3 00 00 00       	push   $0xb3
c00229b5:	e9 28 f8 ff ff       	jmp    c00221e2 <intr_entry>

c00229ba <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c00229ba:	55                   	push   %ebp
c00229bb:	6a 00                	push   $0x0
c00229bd:	68 b4 00 00 00       	push   $0xb4
c00229c2:	e9 1b f8 ff ff       	jmp    c00221e2 <intr_entry>

c00229c7 <intrb5_stub>:
c00229c7:	55                   	push   %ebp
c00229c8:	6a 00                	push   $0x0
c00229ca:	68 b5 00 00 00       	push   $0xb5
c00229cf:	e9 0e f8 ff ff       	jmp    c00221e2 <intr_entry>

c00229d4 <intrb6_stub>:
c00229d4:	55                   	push   %ebp
c00229d5:	6a 00                	push   $0x0
c00229d7:	68 b6 00 00 00       	push   $0xb6
c00229dc:	e9 01 f8 ff ff       	jmp    c00221e2 <intr_entry>

c00229e1 <intrb7_stub>:
c00229e1:	55                   	push   %ebp
c00229e2:	6a 00                	push   $0x0
c00229e4:	68 b7 00 00 00       	push   $0xb7
c00229e9:	e9 f4 f7 ff ff       	jmp    c00221e2 <intr_entry>

c00229ee <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c00229ee:	55                   	push   %ebp
c00229ef:	6a 00                	push   $0x0
c00229f1:	68 b8 00 00 00       	push   $0xb8
c00229f6:	e9 e7 f7 ff ff       	jmp    c00221e2 <intr_entry>

c00229fb <intrb9_stub>:
c00229fb:	55                   	push   %ebp
c00229fc:	6a 00                	push   $0x0
c00229fe:	68 b9 00 00 00       	push   $0xb9
c0022a03:	e9 da f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a08 <intrba_stub>:
c0022a08:	55                   	push   %ebp
c0022a09:	6a 00                	push   $0x0
c0022a0b:	68 ba 00 00 00       	push   $0xba
c0022a10:	e9 cd f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a15 <intrbb_stub>:
c0022a15:	55                   	push   %ebp
c0022a16:	6a 00                	push   $0x0
c0022a18:	68 bb 00 00 00       	push   $0xbb
c0022a1d:	e9 c0 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a22 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022a22:	55                   	push   %ebp
c0022a23:	6a 00                	push   $0x0
c0022a25:	68 bc 00 00 00       	push   $0xbc
c0022a2a:	e9 b3 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a2f <intrbd_stub>:
c0022a2f:	55                   	push   %ebp
c0022a30:	6a 00                	push   $0x0
c0022a32:	68 bd 00 00 00       	push   $0xbd
c0022a37:	e9 a6 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a3c <intrbe_stub>:
c0022a3c:	55                   	push   %ebp
c0022a3d:	6a 00                	push   $0x0
c0022a3f:	68 be 00 00 00       	push   $0xbe
c0022a44:	e9 99 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a49 <intrbf_stub>:
c0022a49:	55                   	push   %ebp
c0022a4a:	6a 00                	push   $0x0
c0022a4c:	68 bf 00 00 00       	push   $0xbf
c0022a51:	e9 8c f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a56 <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022a56:	55                   	push   %ebp
c0022a57:	6a 00                	push   $0x0
c0022a59:	68 c0 00 00 00       	push   $0xc0
c0022a5e:	e9 7f f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a63 <intrc1_stub>:
c0022a63:	55                   	push   %ebp
c0022a64:	6a 00                	push   $0x0
c0022a66:	68 c1 00 00 00       	push   $0xc1
c0022a6b:	e9 72 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a70 <intrc2_stub>:
c0022a70:	55                   	push   %ebp
c0022a71:	6a 00                	push   $0x0
c0022a73:	68 c2 00 00 00       	push   $0xc2
c0022a78:	e9 65 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a7d <intrc3_stub>:
c0022a7d:	55                   	push   %ebp
c0022a7e:	6a 00                	push   $0x0
c0022a80:	68 c3 00 00 00       	push   $0xc3
c0022a85:	e9 58 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a8a <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022a8a:	55                   	push   %ebp
c0022a8b:	6a 00                	push   $0x0
c0022a8d:	68 c4 00 00 00       	push   $0xc4
c0022a92:	e9 4b f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022a97 <intrc5_stub>:
c0022a97:	55                   	push   %ebp
c0022a98:	6a 00                	push   $0x0
c0022a9a:	68 c5 00 00 00       	push   $0xc5
c0022a9f:	e9 3e f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022aa4 <intrc6_stub>:
c0022aa4:	55                   	push   %ebp
c0022aa5:	6a 00                	push   $0x0
c0022aa7:	68 c6 00 00 00       	push   $0xc6
c0022aac:	e9 31 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022ab1 <intrc7_stub>:
c0022ab1:	55                   	push   %ebp
c0022ab2:	6a 00                	push   $0x0
c0022ab4:	68 c7 00 00 00       	push   $0xc7
c0022ab9:	e9 24 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022abe <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c0022abe:	55                   	push   %ebp
c0022abf:	6a 00                	push   $0x0
c0022ac1:	68 c8 00 00 00       	push   $0xc8
c0022ac6:	e9 17 f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022acb <intrc9_stub>:
c0022acb:	55                   	push   %ebp
c0022acc:	6a 00                	push   $0x0
c0022ace:	68 c9 00 00 00       	push   $0xc9
c0022ad3:	e9 0a f7 ff ff       	jmp    c00221e2 <intr_entry>

c0022ad8 <intrca_stub>:
c0022ad8:	55                   	push   %ebp
c0022ad9:	6a 00                	push   $0x0
c0022adb:	68 ca 00 00 00       	push   $0xca
c0022ae0:	e9 fd f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022ae5 <intrcb_stub>:
c0022ae5:	55                   	push   %ebp
c0022ae6:	6a 00                	push   $0x0
c0022ae8:	68 cb 00 00 00       	push   $0xcb
c0022aed:	e9 f0 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022af2 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c0022af2:	55                   	push   %ebp
c0022af3:	6a 00                	push   $0x0
c0022af5:	68 cc 00 00 00       	push   $0xcc
c0022afa:	e9 e3 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022aff <intrcd_stub>:
c0022aff:	55                   	push   %ebp
c0022b00:	6a 00                	push   $0x0
c0022b02:	68 cd 00 00 00       	push   $0xcd
c0022b07:	e9 d6 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b0c <intrce_stub>:
c0022b0c:	55                   	push   %ebp
c0022b0d:	6a 00                	push   $0x0
c0022b0f:	68 ce 00 00 00       	push   $0xce
c0022b14:	e9 c9 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b19 <intrcf_stub>:
c0022b19:	55                   	push   %ebp
c0022b1a:	6a 00                	push   $0x0
c0022b1c:	68 cf 00 00 00       	push   $0xcf
c0022b21:	e9 bc f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b26 <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022b26:	55                   	push   %ebp
c0022b27:	6a 00                	push   $0x0
c0022b29:	68 d0 00 00 00       	push   $0xd0
c0022b2e:	e9 af f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b33 <intrd1_stub>:
c0022b33:	55                   	push   %ebp
c0022b34:	6a 00                	push   $0x0
c0022b36:	68 d1 00 00 00       	push   $0xd1
c0022b3b:	e9 a2 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b40 <intrd2_stub>:
c0022b40:	55                   	push   %ebp
c0022b41:	6a 00                	push   $0x0
c0022b43:	68 d2 00 00 00       	push   $0xd2
c0022b48:	e9 95 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b4d <intrd3_stub>:
c0022b4d:	55                   	push   %ebp
c0022b4e:	6a 00                	push   $0x0
c0022b50:	68 d3 00 00 00       	push   $0xd3
c0022b55:	e9 88 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b5a <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022b5a:	55                   	push   %ebp
c0022b5b:	6a 00                	push   $0x0
c0022b5d:	68 d4 00 00 00       	push   $0xd4
c0022b62:	e9 7b f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b67 <intrd5_stub>:
c0022b67:	55                   	push   %ebp
c0022b68:	6a 00                	push   $0x0
c0022b6a:	68 d5 00 00 00       	push   $0xd5
c0022b6f:	e9 6e f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b74 <intrd6_stub>:
c0022b74:	55                   	push   %ebp
c0022b75:	6a 00                	push   $0x0
c0022b77:	68 d6 00 00 00       	push   $0xd6
c0022b7c:	e9 61 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b81 <intrd7_stub>:
c0022b81:	55                   	push   %ebp
c0022b82:	6a 00                	push   $0x0
c0022b84:	68 d7 00 00 00       	push   $0xd7
c0022b89:	e9 54 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b8e <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022b8e:	55                   	push   %ebp
c0022b8f:	6a 00                	push   $0x0
c0022b91:	68 d8 00 00 00       	push   $0xd8
c0022b96:	e9 47 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022b9b <intrd9_stub>:
c0022b9b:	55                   	push   %ebp
c0022b9c:	6a 00                	push   $0x0
c0022b9e:	68 d9 00 00 00       	push   $0xd9
c0022ba3:	e9 3a f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022ba8 <intrda_stub>:
c0022ba8:	55                   	push   %ebp
c0022ba9:	6a 00                	push   $0x0
c0022bab:	68 da 00 00 00       	push   $0xda
c0022bb0:	e9 2d f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022bb5 <intrdb_stub>:
c0022bb5:	55                   	push   %ebp
c0022bb6:	6a 00                	push   $0x0
c0022bb8:	68 db 00 00 00       	push   $0xdb
c0022bbd:	e9 20 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022bc2 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022bc2:	55                   	push   %ebp
c0022bc3:	6a 00                	push   $0x0
c0022bc5:	68 dc 00 00 00       	push   $0xdc
c0022bca:	e9 13 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022bcf <intrdd_stub>:
c0022bcf:	55                   	push   %ebp
c0022bd0:	6a 00                	push   $0x0
c0022bd2:	68 dd 00 00 00       	push   $0xdd
c0022bd7:	e9 06 f6 ff ff       	jmp    c00221e2 <intr_entry>

c0022bdc <intrde_stub>:
c0022bdc:	55                   	push   %ebp
c0022bdd:	6a 00                	push   $0x0
c0022bdf:	68 de 00 00 00       	push   $0xde
c0022be4:	e9 f9 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022be9 <intrdf_stub>:
c0022be9:	55                   	push   %ebp
c0022bea:	6a 00                	push   $0x0
c0022bec:	68 df 00 00 00       	push   $0xdf
c0022bf1:	e9 ec f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022bf6 <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022bf6:	55                   	push   %ebp
c0022bf7:	6a 00                	push   $0x0
c0022bf9:	68 e0 00 00 00       	push   $0xe0
c0022bfe:	e9 df f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c03 <intre1_stub>:
c0022c03:	55                   	push   %ebp
c0022c04:	6a 00                	push   $0x0
c0022c06:	68 e1 00 00 00       	push   $0xe1
c0022c0b:	e9 d2 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c10 <intre2_stub>:
c0022c10:	55                   	push   %ebp
c0022c11:	6a 00                	push   $0x0
c0022c13:	68 e2 00 00 00       	push   $0xe2
c0022c18:	e9 c5 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c1d <intre3_stub>:
c0022c1d:	55                   	push   %ebp
c0022c1e:	6a 00                	push   $0x0
c0022c20:	68 e3 00 00 00       	push   $0xe3
c0022c25:	e9 b8 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c2a <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022c2a:	55                   	push   %ebp
c0022c2b:	6a 00                	push   $0x0
c0022c2d:	68 e4 00 00 00       	push   $0xe4
c0022c32:	e9 ab f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c37 <intre5_stub>:
c0022c37:	55                   	push   %ebp
c0022c38:	6a 00                	push   $0x0
c0022c3a:	68 e5 00 00 00       	push   $0xe5
c0022c3f:	e9 9e f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c44 <intre6_stub>:
c0022c44:	55                   	push   %ebp
c0022c45:	6a 00                	push   $0x0
c0022c47:	68 e6 00 00 00       	push   $0xe6
c0022c4c:	e9 91 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c51 <intre7_stub>:
c0022c51:	55                   	push   %ebp
c0022c52:	6a 00                	push   $0x0
c0022c54:	68 e7 00 00 00       	push   $0xe7
c0022c59:	e9 84 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c5e <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022c5e:	55                   	push   %ebp
c0022c5f:	6a 00                	push   $0x0
c0022c61:	68 e8 00 00 00       	push   $0xe8
c0022c66:	e9 77 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c6b <intre9_stub>:
c0022c6b:	55                   	push   %ebp
c0022c6c:	6a 00                	push   $0x0
c0022c6e:	68 e9 00 00 00       	push   $0xe9
c0022c73:	e9 6a f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c78 <intrea_stub>:
c0022c78:	55                   	push   %ebp
c0022c79:	6a 00                	push   $0x0
c0022c7b:	68 ea 00 00 00       	push   $0xea
c0022c80:	e9 5d f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c85 <intreb_stub>:
c0022c85:	55                   	push   %ebp
c0022c86:	6a 00                	push   $0x0
c0022c88:	68 eb 00 00 00       	push   $0xeb
c0022c8d:	e9 50 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c92 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022c92:	55                   	push   %ebp
c0022c93:	6a 00                	push   $0x0
c0022c95:	68 ec 00 00 00       	push   $0xec
c0022c9a:	e9 43 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022c9f <intred_stub>:
c0022c9f:	55                   	push   %ebp
c0022ca0:	6a 00                	push   $0x0
c0022ca2:	68 ed 00 00 00       	push   $0xed
c0022ca7:	e9 36 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022cac <intree_stub>:
c0022cac:	55                   	push   %ebp
c0022cad:	6a 00                	push   $0x0
c0022caf:	68 ee 00 00 00       	push   $0xee
c0022cb4:	e9 29 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022cb9 <intref_stub>:
c0022cb9:	55                   	push   %ebp
c0022cba:	6a 00                	push   $0x0
c0022cbc:	68 ef 00 00 00       	push   $0xef
c0022cc1:	e9 1c f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022cc6 <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022cc6:	55                   	push   %ebp
c0022cc7:	6a 00                	push   $0x0
c0022cc9:	68 f0 00 00 00       	push   $0xf0
c0022cce:	e9 0f f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022cd3 <intrf1_stub>:
c0022cd3:	55                   	push   %ebp
c0022cd4:	6a 00                	push   $0x0
c0022cd6:	68 f1 00 00 00       	push   $0xf1
c0022cdb:	e9 02 f5 ff ff       	jmp    c00221e2 <intr_entry>

c0022ce0 <intrf2_stub>:
c0022ce0:	55                   	push   %ebp
c0022ce1:	6a 00                	push   $0x0
c0022ce3:	68 f2 00 00 00       	push   $0xf2
c0022ce8:	e9 f5 f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022ced <intrf3_stub>:
c0022ced:	55                   	push   %ebp
c0022cee:	6a 00                	push   $0x0
c0022cf0:	68 f3 00 00 00       	push   $0xf3
c0022cf5:	e9 e8 f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022cfa <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022cfa:	55                   	push   %ebp
c0022cfb:	6a 00                	push   $0x0
c0022cfd:	68 f4 00 00 00       	push   $0xf4
c0022d02:	e9 db f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d07 <intrf5_stub>:
c0022d07:	55                   	push   %ebp
c0022d08:	6a 00                	push   $0x0
c0022d0a:	68 f5 00 00 00       	push   $0xf5
c0022d0f:	e9 ce f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d14 <intrf6_stub>:
c0022d14:	55                   	push   %ebp
c0022d15:	6a 00                	push   $0x0
c0022d17:	68 f6 00 00 00       	push   $0xf6
c0022d1c:	e9 c1 f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d21 <intrf7_stub>:
c0022d21:	55                   	push   %ebp
c0022d22:	6a 00                	push   $0x0
c0022d24:	68 f7 00 00 00       	push   $0xf7
c0022d29:	e9 b4 f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d2e <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022d2e:	55                   	push   %ebp
c0022d2f:	6a 00                	push   $0x0
c0022d31:	68 f8 00 00 00       	push   $0xf8
c0022d36:	e9 a7 f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d3b <intrf9_stub>:
c0022d3b:	55                   	push   %ebp
c0022d3c:	6a 00                	push   $0x0
c0022d3e:	68 f9 00 00 00       	push   $0xf9
c0022d43:	e9 9a f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d48 <intrfa_stub>:
c0022d48:	55                   	push   %ebp
c0022d49:	6a 00                	push   $0x0
c0022d4b:	68 fa 00 00 00       	push   $0xfa
c0022d50:	e9 8d f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d55 <intrfb_stub>:
c0022d55:	55                   	push   %ebp
c0022d56:	6a 00                	push   $0x0
c0022d58:	68 fb 00 00 00       	push   $0xfb
c0022d5d:	e9 80 f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d62 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022d62:	55                   	push   %ebp
c0022d63:	6a 00                	push   $0x0
c0022d65:	68 fc 00 00 00       	push   $0xfc
c0022d6a:	e9 73 f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d6f <intrfd_stub>:
c0022d6f:	55                   	push   %ebp
c0022d70:	6a 00                	push   $0x0
c0022d72:	68 fd 00 00 00       	push   $0xfd
c0022d77:	e9 66 f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d7c <intrfe_stub>:
c0022d7c:	55                   	push   %ebp
c0022d7d:	6a 00                	push   $0x0
c0022d7f:	68 fe 00 00 00       	push   $0xfe
c0022d84:	e9 59 f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d89 <intrff_stub>:
c0022d89:	55                   	push   %ebp
c0022d8a:	6a 00                	push   $0x0
c0022d8c:	68 ff 00 00 00       	push   $0xff
c0022d91:	e9 4c f4 ff ff       	jmp    c00221e2 <intr_entry>

c0022d96 <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c0022d96:	55                   	push   %ebp
c0022d97:	89 e5                	mov    %esp,%ebp
c0022d99:	83 ec 08             	sub    $0x8,%esp
  ASSERT (sema != NULL);
c0022d9c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022da0:	75 1e                	jne    c0022dc0 <sema_init+0x2a>
c0022da2:	83 ec 0c             	sub    $0xc,%esp
c0022da5:	68 34 0b 03 c0       	push   $0xc0030b34
c0022daa:	68 41 0b 03 c0       	push   $0xc0030b41
c0022daf:	68 08 0c 03 c0       	push   $0xc0030c08
c0022db4:	6a 2f                	push   $0x2f
c0022db6:	68 58 0b 03 c0       	push   $0xc0030b58
c0022dbb:	e8 dd 6d 00 00       	call   c0029b9d <debug_panic>

  sema->value = value;
c0022dc0:	8b 45 08             	mov    0x8(%ebp),%eax
c0022dc3:	8b 55 0c             	mov    0xc(%ebp),%edx
c0022dc6:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c0022dc8:	8b 45 08             	mov    0x8(%ebp),%eax
c0022dcb:	83 c0 04             	add    $0x4,%eax
c0022dce:	83 ec 0c             	sub    $0xc,%esp
c0022dd1:	50                   	push   %eax
c0022dd2:	e8 37 70 00 00       	call   c0029e0e <list_init>
c0022dd7:	83 c4 10             	add    $0x10,%esp
}
c0022dda:	90                   	nop
c0022ddb:	c9                   	leave  
c0022ddc:	c3                   	ret    

c0022ddd <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c0022ddd:	55                   	push   %ebp
c0022dde:	89 e5                	mov    %esp,%ebp
c0022de0:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022de3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022de7:	75 1e                	jne    c0022e07 <sema_down+0x2a>
c0022de9:	83 ec 0c             	sub    $0xc,%esp
c0022dec:	68 34 0b 03 c0       	push   $0xc0030b34
c0022df1:	68 41 0b 03 c0       	push   $0xc0030b41
c0022df6:	68 14 0c 03 c0       	push   $0xc0030c14
c0022dfb:	6a 41                	push   $0x41
c0022dfd:	68 58 0b 03 c0       	push   $0xc0030b58
c0022e02:	e8 96 6d 00 00       	call   c0029b9d <debug_panic>
  ASSERT (!intr_context ());
c0022e07:	e8 58 ee ff ff       	call   c0021c64 <intr_context>
c0022e0c:	83 f0 01             	xor    $0x1,%eax
c0022e0f:	84 c0                	test   %al,%al
c0022e11:	75 1e                	jne    c0022e31 <sema_down+0x54>
c0022e13:	83 ec 0c             	sub    $0xc,%esp
c0022e16:	68 6e 0b 03 c0       	push   $0xc0030b6e
c0022e1b:	68 41 0b 03 c0       	push   $0xc0030b41
c0022e20:	68 14 0c 03 c0       	push   $0xc0030c14
c0022e25:	6a 42                	push   $0x42
c0022e27:	68 58 0b 03 c0       	push   $0xc0030b58
c0022e2c:	e8 6c 6d 00 00       	call   c0029b9d <debug_panic>

  old_level = intr_disable ();
c0022e31:	e8 61 eb ff ff       	call   c0021997 <intr_disable>
c0022e36:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (sema->value == 0) 
c0022e39:	eb 20                	jmp    c0022e5b <sema_down+0x7e>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c0022e3b:	e8 76 e2 ff ff       	call   c00210b6 <thread_current>
c0022e40:	8d 50 28             	lea    0x28(%eax),%edx
c0022e43:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e46:	83 c0 04             	add    $0x4,%eax
c0022e49:	83 ec 08             	sub    $0x8,%esp
c0022e4c:	52                   	push   %edx
c0022e4d:	50                   	push   %eax
c0022e4e:	e8 9b 73 00 00       	call   c002a1ee <list_push_back>
c0022e53:	83 c4 10             	add    $0x10,%esp
      thread_block ();
c0022e56:	e8 3b e1 ff ff       	call   c0020f96 <thread_block>
  while (sema->value == 0) 
c0022e5b:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e5e:	8b 00                	mov    (%eax),%eax
c0022e60:	85 c0                	test   %eax,%eax
c0022e62:	74 d7                	je     c0022e3b <sema_down+0x5e>
    }
  sema->value--;
c0022e64:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e67:	8b 00                	mov    (%eax),%eax
c0022e69:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022e6c:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e6f:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022e71:	83 ec 0c             	sub    $0xc,%esp
c0022e74:	ff 75 f4             	pushl  -0xc(%ebp)
c0022e77:	e8 c3 ea ff ff       	call   c002193f <intr_set_level>
c0022e7c:	83 c4 10             	add    $0x10,%esp
}
c0022e7f:	90                   	nop
c0022e80:	c9                   	leave  
c0022e81:	c3                   	ret    

c0022e82 <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0022e82:	55                   	push   %ebp
c0022e83:	89 e5                	mov    %esp,%ebp
c0022e85:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c0022e88:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022e8c:	75 1e                	jne    c0022eac <sema_try_down+0x2a>
c0022e8e:	83 ec 0c             	sub    $0xc,%esp
c0022e91:	68 34 0b 03 c0       	push   $0xc0030b34
c0022e96:	68 41 0b 03 c0       	push   $0xc0030b41
c0022e9b:	68 20 0c 03 c0       	push   $0xc0030c20
c0022ea0:	6a 59                	push   $0x59
c0022ea2:	68 58 0b 03 c0       	push   $0xc0030b58
c0022ea7:	e8 f1 6c 00 00       	call   c0029b9d <debug_panic>

  old_level = intr_disable ();
c0022eac:	e8 e6 ea ff ff       	call   c0021997 <intr_disable>
c0022eb1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (sema->value > 0) 
c0022eb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0022eb7:	8b 00                	mov    (%eax),%eax
c0022eb9:	85 c0                	test   %eax,%eax
c0022ebb:	74 13                	je     c0022ed0 <sema_try_down+0x4e>
    {
      sema->value--;
c0022ebd:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ec0:	8b 00                	mov    (%eax),%eax
c0022ec2:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022ec5:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ec8:	89 10                	mov    %edx,(%eax)
      success = true; 
c0022eca:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
c0022ece:	eb 04                	jmp    c0022ed4 <sema_try_down+0x52>
    }
  else
    success = false;
c0022ed0:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  intr_set_level (old_level);
c0022ed4:	83 ec 0c             	sub    $0xc,%esp
c0022ed7:	ff 75 f0             	pushl  -0x10(%ebp)
c0022eda:	e8 60 ea ff ff       	call   c002193f <intr_set_level>
c0022edf:	83 c4 10             	add    $0x10,%esp

  return success;
c0022ee2:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c0022ee5:	c9                   	leave  
c0022ee6:	c3                   	ret    

c0022ee7 <semaphore_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
semaphore_up (struct semaphore *sema) 
{
c0022ee7:	55                   	push   %ebp
c0022ee8:	89 e5                	mov    %esp,%ebp
c0022eea:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022eed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ef1:	75 1e                	jne    c0022f11 <semaphore_up+0x2a>
c0022ef3:	83 ec 0c             	sub    $0xc,%esp
c0022ef6:	68 34 0b 03 c0       	push   $0xc0030b34
c0022efb:	68 41 0b 03 c0       	push   $0xc0030b41
c0022f00:	68 30 0c 03 c0       	push   $0xc0030c30
c0022f05:	6a 71                	push   $0x71
c0022f07:	68 58 0b 03 c0       	push   $0xc0030b58
c0022f0c:	e8 8c 6c 00 00       	call   c0029b9d <debug_panic>

  old_level = intr_disable ();
c0022f11:	e8 81 ea ff ff       	call   c0021997 <intr_disable>
c0022f16:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!list_empty (&sema->waiters)) 
c0022f19:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f1c:	83 c0 04             	add    $0x4,%eax
c0022f1f:	83 ec 0c             	sub    $0xc,%esp
c0022f22:	50                   	push   %eax
c0022f23:	e8 6d 74 00 00       	call   c002a395 <list_empty>
c0022f28:	83 c4 10             	add    $0x10,%esp
c0022f2b:	83 f0 01             	xor    $0x1,%eax
c0022f2e:	84 c0                	test   %al,%al
c0022f30:	74 24                	je     c0022f56 <semaphore_up+0x6f>
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c0022f32:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f35:	83 c0 04             	add    $0x4,%eax
c0022f38:	83 ec 0c             	sub    $0xc,%esp
c0022f3b:	50                   	push   %eax
c0022f3c:	e8 2c 73 00 00       	call   c002a26d <list_pop_front>
c0022f41:	83 c4 10             	add    $0x10,%esp
c0022f44:	83 c0 04             	add    $0x4,%eax
c0022f47:	83 e8 2c             	sub    $0x2c,%eax
c0022f4a:	83 ec 0c             	sub    $0xc,%esp
c0022f4d:	50                   	push   %eax
c0022f4e:	e8 b4 e0 ff ff       	call   c0021007 <thread_unblock>
c0022f53:	83 c4 10             	add    $0x10,%esp
                                struct thread, elem));
  sema->value++;
c0022f56:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f59:	8b 00                	mov    (%eax),%eax
c0022f5b:	8d 50 01             	lea    0x1(%eax),%edx
c0022f5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f61:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022f63:	83 ec 0c             	sub    $0xc,%esp
c0022f66:	ff 75 f4             	pushl  -0xc(%ebp)
c0022f69:	e8 d1 e9 ff ff       	call   c002193f <intr_set_level>
c0022f6e:	83 c4 10             	add    $0x10,%esp
}
c0022f71:	90                   	nop
c0022f72:	c9                   	leave  
c0022f73:	c3                   	ret    

c0022f74 <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c0022f74:	55                   	push   %ebp
c0022f75:	89 e5                	mov    %esp,%ebp
c0022f77:	83 ec 38             	sub    $0x38,%esp
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c0022f7a:	83 ec 0c             	sub    $0xc,%esp
c0022f7d:	68 7f 0b 03 c0       	push   $0xc0030b7f
c0022f82:	e8 57 48 00 00       	call   c00277de <printf>
c0022f87:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[0], 0);
c0022f8a:	83 ec 08             	sub    $0x8,%esp
c0022f8d:	6a 00                	push   $0x0
c0022f8f:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022f92:	50                   	push   %eax
c0022f93:	e8 fe fd ff ff       	call   c0022d96 <sema_init>
c0022f98:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[1], 0);
c0022f9b:	83 ec 08             	sub    $0x8,%esp
c0022f9e:	6a 00                	push   $0x0
c0022fa0:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022fa3:	83 c0 14             	add    $0x14,%eax
c0022fa6:	50                   	push   %eax
c0022fa7:	e8 ea fd ff ff       	call   c0022d96 <sema_init>
c0022fac:	83 c4 10             	add    $0x10,%esp
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0022faf:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022fb2:	50                   	push   %eax
c0022fb3:	68 0d 30 02 c0       	push   $0xc002300d
c0022fb8:	6a 1f                	push   $0x1f
c0022fba:	68 95 0b 03 c0       	push   $0xc0030b95
c0022fbf:	e8 99 de ff ff       	call   c0020e5d <thread_create>
c0022fc4:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022fc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022fce:	eb 24                	jmp    c0022ff4 <sema_self_test+0x80>
    {
      semaphore_up (&sema[0]);
c0022fd0:	83 ec 0c             	sub    $0xc,%esp
c0022fd3:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022fd6:	50                   	push   %eax
c0022fd7:	e8 0b ff ff ff       	call   c0022ee7 <semaphore_up>
c0022fdc:	83 c4 10             	add    $0x10,%esp
      sema_down (&sema[1]);
c0022fdf:	83 ec 0c             	sub    $0xc,%esp
c0022fe2:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022fe5:	83 c0 14             	add    $0x14,%eax
c0022fe8:	50                   	push   %eax
c0022fe9:	e8 ef fd ff ff       	call   c0022ddd <sema_down>
c0022fee:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022ff1:	ff 45 f4             	incl   -0xc(%ebp)
c0022ff4:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022ff8:	7e d6                	jle    c0022fd0 <sema_self_test+0x5c>
    }
  printf ("done.\n");
c0022ffa:	83 ec 0c             	sub    $0xc,%esp
c0022ffd:	68 9f 0b 03 c0       	push   $0xc0030b9f
c0023002:	e8 68 8e 00 00       	call   c002be6f <puts>
c0023007:	83 c4 10             	add    $0x10,%esp
}
c002300a:	90                   	nop
c002300b:	c9                   	leave  
c002300c:	c3                   	ret    

c002300d <sema_test_helper>:

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c002300d:	55                   	push   %ebp
c002300e:	89 e5                	mov    %esp,%ebp
c0023010:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *sema = sema_;
c0023013:	8b 45 08             	mov    0x8(%ebp),%eax
c0023016:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  for (i = 0; i < 10; i++) 
c0023019:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023020:	eb 23                	jmp    c0023045 <sema_test_helper+0x38>
    {
      sema_down (&sema[0]);
c0023022:	83 ec 0c             	sub    $0xc,%esp
c0023025:	ff 75 f0             	pushl  -0x10(%ebp)
c0023028:	e8 b0 fd ff ff       	call   c0022ddd <sema_down>
c002302d:	83 c4 10             	add    $0x10,%esp
      semaphore_up (&sema[1]);
c0023030:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023033:	83 c0 14             	add    $0x14,%eax
c0023036:	83 ec 0c             	sub    $0xc,%esp
c0023039:	50                   	push   %eax
c002303a:	e8 a8 fe ff ff       	call   c0022ee7 <semaphore_up>
c002303f:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0023042:	ff 45 f4             	incl   -0xc(%ebp)
c0023045:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0023049:	7e d7                	jle    c0023022 <sema_test_helper+0x15>
    }
}
c002304b:	90                   	nop
c002304c:	c9                   	leave  
c002304d:	c3                   	ret    

c002304e <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c002304e:	55                   	push   %ebp
c002304f:	89 e5                	mov    %esp,%ebp
c0023051:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0023054:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023058:	75 21                	jne    c002307b <lock_init+0x2d>
c002305a:	83 ec 0c             	sub    $0xc,%esp
c002305d:	68 a5 0b 03 c0       	push   $0xc0030ba5
c0023062:	68 41 0b 03 c0       	push   $0xc0030b41
c0023067:	68 40 0c 03 c0       	push   $0xc0030c40
c002306c:	68 b2 00 00 00       	push   $0xb2
c0023071:	68 58 0b 03 c0       	push   $0xc0030b58
c0023076:	e8 22 6b 00 00       	call   c0029b9d <debug_panic>

  lock->holder = NULL;
c002307b:	8b 45 08             	mov    0x8(%ebp),%eax
c002307e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0023084:	8b 45 08             	mov    0x8(%ebp),%eax
c0023087:	83 c0 04             	add    $0x4,%eax
c002308a:	83 ec 08             	sub    $0x8,%esp
c002308d:	6a 01                	push   $0x1
c002308f:	50                   	push   %eax
c0023090:	e8 01 fd ff ff       	call   c0022d96 <sema_init>
c0023095:	83 c4 10             	add    $0x10,%esp
}
c0023098:	90                   	nop
c0023099:	c9                   	leave  
c002309a:	c3                   	ret    

c002309b <lock_acquire>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
lock_acquire (struct lock *lock)
{
c002309b:	55                   	push   %ebp
c002309c:	89 e5                	mov    %esp,%ebp
c002309e:	53                   	push   %ebx
c002309f:	83 ec 04             	sub    $0x4,%esp
  ASSERT (lock != NULL);
c00230a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00230a6:	75 21                	jne    c00230c9 <lock_acquire+0x2e>
c00230a8:	83 ec 0c             	sub    $0xc,%esp
c00230ab:	68 a5 0b 03 c0       	push   $0xc0030ba5
c00230b0:	68 41 0b 03 c0       	push   $0xc0030b41
c00230b5:	68 4c 0c 03 c0       	push   $0xc0030c4c
c00230ba:	68 c3 00 00 00       	push   $0xc3
c00230bf:	68 58 0b 03 c0       	push   $0xc0030b58
c00230c4:	e8 d4 6a 00 00       	call   c0029b9d <debug_panic>
  ASSERT (!intr_context ());
c00230c9:	e8 96 eb ff ff       	call   c0021c64 <intr_context>
c00230ce:	83 f0 01             	xor    $0x1,%eax
c00230d1:	84 c0                	test   %al,%al
c00230d3:	75 21                	jne    c00230f6 <lock_acquire+0x5b>
c00230d5:	83 ec 0c             	sub    $0xc,%esp
c00230d8:	68 6e 0b 03 c0       	push   $0xc0030b6e
c00230dd:	68 41 0b 03 c0       	push   $0xc0030b41
c00230e2:	68 4c 0c 03 c0       	push   $0xc0030c4c
c00230e7:	68 c4 00 00 00       	push   $0xc4
c00230ec:	68 58 0b 03 c0       	push   $0xc0030b58
c00230f1:	e8 a7 6a 00 00       	call   c0029b9d <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c00230f6:	83 ec 0c             	sub    $0xc,%esp
c00230f9:	ff 75 08             	pushl  0x8(%ebp)
c00230fc:	e8 a8 01 00 00       	call   c00232a9 <lock_held_by_current_thread>
c0023101:	83 c4 10             	add    $0x10,%esp
c0023104:	83 f0 01             	xor    $0x1,%eax
c0023107:	84 c0                	test   %al,%al
c0023109:	75 21                	jne    c002312c <lock_acquire+0x91>
c002310b:	83 ec 0c             	sub    $0xc,%esp
c002310e:	68 b4 0b 03 c0       	push   $0xc0030bb4
c0023113:	68 41 0b 03 c0       	push   $0xc0030b41
c0023118:	68 4c 0c 03 c0       	push   $0xc0030c4c
c002311d:	68 c5 00 00 00       	push   $0xc5
c0023122:	68 58 0b 03 c0       	push   $0xc0030b58
c0023127:	e8 71 6a 00 00       	call   c0029b9d <debug_panic>

  sema_down (&lock->semaphore);
c002312c:	8b 45 08             	mov    0x8(%ebp),%eax
c002312f:	83 c0 04             	add    $0x4,%eax
c0023132:	83 ec 0c             	sub    $0xc,%esp
c0023135:	50                   	push   %eax
c0023136:	e8 a2 fc ff ff       	call   c0022ddd <sema_down>
c002313b:	83 c4 10             	add    $0x10,%esp
  lock->holder = thread_current ();
c002313e:	e8 73 df ff ff       	call   c00210b6 <thread_current>
c0023143:	89 c2                	mov    %eax,%edx
c0023145:	8b 45 08             	mov    0x8(%ebp),%eax
c0023148:	89 10                	mov    %edx,(%eax)
  list_push_back(&thread_current()->lock_list, &lock->elem);
c002314a:	8b 45 08             	mov    0x8(%ebp),%eax
c002314d:	8d 58 18             	lea    0x18(%eax),%ebx
c0023150:	e8 61 df ff ff       	call   c00210b6 <thread_current>
c0023155:	83 c0 4c             	add    $0x4c,%eax
c0023158:	83 ec 08             	sub    $0x8,%esp
c002315b:	53                   	push   %ebx
c002315c:	50                   	push   %eax
c002315d:	e8 8c 70 00 00       	call   c002a1ee <list_push_back>
c0023162:	83 c4 10             	add    $0x10,%esp
}
c0023165:	90                   	nop
c0023166:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023169:	c9                   	leave  
c002316a:	c3                   	ret    

c002316b <lock_try_acquire>:

   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c002316b:	55                   	push   %ebp
c002316c:	89 e5                	mov    %esp,%ebp
c002316e:	53                   	push   %ebx
c002316f:	83 ec 14             	sub    $0x14,%esp
  bool success;

  ASSERT (lock != NULL);
c0023172:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023176:	75 21                	jne    c0023199 <lock_try_acquire+0x2e>
c0023178:	83 ec 0c             	sub    $0xc,%esp
c002317b:	68 a5 0b 03 c0       	push   $0xc0030ba5
c0023180:	68 41 0b 03 c0       	push   $0xc0030b41
c0023185:	68 5c 0c 03 c0       	push   $0xc0030c5c
c002318a:	68 d7 00 00 00       	push   $0xd7
c002318f:	68 58 0b 03 c0       	push   $0xc0030b58
c0023194:	e8 04 6a 00 00       	call   c0029b9d <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0023199:	83 ec 0c             	sub    $0xc,%esp
c002319c:	ff 75 08             	pushl  0x8(%ebp)
c002319f:	e8 05 01 00 00       	call   c00232a9 <lock_held_by_current_thread>
c00231a4:	83 c4 10             	add    $0x10,%esp
c00231a7:	83 f0 01             	xor    $0x1,%eax
c00231aa:	84 c0                	test   %al,%al
c00231ac:	75 21                	jne    c00231cf <lock_try_acquire+0x64>
c00231ae:	83 ec 0c             	sub    $0xc,%esp
c00231b1:	68 b4 0b 03 c0       	push   $0xc0030bb4
c00231b6:	68 41 0b 03 c0       	push   $0xc0030b41
c00231bb:	68 5c 0c 03 c0       	push   $0xc0030c5c
c00231c0:	68 d8 00 00 00       	push   $0xd8
c00231c5:	68 58 0b 03 c0       	push   $0xc0030b58
c00231ca:	e8 ce 69 00 00       	call   c0029b9d <debug_panic>

  success = sema_try_down (&lock->semaphore);
c00231cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00231d2:	83 c0 04             	add    $0x4,%eax
c00231d5:	83 ec 0c             	sub    $0xc,%esp
c00231d8:	50                   	push   %eax
c00231d9:	e8 a4 fc ff ff       	call   c0022e82 <sema_try_down>
c00231de:	83 c4 10             	add    $0x10,%esp
c00231e1:	88 45 f7             	mov    %al,-0x9(%ebp)
  if (success) {
c00231e4:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c00231e8:	74 27                	je     c0023211 <lock_try_acquire+0xa6>
    lock->holder = thread_current ();
c00231ea:	e8 c7 de ff ff       	call   c00210b6 <thread_current>
c00231ef:	89 c2                	mov    %eax,%edx
c00231f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00231f4:	89 10                	mov    %edx,(%eax)
    list_push_back(&thread_current()->lock_list, &lock->elem);
c00231f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00231f9:	8d 58 18             	lea    0x18(%eax),%ebx
c00231fc:	e8 b5 de ff ff       	call   c00210b6 <thread_current>
c0023201:	83 c0 4c             	add    $0x4c,%eax
c0023204:	83 ec 08             	sub    $0x8,%esp
c0023207:	53                   	push   %ebx
c0023208:	50                   	push   %eax
c0023209:	e8 e0 6f 00 00       	call   c002a1ee <list_push_back>
c002320e:	83 c4 10             	add    $0x10,%esp
  }
  return success;
c0023211:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c0023214:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023217:	c9                   	leave  
c0023218:	c3                   	ret    

c0023219 <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c0023219:	55                   	push   %ebp
c002321a:	89 e5                	mov    %esp,%ebp
c002321c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c002321f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023223:	75 21                	jne    c0023246 <lock_release+0x2d>
c0023225:	83 ec 0c             	sub    $0xc,%esp
c0023228:	68 a5 0b 03 c0       	push   $0xc0030ba5
c002322d:	68 41 0b 03 c0       	push   $0xc0030b41
c0023232:	68 70 0c 03 c0       	push   $0xc0030c70
c0023237:	68 ea 00 00 00       	push   $0xea
c002323c:	68 58 0b 03 c0       	push   $0xc0030b58
c0023241:	e8 57 69 00 00       	call   c0029b9d <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023246:	83 ec 0c             	sub    $0xc,%esp
c0023249:	ff 75 08             	pushl  0x8(%ebp)
c002324c:	e8 58 00 00 00       	call   c00232a9 <lock_held_by_current_thread>
c0023251:	83 c4 10             	add    $0x10,%esp
c0023254:	84 c0                	test   %al,%al
c0023256:	75 21                	jne    c0023279 <lock_release+0x60>
c0023258:	83 ec 0c             	sub    $0xc,%esp
c002325b:	68 d8 0b 03 c0       	push   $0xc0030bd8
c0023260:	68 41 0b 03 c0       	push   $0xc0030b41
c0023265:	68 70 0c 03 c0       	push   $0xc0030c70
c002326a:	68 eb 00 00 00       	push   $0xeb
c002326f:	68 58 0b 03 c0       	push   $0xc0030b58
c0023274:	e8 24 69 00 00       	call   c0029b9d <debug_panic>

  lock->holder = NULL;
c0023279:	8b 45 08             	mov    0x8(%ebp),%eax
c002327c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list_remove(&lock->elem);
c0023282:	8b 45 08             	mov    0x8(%ebp),%eax
c0023285:	83 c0 18             	add    $0x18,%eax
c0023288:	83 ec 0c             	sub    $0xc,%esp
c002328b:	50                   	push   %eax
c002328c:	e8 83 6f 00 00       	call   c002a214 <list_remove>
c0023291:	83 c4 10             	add    $0x10,%esp
  semaphore_up (&lock->semaphore);
c0023294:	8b 45 08             	mov    0x8(%ebp),%eax
c0023297:	83 c0 04             	add    $0x4,%eax
c002329a:	83 ec 0c             	sub    $0xc,%esp
c002329d:	50                   	push   %eax
c002329e:	e8 44 fc ff ff       	call   c0022ee7 <semaphore_up>
c00232a3:	83 c4 10             	add    $0x10,%esp
}
c00232a6:	90                   	nop
c00232a7:	c9                   	leave  
c00232a8:	c3                   	ret    

c00232a9 <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c00232a9:	55                   	push   %ebp
c00232aa:	89 e5                	mov    %esp,%ebp
c00232ac:	53                   	push   %ebx
c00232ad:	83 ec 04             	sub    $0x4,%esp
  ASSERT (lock != NULL);
c00232b0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00232b4:	75 21                	jne    c00232d7 <lock_held_by_current_thread+0x2e>
c00232b6:	83 ec 0c             	sub    $0xc,%esp
c00232b9:	68 a5 0b 03 c0       	push   $0xc0030ba5
c00232be:	68 41 0b 03 c0       	push   $0xc0030b41
c00232c3:	68 80 0c 03 c0       	push   $0xc0030c80
c00232c8:	68 f8 00 00 00       	push   $0xf8
c00232cd:	68 58 0b 03 c0       	push   $0xc0030b58
c00232d2:	e8 c6 68 00 00       	call   c0029b9d <debug_panic>

  return lock->holder == thread_current ();
c00232d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00232da:	8b 18                	mov    (%eax),%ebx
c00232dc:	e8 d5 dd ff ff       	call   c00210b6 <thread_current>
c00232e1:	39 c3                	cmp    %eax,%ebx
c00232e3:	0f 94 c0             	sete   %al
}
c00232e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00232e9:	c9                   	leave  
c00232ea:	c3                   	ret    

c00232eb <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c00232eb:	55                   	push   %ebp
c00232ec:	89 e5                	mov    %esp,%ebp
c00232ee:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c00232f1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00232f5:	75 21                	jne    c0023318 <cond_init+0x2d>
c00232f7:	83 ec 0c             	sub    $0xc,%esp
c00232fa:	68 fb 0b 03 c0       	push   $0xc0030bfb
c00232ff:	68 41 0b 03 c0       	push   $0xc0030b41
c0023304:	68 9c 0c 03 c0       	push   $0xc0030c9c
c0023309:	68 0a 01 00 00       	push   $0x10a
c002330e:	68 58 0b 03 c0       	push   $0xc0030b58
c0023313:	e8 85 68 00 00       	call   c0029b9d <debug_panic>

  list_init (&cond->waiters);
c0023318:	8b 45 08             	mov    0x8(%ebp),%eax
c002331b:	83 ec 0c             	sub    $0xc,%esp
c002331e:	50                   	push   %eax
c002331f:	e8 ea 6a 00 00       	call   c0029e0e <list_init>
c0023324:	83 c4 10             	add    $0x10,%esp
}
c0023327:	90                   	nop
c0023328:	c9                   	leave  
c0023329:	c3                   	ret    

c002332a <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c002332a:	55                   	push   %ebp
c002332b:	89 e5                	mov    %esp,%ebp
c002332d:	83 ec 28             	sub    $0x28,%esp
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0023330:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023334:	75 21                	jne    c0023357 <cond_wait+0x2d>
c0023336:	83 ec 0c             	sub    $0xc,%esp
c0023339:	68 fb 0b 03 c0       	push   $0xc0030bfb
c002333e:	68 41 0b 03 c0       	push   $0xc0030b41
c0023343:	68 a8 0c 03 c0       	push   $0xc0030ca8
c0023348:	68 28 01 00 00       	push   $0x128
c002334d:	68 58 0b 03 c0       	push   $0xc0030b58
c0023352:	e8 46 68 00 00       	call   c0029b9d <debug_panic>
  ASSERT (lock != NULL);
c0023357:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002335b:	75 21                	jne    c002337e <cond_wait+0x54>
c002335d:	83 ec 0c             	sub    $0xc,%esp
c0023360:	68 a5 0b 03 c0       	push   $0xc0030ba5
c0023365:	68 41 0b 03 c0       	push   $0xc0030b41
c002336a:	68 a8 0c 03 c0       	push   $0xc0030ca8
c002336f:	68 29 01 00 00       	push   $0x129
c0023374:	68 58 0b 03 c0       	push   $0xc0030b58
c0023379:	e8 1f 68 00 00       	call   c0029b9d <debug_panic>
  ASSERT (!intr_context ());
c002337e:	e8 e1 e8 ff ff       	call   c0021c64 <intr_context>
c0023383:	83 f0 01             	xor    $0x1,%eax
c0023386:	84 c0                	test   %al,%al
c0023388:	75 21                	jne    c00233ab <cond_wait+0x81>
c002338a:	83 ec 0c             	sub    $0xc,%esp
c002338d:	68 6e 0b 03 c0       	push   $0xc0030b6e
c0023392:	68 41 0b 03 c0       	push   $0xc0030b41
c0023397:	68 a8 0c 03 c0       	push   $0xc0030ca8
c002339c:	68 2a 01 00 00       	push   $0x12a
c00233a1:	68 58 0b 03 c0       	push   $0xc0030b58
c00233a6:	e8 f2 67 00 00       	call   c0029b9d <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c00233ab:	83 ec 0c             	sub    $0xc,%esp
c00233ae:	ff 75 0c             	pushl  0xc(%ebp)
c00233b1:	e8 f3 fe ff ff       	call   c00232a9 <lock_held_by_current_thread>
c00233b6:	83 c4 10             	add    $0x10,%esp
c00233b9:	84 c0                	test   %al,%al
c00233bb:	75 21                	jne    c00233de <cond_wait+0xb4>
c00233bd:	83 ec 0c             	sub    $0xc,%esp
c00233c0:	68 d8 0b 03 c0       	push   $0xc0030bd8
c00233c5:	68 41 0b 03 c0       	push   $0xc0030b41
c00233ca:	68 a8 0c 03 c0       	push   $0xc0030ca8
c00233cf:	68 2b 01 00 00       	push   $0x12b
c00233d4:	68 58 0b 03 c0       	push   $0xc0030b58
c00233d9:	e8 bf 67 00 00       	call   c0029b9d <debug_panic>
  
  sema_init (&waiter.semaphore, 0);
c00233de:	83 ec 08             	sub    $0x8,%esp
c00233e1:	6a 00                	push   $0x0
c00233e3:	8d 45 dc             	lea    -0x24(%ebp),%eax
c00233e6:	83 c0 08             	add    $0x8,%eax
c00233e9:	50                   	push   %eax
c00233ea:	e8 a7 f9 ff ff       	call   c0022d96 <sema_init>
c00233ef:	83 c4 10             	add    $0x10,%esp
  list_push_back (&cond->waiters, &waiter.elem);
c00233f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00233f5:	83 ec 08             	sub    $0x8,%esp
c00233f8:	8d 55 dc             	lea    -0x24(%ebp),%edx
c00233fb:	52                   	push   %edx
c00233fc:	50                   	push   %eax
c00233fd:	e8 ec 6d 00 00       	call   c002a1ee <list_push_back>
c0023402:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c0023405:	83 ec 0c             	sub    $0xc,%esp
c0023408:	ff 75 0c             	pushl  0xc(%ebp)
c002340b:	e8 09 fe ff ff       	call   c0023219 <lock_release>
c0023410:	83 c4 10             	add    $0x10,%esp
  sema_down (&waiter.semaphore);
c0023413:	83 ec 0c             	sub    $0xc,%esp
c0023416:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0023419:	83 c0 08             	add    $0x8,%eax
c002341c:	50                   	push   %eax
c002341d:	e8 bb f9 ff ff       	call   c0022ddd <sema_down>
c0023422:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c0023425:	83 ec 0c             	sub    $0xc,%esp
c0023428:	ff 75 0c             	pushl  0xc(%ebp)
c002342b:	e8 6b fc ff ff       	call   c002309b <lock_acquire>
c0023430:	83 c4 10             	add    $0x10,%esp
}
c0023433:	90                   	nop
c0023434:	c9                   	leave  
c0023435:	c3                   	ret    

c0023436 <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c0023436:	55                   	push   %ebp
c0023437:	89 e5                	mov    %esp,%ebp
c0023439:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c002343c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023440:	75 21                	jne    c0023463 <cond_signal+0x2d>
c0023442:	83 ec 0c             	sub    $0xc,%esp
c0023445:	68 fb 0b 03 c0       	push   $0xc0030bfb
c002344a:	68 41 0b 03 c0       	push   $0xc0030b41
c002344f:	68 b4 0c 03 c0       	push   $0xc0030cb4
c0023454:	68 3e 01 00 00       	push   $0x13e
c0023459:	68 58 0b 03 c0       	push   $0xc0030b58
c002345e:	e8 3a 67 00 00       	call   c0029b9d <debug_panic>
  ASSERT (lock != NULL);
c0023463:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023467:	75 21                	jne    c002348a <cond_signal+0x54>
c0023469:	83 ec 0c             	sub    $0xc,%esp
c002346c:	68 a5 0b 03 c0       	push   $0xc0030ba5
c0023471:	68 41 0b 03 c0       	push   $0xc0030b41
c0023476:	68 b4 0c 03 c0       	push   $0xc0030cb4
c002347b:	68 3f 01 00 00       	push   $0x13f
c0023480:	68 58 0b 03 c0       	push   $0xc0030b58
c0023485:	e8 13 67 00 00       	call   c0029b9d <debug_panic>
  ASSERT (!intr_context ());
c002348a:	e8 d5 e7 ff ff       	call   c0021c64 <intr_context>
c002348f:	83 f0 01             	xor    $0x1,%eax
c0023492:	84 c0                	test   %al,%al
c0023494:	75 21                	jne    c00234b7 <cond_signal+0x81>
c0023496:	83 ec 0c             	sub    $0xc,%esp
c0023499:	68 6e 0b 03 c0       	push   $0xc0030b6e
c002349e:	68 41 0b 03 c0       	push   $0xc0030b41
c00234a3:	68 b4 0c 03 c0       	push   $0xc0030cb4
c00234a8:	68 40 01 00 00       	push   $0x140
c00234ad:	68 58 0b 03 c0       	push   $0xc0030b58
c00234b2:	e8 e6 66 00 00       	call   c0029b9d <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c00234b7:	83 ec 0c             	sub    $0xc,%esp
c00234ba:	ff 75 0c             	pushl  0xc(%ebp)
c00234bd:	e8 e7 fd ff ff       	call   c00232a9 <lock_held_by_current_thread>
c00234c2:	83 c4 10             	add    $0x10,%esp
c00234c5:	84 c0                	test   %al,%al
c00234c7:	75 21                	jne    c00234ea <cond_signal+0xb4>
c00234c9:	83 ec 0c             	sub    $0xc,%esp
c00234cc:	68 d8 0b 03 c0       	push   $0xc0030bd8
c00234d1:	68 41 0b 03 c0       	push   $0xc0030b41
c00234d6:	68 b4 0c 03 c0       	push   $0xc0030cb4
c00234db:	68 41 01 00 00       	push   $0x141
c00234e0:	68 58 0b 03 c0       	push   $0xc0030b58
c00234e5:	e8 b3 66 00 00       	call   c0029b9d <debug_panic>

  if (!list_empty (&cond->waiters)) 
c00234ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00234ed:	83 ec 0c             	sub    $0xc,%esp
c00234f0:	50                   	push   %eax
c00234f1:	e8 9f 6e 00 00       	call   c002a395 <list_empty>
c00234f6:	83 c4 10             	add    $0x10,%esp
c00234f9:	83 f0 01             	xor    $0x1,%eax
c00234fc:	84 c0                	test   %al,%al
c00234fe:	74 24                	je     c0023524 <cond_signal+0xee>
    semaphore_up (&list_entry (list_pop_front (&cond->waiters),
c0023500:	8b 45 08             	mov    0x8(%ebp),%eax
c0023503:	83 ec 0c             	sub    $0xc,%esp
c0023506:	50                   	push   %eax
c0023507:	e8 61 6d 00 00       	call   c002a26d <list_pop_front>
c002350c:	83 c4 10             	add    $0x10,%esp
c002350f:	83 c0 04             	add    $0x4,%eax
c0023512:	83 e8 04             	sub    $0x4,%eax
c0023515:	83 c0 08             	add    $0x8,%eax
c0023518:	83 ec 0c             	sub    $0xc,%esp
c002351b:	50                   	push   %eax
c002351c:	e8 c6 f9 ff ff       	call   c0022ee7 <semaphore_up>
c0023521:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
}
c0023524:	90                   	nop
c0023525:	c9                   	leave  
c0023526:	c3                   	ret    

c0023527 <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0023527:	55                   	push   %ebp
c0023528:	89 e5                	mov    %esp,%ebp
c002352a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c002352d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023531:	75 21                	jne    c0023554 <cond_broadcast+0x2d>
c0023533:	83 ec 0c             	sub    $0xc,%esp
c0023536:	68 fb 0b 03 c0       	push   $0xc0030bfb
c002353b:	68 41 0b 03 c0       	push   $0xc0030b41
c0023540:	68 c0 0c 03 c0       	push   $0xc0030cc0
c0023545:	68 51 01 00 00       	push   $0x151
c002354a:	68 58 0b 03 c0       	push   $0xc0030b58
c002354f:	e8 49 66 00 00       	call   c0029b9d <debug_panic>
  ASSERT (lock != NULL);
c0023554:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023558:	75 32                	jne    c002358c <cond_broadcast+0x65>
c002355a:	83 ec 0c             	sub    $0xc,%esp
c002355d:	68 a5 0b 03 c0       	push   $0xc0030ba5
c0023562:	68 41 0b 03 c0       	push   $0xc0030b41
c0023567:	68 c0 0c 03 c0       	push   $0xc0030cc0
c002356c:	68 52 01 00 00       	push   $0x152
c0023571:	68 58 0b 03 c0       	push   $0xc0030b58
c0023576:	e8 22 66 00 00       	call   c0029b9d <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c002357b:	83 ec 08             	sub    $0x8,%esp
c002357e:	ff 75 0c             	pushl  0xc(%ebp)
c0023581:	ff 75 08             	pushl  0x8(%ebp)
c0023584:	e8 ad fe ff ff       	call   c0023436 <cond_signal>
c0023589:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c002358c:	8b 45 08             	mov    0x8(%ebp),%eax
c002358f:	83 ec 0c             	sub    $0xc,%esp
c0023592:	50                   	push   %eax
c0023593:	e8 fd 6d 00 00       	call   c002a395 <list_empty>
c0023598:	83 c4 10             	add    $0x10,%esp
c002359b:	83 f0 01             	xor    $0x1,%eax
c002359e:	84 c0                	test   %al,%al
c00235a0:	75 d9                	jne    c002357b <cond_broadcast+0x54>
}
c00235a2:	90                   	nop
c00235a3:	c9                   	leave  
c00235a4:	c3                   	ret    

c00235a5 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c00235a5:	55                   	push   %ebp
c00235a6:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c00235a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00235ab:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00235b0:	5d                   	pop    %ebp
c00235b1:	c3                   	ret    

c00235b2 <pg_no>:
static inline uintptr_t pg_no (const void *va) {
c00235b2:	55                   	push   %ebp
c00235b3:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PGBITS;
c00235b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00235b8:	c1 e8 0c             	shr    $0xc,%eax
}
c00235bb:	5d                   	pop    %ebp
c00235bc:	c3                   	ret    

c00235bd <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c00235bd:	55                   	push   %ebp
c00235be:	89 e5                	mov    %esp,%ebp
c00235c0:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c00235c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00235c6:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00235cb:	76 1e                	jbe    c00235eb <ptov+0x2e>
c00235cd:	83 ec 0c             	sub    $0xc,%esp
c00235d0:	68 d0 0c 03 c0       	push   $0xc0030cd0
c00235d5:	68 eb 0c 03 c0       	push   $0xc0030ceb
c00235da:	68 08 0e 03 c0       	push   $0xc0030e08
c00235df:	6a 4a                	push   $0x4a
c00235e1:	68 02 0d 03 c0       	push   $0xc0030d02
c00235e6:	e8 b2 65 00 00       	call   c0029b9d <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c00235eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00235ee:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00235f3:	c9                   	leave  
c00235f4:	c3                   	ret    

c00235f5 <palloc_init>:

/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */
void
palloc_init (size_t user_page_limit)
{
c00235f5:	55                   	push   %ebp
c00235f6:	89 e5                	mov    %esp,%ebp
c00235f8:	83 ec 28             	sub    $0x28,%esp
  /* Free memory starts at 1 MB and runs to the end of RAM. */
  uint8_t *free_start = ptov (1024 * 1024);
c00235fb:	83 ec 0c             	sub    $0xc,%esp
c00235fe:	68 00 00 10 00       	push   $0x100000
c0023603:	e8 b5 ff ff ff       	call   c00235bd <ptov>
c0023608:	83 c4 10             	add    $0x10,%esp
c002360b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c002360e:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c0023613:	c1 e0 0c             	shl    $0xc,%eax
c0023616:	83 ec 0c             	sub    $0xc,%esp
c0023619:	50                   	push   %eax
c002361a:	e8 9e ff ff ff       	call   c00235bd <ptov>
c002361f:	83 c4 10             	add    $0x10,%esp
c0023622:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0023625:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023628:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002362b:	29 c2                	sub    %eax,%edx
c002362d:	89 d0                	mov    %edx,%eax
c002362f:	85 c0                	test   %eax,%eax
c0023631:	79 05                	jns    c0023638 <palloc_init+0x43>
c0023633:	05 ff 0f 00 00       	add    $0xfff,%eax
c0023638:	c1 f8 0c             	sar    $0xc,%eax
c002363b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  size_t user_pages = free_pages / 2;
c002363e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023641:	d1 e8                	shr    %eax
c0023643:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t kernel_pages;
  if (user_pages > user_page_limit)
c0023646:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023649:	3b 45 08             	cmp    0x8(%ebp),%eax
c002364c:	76 06                	jbe    c0023654 <palloc_init+0x5f>
    user_pages = user_page_limit;
c002364e:	8b 45 08             	mov    0x8(%ebp),%eax
c0023651:	89 45 f4             	mov    %eax,-0xc(%ebp)
  kernel_pages = free_pages - user_pages;
c0023654:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023657:	2b 45 f4             	sub    -0xc(%ebp),%eax
c002365a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Give half of memory to kernel, half to user. */
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c002365d:	68 18 0d 03 c0       	push   $0xc0030d18
c0023662:	ff 75 e4             	pushl  -0x1c(%ebp)
c0023665:	ff 75 f0             	pushl  -0x10(%ebp)
c0023668:	68 00 a0 03 c0       	push   $0xc003a000
c002366d:	e8 6e 02 00 00       	call   c00238e0 <init_pool>
c0023672:	83 c4 10             	add    $0x10,%esp
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c0023675:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023678:	c1 e0 0c             	shl    $0xc,%eax
c002367b:	89 c2                	mov    %eax,%edx
c002367d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023680:	01 d0                	add    %edx,%eax
c0023682:	68 24 0d 03 c0       	push   $0xc0030d24
c0023687:	ff 75 f4             	pushl  -0xc(%ebp)
c002368a:	50                   	push   %eax
c002368b:	68 40 a0 03 c0       	push   $0xc003a040
c0023690:	e8 4b 02 00 00       	call   c00238e0 <init_pool>
c0023695:	83 c4 10             	add    $0x10,%esp
             user_pages, "user pool");
}
c0023698:	90                   	nop
c0023699:	c9                   	leave  
c002369a:	c3                   	ret    

c002369b <palloc_get_multiple>:
   then the pages are filled with zeros.  If too few pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
{
c002369b:	55                   	push   %ebp
c002369c:	89 e5                	mov    %esp,%ebp
c002369e:	83 ec 18             	sub    $0x18,%esp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c00236a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00236a4:	83 e0 04             	and    $0x4,%eax
c00236a7:	85 c0                	test   %eax,%eax
c00236a9:	74 07                	je     c00236b2 <palloc_get_multiple+0x17>
c00236ab:	b8 40 a0 03 c0       	mov    $0xc003a040,%eax
c00236b0:	eb 05                	jmp    c00236b7 <palloc_get_multiple+0x1c>
c00236b2:	b8 00 a0 03 c0       	mov    $0xc003a000,%eax
c00236b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
c00236ba:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00236be:	75 0a                	jne    c00236ca <palloc_get_multiple+0x2f>
    return NULL;
c00236c0:	b8 00 00 00 00       	mov    $0x0,%eax
c00236c5:	e9 a3 00 00 00       	jmp    c002376d <palloc_get_multiple+0xd2>

  lock_acquire (&pool->lock);
c00236ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00236cd:	83 ec 0c             	sub    $0xc,%esp
c00236d0:	50                   	push   %eax
c00236d1:	e8 c5 f9 ff ff       	call   c002309b <lock_acquire>
c00236d6:	83 c4 10             	add    $0x10,%esp
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c00236d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00236dc:	8b 40 20             	mov    0x20(%eax),%eax
c00236df:	6a 00                	push   $0x0
c00236e1:	ff 75 0c             	pushl  0xc(%ebp)
c00236e4:	6a 00                	push   $0x0
c00236e6:	50                   	push   %eax
c00236e7:	e8 05 7c 00 00       	call   c002b2f1 <bitmap_scan_and_flip>
c00236ec:	83 c4 10             	add    $0x10,%esp
c00236ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
  lock_release (&pool->lock);
c00236f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00236f5:	83 ec 0c             	sub    $0xc,%esp
c00236f8:	50                   	push   %eax
c00236f9:	e8 1b fb ff ff       	call   c0023219 <lock_release>
c00236fe:	83 c4 10             	add    $0x10,%esp

  if (page_idx != BITMAP_ERROR)
c0023701:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c0023705:	74 13                	je     c002371a <palloc_get_multiple+0x7f>
    pages = pool->base + PGSIZE * page_idx;
c0023707:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002370a:	8b 40 24             	mov    0x24(%eax),%eax
c002370d:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023710:	c1 e2 0c             	shl    $0xc,%edx
c0023713:	01 d0                	add    %edx,%eax
c0023715:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023718:	eb 07                	jmp    c0023721 <palloc_get_multiple+0x86>
  else
    pages = NULL;
c002371a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (pages != NULL) 
c0023721:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023725:	74 23                	je     c002374a <palloc_get_multiple+0xaf>
    {
      if (flags & PAL_ZERO)
c0023727:	8b 45 08             	mov    0x8(%ebp),%eax
c002372a:	83 e0 02             	and    $0x2,%eax
c002372d:	85 c0                	test   %eax,%eax
c002372f:	74 39                	je     c002376a <palloc_get_multiple+0xcf>
        memset (pages, 0, PGSIZE * page_cnt);
c0023731:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023734:	c1 e0 0c             	shl    $0xc,%eax
c0023737:	83 ec 04             	sub    $0x4,%esp
c002373a:	50                   	push   %eax
c002373b:	6a 00                	push   $0x0
c002373d:	ff 75 f4             	pushl  -0xc(%ebp)
c0023740:	e8 72 58 00 00       	call   c0028fb7 <memset>
c0023745:	83 c4 10             	add    $0x10,%esp
c0023748:	eb 20                	jmp    c002376a <palloc_get_multiple+0xcf>
    }
  else 
    {
      if (flags & PAL_ASSERT)
c002374a:	8b 45 08             	mov    0x8(%ebp),%eax
c002374d:	83 e0 01             	and    $0x1,%eax
c0023750:	85 c0                	test   %eax,%eax
c0023752:	74 16                	je     c002376a <palloc_get_multiple+0xcf>
        PANIC ("palloc_get: out of pages");
c0023754:	68 2e 0d 03 c0       	push   $0xc0030d2e
c0023759:	68 10 0e 03 c0       	push   $0xc0030e10
c002375e:	6a 61                	push   $0x61
c0023760:	68 47 0d 03 c0       	push   $0xc0030d47
c0023765:	e8 33 64 00 00       	call   c0029b9d <debug_panic>
    }

  return pages;
c002376a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002376d:	c9                   	leave  
c002376e:	c3                   	ret    

c002376f <palloc_get_page>:
   then the page is filled with zeros.  If no pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_page (enum palloc_flags flags) 
{
c002376f:	55                   	push   %ebp
c0023770:	89 e5                	mov    %esp,%ebp
c0023772:	83 ec 08             	sub    $0x8,%esp
  return palloc_get_multiple (flags, 1);
c0023775:	83 ec 08             	sub    $0x8,%esp
c0023778:	6a 01                	push   $0x1
c002377a:	ff 75 08             	pushl  0x8(%ebp)
c002377d:	e8 19 ff ff ff       	call   c002369b <palloc_get_multiple>
c0023782:	83 c4 10             	add    $0x10,%esp
}
c0023785:	c9                   	leave  
c0023786:	c3                   	ret    

c0023787 <palloc_free_multiple>:

/* Frees the PAGE_CNT pages starting at PAGES. */
void
palloc_free_multiple (void *pages, size_t page_cnt) 
{
c0023787:	55                   	push   %ebp
c0023788:	89 e5                	mov    %esp,%ebp
c002378a:	53                   	push   %ebx
c002378b:	83 ec 14             	sub    $0x14,%esp
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
c002378e:	ff 75 08             	pushl  0x8(%ebp)
c0023791:	e8 0f fe ff ff       	call   c00235a5 <pg_ofs>
c0023796:	83 c4 04             	add    $0x4,%esp
c0023799:	85 c0                	test   %eax,%eax
c002379b:	74 1e                	je     c00237bb <palloc_free_multiple+0x34>
c002379d:	83 ec 0c             	sub    $0xc,%esp
c00237a0:	68 5e 0d 03 c0       	push   $0xc0030d5e
c00237a5:	68 eb 0c 03 c0       	push   $0xc0030ceb
c00237aa:	68 24 0e 03 c0       	push   $0xc0030e24
c00237af:	6a 7b                	push   $0x7b
c00237b1:	68 47 0d 03 c0       	push   $0xc0030d47
c00237b6:	e8 e2 63 00 00       	call   c0029b9d <debug_panic>
  if (pages == NULL || page_cnt == 0)
c00237bb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00237bf:	0f 84 fc 00 00 00    	je     c00238c1 <palloc_free_multiple+0x13a>
c00237c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00237c9:	0f 84 f2 00 00 00    	je     c00238c1 <palloc_free_multiple+0x13a>
    return;

  if (page_from_pool (&kernel_pool, pages))
c00237cf:	83 ec 08             	sub    $0x8,%esp
c00237d2:	ff 75 08             	pushl  0x8(%ebp)
c00237d5:	68 00 a0 03 c0       	push   $0xc003a000
c00237da:	e8 a8 01 00 00       	call   c0023987 <page_from_pool>
c00237df:	83 c4 10             	add    $0x10,%esp
c00237e2:	84 c0                	test   %al,%al
c00237e4:	74 09                	je     c00237ef <palloc_free_multiple+0x68>
    pool = &kernel_pool;
c00237e6:	c7 45 f4 00 a0 03 c0 	movl   $0xc003a000,-0xc(%ebp)
c00237ed:	eb 39                	jmp    c0023828 <palloc_free_multiple+0xa1>
  else if (page_from_pool (&user_pool, pages))
c00237ef:	83 ec 08             	sub    $0x8,%esp
c00237f2:	ff 75 08             	pushl  0x8(%ebp)
c00237f5:	68 40 a0 03 c0       	push   $0xc003a040
c00237fa:	e8 88 01 00 00       	call   c0023987 <page_from_pool>
c00237ff:	83 c4 10             	add    $0x10,%esp
c0023802:	84 c0                	test   %al,%al
c0023804:	74 09                	je     c002380f <palloc_free_multiple+0x88>
    pool = &user_pool;
c0023806:	c7 45 f4 40 a0 03 c0 	movl   $0xc003a040,-0xc(%ebp)
c002380d:	eb 19                	jmp    c0023828 <palloc_free_multiple+0xa1>
  else
    NOT_REACHED ();
c002380f:	68 74 0d 03 c0       	push   $0xc0030d74
c0023814:	68 24 0e 03 c0       	push   $0xc0030e24
c0023819:	68 84 00 00 00       	push   $0x84
c002381e:	68 47 0d 03 c0       	push   $0xc0030d47
c0023823:	e8 75 63 00 00       	call   c0029b9d <debug_panic>

  page_idx = pg_no (pages) - pg_no (pool->base);
c0023828:	83 ec 0c             	sub    $0xc,%esp
c002382b:	ff 75 08             	pushl  0x8(%ebp)
c002382e:	e8 7f fd ff ff       	call   c00235b2 <pg_no>
c0023833:	83 c4 10             	add    $0x10,%esp
c0023836:	89 c3                	mov    %eax,%ebx
c0023838:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002383b:	8b 40 24             	mov    0x24(%eax),%eax
c002383e:	83 ec 0c             	sub    $0xc,%esp
c0023841:	50                   	push   %eax
c0023842:	e8 6b fd ff ff       	call   c00235b2 <pg_no>
c0023847:	83 c4 10             	add    $0x10,%esp
c002384a:	29 c3                	sub    %eax,%ebx
c002384c:	89 d8                	mov    %ebx,%eax
c002384e:	89 45 f0             	mov    %eax,-0x10(%ebp)

#ifndef NDEBUG
  memset (pages, 0xcc, PGSIZE * page_cnt);
c0023851:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023854:	c1 e0 0c             	shl    $0xc,%eax
c0023857:	83 ec 04             	sub    $0x4,%esp
c002385a:	50                   	push   %eax
c002385b:	68 cc 00 00 00       	push   $0xcc
c0023860:	ff 75 08             	pushl  0x8(%ebp)
c0023863:	e8 4f 57 00 00       	call   c0028fb7 <memset>
c0023868:	83 c4 10             	add    $0x10,%esp
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c002386b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002386e:	8b 40 20             	mov    0x20(%eax),%eax
c0023871:	83 ec 04             	sub    $0x4,%esp
c0023874:	ff 75 0c             	pushl  0xc(%ebp)
c0023877:	ff 75 f0             	pushl  -0x10(%ebp)
c002387a:	50                   	push   %eax
c002387b:	e8 85 79 00 00       	call   c002b205 <bitmap_all>
c0023880:	83 c4 10             	add    $0x10,%esp
c0023883:	84 c0                	test   %al,%al
c0023885:	75 21                	jne    c00238a8 <palloc_free_multiple+0x121>
c0023887:	83 ec 0c             	sub    $0xc,%esp
c002388a:	68 98 0d 03 c0       	push   $0xc0030d98
c002388f:	68 eb 0c 03 c0       	push   $0xc0030ceb
c0023894:	68 24 0e 03 c0       	push   $0xc0030e24
c0023899:	68 8c 00 00 00       	push   $0x8c
c002389e:	68 47 0d 03 c0       	push   $0xc0030d47
c00238a3:	e8 f5 62 00 00       	call   c0029b9d <debug_panic>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c00238a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00238ab:	8b 40 20             	mov    0x20(%eax),%eax
c00238ae:	6a 00                	push   $0x0
c00238b0:	ff 75 0c             	pushl  0xc(%ebp)
c00238b3:	ff 75 f0             	pushl  -0x10(%ebp)
c00238b6:	50                   	push   %eax
c00238b7:	e8 a8 76 00 00       	call   c002af64 <bitmap_set_multiple>
c00238bc:	83 c4 10             	add    $0x10,%esp
c00238bf:	eb 01                	jmp    c00238c2 <palloc_free_multiple+0x13b>
    return;
c00238c1:	90                   	nop
}
c00238c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00238c5:	c9                   	leave  
c00238c6:	c3                   	ret    

c00238c7 <palloc_free_page>:

/* Frees the page at PAGE. */
void
palloc_free_page (void *page) 
{
c00238c7:	55                   	push   %ebp
c00238c8:	89 e5                	mov    %esp,%ebp
c00238ca:	83 ec 08             	sub    $0x8,%esp
  palloc_free_multiple (page, 1);
c00238cd:	83 ec 08             	sub    $0x8,%esp
c00238d0:	6a 01                	push   $0x1
c00238d2:	ff 75 08             	pushl  0x8(%ebp)
c00238d5:	e8 ad fe ff ff       	call   c0023787 <palloc_free_multiple>
c00238da:	83 c4 10             	add    $0x10,%esp
}
c00238dd:	90                   	nop
c00238de:	c9                   	leave  
c00238df:	c3                   	ret    

c00238e0 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c00238e0:	55                   	push   %ebp
c00238e1:	89 e5                	mov    %esp,%ebp
c00238e3:	83 ec 18             	sub    $0x18,%esp
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c00238e6:	83 ec 0c             	sub    $0xc,%esp
c00238e9:	ff 75 10             	pushl  0x10(%ebp)
c00238ec:	e8 09 74 00 00       	call   c002acfa <bitmap_buf_size>
c00238f1:	83 c4 10             	add    $0x10,%esp
c00238f4:	05 ff 0f 00 00       	add    $0xfff,%eax
c00238f9:	c1 e8 0c             	shr    $0xc,%eax
c00238fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (bm_pages > page_cnt)
c00238ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023902:	3b 45 10             	cmp    0x10(%ebp),%eax
c0023905:	76 1f                	jbe    c0023926 <init_pool+0x46>
    PANIC ("Not enough memory in %s for bitmap.", name);
c0023907:	83 ec 0c             	sub    $0xc,%esp
c002390a:	ff 75 14             	pushl  0x14(%ebp)
c002390d:	68 c8 0d 03 c0       	push   $0xc0030dc8
c0023912:	68 3c 0e 03 c0       	push   $0xc0030e3c
c0023917:	68 a1 00 00 00       	push   $0xa1
c002391c:	68 47 0d 03 c0       	push   $0xc0030d47
c0023921:	e8 77 62 00 00       	call   c0029b9d <debug_panic>
  page_cnt -= bm_pages;
c0023926:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023929:	29 45 10             	sub    %eax,0x10(%ebp)

  printf ("%zu pages available in %s.\n", page_cnt, name);
c002392c:	83 ec 04             	sub    $0x4,%esp
c002392f:	ff 75 14             	pushl  0x14(%ebp)
c0023932:	ff 75 10             	pushl  0x10(%ebp)
c0023935:	68 ec 0d 03 c0       	push   $0xc0030dec
c002393a:	e8 9f 3e 00 00       	call   c00277de <printf>
c002393f:	83 c4 10             	add    $0x10,%esp

  /* Initialize the pool. */
  lock_init (&p->lock);
c0023942:	8b 45 08             	mov    0x8(%ebp),%eax
c0023945:	83 ec 0c             	sub    $0xc,%esp
c0023948:	50                   	push   %eax
c0023949:	e8 00 f7 ff ff       	call   c002304e <lock_init>
c002394e:	83 c4 10             	add    $0x10,%esp
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c0023951:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023954:	c1 e0 0c             	shl    $0xc,%eax
c0023957:	83 ec 04             	sub    $0x4,%esp
c002395a:	50                   	push   %eax
c002395b:	ff 75 0c             	pushl  0xc(%ebp)
c002395e:	ff 75 10             	pushl  0x10(%ebp)
c0023961:	e8 2e 73 00 00       	call   c002ac94 <bitmap_create_in_buf>
c0023966:	83 c4 10             	add    $0x10,%esp
c0023969:	89 c2                	mov    %eax,%edx
c002396b:	8b 45 08             	mov    0x8(%ebp),%eax
c002396e:	89 50 20             	mov    %edx,0x20(%eax)
  p->base = base + bm_pages * PGSIZE;
c0023971:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023974:	c1 e0 0c             	shl    $0xc,%eax
c0023977:	89 c2                	mov    %eax,%edx
c0023979:	8b 45 0c             	mov    0xc(%ebp),%eax
c002397c:	01 c2                	add    %eax,%edx
c002397e:	8b 45 08             	mov    0x8(%ebp),%eax
c0023981:	89 50 24             	mov    %edx,0x24(%eax)
}
c0023984:	90                   	nop
c0023985:	c9                   	leave  
c0023986:	c3                   	ret    

c0023987 <page_from_pool>:

/* Returns true if PAGE was allocated from POOL,
   false otherwise. */
static bool
page_from_pool (const struct pool *pool, void *page) 
{
c0023987:	55                   	push   %ebp
c0023988:	89 e5                	mov    %esp,%ebp
c002398a:	83 ec 18             	sub    $0x18,%esp
  size_t page_no = pg_no (page);
c002398d:	ff 75 0c             	pushl  0xc(%ebp)
c0023990:	e8 1d fc ff ff       	call   c00235b2 <pg_no>
c0023995:	83 c4 04             	add    $0x4,%esp
c0023998:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t start_page = pg_no (pool->base);
c002399b:	8b 45 08             	mov    0x8(%ebp),%eax
c002399e:	8b 40 24             	mov    0x24(%eax),%eax
c00239a1:	50                   	push   %eax
c00239a2:	e8 0b fc ff ff       	call   c00235b2 <pg_no>
c00239a7:	83 c4 04             	add    $0x4,%esp
c00239aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t end_page = start_page + bitmap_size (pool->used_map);
c00239ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00239b0:	8b 40 20             	mov    0x20(%eax),%eax
c00239b3:	83 ec 0c             	sub    $0xc,%esp
c00239b6:	50                   	push   %eax
c00239b7:	e8 80 73 00 00       	call   c002ad3c <bitmap_size>
c00239bc:	83 c4 10             	add    $0x10,%esp
c00239bf:	89 c2                	mov    %eax,%edx
c00239c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00239c4:	01 d0                	add    %edx,%eax
c00239c6:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return page_no >= start_page && page_no < end_page;
c00239c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00239cc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00239cf:	72 0f                	jb     c00239e0 <page_from_pool+0x59>
c00239d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00239d4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00239d7:	73 07                	jae    c00239e0 <page_from_pool+0x59>
c00239d9:	b8 01 00 00 00       	mov    $0x1,%eax
c00239de:	eb 05                	jmp    c00239e5 <page_from_pool+0x5e>
c00239e0:	b8 00 00 00 00       	mov    $0x0,%eax
c00239e5:	83 e0 01             	and    $0x1,%eax
}
c00239e8:	c9                   	leave  
c00239e9:	c3                   	ret    

c00239ea <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c00239ea:	55                   	push   %ebp
c00239eb:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c00239ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00239f0:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00239f5:	5d                   	pop    %ebp
c00239f6:	c3                   	ret    

c00239f7 <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c00239f7:	55                   	push   %ebp
c00239f8:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00239fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00239fd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c0023a02:	5d                   	pop    %ebp
c0023a03:	c3                   	ret    

c0023a04 <malloc_init>:
static struct block *arena_to_block (struct arena *, size_t idx);

/* Initializes the malloc() descriptors. */
void
malloc_init (void) 
{
c0023a04:	55                   	push   %ebp
c0023a05:	89 e5                	mov    %esp,%ebp
c0023a07:	83 ec 18             	sub    $0x18,%esp
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023a0a:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c0023a11:	e9 94 00 00 00       	jmp    c0023aaa <malloc_init+0xa6>
    {
      struct desc *d = &descs[desc_cnt++];
c0023a16:	8b 15 b0 a2 03 c0    	mov    0xc003a2b0,%edx
c0023a1c:	8d 42 01             	lea    0x1(%edx),%eax
c0023a1f:	a3 b0 a2 03 c0       	mov    %eax,0xc003a2b0
c0023a24:	89 d0                	mov    %edx,%eax
c0023a26:	01 c0                	add    %eax,%eax
c0023a28:	01 d0                	add    %edx,%eax
c0023a2a:	01 c0                	add    %eax,%eax
c0023a2c:	01 d0                	add    %edx,%eax
c0023a2e:	c1 e0 03             	shl    $0x3,%eax
c0023a31:	05 80 a0 03 c0       	add    $0xc003a080,%eax
c0023a36:	89 45 f0             	mov    %eax,-0x10(%ebp)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023a39:	a1 b0 a2 03 c0       	mov    0xc003a2b0,%eax
c0023a3e:	83 f8 0a             	cmp    $0xa,%eax
c0023a41:	76 1e                	jbe    c0023a61 <malloc_init+0x5d>
c0023a43:	83 ec 0c             	sub    $0xc,%esp
c0023a46:	68 48 0e 03 c0       	push   $0xc0030e48
c0023a4b:	68 71 0e 03 c0       	push   $0xc0030e71
c0023a50:	68 7c 0f 03 c0       	push   $0xc0030f7c
c0023a55:	6a 4f                	push   $0x4f
c0023a57:	68 88 0e 03 c0       	push   $0xc0030e88
c0023a5c:	e8 3c 61 00 00       	call   c0029b9d <debug_panic>
      d->block_size = block_size;
c0023a61:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023a64:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023a67:	89 10                	mov    %edx,(%eax)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023a69:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023a6e:	ba 00 00 00 00       	mov    $0x0,%edx
c0023a73:	f7 75 f4             	divl   -0xc(%ebp)
c0023a76:	89 c2                	mov    %eax,%edx
c0023a78:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023a7b:	89 50 04             	mov    %edx,0x4(%eax)
      list_init (&d->free_list);
c0023a7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023a81:	83 c0 08             	add    $0x8,%eax
c0023a84:	83 ec 0c             	sub    $0xc,%esp
c0023a87:	50                   	push   %eax
c0023a88:	e8 81 63 00 00       	call   c0029e0e <list_init>
c0023a8d:	83 c4 10             	add    $0x10,%esp
      lock_init (&d->lock);
c0023a90:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023a93:	83 c0 18             	add    $0x18,%eax
c0023a96:	83 ec 0c             	sub    $0xc,%esp
c0023a99:	50                   	push   %eax
c0023a9a:	e8 af f5 ff ff       	call   c002304e <lock_init>
c0023a9f:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023aa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023aa5:	01 c0                	add    %eax,%eax
c0023aa7:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023aaa:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c0023ab1:	0f 86 5f ff ff ff    	jbe    c0023a16 <malloc_init+0x12>
    }
}
c0023ab7:	90                   	nop
c0023ab8:	c9                   	leave  
c0023ab9:	c3                   	ret    

c0023aba <malloc>:

/* Obtains and returns a new block of at least SIZE bytes.
   Returns a null pointer if memory is not available. */
void *
malloc (size_t size) 
{
c0023aba:	55                   	push   %ebp
c0023abb:	89 e5                	mov    %esp,%ebp
c0023abd:	83 ec 28             	sub    $0x28,%esp
  struct desc *d;
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
c0023ac0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023ac4:	75 0a                	jne    c0023ad0 <malloc+0x16>
    return NULL;
c0023ac6:	b8 00 00 00 00       	mov    $0x0,%eax
c0023acb:	e9 b9 01 00 00       	jmp    c0023c89 <malloc+0x1cf>

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c0023ad0:	c7 45 f4 80 a0 03 c0 	movl   $0xc003a080,-0xc(%ebp)
c0023ad7:	eb 0e                	jmp    c0023ae7 <malloc+0x2d>
    if (d->block_size >= size)
c0023ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023adc:	8b 00                	mov    (%eax),%eax
c0023ade:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023ae1:	73 23                	jae    c0023b06 <malloc+0x4c>
  for (d = descs; d < descs + desc_cnt; d++)
c0023ae3:	83 45 f4 38          	addl   $0x38,-0xc(%ebp)
c0023ae7:	8b 15 b0 a2 03 c0    	mov    0xc003a2b0,%edx
c0023aed:	89 d0                	mov    %edx,%eax
c0023aef:	01 c0                	add    %eax,%eax
c0023af1:	01 d0                	add    %edx,%eax
c0023af3:	01 c0                	add    %eax,%eax
c0023af5:	01 d0                	add    %edx,%eax
c0023af7:	c1 e0 03             	shl    $0x3,%eax
c0023afa:	05 80 a0 03 c0       	add    $0xc003a080,%eax
c0023aff:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023b02:	77 d5                	ja     c0023ad9 <malloc+0x1f>
c0023b04:	eb 01                	jmp    c0023b07 <malloc+0x4d>
      break;
c0023b06:	90                   	nop
  if (d == descs + desc_cnt) 
c0023b07:	8b 15 b0 a2 03 c0    	mov    0xc003a2b0,%edx
c0023b0d:	89 d0                	mov    %edx,%eax
c0023b0f:	01 c0                	add    %eax,%eax
c0023b11:	01 d0                	add    %edx,%eax
c0023b13:	01 c0                	add    %eax,%eax
c0023b15:	01 d0                	add    %edx,%eax
c0023b17:	c1 e0 03             	shl    $0x3,%eax
c0023b1a:	05 80 a0 03 c0       	add    $0xc003a080,%eax
c0023b1f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023b22:	75 58                	jne    c0023b7c <malloc+0xc2>
    {
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c0023b24:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b27:	05 0b 10 00 00       	add    $0x100b,%eax
c0023b2c:	c1 e8 0c             	shr    $0xc,%eax
c0023b2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
      a = palloc_get_multiple (0, page_cnt);
c0023b32:	83 ec 08             	sub    $0x8,%esp
c0023b35:	ff 75 ec             	pushl  -0x14(%ebp)
c0023b38:	6a 00                	push   $0x0
c0023b3a:	e8 5c fb ff ff       	call   c002369b <palloc_get_multiple>
c0023b3f:	83 c4 10             	add    $0x10,%esp
c0023b42:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL)
c0023b45:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023b49:	75 0a                	jne    c0023b55 <malloc+0x9b>
        return NULL;
c0023b4b:	b8 00 00 00 00       	mov    $0x0,%eax
c0023b50:	e9 34 01 00 00       	jmp    c0023c89 <malloc+0x1cf>

      /* Initialize the arena to indicate a big block of PAGE_CNT
         pages, and return it. */
      a->magic = ARENA_MAGIC;
c0023b55:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023b58:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c0023b5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023b61:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023b68:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023b6b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023b6e:	89 50 08             	mov    %edx,0x8(%eax)
      return a + 1;
c0023b71:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023b74:	83 c0 0c             	add    $0xc,%eax
c0023b77:	e9 0d 01 00 00       	jmp    c0023c89 <malloc+0x1cf>
    }

  lock_acquire (&d->lock);
c0023b7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b7f:	83 c0 18             	add    $0x18,%eax
c0023b82:	83 ec 0c             	sub    $0xc,%esp
c0023b85:	50                   	push   %eax
c0023b86:	e8 10 f5 ff ff       	call   c002309b <lock_acquire>
c0023b8b:	83 c4 10             	add    $0x10,%esp

  /* If the free list is empty, create a new arena. */
  if (list_empty (&d->free_list))
c0023b8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b91:	83 c0 08             	add    $0x8,%eax
c0023b94:	83 ec 0c             	sub    $0xc,%esp
c0023b97:	50                   	push   %eax
c0023b98:	e8 f8 67 00 00       	call   c002a395 <list_empty>
c0023b9d:	83 c4 10             	add    $0x10,%esp
c0023ba0:	84 c0                	test   %al,%al
c0023ba2:	0f 84 91 00 00 00    	je     c0023c39 <malloc+0x17f>
    {
      size_t i;

      /* Allocate a page. */
      a = palloc_get_page (0);
c0023ba8:	83 ec 0c             	sub    $0xc,%esp
c0023bab:	6a 00                	push   $0x0
c0023bad:	e8 bd fb ff ff       	call   c002376f <palloc_get_page>
c0023bb2:	83 c4 10             	add    $0x10,%esp
c0023bb5:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL) 
c0023bb8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023bbc:	75 1c                	jne    c0023bda <malloc+0x120>
        {
          lock_release (&d->lock);
c0023bbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023bc1:	83 c0 18             	add    $0x18,%eax
c0023bc4:	83 ec 0c             	sub    $0xc,%esp
c0023bc7:	50                   	push   %eax
c0023bc8:	e8 4c f6 ff ff       	call   c0023219 <lock_release>
c0023bcd:	83 c4 10             	add    $0x10,%esp
          return NULL; 
c0023bd0:	b8 00 00 00 00       	mov    $0x0,%eax
c0023bd5:	e9 af 00 00 00       	jmp    c0023c89 <malloc+0x1cf>
        }

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
c0023bda:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023bdd:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c0023be3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023be6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023be9:	89 50 04             	mov    %edx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c0023bec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023bef:	8b 50 04             	mov    0x4(%eax),%edx
c0023bf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023bf5:	89 50 08             	mov    %edx,0x8(%eax)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023bf8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0023bff:	eb 2d                	jmp    c0023c2e <malloc+0x174>
        {
          struct block *b = arena_to_block (a, i);
c0023c01:	83 ec 08             	sub    $0x8,%esp
c0023c04:	ff 75 f0             	pushl  -0x10(%ebp)
c0023c07:	ff 75 e8             	pushl  -0x18(%ebp)
c0023c0a:	e8 ea 03 00 00       	call   c0023ff9 <arena_to_block>
c0023c0f:	83 c4 10             	add    $0x10,%esp
c0023c12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          list_push_back (&d->free_list, &b->free_elem);
c0023c15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023c18:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023c1b:	83 c2 08             	add    $0x8,%edx
c0023c1e:	83 ec 08             	sub    $0x8,%esp
c0023c21:	50                   	push   %eax
c0023c22:	52                   	push   %edx
c0023c23:	e8 c6 65 00 00       	call   c002a1ee <list_push_back>
c0023c28:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023c2b:	ff 45 f0             	incl   -0x10(%ebp)
c0023c2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023c31:	8b 40 04             	mov    0x4(%eax),%eax
c0023c34:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0023c37:	77 c8                	ja     c0023c01 <malloc+0x147>
        }
    }

  /* Get a block from free list and return it. */
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023c39:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023c3c:	83 c0 08             	add    $0x8,%eax
c0023c3f:	83 ec 0c             	sub    $0xc,%esp
c0023c42:	50                   	push   %eax
c0023c43:	e8 25 66 00 00       	call   c002a26d <list_pop_front>
c0023c48:	83 c4 10             	add    $0x10,%esp
c0023c4b:	83 c0 04             	add    $0x4,%eax
c0023c4e:	83 e8 04             	sub    $0x4,%eax
c0023c51:	89 45 e0             	mov    %eax,-0x20(%ebp)
  a = block_to_arena (b);
c0023c54:	83 ec 0c             	sub    $0xc,%esp
c0023c57:	ff 75 e0             	pushl  -0x20(%ebp)
c0023c5a:	e8 9c 02 00 00       	call   c0023efb <block_to_arena>
c0023c5f:	83 c4 10             	add    $0x10,%esp
c0023c62:	89 45 e8             	mov    %eax,-0x18(%ebp)
  a->free_cnt--;
c0023c65:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023c68:	8b 40 08             	mov    0x8(%eax),%eax
c0023c6b:	8d 50 ff             	lea    -0x1(%eax),%edx
c0023c6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023c71:	89 50 08             	mov    %edx,0x8(%eax)
  lock_release (&d->lock);
c0023c74:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023c77:	83 c0 18             	add    $0x18,%eax
c0023c7a:	83 ec 0c             	sub    $0xc,%esp
c0023c7d:	50                   	push   %eax
c0023c7e:	e8 96 f5 ff ff       	call   c0023219 <lock_release>
c0023c83:	83 c4 10             	add    $0x10,%esp
  return b;
c0023c86:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
c0023c89:	c9                   	leave  
c0023c8a:	c3                   	ret    

c0023c8b <calloc>:

/* Allocates and return A times B bytes initialized to zeroes.
   Returns a null pointer if memory is not available. */
void *
calloc (size_t a, size_t b) 
{
c0023c8b:	55                   	push   %ebp
c0023c8c:	89 e5                	mov    %esp,%ebp
c0023c8e:	83 ec 18             	sub    $0x18,%esp
  void *p;
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
c0023c91:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c94:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023c98:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (size < a || size < b)
c0023c9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023c9e:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023ca1:	72 08                	jb     c0023cab <calloc+0x20>
c0023ca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023ca6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023ca9:	73 07                	jae    c0023cb2 <calloc+0x27>
    return NULL;
c0023cab:	b8 00 00 00 00       	mov    $0x0,%eax
c0023cb0:	eb 2d                	jmp    c0023cdf <calloc+0x54>

  /* Allocate and zero memory. */
  p = malloc (size);
c0023cb2:	83 ec 0c             	sub    $0xc,%esp
c0023cb5:	ff 75 f4             	pushl  -0xc(%ebp)
c0023cb8:	e8 fd fd ff ff       	call   c0023aba <malloc>
c0023cbd:	83 c4 10             	add    $0x10,%esp
c0023cc0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (p != NULL)
c0023cc3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0023cc7:	74 13                	je     c0023cdc <calloc+0x51>
    memset (p, 0, size);
c0023cc9:	83 ec 04             	sub    $0x4,%esp
c0023ccc:	ff 75 f4             	pushl  -0xc(%ebp)
c0023ccf:	6a 00                	push   $0x0
c0023cd1:	ff 75 f0             	pushl  -0x10(%ebp)
c0023cd4:	e8 de 52 00 00       	call   c0028fb7 <memset>
c0023cd9:	83 c4 10             	add    $0x10,%esp

  return p;
c0023cdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0023cdf:	c9                   	leave  
c0023ce0:	c3                   	ret    

c0023ce1 <block_size>:

/* Returns the number of bytes allocated for BLOCK. */
static size_t
block_size (void *block) 
{
c0023ce1:	55                   	push   %ebp
c0023ce2:	89 e5                	mov    %esp,%ebp
c0023ce4:	53                   	push   %ebx
c0023ce5:	83 ec 14             	sub    $0x14,%esp
  struct block *b = block;
c0023ce8:	8b 45 08             	mov    0x8(%ebp),%eax
c0023ceb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct arena *a = block_to_arena (b);
c0023cee:	83 ec 0c             	sub    $0xc,%esp
c0023cf1:	ff 75 f4             	pushl  -0xc(%ebp)
c0023cf4:	e8 02 02 00 00       	call   c0023efb <block_to_arena>
c0023cf9:	83 c4 10             	add    $0x10,%esp
c0023cfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct desc *d = a->desc;
c0023cff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023d02:	8b 40 04             	mov    0x4(%eax),%eax
c0023d05:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023d08:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0023d0c:	74 07                	je     c0023d15 <block_size+0x34>
c0023d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023d11:	8b 00                	mov    (%eax),%eax
c0023d13:	eb 1d                	jmp    c0023d32 <block_size+0x51>
c0023d15:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023d18:	8b 40 08             	mov    0x8(%eax),%eax
c0023d1b:	c1 e0 0c             	shl    $0xc,%eax
c0023d1e:	89 c3                	mov    %eax,%ebx
c0023d20:	83 ec 0c             	sub    $0xc,%esp
c0023d23:	ff 75 08             	pushl  0x8(%ebp)
c0023d26:	e8 bf fc ff ff       	call   c00239ea <pg_ofs>
c0023d2b:	83 c4 10             	add    $0x10,%esp
c0023d2e:	29 c3                	sub    %eax,%ebx
c0023d30:	89 d8                	mov    %ebx,%eax
}
c0023d32:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023d35:	c9                   	leave  
c0023d36:	c3                   	ret    

c0023d37 <realloc>:
   null pointer.
   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).
   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */
void *
realloc (void *old_block, size_t new_size) 
{
c0023d37:	55                   	push   %ebp
c0023d38:	89 e5                	mov    %esp,%ebp
c0023d3a:	83 ec 18             	sub    $0x18,%esp
  if (new_size == 0) 
c0023d3d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023d41:	75 15                	jne    c0023d58 <realloc+0x21>
    {
      free (old_block);
c0023d43:	83 ec 0c             	sub    $0xc,%esp
c0023d46:	ff 75 08             	pushl  0x8(%ebp)
c0023d49:	e8 6e 00 00 00       	call   c0023dbc <free>
c0023d4e:	83 c4 10             	add    $0x10,%esp
      return NULL;
c0023d51:	b8 00 00 00 00       	mov    $0x0,%eax
c0023d56:	eb 62                	jmp    c0023dba <realloc+0x83>
    }
  else 
    {
      void *new_block = malloc (new_size);
c0023d58:	83 ec 0c             	sub    $0xc,%esp
c0023d5b:	ff 75 0c             	pushl  0xc(%ebp)
c0023d5e:	e8 57 fd ff ff       	call   c0023aba <malloc>
c0023d63:	83 c4 10             	add    $0x10,%esp
c0023d66:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (old_block != NULL && new_block != NULL)
c0023d69:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023d6d:	74 48                	je     c0023db7 <realloc+0x80>
c0023d6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023d73:	74 42                	je     c0023db7 <realloc+0x80>
        {
          size_t old_size = block_size (old_block);
c0023d75:	83 ec 0c             	sub    $0xc,%esp
c0023d78:	ff 75 08             	pushl  0x8(%ebp)
c0023d7b:	e8 61 ff ff ff       	call   c0023ce1 <block_size>
c0023d80:	83 c4 10             	add    $0x10,%esp
c0023d83:	89 45 f0             	mov    %eax,-0x10(%ebp)
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023d86:	8b 55 0c             	mov    0xc(%ebp),%edx
c0023d89:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023d8c:	39 d0                	cmp    %edx,%eax
c0023d8e:	76 02                	jbe    c0023d92 <realloc+0x5b>
c0023d90:	89 d0                	mov    %edx,%eax
c0023d92:	89 45 ec             	mov    %eax,-0x14(%ebp)
          memcpy (new_block, old_block, min_size);
c0023d95:	83 ec 04             	sub    $0x4,%esp
c0023d98:	ff 75 ec             	pushl  -0x14(%ebp)
c0023d9b:	ff 75 08             	pushl  0x8(%ebp)
c0023d9e:	ff 75 f4             	pushl  -0xc(%ebp)
c0023da1:	e8 37 4c 00 00       	call   c00289dd <memcpy>
c0023da6:	83 c4 10             	add    $0x10,%esp
          free (old_block);
c0023da9:	83 ec 0c             	sub    $0xc,%esp
c0023dac:	ff 75 08             	pushl  0x8(%ebp)
c0023daf:	e8 08 00 00 00       	call   c0023dbc <free>
c0023db4:	83 c4 10             	add    $0x10,%esp
        }
      return new_block;
c0023db7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c0023dba:	c9                   	leave  
c0023dbb:	c3                   	ret    

c0023dbc <free>:

/* Frees block P, which must have been previously allocated with
   malloc(), calloc(), or realloc(). */
void
free (void *p) 
{
c0023dbc:	55                   	push   %ebp
c0023dbd:	89 e5                	mov    %esp,%ebp
c0023dbf:	83 ec 28             	sub    $0x28,%esp
  if (p != NULL)
c0023dc2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023dc6:	0f 84 2d 01 00 00    	je     c0023ef9 <free+0x13d>
    {
      struct block *b = p;
c0023dcc:	8b 45 08             	mov    0x8(%ebp),%eax
c0023dcf:	89 45 f0             	mov    %eax,-0x10(%ebp)
      struct arena *a = block_to_arena (b);
c0023dd2:	83 ec 0c             	sub    $0xc,%esp
c0023dd5:	ff 75 f0             	pushl  -0x10(%ebp)
c0023dd8:	e8 1e 01 00 00       	call   c0023efb <block_to_arena>
c0023ddd:	83 c4 10             	add    $0x10,%esp
c0023de0:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct desc *d = a->desc;
c0023de3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023de6:	8b 40 04             	mov    0x4(%eax),%eax
c0023de9:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      if (d != NULL) 
c0023dec:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023df0:	0f 84 ed 00 00 00    	je     c0023ee3 <free+0x127>
        {
          /* It's a normal block.  We handle it here. */

#ifndef NDEBUG
          /* Clear the block to help detect use-after-free bugs. */
          memset (b, 0xcc, d->block_size);
c0023df6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023df9:	8b 00                	mov    (%eax),%eax
c0023dfb:	83 ec 04             	sub    $0x4,%esp
c0023dfe:	50                   	push   %eax
c0023dff:	68 cc 00 00 00       	push   $0xcc
c0023e04:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e07:	e8 ab 51 00 00       	call   c0028fb7 <memset>
c0023e0c:	83 c4 10             	add    $0x10,%esp
#endif
  
          lock_acquire (&d->lock);
c0023e0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023e12:	83 c0 18             	add    $0x18,%eax
c0023e15:	83 ec 0c             	sub    $0xc,%esp
c0023e18:	50                   	push   %eax
c0023e19:	e8 7d f2 ff ff       	call   c002309b <lock_acquire>
c0023e1e:	83 c4 10             	add    $0x10,%esp

          /* Add block to free list. */
          list_push_front (&d->free_list, &b->free_elem);
c0023e21:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023e24:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0023e27:	83 c2 08             	add    $0x8,%edx
c0023e2a:	83 ec 08             	sub    $0x8,%esp
c0023e2d:	50                   	push   %eax
c0023e2e:	52                   	push   %edx
c0023e2f:	e8 94 63 00 00       	call   c002a1c8 <list_push_front>
c0023e34:	83 c4 10             	add    $0x10,%esp

          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
c0023e37:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023e3a:	8b 40 08             	mov    0x8(%eax),%eax
c0023e3d:	8d 50 01             	lea    0x1(%eax),%edx
c0023e40:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023e43:	89 50 08             	mov    %edx,0x8(%eax)
c0023e46:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023e49:	8b 50 08             	mov    0x8(%eax),%edx
c0023e4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023e4f:	8b 40 04             	mov    0x4(%eax),%eax
c0023e52:	39 c2                	cmp    %eax,%edx
c0023e54:	72 79                	jb     c0023ecf <free+0x113>
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023e56:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023e59:	8b 50 08             	mov    0x8(%eax),%edx
c0023e5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023e5f:	8b 40 04             	mov    0x4(%eax),%eax
c0023e62:	39 c2                	cmp    %eax,%edx
c0023e64:	74 21                	je     c0023e87 <free+0xcb>
c0023e66:	83 ec 0c             	sub    $0xc,%esp
c0023e69:	68 a0 0e 03 c0       	push   $0xc0030ea0
c0023e6e:	68 71 0e 03 c0       	push   $0xc0030e71
c0023e73:	68 88 0f 03 c0       	push   $0xc0030f88
c0023e78:	68 f6 00 00 00       	push   $0xf6
c0023e7d:	68 88 0e 03 c0       	push   $0xc0030e88
c0023e82:	e8 16 5d 00 00       	call   c0029b9d <debug_panic>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023e87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023e8e:	eb 26                	jmp    c0023eb6 <free+0xfa>
                {
                  struct block *b = arena_to_block (a, i);
c0023e90:	83 ec 08             	sub    $0x8,%esp
c0023e93:	ff 75 f4             	pushl  -0xc(%ebp)
c0023e96:	ff 75 ec             	pushl  -0x14(%ebp)
c0023e99:	e8 5b 01 00 00       	call   c0023ff9 <arena_to_block>
c0023e9e:	83 c4 10             	add    $0x10,%esp
c0023ea1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  list_remove (&b->free_elem);
c0023ea4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023ea7:	83 ec 0c             	sub    $0xc,%esp
c0023eaa:	50                   	push   %eax
c0023eab:	e8 64 63 00 00       	call   c002a214 <list_remove>
c0023eb0:	83 c4 10             	add    $0x10,%esp
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023eb3:	ff 45 f4             	incl   -0xc(%ebp)
c0023eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023eb9:	8b 40 04             	mov    0x4(%eax),%eax
c0023ebc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023ebf:	77 cf                	ja     c0023e90 <free+0xd4>
                }
              palloc_free_page (a);
c0023ec1:	83 ec 0c             	sub    $0xc,%esp
c0023ec4:	ff 75 ec             	pushl  -0x14(%ebp)
c0023ec7:	e8 fb f9 ff ff       	call   c00238c7 <palloc_free_page>
c0023ecc:	83 c4 10             	add    $0x10,%esp
            }

          lock_release (&d->lock);
c0023ecf:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023ed2:	83 c0 18             	add    $0x18,%eax
c0023ed5:	83 ec 0c             	sub    $0xc,%esp
c0023ed8:	50                   	push   %eax
c0023ed9:	e8 3b f3 ff ff       	call   c0023219 <lock_release>
c0023ede:	83 c4 10             	add    $0x10,%esp
c0023ee1:	eb 16                	jmp    c0023ef9 <free+0x13d>
        }
      else
        {
          /* It's a big block.  Free its pages. */
          palloc_free_multiple (a, a->free_cnt);
c0023ee3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023ee6:	8b 40 08             	mov    0x8(%eax),%eax
c0023ee9:	83 ec 08             	sub    $0x8,%esp
c0023eec:	50                   	push   %eax
c0023eed:	ff 75 ec             	pushl  -0x14(%ebp)
c0023ef0:	e8 92 f8 ff ff       	call   c0023787 <palloc_free_multiple>
c0023ef5:	83 c4 10             	add    $0x10,%esp
          return;
c0023ef8:	90                   	nop
        }
    }
}
c0023ef9:	c9                   	leave  
c0023efa:	c3                   	ret    

c0023efb <block_to_arena>:

/* Returns the arena that block B is inside. */
static struct arena *
block_to_arena (struct block *b)
{
c0023efb:	55                   	push   %ebp
c0023efc:	89 e5                	mov    %esp,%ebp
c0023efe:	83 ec 18             	sub    $0x18,%esp
  struct arena *a = pg_round_down (b);
c0023f01:	ff 75 08             	pushl  0x8(%ebp)
c0023f04:	e8 ee fa ff ff       	call   c00239f7 <pg_round_down>
c0023f09:	83 c4 04             	add    $0x4,%esp
c0023f0c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Check that the arena is valid. */
  ASSERT (a != NULL);
c0023f0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023f13:	75 21                	jne    c0023f36 <block_to_arena+0x3b>
c0023f15:	83 ec 0c             	sub    $0xc,%esp
c0023f18:	68 c3 0e 03 c0       	push   $0xc0030ec3
c0023f1d:	68 71 0e 03 c0       	push   $0xc0030e71
c0023f22:	68 90 0f 03 c0       	push   $0xc0030f90
c0023f27:	68 11 01 00 00       	push   $0x111
c0023f2c:	68 88 0e 03 c0       	push   $0xc0030e88
c0023f31:	e8 67 5c 00 00       	call   c0029b9d <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023f36:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023f39:	8b 00                	mov    (%eax),%eax
c0023f3b:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0023f40:	74 21                	je     c0023f63 <block_to_arena+0x68>
c0023f42:	83 ec 0c             	sub    $0xc,%esp
c0023f45:	68 cd 0e 03 c0       	push   $0xc0030ecd
c0023f4a:	68 71 0e 03 c0       	push   $0xc0030e71
c0023f4f:	68 90 0f 03 c0       	push   $0xc0030f90
c0023f54:	68 12 01 00 00       	push   $0x112
c0023f59:	68 88 0e 03 c0       	push   $0xc0030e88
c0023f5e:	e8 3a 5c 00 00       	call   c0029b9d <debug_panic>

  /* Check that the block is properly aligned for the arena. */
  ASSERT (a->desc == NULL
c0023f63:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023f66:	8b 40 04             	mov    0x4(%eax),%eax
c0023f69:	85 c0                	test   %eax,%eax
c0023f6b:	74 49                	je     c0023fb6 <block_to_arena+0xbb>
c0023f6d:	83 ec 0c             	sub    $0xc,%esp
c0023f70:	ff 75 08             	pushl  0x8(%ebp)
c0023f73:	e8 72 fa ff ff       	call   c00239ea <pg_ofs>
c0023f78:	83 c4 10             	add    $0x10,%esp
c0023f7b:	8d 50 f4             	lea    -0xc(%eax),%edx
c0023f7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023f81:	8b 40 04             	mov    0x4(%eax),%eax
c0023f84:	8b 08                	mov    (%eax),%ecx
c0023f86:	89 d0                	mov    %edx,%eax
c0023f88:	ba 00 00 00 00       	mov    $0x0,%edx
c0023f8d:	f7 f1                	div    %ecx
c0023f8f:	89 d0                	mov    %edx,%eax
c0023f91:	85 c0                	test   %eax,%eax
c0023f93:	74 21                	je     c0023fb6 <block_to_arena+0xbb>
c0023f95:	83 ec 0c             	sub    $0xc,%esp
c0023f98:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0023f9d:	68 71 0e 03 c0       	push   $0xc0030e71
c0023fa2:	68 90 0f 03 c0       	push   $0xc0030f90
c0023fa7:	68 16 01 00 00       	push   $0x116
c0023fac:	68 88 0e 03 c0       	push   $0xc0030e88
c0023fb1:	e8 e7 5b 00 00       	call   c0029b9d <debug_panic>
          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c0023fb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023fb9:	8b 40 04             	mov    0x4(%eax),%eax
c0023fbc:	85 c0                	test   %eax,%eax
c0023fbe:	75 34                	jne    c0023ff4 <block_to_arena+0xf9>
c0023fc0:	83 ec 0c             	sub    $0xc,%esp
c0023fc3:	ff 75 08             	pushl  0x8(%ebp)
c0023fc6:	e8 1f fa ff ff       	call   c00239ea <pg_ofs>
c0023fcb:	83 c4 10             	add    $0x10,%esp
c0023fce:	83 f8 0c             	cmp    $0xc,%eax
c0023fd1:	74 21                	je     c0023ff4 <block_to_arena+0xf9>
c0023fd3:	83 ec 0c             	sub    $0xc,%esp
c0023fd6:	68 30 0f 03 c0       	push   $0xc0030f30
c0023fdb:	68 71 0e 03 c0       	push   $0xc0030e71
c0023fe0:	68 90 0f 03 c0       	push   $0xc0030f90
c0023fe5:	68 17 01 00 00       	push   $0x117
c0023fea:	68 88 0e 03 c0       	push   $0xc0030e88
c0023fef:	e8 a9 5b 00 00       	call   c0029b9d <debug_panic>

  return a;
c0023ff4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0023ff7:	c9                   	leave  
c0023ff8:	c3                   	ret    

c0023ff9 <arena_to_block>:

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c0023ff9:	55                   	push   %ebp
c0023ffa:	89 e5                	mov    %esp,%ebp
c0023ffc:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0023fff:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0024003:	75 21                	jne    c0024026 <arena_to_block+0x2d>
c0024005:	83 ec 0c             	sub    $0xc,%esp
c0024008:	68 c3 0e 03 c0       	push   $0xc0030ec3
c002400d:	68 71 0e 03 c0       	push   $0xc0030e71
c0024012:	68 a0 0f 03 c0       	push   $0xc0030fa0
c0024017:	68 20 01 00 00       	push   $0x120
c002401c:	68 88 0e 03 c0       	push   $0xc0030e88
c0024021:	e8 77 5b 00 00       	call   c0029b9d <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0024026:	8b 45 08             	mov    0x8(%ebp),%eax
c0024029:	8b 00                	mov    (%eax),%eax
c002402b:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0024030:	74 21                	je     c0024053 <arena_to_block+0x5a>
c0024032:	83 ec 0c             	sub    $0xc,%esp
c0024035:	68 cd 0e 03 c0       	push   $0xc0030ecd
c002403a:	68 71 0e 03 c0       	push   $0xc0030e71
c002403f:	68 a0 0f 03 c0       	push   $0xc0030fa0
c0024044:	68 21 01 00 00       	push   $0x121
c0024049:	68 88 0e 03 c0       	push   $0xc0030e88
c002404e:	e8 4a 5b 00 00       	call   c0029b9d <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c0024053:	8b 45 08             	mov    0x8(%ebp),%eax
c0024056:	8b 40 04             	mov    0x4(%eax),%eax
c0024059:	8b 40 04             	mov    0x4(%eax),%eax
c002405c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002405f:	77 21                	ja     c0024082 <arena_to_block+0x89>
c0024061:	83 ec 0c             	sub    $0xc,%esp
c0024064:	68 5c 0f 03 c0       	push   $0xc0030f5c
c0024069:	68 71 0e 03 c0       	push   $0xc0030e71
c002406e:	68 a0 0f 03 c0       	push   $0xc0030fa0
c0024073:	68 22 01 00 00       	push   $0x122
c0024078:	68 88 0e 03 c0       	push   $0xc0030e88
c002407d:	e8 1b 5b 00 00       	call   c0029b9d <debug_panic>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0024082:	8b 45 08             	mov    0x8(%ebp),%eax
c0024085:	8b 40 04             	mov    0x4(%eax),%eax
c0024088:	8b 00                	mov    (%eax),%eax
c002408a:	0f af 45 0c          	imul   0xc(%ebp),%eax
c002408e:	8d 50 0c             	lea    0xc(%eax),%edx
  return (struct block *) ((uint8_t *) a
c0024091:	8b 45 08             	mov    0x8(%ebp),%eax
c0024094:	01 d0                	add    %edx,%eax
}
c0024096:	c9                   	leave  
c0024097:	c3                   	ret    

c0024098 <outb>:
{
c0024098:	55                   	push   %ebp
c0024099:	89 e5                	mov    %esp,%ebp
c002409b:	83 ec 08             	sub    $0x8,%esp
c002409e:	8b 45 08             	mov    0x8(%ebp),%eax
c00240a1:	8b 55 0c             	mov    0xc(%ebp),%edx
c00240a4:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00240a8:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00240ab:	8a 45 f8             	mov    -0x8(%ebp),%al
c00240ae:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00240b1:	ee                   	out    %al,(%dx)
}
c00240b2:	90                   	nop
c00240b3:	c9                   	leave  
c00240b4:	c3                   	ret    

c00240b5 <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c00240b5:	55                   	push   %ebp
c00240b6:	89 e5                	mov    %esp,%ebp
c00240b8:	83 ec 18             	sub    $0x18,%esp
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c00240bb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00240bf:	74 24                	je     c00240e5 <pit_configure_channel+0x30>
c00240c1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c00240c5:	74 1e                	je     c00240e5 <pit_configure_channel+0x30>
c00240c7:	83 ec 0c             	sub    $0xc,%esp
c00240ca:	68 b0 0f 03 c0       	push   $0xc0030fb0
c00240cf:	68 cd 0f 03 c0       	push   $0xc0030fcd
c00240d4:	68 10 10 03 c0       	push   $0xc0031010
c00240d9:	6a 33                	push   $0x33
c00240db:	68 e4 0f 03 c0       	push   $0xc0030fe4
c00240e0:	e8 b8 5a 00 00       	call   c0029b9d <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c00240e5:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c00240e9:	74 24                	je     c002410f <pit_configure_channel+0x5a>
c00240eb:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c00240ef:	74 1e                	je     c002410f <pit_configure_channel+0x5a>
c00240f1:	83 ec 0c             	sub    $0xc,%esp
c00240f4:	68 f8 0f 03 c0       	push   $0xc0030ff8
c00240f9:	68 cd 0f 03 c0       	push   $0xc0030fcd
c00240fe:	68 10 10 03 c0       	push   $0xc0031010
c0024103:	6a 34                	push   $0x34
c0024105:	68 e4 0f 03 c0       	push   $0xc0030fe4
c002410a:	e8 8e 5a 00 00       	call   c0029b9d <debug_panic>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c002410f:	83 7d 10 12          	cmpl   $0x12,0x10(%ebp)
c0024113:	7f 08                	jg     c002411d <pit_configure_channel+0x68>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0024115:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c002411b:	eb 2a                	jmp    c0024147 <pit_configure_channel+0x92>
    }
  else if (frequency > PIT_HZ)
c002411d:	81 7d 10 dc 34 12 00 	cmpl   $0x1234dc,0x10(%ebp)
c0024124:	7e 08                	jle    c002412e <pit_configure_channel+0x79>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c0024126:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
c002412c:	eb 19                	jmp    c0024147 <pit_configure_channel+0x92>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c002412e:	8b 45 10             	mov    0x10(%ebp),%eax
c0024131:	89 c2                	mov    %eax,%edx
c0024133:	c1 ea 1f             	shr    $0x1f,%edx
c0024136:	01 d0                	add    %edx,%eax
c0024138:	d1 f8                	sar    %eax
c002413a:	05 dc 34 12 00       	add    $0x1234dc,%eax
c002413f:	99                   	cltd   
c0024140:	f7 7d 10             	idivl  0x10(%ebp)
c0024143:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0024147:	e8 4b d8 ff ff       	call   c0021997 <intr_disable>
c002414c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c002414f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024152:	c1 e0 06             	shl    $0x6,%eax
c0024155:	83 c8 30             	or     $0x30,%eax
c0024158:	88 c2                	mov    %al,%dl
c002415a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002415d:	01 c0                	add    %eax,%eax
c002415f:	09 d0                	or     %edx,%eax
c0024161:	0f b6 c0             	movzbl %al,%eax
c0024164:	83 ec 08             	sub    $0x8,%esp
c0024167:	50                   	push   %eax
c0024168:	6a 43                	push   $0x43
c002416a:	e8 29 ff ff ff       	call   c0024098 <outb>
c002416f:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count);
c0024172:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c0024176:	0f b6 d0             	movzbl %al,%edx
c0024179:	8b 45 08             	mov    0x8(%ebp),%eax
c002417c:	83 c0 40             	add    $0x40,%eax
c002417f:	0f b7 c0             	movzwl %ax,%eax
c0024182:	83 ec 08             	sub    $0x8,%esp
c0024185:	52                   	push   %edx
c0024186:	50                   	push   %eax
c0024187:	e8 0c ff ff ff       	call   c0024098 <outb>
c002418c:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c002418f:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c0024193:	66 c1 e8 08          	shr    $0x8,%ax
c0024197:	0f b6 d0             	movzbl %al,%edx
c002419a:	8b 45 08             	mov    0x8(%ebp),%eax
c002419d:	83 c0 40             	add    $0x40,%eax
c00241a0:	0f b7 c0             	movzwl %ax,%eax
c00241a3:	83 ec 08             	sub    $0x8,%esp
c00241a6:	52                   	push   %edx
c00241a7:	50                   	push   %eax
c00241a8:	e8 eb fe ff ff       	call   c0024098 <outb>
c00241ad:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c00241b0:	83 ec 0c             	sub    $0xc,%esp
c00241b3:	ff 75 f0             	pushl  -0x10(%ebp)
c00241b6:	e8 84 d7 ff ff       	call   c002193f <intr_set_level>
c00241bb:	83 c4 10             	add    $0x10,%esp
}
c00241be:	90                   	nop
c00241bf:	c9                   	leave  
c00241c0:	c3                   	ret    

c00241c1 <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c00241c1:	55                   	push   %ebp
c00241c2:	89 e5                	mov    %esp,%ebp
c00241c4:	83 ec 08             	sub    $0x8,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c00241c7:	83 ec 04             	sub    $0x4,%esp
c00241ca:	6a 64                	push   $0x64
c00241cc:	6a 02                	push   $0x2
c00241ce:	6a 00                	push   $0x0
c00241d0:	e8 e0 fe ff ff       	call   c00240b5 <pit_configure_channel>
c00241d5:	83 c4 10             	add    $0x10,%esp
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c00241d8:	83 ec 04             	sub    $0x4,%esp
c00241db:	68 28 10 03 c0       	push   $0xc0031028
c00241e0:	68 e8 44 02 c0       	push   $0xc00244e8
c00241e5:	6a 20                	push   $0x20
c00241e7:	e8 ca d9 ff ff       	call   c0021bb6 <intr_register_ext>
c00241ec:	83 c4 10             	add    $0x10,%esp
}
c00241ef:	90                   	nop
c00241f0:	c9                   	leave  
c00241f1:	c3                   	ret    

c00241f2 <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c00241f2:	55                   	push   %ebp
c00241f3:	89 e5                	mov    %esp,%ebp
c00241f5:	53                   	push   %ebx
c00241f6:	83 ec 14             	sub    $0x14,%esp
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c00241f9:	e8 24 d7 ff ff       	call   c0021922 <intr_get_level>
c00241fe:	83 f8 01             	cmp    $0x1,%eax
c0024201:	74 1e                	je     c0024221 <timer_calibrate+0x2f>
c0024203:	83 ec 0c             	sub    $0xc,%esp
c0024206:	68 33 10 03 c0       	push   $0xc0031033
c002420b:	68 50 10 03 c0       	push   $0xc0031050
c0024210:	68 e0 10 03 c0       	push   $0xc00310e0
c0024215:	6a 30                	push   $0x30
c0024217:	68 67 10 03 c0       	push   $0xc0031067
c002421c:	e8 7c 59 00 00       	call   c0029b9d <debug_panic>
  printf ("Calibrating timer...  ");
c0024221:	83 ec 0c             	sub    $0xc,%esp
c0024224:	68 7d 10 03 c0       	push   $0xc003107d
c0024229:	e8 b0 35 00 00       	call   c00277de <printf>
c002422e:	83 c4 10             	add    $0x10,%esp

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c0024231:	c7 05 c0 a2 03 c0 00 	movl   $0x400,0xc003a2c0
c0024238:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c002423b:	eb 33                	jmp    c0024270 <timer_calibrate+0x7e>
    {
      loops_per_tick <<= 1;
c002423d:	a1 c0 a2 03 c0       	mov    0xc003a2c0,%eax
c0024242:	01 c0                	add    %eax,%eax
c0024244:	a3 c0 a2 03 c0       	mov    %eax,0xc003a2c0
      ASSERT (loops_per_tick != 0);
c0024249:	a1 c0 a2 03 c0       	mov    0xc003a2c0,%eax
c002424e:	85 c0                	test   %eax,%eax
c0024250:	75 1e                	jne    c0024270 <timer_calibrate+0x7e>
c0024252:	83 ec 0c             	sub    $0xc,%esp
c0024255:	68 94 10 03 c0       	push   $0xc0031094
c002425a:	68 50 10 03 c0       	push   $0xc0031050
c002425f:	68 e0 10 03 c0       	push   $0xc00310e0
c0024264:	6a 39                	push   $0x39
c0024266:	68 67 10 03 c0       	push   $0xc0031067
c002426b:	e8 2d 59 00 00       	call   c0029b9d <debug_panic>
  while (!too_many_loops (loops_per_tick << 1)) 
c0024270:	a1 c0 a2 03 c0       	mov    0xc003a2c0,%eax
c0024275:	01 c0                	add    %eax,%eax
c0024277:	83 ec 0c             	sub    $0xc,%esp
c002427a:	50                   	push   %eax
c002427b:	e8 92 02 00 00       	call   c0024512 <too_many_loops>
c0024280:	83 c4 10             	add    $0x10,%esp
c0024283:	83 f0 01             	xor    $0x1,%eax
c0024286:	84 c0                	test   %al,%al
c0024288:	75 b3                	jne    c002423d <timer_calibrate+0x4b>
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
c002428a:	a1 c0 a2 03 c0       	mov    0xc003a2c0,%eax
c002428f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0024292:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024295:	d1 e8                	shr    %eax
c0024297:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002429a:	eb 29                	jmp    c00242c5 <timer_calibrate+0xd3>
    if (!too_many_loops (high_bit | test_bit))
c002429c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002429f:	0b 45 f4             	or     -0xc(%ebp),%eax
c00242a2:	83 ec 0c             	sub    $0xc,%esp
c00242a5:	50                   	push   %eax
c00242a6:	e8 67 02 00 00       	call   c0024512 <too_many_loops>
c00242ab:	83 c4 10             	add    $0x10,%esp
c00242ae:	83 f0 01             	xor    $0x1,%eax
c00242b1:	84 c0                	test   %al,%al
c00242b3:	74 0d                	je     c00242c2 <timer_calibrate+0xd0>
      loops_per_tick |= test_bit;
c00242b5:	a1 c0 a2 03 c0       	mov    0xc003a2c0,%eax
c00242ba:	0b 45 f4             	or     -0xc(%ebp),%eax
c00242bd:	a3 c0 a2 03 c0       	mov    %eax,0xc003a2c0
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c00242c2:	d1 6d f4             	shrl   -0xc(%ebp)
c00242c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00242c8:	c1 e8 0a             	shr    $0xa,%eax
c00242cb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00242ce:	75 cc                	jne    c002429c <timer_calibrate+0xaa>

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c00242d0:	a1 c0 a2 03 c0       	mov    0xc003a2c0,%eax
c00242d5:	ba 00 00 00 00       	mov    $0x0,%edx
c00242da:	6b da 64             	imul   $0x64,%edx,%ebx
c00242dd:	6b c8 00             	imul   $0x0,%eax,%ecx
c00242e0:	01 d9                	add    %ebx,%ecx
c00242e2:	bb 64 00 00 00       	mov    $0x64,%ebx
c00242e7:	f7 e3                	mul    %ebx
c00242e9:	01 d1                	add    %edx,%ecx
c00242eb:	89 ca                	mov    %ecx,%edx
c00242ed:	83 ec 04             	sub    $0x4,%esp
c00242f0:	52                   	push   %edx
c00242f1:	50                   	push   %eax
c00242f2:	68 a8 10 03 c0       	push   $0xc00310a8
c00242f7:	e8 e2 34 00 00       	call   c00277de <printf>
c00242fc:	83 c4 10             	add    $0x10,%esp
}
c00242ff:	90                   	nop
c0024300:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024303:	c9                   	leave  
c0024304:	c3                   	ret    

c0024305 <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c0024305:	55                   	push   %ebp
c0024306:	89 e5                	mov    %esp,%ebp
c0024308:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c002430b:	e8 87 d6 ff ff       	call   c0021997 <intr_disable>
c0024310:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t t = ticks;
c0024313:	a1 b8 a2 03 c0       	mov    0xc003a2b8,%eax
c0024318:	8b 15 bc a2 03 c0    	mov    0xc003a2bc,%edx
c002431e:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0024321:	89 55 ec             	mov    %edx,-0x14(%ebp)
  intr_set_level (old_level);
c0024324:	83 ec 0c             	sub    $0xc,%esp
c0024327:	ff 75 f4             	pushl  -0xc(%ebp)
c002432a:	e8 10 d6 ff ff       	call   c002193f <intr_set_level>
c002432f:	83 c4 10             	add    $0x10,%esp
  return t;
c0024332:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0024335:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
c0024338:	c9                   	leave  
c0024339:	c3                   	ret    

c002433a <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c002433a:	55                   	push   %ebp
c002433b:	89 e5                	mov    %esp,%ebp
c002433d:	83 ec 18             	sub    $0x18,%esp
c0024340:	8b 45 08             	mov    0x8(%ebp),%eax
c0024343:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024346:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024349:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return timer_ticks () - then;
c002434c:	e8 b4 ff ff ff       	call   c0024305 <timer_ticks>
c0024351:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0024354:	1b 55 f4             	sbb    -0xc(%ebp),%edx
}
c0024357:	c9                   	leave  
c0024358:	c3                   	ret    

c0024359 <timer_sleep>:

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{
c0024359:	55                   	push   %ebp
c002435a:	89 e5                	mov    %esp,%ebp
c002435c:	83 ec 28             	sub    $0x28,%esp
c002435f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024362:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0024365:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024368:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  int64_t start = timer_ticks ();
c002436b:	e8 95 ff ff ff       	call   c0024305 <timer_ticks>
c0024370:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024373:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c0024376:	e8 a7 d5 ff ff       	call   c0021922 <intr_get_level>
c002437b:	83 f8 01             	cmp    $0x1,%eax
c002437e:	74 23                	je     c00243a3 <timer_sleep+0x4a>
c0024380:	83 ec 0c             	sub    $0xc,%esp
c0024383:	68 33 10 03 c0       	push   $0xc0031033
c0024388:	68 50 10 03 c0       	push   $0xc0031050
c002438d:	68 f0 10 03 c0       	push   $0xc00310f0
c0024392:	6a 5e                	push   $0x5e
c0024394:	68 67 10 03 c0       	push   $0xc0031067
c0024399:	e8 ff 57 00 00       	call   c0029b9d <debug_panic>
  while (timer_elapsed (start) < ticks) 
    thread_yield ();
c002439e:	e8 87 ce ff ff       	call   c002122a <thread_yield>
  while (timer_elapsed (start) < ticks) 
c00243a3:	83 ec 08             	sub    $0x8,%esp
c00243a6:	ff 75 f4             	pushl  -0xc(%ebp)
c00243a9:	ff 75 f0             	pushl  -0x10(%ebp)
c00243ac:	e8 89 ff ff ff       	call   c002433a <timer_elapsed>
c00243b1:	83 c4 10             	add    $0x10,%esp
c00243b4:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c00243b7:	7c e5                	jl     c002439e <timer_sleep+0x45>
c00243b9:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c00243bc:	7f 05                	jg     c00243c3 <timer_sleep+0x6a>
c00243be:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c00243c1:	72 db                	jb     c002439e <timer_sleep+0x45>
}
c00243c3:	90                   	nop
c00243c4:	c9                   	leave  
c00243c5:	c3                   	ret    

c00243c6 <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c00243c6:	55                   	push   %ebp
c00243c7:	89 e5                	mov    %esp,%ebp
c00243c9:	83 ec 18             	sub    $0x18,%esp
c00243cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00243cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00243d2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00243d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ms, 1000);
c00243d8:	83 ec 04             	sub    $0x4,%esp
c00243db:	68 e8 03 00 00       	push   $0x3e8
c00243e0:	ff 75 f4             	pushl  -0xc(%ebp)
c00243e3:	ff 75 f0             	pushl  -0x10(%ebp)
c00243e6:	e8 f9 01 00 00       	call   c00245e4 <real_time_sleep>
c00243eb:	83 c4 10             	add    $0x10,%esp
}
c00243ee:	90                   	nop
c00243ef:	c9                   	leave  
c00243f0:	c3                   	ret    

c00243f1 <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c00243f1:	55                   	push   %ebp
c00243f2:	89 e5                	mov    %esp,%ebp
c00243f4:	83 ec 18             	sub    $0x18,%esp
c00243f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00243fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00243fd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024400:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (us, 1000 * 1000);
c0024403:	83 ec 04             	sub    $0x4,%esp
c0024406:	68 40 42 0f 00       	push   $0xf4240
c002440b:	ff 75 f4             	pushl  -0xc(%ebp)
c002440e:	ff 75 f0             	pushl  -0x10(%ebp)
c0024411:	e8 ce 01 00 00       	call   c00245e4 <real_time_sleep>
c0024416:	83 c4 10             	add    $0x10,%esp
}
c0024419:	90                   	nop
c002441a:	c9                   	leave  
c002441b:	c3                   	ret    

c002441c <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c002441c:	55                   	push   %ebp
c002441d:	89 e5                	mov    %esp,%ebp
c002441f:	83 ec 18             	sub    $0x18,%esp
c0024422:	8b 45 08             	mov    0x8(%ebp),%eax
c0024425:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024428:	8b 45 0c             	mov    0xc(%ebp),%eax
c002442b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ns, 1000 * 1000 * 1000);
c002442e:	83 ec 04             	sub    $0x4,%esp
c0024431:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0024436:	ff 75 f4             	pushl  -0xc(%ebp)
c0024439:	ff 75 f0             	pushl  -0x10(%ebp)
c002443c:	e8 a3 01 00 00       	call   c00245e4 <real_time_sleep>
c0024441:	83 c4 10             	add    $0x10,%esp
}
c0024444:	90                   	nop
c0024445:	c9                   	leave  
c0024446:	c3                   	ret    

c0024447 <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c0024447:	55                   	push   %ebp
c0024448:	89 e5                	mov    %esp,%ebp
c002444a:	83 ec 18             	sub    $0x18,%esp
c002444d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024450:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024453:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024456:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ms, 1000);
c0024459:	83 ec 04             	sub    $0x4,%esp
c002445c:	68 e8 03 00 00       	push   $0x3e8
c0024461:	ff 75 f4             	pushl  -0xc(%ebp)
c0024464:	ff 75 f0             	pushl  -0x10(%ebp)
c0024467:	e8 2a 02 00 00       	call   c0024696 <real_time_delay>
c002446c:	83 c4 10             	add    $0x10,%esp
}
c002446f:	90                   	nop
c0024470:	c9                   	leave  
c0024471:	c3                   	ret    

c0024472 <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c0024472:	55                   	push   %ebp
c0024473:	89 e5                	mov    %esp,%ebp
c0024475:	83 ec 18             	sub    $0x18,%esp
c0024478:	8b 45 08             	mov    0x8(%ebp),%eax
c002447b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002447e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024481:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (us, 1000 * 1000);
c0024484:	83 ec 04             	sub    $0x4,%esp
c0024487:	68 40 42 0f 00       	push   $0xf4240
c002448c:	ff 75 f4             	pushl  -0xc(%ebp)
c002448f:	ff 75 f0             	pushl  -0x10(%ebp)
c0024492:	e8 ff 01 00 00       	call   c0024696 <real_time_delay>
c0024497:	83 c4 10             	add    $0x10,%esp
}
c002449a:	90                   	nop
c002449b:	c9                   	leave  
c002449c:	c3                   	ret    

c002449d <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c002449d:	55                   	push   %ebp
c002449e:	89 e5                	mov    %esp,%ebp
c00244a0:	83 ec 18             	sub    $0x18,%esp
c00244a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00244a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00244a9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00244ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ns, 1000 * 1000 * 1000);
c00244af:	83 ec 04             	sub    $0x4,%esp
c00244b2:	68 00 ca 9a 3b       	push   $0x3b9aca00
c00244b7:	ff 75 f4             	pushl  -0xc(%ebp)
c00244ba:	ff 75 f0             	pushl  -0x10(%ebp)
c00244bd:	e8 d4 01 00 00       	call   c0024696 <real_time_delay>
c00244c2:	83 c4 10             	add    $0x10,%esp
}
c00244c5:	90                   	nop
c00244c6:	c9                   	leave  
c00244c7:	c3                   	ret    

c00244c8 <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c00244c8:	55                   	push   %ebp
c00244c9:	89 e5                	mov    %esp,%ebp
c00244cb:	83 ec 08             	sub    $0x8,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c00244ce:	e8 32 fe ff ff       	call   c0024305 <timer_ticks>
c00244d3:	83 ec 04             	sub    $0x4,%esp
c00244d6:	52                   	push   %edx
c00244d7:	50                   	push   %eax
c00244d8:	68 b8 10 03 c0       	push   $0xc00310b8
c00244dd:	e8 fc 32 00 00       	call   c00277de <printf>
c00244e2:	83 c4 10             	add    $0x10,%esp
}
c00244e5:	90                   	nop
c00244e6:	c9                   	leave  
c00244e7:	c3                   	ret    

c00244e8 <timer_interrupt>:

/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
c00244e8:	55                   	push   %ebp
c00244e9:	89 e5                	mov    %esp,%ebp
c00244eb:	83 ec 08             	sub    $0x8,%esp
  ticks++;
c00244ee:	a1 b8 a2 03 c0       	mov    0xc003a2b8,%eax
c00244f3:	8b 15 bc a2 03 c0    	mov    0xc003a2bc,%edx
c00244f9:	83 c0 01             	add    $0x1,%eax
c00244fc:	83 d2 00             	adc    $0x0,%edx
c00244ff:	a3 b8 a2 03 c0       	mov    %eax,0xc003a2b8
c0024504:	89 15 bc a2 03 c0    	mov    %edx,0xc003a2bc
  thread_tick ();
c002450a:	e8 6c c8 ff ff       	call   c0020d7b <thread_tick>
}
c002450f:	90                   	nop
c0024510:	c9                   	leave  
c0024511:	c3                   	ret    

c0024512 <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c0024512:	55                   	push   %ebp
c0024513:	89 e5                	mov    %esp,%ebp
c0024515:	56                   	push   %esi
c0024516:	53                   	push   %ebx
c0024517:	83 ec 20             	sub    $0x20,%esp
  /* Wait for a timer tick. */
  int64_t start = ticks;
c002451a:	a1 b8 a2 03 c0       	mov    0xc003a2b8,%eax
c002451f:	8b 15 bc a2 03 c0    	mov    0xc003a2bc,%edx
c0024525:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024528:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (ticks == start)
c002452b:	eb 00                	jmp    c002452d <too_many_loops+0x1b>
c002452d:	a1 b8 a2 03 c0       	mov    0xc003a2b8,%eax
c0024532:	8b 15 bc a2 03 c0    	mov    0xc003a2bc,%edx
c0024538:	89 c1                	mov    %eax,%ecx
c002453a:	33 4d f0             	xor    -0x10(%ebp),%ecx
c002453d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c0024540:	89 d0                	mov    %edx,%eax
c0024542:	33 45 f4             	xor    -0xc(%ebp),%eax
c0024545:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0024548:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002454b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002454e:	89 c8                	mov    %ecx,%eax
c0024550:	09 d0                	or     %edx,%eax
c0024552:	85 c0                	test   %eax,%eax
c0024554:	74 d7                	je     c002452d <too_many_loops+0x1b>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
c0024556:	a1 b8 a2 03 c0       	mov    0xc003a2b8,%eax
c002455b:	8b 15 bc a2 03 c0    	mov    0xc003a2bc,%edx
c0024561:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024564:	89 55 f4             	mov    %edx,-0xc(%ebp)
  busy_wait (loops);
c0024567:	8b 45 08             	mov    0x8(%ebp),%eax
c002456a:	ba 00 00 00 00       	mov    $0x0,%edx
c002456f:	83 ec 08             	sub    $0x8,%esp
c0024572:	52                   	push   %edx
c0024573:	50                   	push   %eax
c0024574:	e8 2c 00 00 00       	call   c00245a5 <busy_wait>
c0024579:	83 c4 10             	add    $0x10,%esp

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c002457c:	a1 b8 a2 03 c0       	mov    0xc003a2b8,%eax
c0024581:	8b 15 bc a2 03 c0    	mov    0xc003a2bc,%edx
c0024587:	89 c1                	mov    %eax,%ecx
c0024589:	33 4d f0             	xor    -0x10(%ebp),%ecx
c002458c:	89 cb                	mov    %ecx,%ebx
c002458e:	89 d0                	mov    %edx,%eax
c0024590:	33 45 f4             	xor    -0xc(%ebp),%eax
c0024593:	89 c6                	mov    %eax,%esi
c0024595:	89 d8                	mov    %ebx,%eax
c0024597:	09 f0                	or     %esi,%eax
c0024599:	85 c0                	test   %eax,%eax
c002459b:	0f 95 c0             	setne  %al
}
c002459e:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00245a1:	5b                   	pop    %ebx
c00245a2:	5e                   	pop    %esi
c00245a3:	5d                   	pop    %ebp
c00245a4:	c3                   	ret    

c00245a5 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c00245a5:	55                   	push   %ebp
c00245a6:	89 e5                	mov    %esp,%ebp
c00245a8:	53                   	push   %ebx
c00245a9:	83 ec 0c             	sub    $0xc,%esp
c00245ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00245af:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00245b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00245b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (loops-- > 0)
c00245b8:	eb 00                	jmp    c00245ba <busy_wait+0x15>
c00245ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00245bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00245c0:	89 c1                	mov    %eax,%ecx
c00245c2:	89 d3                	mov    %edx,%ebx
c00245c4:	83 c1 ff             	add    $0xffffffff,%ecx
c00245c7:	83 d3 ff             	adc    $0xffffffff,%ebx
c00245ca:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c00245cd:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c00245d0:	85 d2                	test   %edx,%edx
c00245d2:	7f e6                	jg     c00245ba <busy_wait+0x15>
c00245d4:	85 d2                	test   %edx,%edx
c00245d6:	78 05                	js     c00245dd <busy_wait+0x38>
c00245d8:	83 f8 00             	cmp    $0x0,%eax
c00245db:	77 dd                	ja     c00245ba <busy_wait+0x15>
    barrier ();
}
c00245dd:	90                   	nop
c00245de:	83 c4 0c             	add    $0xc,%esp
c00245e1:	5b                   	pop    %ebx
c00245e2:	5d                   	pop    %ebp
c00245e3:	c3                   	ret    

c00245e4 <real_time_sleep>:

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c00245e4:	55                   	push   %ebp
c00245e5:	89 e5                	mov    %esp,%ebp
c00245e7:	53                   	push   %ebx
c00245e8:	83 ec 24             	sub    $0x24,%esp
c00245eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00245ee:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00245f1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00245f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c00245f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00245fa:	6b d0 64             	imul   $0x64,%eax,%edx
c00245fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0024600:	6b c0 00             	imul   $0x0,%eax,%eax
c0024603:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0024606:	b8 64 00 00 00       	mov    $0x64,%eax
c002460b:	f7 65 e0             	mull   -0x20(%ebp)
c002460e:	01 d1                	add    %edx,%ecx
c0024610:	89 ca                	mov    %ecx,%edx
c0024612:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0024615:	89 cb                	mov    %ecx,%ebx
c0024617:	c1 fb 1f             	sar    $0x1f,%ebx
c002461a:	53                   	push   %ebx
c002461b:	51                   	push   %ecx
c002461c:	52                   	push   %edx
c002461d:	50                   	push   %eax
c002461e:	e8 80 4f 00 00       	call   c00295a3 <__divdi3>
c0024623:	83 c4 10             	add    $0x10,%esp
c0024626:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024629:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c002462c:	e8 f1 d2 ff ff       	call   c0021922 <intr_get_level>
c0024631:	83 f8 01             	cmp    $0x1,%eax
c0024634:	74 21                	je     c0024657 <real_time_sleep+0x73>
c0024636:	83 ec 0c             	sub    $0xc,%esp
c0024639:	68 33 10 03 c0       	push   $0xc0031033
c002463e:	68 50 10 03 c0       	push   $0xc0031050
c0024643:	68 fc 10 03 c0       	push   $0xc00310fc
c0024648:	68 de 00 00 00       	push   $0xde
c002464d:	68 67 10 03 c0       	push   $0xc0031067
c0024652:	e8 46 55 00 00       	call   c0029b9d <debug_panic>
  if (ticks > 0)
c0024657:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002465b:	78 1f                	js     c002467c <real_time_sleep+0x98>
c002465d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024661:	7f 06                	jg     c0024669 <real_time_sleep+0x85>
c0024663:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0024667:	76 13                	jbe    c002467c <real_time_sleep+0x98>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c0024669:	83 ec 08             	sub    $0x8,%esp
c002466c:	ff 75 f4             	pushl  -0xc(%ebp)
c002466f:	ff 75 f0             	pushl  -0x10(%ebp)
c0024672:	e8 e2 fc ff ff       	call   c0024359 <timer_sleep>
c0024677:	83 c4 10             	add    $0x10,%esp
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
    }
}
c002467a:	eb 14                	jmp    c0024690 <real_time_sleep+0xac>
      real_time_delay (num, denom); 
c002467c:	83 ec 04             	sub    $0x4,%esp
c002467f:	ff 75 10             	pushl  0x10(%ebp)
c0024682:	ff 75 e4             	pushl  -0x1c(%ebp)
c0024685:	ff 75 e0             	pushl  -0x20(%ebp)
c0024688:	e8 09 00 00 00       	call   c0024696 <real_time_delay>
c002468d:	83 c4 10             	add    $0x10,%esp
}
c0024690:	90                   	nop
c0024691:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024694:	c9                   	leave  
c0024695:	c3                   	ret    

c0024696 <real_time_delay>:

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0024696:	55                   	push   %ebp
c0024697:	89 e5                	mov    %esp,%ebp
c0024699:	56                   	push   %esi
c002469a:	53                   	push   %ebx
c002469b:	83 ec 10             	sub    $0x10,%esp
c002469e:	8b 45 08             	mov    0x8(%ebp),%eax
c00246a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00246a4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00246a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c00246aa:	8b 45 10             	mov    0x10(%ebp),%eax
c00246ad:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c00246b2:	99                   	cltd   
c00246b3:	f7 f9                	idiv   %ecx
c00246b5:	89 d0                	mov    %edx,%eax
c00246b7:	85 c0                	test   %eax,%eax
c00246b9:	74 21                	je     c00246dc <real_time_delay+0x46>
c00246bb:	83 ec 0c             	sub    $0xc,%esp
c00246be:	68 cb 10 03 c0       	push   $0xc00310cb
c00246c3:	68 50 10 03 c0       	push   $0xc0031050
c00246c8:	68 0c 11 03 c0       	push   $0xc003110c
c00246cd:	68 f4 00 00 00       	push   $0xf4
c00246d2:	68 67 10 03 c0       	push   $0xc0031067
c00246d7:	e8 c1 54 00 00       	call   c0029b9d <debug_panic>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c00246dc:	a1 c0 a2 03 c0       	mov    0xc003a2c0,%eax
c00246e1:	ba 00 00 00 00       	mov    $0x0,%edx
c00246e6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00246e9:	89 cb                	mov    %ecx,%ebx
c00246eb:	0f af da             	imul   %edx,%ebx
c00246ee:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00246f1:	0f af c8             	imul   %eax,%ecx
c00246f4:	01 d9                	add    %ebx,%ecx
c00246f6:	f7 65 f0             	mull   -0x10(%ebp)
c00246f9:	01 d1                	add    %edx,%ecx
c00246fb:	89 ca                	mov    %ecx,%edx
c00246fd:	6a 00                	push   $0x0
c00246ff:	68 e8 03 00 00       	push   $0x3e8
c0024704:	52                   	push   %edx
c0024705:	50                   	push   %eax
c0024706:	e8 98 4e 00 00       	call   c00295a3 <__divdi3>
c002470b:	83 c4 10             	add    $0x10,%esp
c002470e:	6b da 64             	imul   $0x64,%edx,%ebx
c0024711:	6b c8 00             	imul   $0x0,%eax,%ecx
c0024714:	8d 34 0b             	lea    (%ebx,%ecx,1),%esi
c0024717:	b9 64 00 00 00       	mov    $0x64,%ecx
c002471c:	f7 e1                	mul    %ecx
c002471e:	89 c1                	mov    %eax,%ecx
c0024720:	89 d3                	mov    %edx,%ebx
c0024722:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c0024725:	89 c3                	mov    %eax,%ebx
c0024727:	8b 75 10             	mov    0x10(%ebp),%esi
c002472a:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c002472f:	f7 ee                	imul   %esi
c0024731:	c1 fa 06             	sar    $0x6,%edx
c0024734:	89 f0                	mov    %esi,%eax
c0024736:	c1 f8 1f             	sar    $0x1f,%eax
c0024739:	29 c2                	sub    %eax,%edx
c002473b:	89 d0                	mov    %edx,%eax
c002473d:	99                   	cltd   
c002473e:	52                   	push   %edx
c002473f:	50                   	push   %eax
c0024740:	53                   	push   %ebx
c0024741:	51                   	push   %ecx
c0024742:	e8 5c 4e 00 00       	call   c00295a3 <__divdi3>
c0024747:	83 c4 10             	add    $0x10,%esp
c002474a:	83 ec 08             	sub    $0x8,%esp
c002474d:	52                   	push   %edx
c002474e:	50                   	push   %eax
c002474f:	e8 51 fe ff ff       	call   c00245a5 <busy_wait>
c0024754:	83 c4 10             	add    $0x10,%esp
}
c0024757:	90                   	nop
c0024758:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002475b:	5b                   	pop    %ebx
c002475c:	5e                   	pop    %esi
c002475d:	5d                   	pop    %ebp
c002475e:	c3                   	ret    

c002475f <isupper>:
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c002475f:	55                   	push   %ebp
c0024760:	89 e5                	mov    %esp,%ebp
c0024762:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0024766:	7e 0d                	jle    c0024775 <isupper+0x16>
c0024768:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c002476c:	7f 07                	jg     c0024775 <isupper+0x16>
c002476e:	b8 01 00 00 00       	mov    $0x1,%eax
c0024773:	eb 05                	jmp    c002477a <isupper+0x1b>
c0024775:	b8 00 00 00 00       	mov    $0x0,%eax
c002477a:	5d                   	pop    %ebp
c002477b:	c3                   	ret    

c002477c <tolower>:
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c002477c:	55                   	push   %ebp
c002477d:	89 e5                	mov    %esp,%ebp
c002477f:	ff 75 08             	pushl  0x8(%ebp)
c0024782:	e8 d8 ff ff ff       	call   c002475f <isupper>
c0024787:	83 c4 04             	add    $0x4,%esp
c002478a:	85 c0                	test   %eax,%eax
c002478c:	74 08                	je     c0024796 <tolower+0x1a>
c002478e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024791:	83 c0 20             	add    $0x20,%eax
c0024794:	eb 03                	jmp    c0024799 <tolower+0x1d>
c0024796:	8b 45 08             	mov    0x8(%ebp),%eax
c0024799:	c9                   	leave  
c002479a:	c3                   	ret    

c002479b <inb>:
{
c002479b:	55                   	push   %ebp
c002479c:	89 e5                	mov    %esp,%ebp
c002479e:	83 ec 14             	sub    $0x14,%esp
c00247a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00247a4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00247a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00247ab:	89 c2                	mov    %eax,%edx
c00247ad:	ec                   	in     (%dx),%al
c00247ae:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00247b1:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c00247b4:	c9                   	leave  
c00247b5:	c3                   	ret    

c00247b6 <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c00247b6:	55                   	push   %ebp
c00247b7:	89 e5                	mov    %esp,%ebp
c00247b9:	83 ec 08             	sub    $0x8,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c00247bc:	83 ec 04             	sub    $0x4,%esp
c00247bf:	68 20 11 03 c0       	push   $0xc0031120
c00247c4:	68 fc 47 02 c0       	push   $0xc00247fc
c00247c9:	6a 21                	push   $0x21
c00247cb:	e8 e6 d3 ff ff       	call   c0021bb6 <intr_register_ext>
c00247d0:	83 c4 10             	add    $0x10,%esp
}
c00247d3:	90                   	nop
c00247d4:	c9                   	leave  
c00247d5:	c3                   	ret    

c00247d6 <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c00247d6:	55                   	push   %ebp
c00247d7:	89 e5                	mov    %esp,%ebp
c00247d9:	83 ec 08             	sub    $0x8,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c00247dc:	a1 d0 a2 03 c0       	mov    0xc003a2d0,%eax
c00247e1:	8b 15 d4 a2 03 c0    	mov    0xc003a2d4,%edx
c00247e7:	83 ec 04             	sub    $0x4,%esp
c00247ea:	52                   	push   %edx
c00247eb:	50                   	push   %eax
c00247ec:	68 2e 11 03 c0       	push   $0xc003112e
c00247f1:	e8 e8 2f 00 00       	call   c00277de <printf>
c00247f6:	83 c4 10             	add    $0x10,%esp
}
c00247f9:	90                   	nop
c00247fa:	c9                   	leave  
c00247fb:	c3                   	ret    

c00247fc <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c00247fc:	55                   	push   %ebp
c00247fd:	89 e5                	mov    %esp,%ebp
c00247ff:	53                   	push   %ebx
c0024800:	83 ec 14             	sub    $0x14,%esp
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c0024803:	a0 c8 a2 03 c0       	mov    0xc003a2c8,%al
c0024808:	84 c0                	test   %al,%al
c002480a:	75 09                	jne    c0024815 <keyboard_interrupt+0x19>
c002480c:	a0 c9 a2 03 c0       	mov    0xc003a2c9,%al
c0024811:	84 c0                	test   %al,%al
c0024813:	74 07                	je     c002481c <keyboard_interrupt+0x20>
c0024815:	b8 01 00 00 00       	mov    $0x1,%eax
c002481a:	eb 05                	jmp    c0024821 <keyboard_interrupt+0x25>
c002481c:	b8 00 00 00 00       	mov    $0x0,%eax
c0024821:	88 45 ef             	mov    %al,-0x11(%ebp)
c0024824:	80 65 ef 01          	andb   $0x1,-0x11(%ebp)
  bool alt = left_alt || right_alt;
c0024828:	a0 ca a2 03 c0       	mov    0xc003a2ca,%al
c002482d:	84 c0                	test   %al,%al
c002482f:	75 09                	jne    c002483a <keyboard_interrupt+0x3e>
c0024831:	a0 cb a2 03 c0       	mov    0xc003a2cb,%al
c0024836:	84 c0                	test   %al,%al
c0024838:	74 07                	je     c0024841 <keyboard_interrupt+0x45>
c002483a:	b8 01 00 00 00       	mov    $0x1,%eax
c002483f:	eb 05                	jmp    c0024846 <keyboard_interrupt+0x4a>
c0024841:	b8 00 00 00 00       	mov    $0x0,%eax
c0024846:	88 45 ee             	mov    %al,-0x12(%ebp)
c0024849:	80 65 ee 01          	andb   $0x1,-0x12(%ebp)
  bool ctrl = left_ctrl || right_ctrl;
c002484d:	a0 cc a2 03 c0       	mov    0xc003a2cc,%al
c0024852:	84 c0                	test   %al,%al
c0024854:	75 09                	jne    c002485f <keyboard_interrupt+0x63>
c0024856:	a0 cd a2 03 c0       	mov    0xc003a2cd,%al
c002485b:	84 c0                	test   %al,%al
c002485d:	74 07                	je     c0024866 <keyboard_interrupt+0x6a>
c002485f:	b8 01 00 00 00       	mov    $0x1,%eax
c0024864:	eb 05                	jmp    c002486b <keyboard_interrupt+0x6f>
c0024866:	b8 00 00 00 00       	mov    $0x0,%eax
c002486b:	88 45 ed             	mov    %al,-0x13(%ebp)
c002486e:	80 65 ed 01          	andb   $0x1,-0x13(%ebp)

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c0024872:	6a 60                	push   $0x60
c0024874:	e8 22 ff ff ff       	call   c002479b <inb>
c0024879:	83 c4 04             	add    $0x4,%esp
c002487c:	0f b6 c0             	movzbl %al,%eax
c002487f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (code == 0xe0)
c0024882:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
c0024889:	75 1a                	jne    c00248a5 <keyboard_interrupt+0xa9>
    code = (code << 8) | inb (DATA_REG);
c002488b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002488e:	c1 e0 08             	shl    $0x8,%eax
c0024891:	89 c3                	mov    %eax,%ebx
c0024893:	6a 60                	push   $0x60
c0024895:	e8 01 ff ff ff       	call   c002479b <inb>
c002489a:	83 c4 04             	add    $0x4,%esp
c002489d:	0f b6 c0             	movzbl %al,%eax
c00248a0:	09 d8                	or     %ebx,%eax
c00248a2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c00248a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00248a8:	25 80 00 00 00       	and    $0x80,%eax
c00248ad:	85 c0                	test   %eax,%eax
c00248af:	0f 95 c0             	setne  %al
c00248b2:	88 45 ec             	mov    %al,-0x14(%ebp)
  code &= ~0x80u;
c00248b5:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)

  /* Interpret key. */
  if (code == 0x3a) 
c00248bc:	83 7d f4 3a          	cmpl   $0x3a,-0xc(%ebp)
c00248c0:	75 2e                	jne    c00248f0 <keyboard_interrupt+0xf4>
    {
      /* Caps Lock. */
      if (!release)
c00248c2:	8a 45 ec             	mov    -0x14(%ebp),%al
c00248c5:	83 f0 01             	xor    $0x1,%eax
c00248c8:	84 c0                	test   %al,%al
c00248ca:	0f 84 77 01 00 00    	je     c0024a47 <keyboard_interrupt+0x24b>
        caps_lock = !caps_lock;
c00248d0:	a0 ce a2 03 c0       	mov    0xc003a2ce,%al
c00248d5:	0f b6 c0             	movzbl %al,%eax
c00248d8:	85 c0                	test   %eax,%eax
c00248da:	0f 95 c0             	setne  %al
c00248dd:	83 f0 01             	xor    $0x1,%eax
c00248e0:	0f b6 c0             	movzbl %al,%eax
c00248e3:	83 e0 01             	and    $0x1,%eax
c00248e6:	a2 ce a2 03 c0       	mov    %al,0xc003a2ce
          {
            *key->state_var = !release;
            break;
          }
    }
}
c00248eb:	e9 57 01 00 00       	jmp    c0024a47 <keyboard_interrupt+0x24b>
  else if (map_key (invariant_keymap, code, &c)
c00248f0:	83 ec 04             	sub    $0x4,%esp
c00248f3:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00248f6:	50                   	push   %eax
c00248f7:	ff 75 f4             	pushl  -0xc(%ebp)
c00248fa:	68 80 11 03 c0       	push   $0xc0031180
c00248ff:	e8 49 01 00 00       	call   c0024a4d <map_key>
c0024904:	83 c4 10             	add    $0x10,%esp
c0024907:	84 c0                	test   %al,%al
c0024909:	75 4e                	jne    c0024959 <keyboard_interrupt+0x15d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c002490b:	8a 45 ef             	mov    -0x11(%ebp),%al
c002490e:	83 f0 01             	xor    $0x1,%eax
c0024911:	84 c0                	test   %al,%al
c0024913:	74 1b                	je     c0024930 <keyboard_interrupt+0x134>
c0024915:	83 ec 04             	sub    $0x4,%esp
c0024918:	8d 45 eb             	lea    -0x15(%ebp),%eax
c002491b:	50                   	push   %eax
c002491c:	ff 75 f4             	pushl  -0xc(%ebp)
c002491f:	68 00 12 03 c0       	push   $0xc0031200
c0024924:	e8 24 01 00 00       	call   c0024a4d <map_key>
c0024929:	83 c4 10             	add    $0x10,%esp
c002492c:	84 c0                	test   %al,%al
c002492e:	75 29                	jne    c0024959 <keyboard_interrupt+0x15d>
           || (shift && map_key (shifted_keymap, code, &c)))
c0024930:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0024934:	0f 84 ce 00 00 00    	je     c0024a08 <keyboard_interrupt+0x20c>
c002493a:	83 ec 04             	sub    $0x4,%esp
c002493d:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0024940:	50                   	push   %eax
c0024941:	ff 75 f4             	pushl  -0xc(%ebp)
c0024944:	68 60 12 03 c0       	push   $0xc0031260
c0024949:	e8 ff 00 00 00       	call   c0024a4d <map_key>
c002494e:	83 c4 10             	add    $0x10,%esp
c0024951:	84 c0                	test   %al,%al
c0024953:	0f 84 af 00 00 00    	je     c0024a08 <keyboard_interrupt+0x20c>
      if (!release) 
c0024959:	8a 45 ec             	mov    -0x14(%ebp),%al
c002495c:	83 f0 01             	xor    $0x1,%eax
c002495f:	84 c0                	test   %al,%al
c0024961:	0f 84 df 00 00 00    	je     c0024a46 <keyboard_interrupt+0x24a>
          if (c == 0177 && ctrl && alt)
c0024967:	8a 45 eb             	mov    -0x15(%ebp),%al
c002496a:	3c 7f                	cmp    $0x7f,%al
c002496c:	75 11                	jne    c002497f <keyboard_interrupt+0x183>
c002496e:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024972:	74 0b                	je     c002497f <keyboard_interrupt+0x183>
c0024974:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c0024978:	74 05                	je     c002497f <keyboard_interrupt+0x183>
            shutdown_reboot ();
c002497a:	e8 e4 28 00 00       	call   c0027263 <shutdown_reboot>
          if (ctrl && c >= 0x40 && c < 0x60) 
c002497f:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024983:	74 19                	je     c002499e <keyboard_interrupt+0x1a2>
c0024985:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024988:	3c 3f                	cmp    $0x3f,%al
c002498a:	76 12                	jbe    c002499e <keyboard_interrupt+0x1a2>
c002498c:	8a 45 eb             	mov    -0x15(%ebp),%al
c002498f:	3c 5f                	cmp    $0x5f,%al
c0024991:	77 0b                	ja     c002499e <keyboard_interrupt+0x1a2>
              c -= 0x40; 
c0024993:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024996:	83 e8 40             	sub    $0x40,%eax
c0024999:	88 45 eb             	mov    %al,-0x15(%ebp)
c002499c:	eb 1f                	jmp    c00249bd <keyboard_interrupt+0x1c1>
          else if (shift == caps_lock)
c002499e:	a0 ce a2 03 c0       	mov    0xc003a2ce,%al
c00249a3:	38 45 ef             	cmp    %al,-0x11(%ebp)
c00249a6:	75 15                	jne    c00249bd <keyboard_interrupt+0x1c1>
            c = tolower (c);
c00249a8:	8a 45 eb             	mov    -0x15(%ebp),%al
c00249ab:	0f b6 c0             	movzbl %al,%eax
c00249ae:	83 ec 0c             	sub    $0xc,%esp
c00249b1:	50                   	push   %eax
c00249b2:	e8 c5 fd ff ff       	call   c002477c <tolower>
c00249b7:	83 c4 10             	add    $0x10,%esp
c00249ba:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (alt)
c00249bd:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c00249c1:	74 09                	je     c00249cc <keyboard_interrupt+0x1d0>
            c += 0x80;
c00249c3:	8a 45 eb             	mov    -0x15(%ebp),%al
c00249c6:	83 c0 80             	add    $0xffffff80,%eax
c00249c9:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (!input_full ())
c00249cc:	e8 39 21 00 00       	call   c0026b0a <input_full>
c00249d1:	83 f0 01             	xor    $0x1,%eax
c00249d4:	84 c0                	test   %al,%al
c00249d6:	74 6e                	je     c0024a46 <keyboard_interrupt+0x24a>
              key_cnt++;
c00249d8:	a1 d0 a2 03 c0       	mov    0xc003a2d0,%eax
c00249dd:	8b 15 d4 a2 03 c0    	mov    0xc003a2d4,%edx
c00249e3:	83 c0 01             	add    $0x1,%eax
c00249e6:	83 d2 00             	adc    $0x0,%edx
c00249e9:	a3 d0 a2 03 c0       	mov    %eax,0xc003a2d0
c00249ee:	89 15 d4 a2 03 c0    	mov    %edx,0xc003a2d4
              input_putc (c);
c00249f4:	8a 45 eb             	mov    -0x15(%ebp),%al
c00249f7:	0f b6 c0             	movzbl %al,%eax
c00249fa:	83 ec 0c             	sub    $0xc,%esp
c00249fd:	50                   	push   %eax
c00249fe:	e8 49 20 00 00       	call   c0026a4c <input_putc>
c0024a03:	83 c4 10             	add    $0x10,%esp
      if (!release) 
c0024a06:	eb 3e                	jmp    c0024a46 <keyboard_interrupt+0x24a>
      for (key = shift_keys; key->scancode != 0; key++) 
c0024a08:	c7 45 f0 a0 12 03 c0 	movl   $0xc00312a0,-0x10(%ebp)
c0024a0f:	eb 2a                	jmp    c0024a3b <keyboard_interrupt+0x23f>
        if (key->scancode == code)
c0024a11:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024a14:	8b 00                	mov    (%eax),%eax
c0024a16:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0024a19:	75 1c                	jne    c0024a37 <keyboard_interrupt+0x23b>
            *key->state_var = !release;
c0024a1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024a1e:	8b 50 04             	mov    0x4(%eax),%edx
c0024a21:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0024a25:	85 c0                	test   %eax,%eax
c0024a27:	0f 95 c0             	setne  %al
c0024a2a:	83 f0 01             	xor    $0x1,%eax
c0024a2d:	0f b6 c0             	movzbl %al,%eax
c0024a30:	83 e0 01             	and    $0x1,%eax
c0024a33:	88 02                	mov    %al,(%edx)
            break;
c0024a35:	eb 10                	jmp    c0024a47 <keyboard_interrupt+0x24b>
      for (key = shift_keys; key->scancode != 0; key++) 
c0024a37:	83 45 f0 08          	addl   $0x8,-0x10(%ebp)
c0024a3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024a3e:	8b 00                	mov    (%eax),%eax
c0024a40:	85 c0                	test   %eax,%eax
c0024a42:	75 cd                	jne    c0024a11 <keyboard_interrupt+0x215>
}
c0024a44:	eb 01                	jmp    c0024a47 <keyboard_interrupt+0x24b>
      if (!release) 
c0024a46:	90                   	nop
}
c0024a47:	90                   	nop
c0024a48:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024a4b:	c9                   	leave  
c0024a4c:	c3                   	ret    

c0024a4d <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c0024a4d:	55                   	push   %ebp
c0024a4e:	89 e5                	mov    %esp,%ebp
c0024a50:	53                   	push   %ebx
c0024a51:	83 ec 04             	sub    $0x4,%esp
  for (; k->first_scancode != 0; k++)
c0024a54:	eb 56                	jmp    c0024aac <map_key+0x5f>
    if (scancode >= k->first_scancode
c0024a56:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a59:	8a 00                	mov    (%eax),%al
c0024a5b:	0f b6 c0             	movzbl %al,%eax
c0024a5e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024a61:	77 45                	ja     c0024aa8 <map_key+0x5b>
        && scancode < k->first_scancode + strlen (k->chars)) 
c0024a63:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a66:	8a 00                	mov    (%eax),%al
c0024a68:	0f b6 d8             	movzbl %al,%ebx
c0024a6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a6e:	8b 40 04             	mov    0x4(%eax),%eax
c0024a71:	83 ec 0c             	sub    $0xc,%esp
c0024a74:	50                   	push   %eax
c0024a75:	e8 96 45 00 00       	call   c0029010 <strlen>
c0024a7a:	83 c4 10             	add    $0x10,%esp
c0024a7d:	01 d8                	add    %ebx,%eax
c0024a7f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024a82:	76 24                	jbe    c0024aa8 <map_key+0x5b>
      {
        *c = k->chars[scancode - k->first_scancode];
c0024a84:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a87:	8b 50 04             	mov    0x4(%eax),%edx
c0024a8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a8d:	8a 00                	mov    (%eax),%al
c0024a8f:	0f b6 c0             	movzbl %al,%eax
c0024a92:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0024a95:	29 c1                	sub    %eax,%ecx
c0024a97:	89 c8                	mov    %ecx,%eax
c0024a99:	01 d0                	add    %edx,%eax
c0024a9b:	8a 00                	mov    (%eax),%al
c0024a9d:	88 c2                	mov    %al,%dl
c0024a9f:	8b 45 10             	mov    0x10(%ebp),%eax
c0024aa2:	88 10                	mov    %dl,(%eax)
        return true; 
c0024aa4:	b0 01                	mov    $0x1,%al
c0024aa6:	eb 0f                	jmp    c0024ab7 <map_key+0x6a>
  for (; k->first_scancode != 0; k++)
c0024aa8:	83 45 08 08          	addl   $0x8,0x8(%ebp)
c0024aac:	8b 45 08             	mov    0x8(%ebp),%eax
c0024aaf:	8a 00                	mov    (%eax),%al
c0024ab1:	84 c0                	test   %al,%al
c0024ab3:	75 a1                	jne    c0024a56 <map_key+0x9>
      }

  return false;
c0024ab5:	b0 00                	mov    $0x0,%al
}
c0024ab7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024aba:	c9                   	leave  
c0024abb:	c3                   	ret    

c0024abc <inb>:
{
c0024abc:	55                   	push   %ebp
c0024abd:	89 e5                	mov    %esp,%ebp
c0024abf:	83 ec 14             	sub    $0x14,%esp
c0024ac2:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ac5:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024ac9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024acc:	89 c2                	mov    %eax,%edx
c0024ace:	ec                   	in     (%dx),%al
c0024acf:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024ad2:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024ad5:	c9                   	leave  
c0024ad6:	c3                   	ret    

c0024ad7 <outb>:
{
c0024ad7:	55                   	push   %ebp
c0024ad8:	89 e5                	mov    %esp,%ebp
c0024ada:	83 ec 08             	sub    $0x8,%esp
c0024add:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ae0:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024ae3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0024ae7:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024aea:	8a 45 f8             	mov    -0x8(%ebp),%al
c0024aed:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024af0:	ee                   	out    %al,(%dx)
}
c0024af1:	90                   	nop
c0024af2:	c9                   	leave  
c0024af3:	c3                   	ret    

c0024af4 <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c0024af4:	55                   	push   %ebp
c0024af5:	89 e5                	mov    %esp,%ebp
c0024af7:	83 ec 08             	sub    $0x8,%esp
c0024afa:	8b 55 08             	mov    0x8(%ebp),%edx
c0024afd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024b00:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0024b04:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0024b08:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0024b0b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024b0e:	66 ef                	out    %ax,(%dx)
}
c0024b10:	90                   	nop
c0024b11:	c9                   	leave  
c0024b12:	c3                   	ret    

c0024b13 <ptov>:
{
c0024b13:	55                   	push   %ebp
c0024b14:	89 e5                	mov    %esp,%ebp
c0024b16:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0024b19:	8b 45 08             	mov    0x8(%ebp),%eax
c0024b1c:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0024b21:	76 1e                	jbe    c0024b41 <ptov+0x2e>
c0024b23:	83 ec 0c             	sub    $0xc,%esp
c0024b26:	68 d8 12 03 c0       	push   $0xc00312d8
c0024b2b:	68 f3 12 03 c0       	push   $0xc00312f3
c0024b30:	68 3c 13 03 c0       	push   $0xc003133c
c0024b35:	6a 4a                	push   $0x4a
c0024b37:	68 0a 13 03 c0       	push   $0xc003130a
c0024b3c:	e8 5c 50 00 00       	call   c0029b9d <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c0024b41:	8b 45 08             	mov    0x8(%ebp),%eax
c0024b44:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0024b49:	c9                   	leave  
c0024b4a:	c3                   	ret    

c0024b4b <init>:
static void find_cursor (size_t *x, size_t *y);

/* Initializes the VGA text display. */
static void
init (void)
{
c0024b4b:	55                   	push   %ebp
c0024b4c:	89 e5                	mov    %esp,%ebp
c0024b4e:	83 ec 08             	sub    $0x8,%esp
  /* Already initialized? */
  static bool inited;
  if (!inited)
c0024b51:	a0 e4 a2 03 c0       	mov    0xc003a2e4,%al
c0024b56:	83 f0 01             	xor    $0x1,%eax
c0024b59:	84 c0                	test   %al,%al
c0024b5b:	74 31                	je     c0024b8e <init+0x43>
    {
      fb = ptov (0xb8000);
c0024b5d:	83 ec 0c             	sub    $0xc,%esp
c0024b60:	68 00 80 0b 00       	push   $0xb8000
c0024b65:	e8 a9 ff ff ff       	call   c0024b13 <ptov>
c0024b6a:	83 c4 10             	add    $0x10,%esp
c0024b6d:	a3 e0 a2 03 c0       	mov    %eax,0xc003a2e0
      find_cursor (&cx, &cy);
c0024b72:	83 ec 08             	sub    $0x8,%esp
c0024b75:	68 dc a2 03 c0       	push   $0xc003a2dc
c0024b7a:	68 d8 a2 03 c0       	push   $0xc003a2d8
c0024b7f:	e8 8f 02 00 00       	call   c0024e13 <find_cursor>
c0024b84:	83 c4 10             	add    $0x10,%esp
      inited = true; 
c0024b87:	c6 05 e4 a2 03 c0 01 	movb   $0x1,0xc003a2e4
    }
}
c0024b8e:	90                   	nop
c0024b8f:	c9                   	leave  
c0024b90:	c3                   	ret    

c0024b91 <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c0024b91:	55                   	push   %ebp
c0024b92:	89 e5                	mov    %esp,%ebp
c0024b94:	83 ec 18             	sub    $0x18,%esp
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c0024b97:	e8 fb cd ff ff       	call   c0021997 <intr_disable>
c0024b9c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  init ();
c0024b9f:	e8 a7 ff ff ff       	call   c0024b4b <init>
  
  switch (c) 
c0024ba4:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ba7:	83 e8 07             	sub    $0x7,%eax
c0024baa:	83 f8 06             	cmp    $0x6,%eax
c0024bad:	0f 87 8b 00 00 00    	ja     c0024c3e <vga_putc+0xad>
c0024bb3:	8b 04 85 20 13 03 c0 	mov    -0x3ffcece0(,%eax,4),%eax
c0024bba:	ff e0                	jmp    *%eax
    {
    case '\n':
      newline ();
c0024bbc:	e8 95 01 00 00       	call   c0024d56 <newline>
      break;
c0024bc1:	e9 e2 00 00 00       	jmp    c0024ca8 <vga_putc+0x117>

    case '\f':
      cls ();
c0024bc6:	e8 f3 00 00 00       	call   c0024cbe <cls>
      break;
c0024bcb:	e9 d8 00 00 00       	jmp    c0024ca8 <vga_putc+0x117>

    case '\b':
      if (cx > 0)
c0024bd0:	a1 d8 a2 03 c0       	mov    0xc003a2d8,%eax
c0024bd5:	85 c0                	test   %eax,%eax
c0024bd7:	0f 84 c4 00 00 00    	je     c0024ca1 <vga_putc+0x110>
        cx--;
c0024bdd:	a1 d8 a2 03 c0       	mov    0xc003a2d8,%eax
c0024be2:	48                   	dec    %eax
c0024be3:	a3 d8 a2 03 c0       	mov    %eax,0xc003a2d8
      break;
c0024be8:	e9 b4 00 00 00       	jmp    c0024ca1 <vga_putc+0x110>
      
    case '\r':
      cx = 0;
c0024bed:	c7 05 d8 a2 03 c0 00 	movl   $0x0,0xc003a2d8
c0024bf4:	00 00 00 
      break;
c0024bf7:	e9 ac 00 00 00       	jmp    c0024ca8 <vga_putc+0x117>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c0024bfc:	a1 d8 a2 03 c0       	mov    0xc003a2d8,%eax
c0024c01:	83 c0 08             	add    $0x8,%eax
c0024c04:	83 e0 f8             	and    $0xfffffff8,%eax
c0024c07:	a3 d8 a2 03 c0       	mov    %eax,0xc003a2d8
      if (cx >= COL_CNT)
c0024c0c:	a1 d8 a2 03 c0       	mov    0xc003a2d8,%eax
c0024c11:	83 f8 4f             	cmp    $0x4f,%eax
c0024c14:	0f 86 8a 00 00 00    	jbe    c0024ca4 <vga_putc+0x113>
        newline ();
c0024c1a:	e8 37 01 00 00       	call   c0024d56 <newline>
      break;
c0024c1f:	e9 80 00 00 00       	jmp    c0024ca4 <vga_putc+0x113>

    case '\a':
      intr_set_level (old_level);
c0024c24:	83 ec 0c             	sub    $0xc,%esp
c0024c27:	ff 75 f4             	pushl  -0xc(%ebp)
c0024c2a:	e8 10 cd ff ff       	call   c002193f <intr_set_level>
c0024c2f:	83 c4 10             	add    $0x10,%esp
      speaker_beep ();
c0024c32:	e8 60 28 00 00       	call   c0027497 <speaker_beep>
      intr_disable ();
c0024c37:	e8 5b cd ff ff       	call   c0021997 <intr_disable>
      break;
c0024c3c:	eb 6a                	jmp    c0024ca8 <vga_putc+0x117>
      
    default:
      fb[cy][cx][0] = c;
c0024c3e:	8b 0d e0 a2 03 c0    	mov    0xc003a2e0,%ecx
c0024c44:	8b 15 dc a2 03 c0    	mov    0xc003a2dc,%edx
c0024c4a:	89 d0                	mov    %edx,%eax
c0024c4c:	c1 e0 02             	shl    $0x2,%eax
c0024c4f:	01 d0                	add    %edx,%eax
c0024c51:	c1 e0 05             	shl    $0x5,%eax
c0024c54:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024c57:	a1 d8 a2 03 c0       	mov    0xc003a2d8,%eax
c0024c5c:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024c5f:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024c62:	8b 0d e0 a2 03 c0    	mov    0xc003a2e0,%ecx
c0024c68:	8b 15 dc a2 03 c0    	mov    0xc003a2dc,%edx
c0024c6e:	89 d0                	mov    %edx,%eax
c0024c70:	c1 e0 02             	shl    $0x2,%eax
c0024c73:	01 d0                	add    %edx,%eax
c0024c75:	c1 e0 05             	shl    $0x5,%eax
c0024c78:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024c7b:	a1 d8 a2 03 c0       	mov    0xc003a2d8,%eax
c0024c80:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c0024c85:	a1 d8 a2 03 c0       	mov    0xc003a2d8,%eax
c0024c8a:	40                   	inc    %eax
c0024c8b:	a3 d8 a2 03 c0       	mov    %eax,0xc003a2d8
c0024c90:	a1 d8 a2 03 c0       	mov    0xc003a2d8,%eax
c0024c95:	83 f8 4f             	cmp    $0x4f,%eax
c0024c98:	76 0d                	jbe    c0024ca7 <vga_putc+0x116>
        newline ();
c0024c9a:	e8 b7 00 00 00       	call   c0024d56 <newline>
      break;
c0024c9f:	eb 06                	jmp    c0024ca7 <vga_putc+0x116>
      break;
c0024ca1:	90                   	nop
c0024ca2:	eb 04                	jmp    c0024ca8 <vga_putc+0x117>
      break;
c0024ca4:	90                   	nop
c0024ca5:	eb 01                	jmp    c0024ca8 <vga_putc+0x117>
      break;
c0024ca7:	90                   	nop
    }

  /* Update cursor position. */
  move_cursor ();
c0024ca8:	e8 0a 01 00 00       	call   c0024db7 <move_cursor>

  intr_set_level (old_level);
c0024cad:	83 ec 0c             	sub    $0xc,%esp
c0024cb0:	ff 75 f4             	pushl  -0xc(%ebp)
c0024cb3:	e8 87 cc ff ff       	call   c002193f <intr_set_level>
c0024cb8:	83 c4 10             	add    $0x10,%esp
}
c0024cbb:	90                   	nop
c0024cbc:	c9                   	leave  
c0024cbd:	c3                   	ret    

c0024cbe <cls>:

/* Clears the screen and moves the cursor to the upper left. */
static void
cls (void)
{
c0024cbe:	55                   	push   %ebp
c0024cbf:	89 e5                	mov    %esp,%ebp
c0024cc1:	83 ec 18             	sub    $0x18,%esp
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c0024cc4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0024ccb:	eb 11                	jmp    c0024cde <cls+0x20>
    clear_row (y);
c0024ccd:	83 ec 0c             	sub    $0xc,%esp
c0024cd0:	ff 75 f4             	pushl  -0xc(%ebp)
c0024cd3:	e8 28 00 00 00       	call   c0024d00 <clear_row>
c0024cd8:	83 c4 10             	add    $0x10,%esp
  for (y = 0; y < ROW_CNT; y++)
c0024cdb:	ff 45 f4             	incl   -0xc(%ebp)
c0024cde:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0024ce2:	76 e9                	jbe    c0024ccd <cls+0xf>

  cx = cy = 0;
c0024ce4:	c7 05 dc a2 03 c0 00 	movl   $0x0,0xc003a2dc
c0024ceb:	00 00 00 
c0024cee:	a1 dc a2 03 c0       	mov    0xc003a2dc,%eax
c0024cf3:	a3 d8 a2 03 c0       	mov    %eax,0xc003a2d8
  move_cursor ();
c0024cf8:	e8 ba 00 00 00       	call   c0024db7 <move_cursor>
}
c0024cfd:	90                   	nop
c0024cfe:	c9                   	leave  
c0024cff:	c3                   	ret    

c0024d00 <clear_row>:

/* Clears row Y to spaces. */
static void
clear_row (size_t y) 
{
c0024d00:	55                   	push   %ebp
c0024d01:	89 e5                	mov    %esp,%ebp
c0024d03:	83 ec 10             	sub    $0x10,%esp
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c0024d06:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0024d0d:	eb 3e                	jmp    c0024d4d <clear_row+0x4d>
    {
      fb[y][x][0] = ' ';
c0024d0f:	8b 0d e0 a2 03 c0    	mov    0xc003a2e0,%ecx
c0024d15:	8b 55 08             	mov    0x8(%ebp),%edx
c0024d18:	89 d0                	mov    %edx,%eax
c0024d1a:	c1 e0 02             	shl    $0x2,%eax
c0024d1d:	01 d0                	add    %edx,%eax
c0024d1f:	c1 e0 05             	shl    $0x5,%eax
c0024d22:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024d25:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0024d28:	c6 04 42 20          	movb   $0x20,(%edx,%eax,2)
      fb[y][x][1] = GRAY_ON_BLACK;
c0024d2c:	8b 0d e0 a2 03 c0    	mov    0xc003a2e0,%ecx
c0024d32:	8b 55 08             	mov    0x8(%ebp),%edx
c0024d35:	89 d0                	mov    %edx,%eax
c0024d37:	c1 e0 02             	shl    $0x2,%eax
c0024d3a:	01 d0                	add    %edx,%eax
c0024d3c:	c1 e0 05             	shl    $0x5,%eax
c0024d3f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024d42:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0024d45:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
  for (x = 0; x < COL_CNT; x++)
c0024d4a:	ff 45 fc             	incl   -0x4(%ebp)
c0024d4d:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
c0024d51:	76 bc                	jbe    c0024d0f <clear_row+0xf>
    }
}
c0024d53:	90                   	nop
c0024d54:	c9                   	leave  
c0024d55:	c3                   	ret    

c0024d56 <newline>:
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c0024d56:	55                   	push   %ebp
c0024d57:	89 e5                	mov    %esp,%ebp
c0024d59:	83 ec 08             	sub    $0x8,%esp
  cx = 0;
c0024d5c:	c7 05 d8 a2 03 c0 00 	movl   $0x0,0xc003a2d8
c0024d63:	00 00 00 
  cy++;
c0024d66:	a1 dc a2 03 c0       	mov    0xc003a2dc,%eax
c0024d6b:	40                   	inc    %eax
c0024d6c:	a3 dc a2 03 c0       	mov    %eax,0xc003a2dc
  if (cy >= ROW_CNT)
c0024d71:	a1 dc a2 03 c0       	mov    0xc003a2dc,%eax
c0024d76:	83 f8 18             	cmp    $0x18,%eax
c0024d79:	76 39                	jbe    c0024db4 <newline+0x5e>
    {
      cy = ROW_CNT - 1;
c0024d7b:	c7 05 dc a2 03 c0 18 	movl   $0x18,0xc003a2dc
c0024d82:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024d85:	a1 e0 a2 03 c0       	mov    0xc003a2e0,%eax
c0024d8a:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0024d90:	a1 e0 a2 03 c0       	mov    0xc003a2e0,%eax
c0024d95:	83 ec 04             	sub    $0x4,%esp
c0024d98:	68 00 0f 00 00       	push   $0xf00
c0024d9d:	52                   	push   %edx
c0024d9e:	50                   	push   %eax
c0024d9f:	e8 c7 3c 00 00       	call   c0028a6b <memmove>
c0024da4:	83 c4 10             	add    $0x10,%esp
      clear_row (ROW_CNT - 1);
c0024da7:	83 ec 0c             	sub    $0xc,%esp
c0024daa:	6a 18                	push   $0x18
c0024dac:	e8 4f ff ff ff       	call   c0024d00 <clear_row>
c0024db1:	83 c4 10             	add    $0x10,%esp
    }
}
c0024db4:	90                   	nop
c0024db5:	c9                   	leave  
c0024db6:	c3                   	ret    

c0024db7 <move_cursor>:

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c0024db7:	55                   	push   %ebp
c0024db8:	89 e5                	mov    %esp,%ebp
c0024dba:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0024dbd:	a1 dc a2 03 c0       	mov    0xc003a2dc,%eax
c0024dc2:	89 c2                	mov    %eax,%edx
c0024dc4:	89 d0                	mov    %edx,%eax
c0024dc6:	c1 e0 02             	shl    $0x2,%eax
c0024dc9:	01 d0                	add    %edx,%eax
c0024dcb:	c1 e0 04             	shl    $0x4,%eax
c0024dce:	89 c2                	mov    %eax,%edx
c0024dd0:	a1 d8 a2 03 c0       	mov    0xc003a2d8,%eax
c0024dd5:	01 d0                	add    %edx,%eax
c0024dd7:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  outw (0x3d4, 0x0e | (cp & 0xff00));
c0024ddb:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0024ddf:	b0 00                	mov    $0x0,%al
c0024de1:	83 c8 0e             	or     $0xe,%eax
c0024de4:	0f b7 c0             	movzwl %ax,%eax
c0024de7:	50                   	push   %eax
c0024de8:	68 d4 03 00 00       	push   $0x3d4
c0024ded:	e8 02 fd ff ff       	call   c0024af4 <outw>
c0024df2:	83 c4 08             	add    $0x8,%esp
  outw (0x3d4, 0x0f | (cp << 8));
c0024df5:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0024df9:	c1 e0 08             	shl    $0x8,%eax
c0024dfc:	83 c8 0f             	or     $0xf,%eax
c0024dff:	0f b7 c0             	movzwl %ax,%eax
c0024e02:	50                   	push   %eax
c0024e03:	68 d4 03 00 00       	push   $0x3d4
c0024e08:	e8 e7 fc ff ff       	call   c0024af4 <outw>
c0024e0d:	83 c4 08             	add    $0x8,%esp
}
c0024e10:	90                   	nop
c0024e11:	c9                   	leave  
c0024e12:	c3                   	ret    

c0024e13 <find_cursor>:

/* Reads the current hardware cursor position into (*X,*Y). */
static void
find_cursor (size_t *x, size_t *y) 
{
c0024e13:	55                   	push   %ebp
c0024e14:	89 e5                	mov    %esp,%ebp
c0024e16:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
c0024e19:	6a 0e                	push   $0xe
c0024e1b:	68 d4 03 00 00       	push   $0x3d4
c0024e20:	e8 b2 fc ff ff       	call   c0024ad7 <outb>
c0024e25:	83 c4 08             	add    $0x8,%esp
  cp = inb (0x3d5) << 8;
c0024e28:	68 d5 03 00 00       	push   $0x3d5
c0024e2d:	e8 8a fc ff ff       	call   c0024abc <inb>
c0024e32:	83 c4 04             	add    $0x4,%esp
c0024e35:	0f b6 c0             	movzbl %al,%eax
c0024e38:	c1 e0 08             	shl    $0x8,%eax
c0024e3b:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  outb (0x3d4, 0x0f);
c0024e3f:	6a 0f                	push   $0xf
c0024e41:	68 d4 03 00 00       	push   $0x3d4
c0024e46:	e8 8c fc ff ff       	call   c0024ad7 <outb>
c0024e4b:	83 c4 08             	add    $0x8,%esp
  cp |= inb (0x3d5);
c0024e4e:	68 d5 03 00 00       	push   $0x3d5
c0024e53:	e8 64 fc ff ff       	call   c0024abc <inb>
c0024e58:	83 c4 04             	add    $0x4,%esp
c0024e5b:	0f b6 c0             	movzbl %al,%eax
c0024e5e:	66 09 45 fe          	or     %ax,-0x2(%ebp)

  *x = cp % COL_CNT;
c0024e62:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0024e66:	b9 50 00 00 00       	mov    $0x50,%ecx
c0024e6b:	ba 00 00 00 00       	mov    $0x0,%edx
c0024e70:	66 f7 f1             	div    %cx
c0024e73:	89 d0                	mov    %edx,%eax
c0024e75:	0f b7 d0             	movzwl %ax,%edx
c0024e78:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e7b:	89 10                	mov    %edx,(%eax)
  *y = cp / COL_CNT;
c0024e7d:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0024e81:	0f b7 d0             	movzwl %ax,%edx
c0024e84:	89 d0                	mov    %edx,%eax
c0024e86:	c1 e0 02             	shl    $0x2,%eax
c0024e89:	01 d0                	add    %edx,%eax
c0024e8b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0024e92:	01 c8                	add    %ecx,%eax
c0024e94:	01 c0                	add    %eax,%eax
c0024e96:	01 d0                	add    %edx,%eax
c0024e98:	89 c1                	mov    %eax,%ecx
c0024e9a:	c1 e1 08             	shl    $0x8,%ecx
c0024e9d:	01 c8                	add    %ecx,%eax
c0024e9f:	c1 e0 02             	shl    $0x2,%eax
c0024ea2:	01 d0                	add    %edx,%eax
c0024ea4:	c1 e8 10             	shr    $0x10,%eax
c0024ea7:	66 c1 e8 06          	shr    $0x6,%ax
c0024eab:	0f b7 d0             	movzwl %ax,%edx
c0024eae:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024eb1:	89 10                	mov    %edx,(%eax)
}
c0024eb3:	90                   	nop
c0024eb4:	c9                   	leave  
c0024eb5:	c3                   	ret    

c0024eb6 <inb>:
{
c0024eb6:	55                   	push   %ebp
c0024eb7:	89 e5                	mov    %esp,%ebp
c0024eb9:	83 ec 14             	sub    $0x14,%esp
c0024ebc:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ebf:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024ec3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024ec6:	89 c2                	mov    %eax,%edx
c0024ec8:	ec                   	in     (%dx),%al
c0024ec9:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024ecc:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024ecf:	c9                   	leave  
c0024ed0:	c3                   	ret    

c0024ed1 <outb>:
{
c0024ed1:	55                   	push   %ebp
c0024ed2:	89 e5                	mov    %esp,%ebp
c0024ed4:	83 ec 08             	sub    $0x8,%esp
c0024ed7:	8b 45 08             	mov    0x8(%ebp),%eax
c0024eda:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024edd:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0024ee1:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024ee4:	8a 45 f8             	mov    -0x8(%ebp),%al
c0024ee7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024eea:	ee                   	out    %al,(%dx)
}
c0024eeb:	90                   	nop
c0024eec:	c9                   	leave  
c0024eed:	c3                   	ret    

c0024eee <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0024eee:	55                   	push   %ebp
c0024eef:	89 e5                	mov    %esp,%ebp
c0024ef1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (mode == UNINIT);
c0024ef4:	a1 00 a3 03 c0       	mov    0xc003a300,%eax
c0024ef9:	85 c0                	test   %eax,%eax
c0024efb:	74 1e                	je     c0024f1b <init_poll+0x2d>
c0024efd:	83 ec 0c             	sub    $0xc,%esp
c0024f00:	68 44 13 03 c0       	push   $0xc0031344
c0024f05:	68 53 13 03 c0       	push   $0xc0031353
c0024f0a:	68 d0 13 03 c0       	push   $0xc00313d0
c0024f0f:	6a 45                	push   $0x45
c0024f11:	68 6a 13 03 c0       	push   $0xc003136a
c0024f16:	e8 82 4c 00 00       	call   c0029b9d <debug_panic>
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
c0024f1b:	83 ec 08             	sub    $0x8,%esp
c0024f1e:	6a 00                	push   $0x0
c0024f20:	68 f9 03 00 00       	push   $0x3f9
c0024f25:	e8 a7 ff ff ff       	call   c0024ed1 <outb>
c0024f2a:	83 c4 10             	add    $0x10,%esp
  outb (FCR_REG, 0);                    /* Disable FIFO. */
c0024f2d:	83 ec 08             	sub    $0x8,%esp
c0024f30:	6a 00                	push   $0x0
c0024f32:	68 fa 03 00 00       	push   $0x3fa
c0024f37:	e8 95 ff ff ff       	call   c0024ed1 <outb>
c0024f3c:	83 c4 10             	add    $0x10,%esp
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
c0024f3f:	83 ec 0c             	sub    $0xc,%esp
c0024f42:	68 80 25 00 00       	push   $0x2580
c0024f47:	e8 e8 01 00 00       	call   c0025134 <set_serial>
c0024f4c:	83 c4 10             	add    $0x10,%esp
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
c0024f4f:	83 ec 08             	sub    $0x8,%esp
c0024f52:	6a 08                	push   $0x8
c0024f54:	68 fc 03 00 00       	push   $0x3fc
c0024f59:	e8 73 ff ff ff       	call   c0024ed1 <outb>
c0024f5e:	83 c4 10             	add    $0x10,%esp
  intq_init (&txq);
c0024f61:	83 ec 0c             	sub    $0xc,%esp
c0024f64:	68 20 a3 03 c0       	push   $0xc003a320
c0024f69:	e8 db 1b 00 00       	call   c0026b49 <intq_init>
c0024f6e:	83 c4 10             	add    $0x10,%esp
  mode = POLL;
c0024f71:	c7 05 00 a3 03 c0 01 	movl   $0x1,0xc003a300
c0024f78:	00 00 00 
} 
c0024f7b:	90                   	nop
c0024f7c:	c9                   	leave  
c0024f7d:	c3                   	ret    

c0024f7e <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c0024f7e:	55                   	push   %ebp
c0024f7f:	89 e5                	mov    %esp,%ebp
c0024f81:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  if (mode == UNINIT)
c0024f84:	a1 00 a3 03 c0       	mov    0xc003a300,%eax
c0024f89:	85 c0                	test   %eax,%eax
c0024f8b:	75 05                	jne    c0024f92 <serial_init_queue+0x14>
    init_poll ();
c0024f8d:	e8 5c ff ff ff       	call   c0024eee <init_poll>
  ASSERT (mode == POLL);
c0024f92:	a1 00 a3 03 c0       	mov    0xc003a300,%eax
c0024f97:	83 f8 01             	cmp    $0x1,%eax
c0024f9a:	74 1e                	je     c0024fba <serial_init_queue+0x3c>
c0024f9c:	83 ec 0c             	sub    $0xc,%esp
c0024f9f:	68 81 13 03 c0       	push   $0xc0031381
c0024fa4:	68 53 13 03 c0       	push   $0xc0031353
c0024fa9:	68 dc 13 03 c0       	push   $0xc00313dc
c0024fae:	6a 58                	push   $0x58
c0024fb0:	68 6a 13 03 c0       	push   $0xc003136a
c0024fb5:	e8 e3 4b 00 00       	call   c0029b9d <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0024fba:	83 ec 04             	sub    $0x4,%esp
c0024fbd:	68 8e 13 03 c0       	push   $0xc003138e
c0024fc2:	68 bd 52 02 c0       	push   $0xc00252bd
c0024fc7:	6a 24                	push   $0x24
c0024fc9:	e8 e8 cb ff ff       	call   c0021bb6 <intr_register_ext>
c0024fce:	83 c4 10             	add    $0x10,%esp
  mode = QUEUE;
c0024fd1:	c7 05 00 a3 03 c0 02 	movl   $0x2,0xc003a300
c0024fd8:	00 00 00 
  old_level = intr_disable ();
c0024fdb:	e8 b7 c9 ff ff       	call   c0021997 <intr_disable>
c0024fe0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  write_ier ();
c0024fe3:	e8 f5 01 00 00       	call   c00251dd <write_ier>
  intr_set_level (old_level);
c0024fe8:	83 ec 0c             	sub    $0xc,%esp
c0024feb:	ff 75 f4             	pushl  -0xc(%ebp)
c0024fee:	e8 4c c9 ff ff       	call   c002193f <intr_set_level>
c0024ff3:	83 c4 10             	add    $0x10,%esp
}
c0024ff6:	90                   	nop
c0024ff7:	c9                   	leave  
c0024ff8:	c3                   	ret    

c0024ff9 <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c0024ff9:	55                   	push   %ebp
c0024ffa:	89 e5                	mov    %esp,%ebp
c0024ffc:	83 ec 28             	sub    $0x28,%esp
c0024fff:	8b 45 08             	mov    0x8(%ebp),%eax
c0025002:	88 45 e4             	mov    %al,-0x1c(%ebp)
  enum intr_level old_level = intr_disable ();
c0025005:	e8 8d c9 ff ff       	call   c0021997 <intr_disable>
c002500a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (mode != QUEUE)
c002500d:	a1 00 a3 03 c0       	mov    0xc003a300,%eax
c0025012:	83 f8 02             	cmp    $0x2,%eax
c0025015:	74 20                	je     c0025037 <serial_putc+0x3e>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c0025017:	a1 00 a3 03 c0       	mov    0xc003a300,%eax
c002501c:	85 c0                	test   %eax,%eax
c002501e:	75 05                	jne    c0025025 <serial_putc+0x2c>
        init_poll ();
c0025020:	e8 c9 fe ff ff       	call   c0024eee <init_poll>
      putc_poll (byte); 
c0025025:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0025029:	83 ec 0c             	sub    $0xc,%esp
c002502c:	50                   	push   %eax
c002502d:	e8 22 02 00 00       	call   c0025254 <putc_poll>
c0025032:	83 c4 10             	add    $0x10,%esp
c0025035:	eb 53                	jmp    c002508a <serial_putc+0x91>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0025037:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002503b:	75 33                	jne    c0025070 <serial_putc+0x77>
c002503d:	83 ec 0c             	sub    $0xc,%esp
c0025040:	68 20 a3 03 c0       	push   $0xc003a320
c0025045:	e8 83 1b 00 00       	call   c0026bcd <intq_full>
c002504a:	83 c4 10             	add    $0x10,%esp
c002504d:	84 c0                	test   %al,%al
c002504f:	74 1f                	je     c0025070 <serial_putc+0x77>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c0025051:	83 ec 0c             	sub    $0xc,%esp
c0025054:	68 20 a3 03 c0       	push   $0xc003a320
c0025059:	e8 bd 1b 00 00       	call   c0026c1b <intq_getc>
c002505e:	83 c4 10             	add    $0x10,%esp
c0025061:	0f b6 c0             	movzbl %al,%eax
c0025064:	83 ec 0c             	sub    $0xc,%esp
c0025067:	50                   	push   %eax
c0025068:	e8 e7 01 00 00       	call   c0025254 <putc_poll>
c002506d:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c0025070:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0025074:	83 ec 08             	sub    $0x8,%esp
c0025077:	50                   	push   %eax
c0025078:	68 20 a3 03 c0       	push   $0xc003a320
c002507d:	e8 79 1c 00 00       	call   c0026cfb <intq_putc>
c0025082:	83 c4 10             	add    $0x10,%esp
      write_ier ();
c0025085:	e8 53 01 00 00       	call   c00251dd <write_ier>
    }
  
  intr_set_level (old_level);
c002508a:	83 ec 0c             	sub    $0xc,%esp
c002508d:	ff 75 f4             	pushl  -0xc(%ebp)
c0025090:	e8 aa c8 ff ff       	call   c002193f <intr_set_level>
c0025095:	83 c4 10             	add    $0x10,%esp
}
c0025098:	90                   	nop
c0025099:	c9                   	leave  
c002509a:	c3                   	ret    

c002509b <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c002509b:	55                   	push   %ebp
c002509c:	89 e5                	mov    %esp,%ebp
c002509e:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c00250a1:	e8 f1 c8 ff ff       	call   c0021997 <intr_disable>
c00250a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!intq_empty (&txq))
c00250a9:	eb 1f                	jmp    c00250ca <serial_flush+0x2f>
    putc_poll (intq_getc (&txq));
c00250ab:	83 ec 0c             	sub    $0xc,%esp
c00250ae:	68 20 a3 03 c0       	push   $0xc003a320
c00250b3:	e8 63 1b 00 00       	call   c0026c1b <intq_getc>
c00250b8:	83 c4 10             	add    $0x10,%esp
c00250bb:	0f b6 c0             	movzbl %al,%eax
c00250be:	83 ec 0c             	sub    $0xc,%esp
c00250c1:	50                   	push   %eax
c00250c2:	e8 8d 01 00 00       	call   c0025254 <putc_poll>
c00250c7:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c00250ca:	83 ec 0c             	sub    $0xc,%esp
c00250cd:	68 20 a3 03 c0       	push   $0xc003a320
c00250d2:	e8 b6 1a 00 00       	call   c0026b8d <intq_empty>
c00250d7:	83 c4 10             	add    $0x10,%esp
c00250da:	83 f0 01             	xor    $0x1,%eax
c00250dd:	84 c0                	test   %al,%al
c00250df:	75 ca                	jne    c00250ab <serial_flush+0x10>
  intr_set_level (old_level);
c00250e1:	83 ec 0c             	sub    $0xc,%esp
c00250e4:	ff 75 f4             	pushl  -0xc(%ebp)
c00250e7:	e8 53 c8 ff ff       	call   c002193f <intr_set_level>
c00250ec:	83 c4 10             	add    $0x10,%esp
}
c00250ef:	90                   	nop
c00250f0:	c9                   	leave  
c00250f1:	c3                   	ret    

c00250f2 <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c00250f2:	55                   	push   %ebp
c00250f3:	89 e5                	mov    %esp,%ebp
c00250f5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00250f8:	e8 25 c8 ff ff       	call   c0021922 <intr_get_level>
c00250fd:	85 c0                	test   %eax,%eax
c00250ff:	74 21                	je     c0025122 <serial_notify+0x30>
c0025101:	83 ec 0c             	sub    $0xc,%esp
c0025104:	68 95 13 03 c0       	push   $0xc0031395
c0025109:	68 53 13 03 c0       	push   $0xc0031353
c002510e:	68 f0 13 03 c0       	push   $0xc00313f0
c0025113:	68 96 00 00 00       	push   $0x96
c0025118:	68 6a 13 03 c0       	push   $0xc003136a
c002511d:	e8 7b 4a 00 00       	call   c0029b9d <debug_panic>
  if (mode == QUEUE)
c0025122:	a1 00 a3 03 c0       	mov    0xc003a300,%eax
c0025127:	83 f8 02             	cmp    $0x2,%eax
c002512a:	75 05                	jne    c0025131 <serial_notify+0x3f>
    write_ier ();
c002512c:	e8 ac 00 00 00       	call   c00251dd <write_ier>
}
c0025131:	90                   	nop
c0025132:	c9                   	leave  
c0025133:	c3                   	ret    

c0025134 <set_serial>:

/* Configures the serial port for BPS bits per second. */
static void
set_serial (int bps)
{
c0025134:	55                   	push   %ebp
c0025135:	89 e5                	mov    %esp,%ebp
c0025137:	83 ec 18             	sub    $0x18,%esp
  int base_rate = 1843200 / 16;         /* Base rate of 16550A, in Hz. */
c002513a:	c7 45 f4 00 c2 01 00 	movl   $0x1c200,-0xc(%ebp)
  uint16_t divisor = base_rate / bps;   /* Clock rate divisor. */
c0025141:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025144:	99                   	cltd   
c0025145:	f7 7d 08             	idivl  0x8(%ebp)
c0025148:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

  ASSERT (bps >= 300 && bps <= 115200);
c002514c:	81 7d 08 2b 01 00 00 	cmpl   $0x12b,0x8(%ebp)
c0025153:	7e 09                	jle    c002515e <set_serial+0x2a>
c0025155:	81 7d 08 00 c2 01 00 	cmpl   $0x1c200,0x8(%ebp)
c002515c:	7e 21                	jle    c002517f <set_serial+0x4b>
c002515e:	83 ec 0c             	sub    $0xc,%esp
c0025161:	68 b3 13 03 c0       	push   $0xc00313b3
c0025166:	68 53 13 03 c0       	push   $0xc0031353
c002516b:	68 00 14 03 c0       	push   $0xc0031400
c0025170:	68 a2 00 00 00       	push   $0xa2
c0025175:	68 6a 13 03 c0       	push   $0xc003136a
c002517a:	e8 1e 4a 00 00       	call   c0029b9d <debug_panic>

  /* Enable DLAB. */
  outb (LCR_REG, LCR_N81 | LCR_DLAB);
c002517f:	83 ec 08             	sub    $0x8,%esp
c0025182:	68 83 00 00 00       	push   $0x83
c0025187:	68 fb 03 00 00       	push   $0x3fb
c002518c:	e8 40 fd ff ff       	call   c0024ed1 <outb>
c0025191:	83 c4 10             	add    $0x10,%esp

  /* Set data rate. */
  outb (LS_REG, divisor & 0xff);
c0025194:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c0025198:	0f b6 c0             	movzbl %al,%eax
c002519b:	83 ec 08             	sub    $0x8,%esp
c002519e:	50                   	push   %eax
c002519f:	68 f8 03 00 00       	push   $0x3f8
c00251a4:	e8 28 fd ff ff       	call   c0024ed1 <outb>
c00251a9:	83 c4 10             	add    $0x10,%esp
  outb (MS_REG, divisor >> 8);
c00251ac:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c00251b0:	66 c1 e8 08          	shr    $0x8,%ax
c00251b4:	0f b6 c0             	movzbl %al,%eax
c00251b7:	83 ec 08             	sub    $0x8,%esp
c00251ba:	50                   	push   %eax
c00251bb:	68 f9 03 00 00       	push   $0x3f9
c00251c0:	e8 0c fd ff ff       	call   c0024ed1 <outb>
c00251c5:	83 c4 10             	add    $0x10,%esp
  
  /* Reset DLAB. */
  outb (LCR_REG, LCR_N81);
c00251c8:	83 ec 08             	sub    $0x8,%esp
c00251cb:	6a 03                	push   $0x3
c00251cd:	68 fb 03 00 00       	push   $0x3fb
c00251d2:	e8 fa fc ff ff       	call   c0024ed1 <outb>
c00251d7:	83 c4 10             	add    $0x10,%esp
}
c00251da:	90                   	nop
c00251db:	c9                   	leave  
c00251dc:	c3                   	ret    

c00251dd <write_ier>:

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c00251dd:	55                   	push   %ebp
c00251de:	89 e5                	mov    %esp,%ebp
c00251e0:	83 ec 18             	sub    $0x18,%esp
  uint8_t ier = 0;
c00251e3:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c00251e7:	e8 36 c7 ff ff       	call   c0021922 <intr_get_level>
c00251ec:	85 c0                	test   %eax,%eax
c00251ee:	74 21                	je     c0025211 <write_ier+0x34>
c00251f0:	83 ec 0c             	sub    $0xc,%esp
c00251f3:	68 95 13 03 c0       	push   $0xc0031395
c00251f8:	68 53 13 03 c0       	push   $0xc0031353
c00251fd:	68 0c 14 03 c0       	push   $0xc003140c
c0025202:	68 b5 00 00 00       	push   $0xb5
c0025207:	68 6a 13 03 c0       	push   $0xc003136a
c002520c:	e8 8c 49 00 00       	call   c0029b9d <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0025211:	83 ec 0c             	sub    $0xc,%esp
c0025214:	68 20 a3 03 c0       	push   $0xc003a320
c0025219:	e8 6f 19 00 00       	call   c0026b8d <intq_empty>
c002521e:	83 c4 10             	add    $0x10,%esp
c0025221:	83 f0 01             	xor    $0x1,%eax
c0025224:	84 c0                	test   %al,%al
c0025226:	74 04                	je     c002522c <write_ier+0x4f>
    ier |= IER_XMIT;
c0025228:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c002522c:	e8 d9 18 00 00       	call   c0026b0a <input_full>
c0025231:	83 f0 01             	xor    $0x1,%eax
c0025234:	84 c0                	test   %al,%al
c0025236:	74 04                	je     c002523c <write_ier+0x5f>
    ier |= IER_RECV;
c0025238:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
  
  outb (IER_REG, ier);
c002523c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0025240:	83 ec 08             	sub    $0x8,%esp
c0025243:	50                   	push   %eax
c0025244:	68 f9 03 00 00       	push   $0x3f9
c0025249:	e8 83 fc ff ff       	call   c0024ed1 <outb>
c002524e:	83 c4 10             	add    $0x10,%esp
}
c0025251:	90                   	nop
c0025252:	c9                   	leave  
c0025253:	c3                   	ret    

c0025254 <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c0025254:	55                   	push   %ebp
c0025255:	89 e5                	mov    %esp,%ebp
c0025257:	83 ec 18             	sub    $0x18,%esp
c002525a:	8b 45 08             	mov    0x8(%ebp),%eax
c002525d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0025260:	e8 bd c6 ff ff       	call   c0021922 <intr_get_level>
c0025265:	85 c0                	test   %eax,%eax
c0025267:	74 22                	je     c002528b <putc_poll+0x37>
c0025269:	83 ec 0c             	sub    $0xc,%esp
c002526c:	68 95 13 03 c0       	push   $0xc0031395
c0025271:	68 53 13 03 c0       	push   $0xc0031353
c0025276:	68 18 14 03 c0       	push   $0xc0031418
c002527b:	68 c9 00 00 00       	push   $0xc9
c0025280:	68 6a 13 03 c0       	push   $0xc003136a
c0025285:	e8 13 49 00 00       	call   c0029b9d <debug_panic>

  while ((inb (LSR_REG) & LSR_THRE) == 0)
    continue;
c002528a:	90                   	nop
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c002528b:	83 ec 0c             	sub    $0xc,%esp
c002528e:	68 fd 03 00 00       	push   $0x3fd
c0025293:	e8 1e fc ff ff       	call   c0024eb6 <inb>
c0025298:	83 c4 10             	add    $0x10,%esp
c002529b:	0f b6 c0             	movzbl %al,%eax
c002529e:	83 e0 20             	and    $0x20,%eax
c00252a1:	85 c0                	test   %eax,%eax
c00252a3:	74 e5                	je     c002528a <putc_poll+0x36>
  outb (THR_REG, byte);
c00252a5:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00252a9:	83 ec 08             	sub    $0x8,%esp
c00252ac:	50                   	push   %eax
c00252ad:	68 f8 03 00 00       	push   $0x3f8
c00252b2:	e8 1a fc ff ff       	call   c0024ed1 <outb>
c00252b7:	83 c4 10             	add    $0x10,%esp
}
c00252ba:	90                   	nop
c00252bb:	c9                   	leave  
c00252bc:	c3                   	ret    

c00252bd <serial_interrupt>:

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c00252bd:	55                   	push   %ebp
c00252be:	89 e5                	mov    %esp,%ebp
c00252c0:	83 ec 08             	sub    $0x8,%esp
  /* Inquire about interrupt in UART.  Without this, we can
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);
c00252c3:	68 fa 03 00 00       	push   $0x3fa
c00252c8:	e8 e9 fb ff ff       	call   c0024eb6 <inb>
c00252cd:	83 c4 04             	add    $0x4,%esp

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c00252d0:	eb 1c                	jmp    c00252ee <serial_interrupt+0x31>
    input_putc (inb (RBR_REG));
c00252d2:	68 f8 03 00 00       	push   $0x3f8
c00252d7:	e8 da fb ff ff       	call   c0024eb6 <inb>
c00252dc:	83 c4 04             	add    $0x4,%esp
c00252df:	0f b6 c0             	movzbl %al,%eax
c00252e2:	83 ec 0c             	sub    $0xc,%esp
c00252e5:	50                   	push   %eax
c00252e6:	e8 61 17 00 00       	call   c0026a4c <input_putc>
c00252eb:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c00252ee:	e8 17 18 00 00       	call   c0026b0a <input_full>
c00252f3:	83 f0 01             	xor    $0x1,%eax
c00252f6:	84 c0                	test   %al,%al
c00252f8:	74 40                	je     c002533a <serial_interrupt+0x7d>
c00252fa:	83 ec 0c             	sub    $0xc,%esp
c00252fd:	68 fd 03 00 00       	push   $0x3fd
c0025302:	e8 af fb ff ff       	call   c0024eb6 <inb>
c0025307:	83 c4 10             	add    $0x10,%esp
c002530a:	0f b6 c0             	movzbl %al,%eax
c002530d:	83 e0 01             	and    $0x1,%eax
c0025310:	85 c0                	test   %eax,%eax
c0025312:	75 be                	jne    c00252d2 <serial_interrupt+0x15>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0025314:	eb 24                	jmp    c002533a <serial_interrupt+0x7d>
    outb (THR_REG, intq_getc (&txq));
c0025316:	83 ec 0c             	sub    $0xc,%esp
c0025319:	68 20 a3 03 c0       	push   $0xc003a320
c002531e:	e8 f8 18 00 00       	call   c0026c1b <intq_getc>
c0025323:	83 c4 10             	add    $0x10,%esp
c0025326:	0f b6 c0             	movzbl %al,%eax
c0025329:	83 ec 08             	sub    $0x8,%esp
c002532c:	50                   	push   %eax
c002532d:	68 f8 03 00 00       	push   $0x3f8
c0025332:	e8 9a fb ff ff       	call   c0024ed1 <outb>
c0025337:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c002533a:	83 ec 0c             	sub    $0xc,%esp
c002533d:	68 20 a3 03 c0       	push   $0xc003a320
c0025342:	e8 46 18 00 00       	call   c0026b8d <intq_empty>
c0025347:	83 c4 10             	add    $0x10,%esp
c002534a:	83 f0 01             	xor    $0x1,%eax
c002534d:	84 c0                	test   %al,%al
c002534f:	74 1a                	je     c002536b <serial_interrupt+0xae>
c0025351:	83 ec 0c             	sub    $0xc,%esp
c0025354:	68 fd 03 00 00       	push   $0x3fd
c0025359:	e8 58 fb ff ff       	call   c0024eb6 <inb>
c002535e:	83 c4 10             	add    $0x10,%esp
c0025361:	0f b6 c0             	movzbl %al,%eax
c0025364:	83 e0 20             	and    $0x20,%eax
c0025367:	85 c0                	test   %eax,%eax
c0025369:	75 ab                	jne    c0025316 <serial_interrupt+0x59>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c002536b:	e8 6d fe ff ff       	call   c00251dd <write_ier>
}
c0025370:	90                   	nop
c0025371:	c9                   	leave  
c0025372:	c3                   	ret    

c0025373 <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c0025373:	55                   	push   %ebp
c0025374:	89 e5                	mov    %esp,%ebp
c0025376:	83 ec 08             	sub    $0x8,%esp
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c0025379:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
c002537d:	76 1e                	jbe    c002539d <block_type_name+0x2a>
c002537f:	83 ec 0c             	sub    $0xc,%esp
c0025382:	68 24 14 03 c0       	push   $0xc0031424
c0025387:	68 35 14 03 c0       	push   $0xc0031435
c002538c:	68 3c 15 03 c0       	push   $0xc003153c
c0025391:	6a 2f                	push   $0x2f
c0025393:	68 4c 14 03 c0       	push   $0xc003144c
c0025398:	e8 00 48 00 00       	call   c0029b9d <debug_panic>
  return block_type_names[type];
c002539d:	8b 45 08             	mov    0x8(%ebp),%eax
c00253a0:	8b 04 85 9c 85 03 c0 	mov    -0x3ffc7a64(,%eax,4),%eax
}
c00253a7:	c9                   	leave  
c00253a8:	c3                   	ret    

c00253a9 <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c00253a9:	55                   	push   %ebp
c00253aa:	89 e5                	mov    %esp,%ebp
c00253ac:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c00253af:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c00253b3:	76 1e                	jbe    c00253d3 <block_get_role+0x2a>
c00253b5:	83 ec 0c             	sub    $0xc,%esp
c00253b8:	68 62 14 03 c0       	push   $0xc0031462
c00253bd:	68 35 14 03 c0       	push   $0xc0031435
c00253c2:	68 74 15 03 c0       	push   $0xc0031574
c00253c7:	6a 38                	push   $0x38
c00253c9:	68 4c 14 03 c0       	push   $0xc003144c
c00253ce:	e8 ca 47 00 00       	call   c0029b9d <debug_panic>
  return block_by_role[role];
c00253d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00253d6:	8b 04 85 90 a3 03 c0 	mov    -0x3ffc5c70(,%eax,4),%eax
}
c00253dd:	c9                   	leave  
c00253de:	c3                   	ret    

c00253df <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c00253df:	55                   	push   %ebp
c00253e0:	89 e5                	mov    %esp,%ebp
c00253e2:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c00253e5:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c00253e9:	76 1e                	jbe    c0025409 <block_set_role+0x2a>
c00253eb:	83 ec 0c             	sub    $0xc,%esp
c00253ee:	68 62 14 03 c0       	push   $0xc0031462
c00253f3:	68 35 14 03 c0       	push   $0xc0031435
c00253f8:	68 84 15 03 c0       	push   $0xc0031584
c00253fd:	6a 40                	push   $0x40
c00253ff:	68 4c 14 03 c0       	push   $0xc003144c
c0025404:	e8 94 47 00 00       	call   c0029b9d <debug_panic>
  block_by_role[role] = block;
c0025409:	8b 45 08             	mov    0x8(%ebp),%eax
c002540c:	8b 55 0c             	mov    0xc(%ebp),%edx
c002540f:	89 14 85 90 a3 03 c0 	mov    %edx,-0x3ffc5c70(,%eax,4)
}
c0025416:	90                   	nop
c0025417:	c9                   	leave  
c0025418:	c3                   	ret    

c0025419 <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c0025419:	55                   	push   %ebp
c002541a:	89 e5                	mov    %esp,%ebp
c002541c:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c002541f:	83 ec 0c             	sub    $0xc,%esp
c0025422:	68 8c 85 03 c0       	push   $0xc003858c
c0025427:	e8 37 4a 00 00       	call   c0029e63 <list_begin>
c002542c:	83 c4 10             	add    $0x10,%esp
c002542f:	83 ec 0c             	sub    $0xc,%esp
c0025432:	50                   	push   %eax
c0025433:	e8 6a 03 00 00       	call   c00257a2 <list_elem_to_block>
c0025438:	83 c4 10             	add    $0x10,%esp
}
c002543b:	c9                   	leave  
c002543c:	c3                   	ret    

c002543d <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c002543d:	55                   	push   %ebp
c002543e:	89 e5                	mov    %esp,%ebp
c0025440:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c0025443:	8b 45 08             	mov    0x8(%ebp),%eax
c0025446:	83 ec 0c             	sub    $0xc,%esp
c0025449:	50                   	push   %eax
c002544a:	e8 46 4a 00 00       	call   c0029e95 <list_next>
c002544f:	83 c4 10             	add    $0x10,%esp
c0025452:	83 ec 0c             	sub    $0xc,%esp
c0025455:	50                   	push   %eax
c0025456:	e8 47 03 00 00       	call   c00257a2 <list_elem_to_block>
c002545b:	83 c4 10             	add    $0x10,%esp
}
c002545e:	c9                   	leave  
c002545f:	c3                   	ret    

c0025460 <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c0025460:	55                   	push   %ebp
c0025461:	89 e5                	mov    %esp,%ebp
c0025463:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0025466:	83 ec 0c             	sub    $0xc,%esp
c0025469:	68 8c 85 03 c0       	push   $0xc003858c
c002546e:	e8 f0 49 00 00       	call   c0029e63 <list_begin>
c0025473:	83 c4 10             	add    $0x10,%esp
c0025476:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0025479:	eb 3b                	jmp    c00254b6 <block_get_by_name+0x56>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
c002547b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002547e:	83 c0 04             	add    $0x4,%eax
c0025481:	83 e8 04             	sub    $0x4,%eax
c0025484:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!strcmp (name, block->name))
c0025487:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002548a:	83 c0 08             	add    $0x8,%eax
c002548d:	83 ec 08             	sub    $0x8,%esp
c0025490:	50                   	push   %eax
c0025491:	ff 75 08             	pushl  0x8(%ebp)
c0025494:	e8 41 37 00 00       	call   c0028bda <strcmp>
c0025499:	83 c4 10             	add    $0x10,%esp
c002549c:	85 c0                	test   %eax,%eax
c002549e:	75 05                	jne    c00254a5 <block_get_by_name+0x45>
        return block;
c00254a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00254a3:	eb 2b                	jmp    c00254d0 <block_get_by_name+0x70>
       e = list_next (e))
c00254a5:	83 ec 0c             	sub    $0xc,%esp
c00254a8:	ff 75 f4             	pushl  -0xc(%ebp)
c00254ab:	e8 e5 49 00 00       	call   c0029e95 <list_next>
c00254b0:	83 c4 10             	add    $0x10,%esp
c00254b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c00254b6:	83 ec 0c             	sub    $0xc,%esp
c00254b9:	68 8c 85 03 c0       	push   $0xc003858c
c00254be:	e8 1c 4a 00 00       	call   c0029edf <list_end>
c00254c3:	83 c4 10             	add    $0x10,%esp
c00254c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00254c9:	75 b0                	jne    c002547b <block_get_by_name+0x1b>
    }

  return NULL;
c00254cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00254d0:	c9                   	leave  
c00254d1:	c3                   	ret    

c00254d2 <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c00254d2:	55                   	push   %ebp
c00254d3:	89 e5                	mov    %esp,%ebp
c00254d5:	53                   	push   %ebx
c00254d6:	83 ec 04             	sub    $0x4,%esp
  if (sector >= block->size)
c00254d9:	8b 45 08             	mov    0x8(%ebp),%eax
c00254dc:	8b 40 1c             	mov    0x1c(%eax),%eax
c00254df:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00254e2:	77 32                	ja     c0025516 <check_sector+0x44>
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c00254e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00254e7:	8b 58 1c             	mov    0x1c(%eax),%ebx
c00254ea:	83 ec 0c             	sub    $0xc,%esp
c00254ed:	ff 75 08             	pushl  0x8(%ebp)
c00254f0:	e8 fd 00 00 00       	call   c00255f2 <block_name>
c00254f5:	83 c4 10             	add    $0x10,%esp
c00254f8:	83 ec 04             	sub    $0x4,%esp
c00254fb:	53                   	push   %ebx
c00254fc:	ff 75 0c             	pushl  0xc(%ebp)
c00254ff:	50                   	push   %eax
c0025500:	68 78 14 03 c0       	push   $0xc0031478
c0025505:	68 94 15 03 c0       	push   $0xc0031594
c002550a:	6a 70                	push   $0x70
c002550c:	68 4c 14 03 c0       	push   $0xc003144c
c0025511:	e8 87 46 00 00       	call   c0029b9d <debug_panic>
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c0025516:	90                   	nop
c0025517:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002551a:	c9                   	leave  
c002551b:	c3                   	ret    

c002551c <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c002551c:	55                   	push   %ebp
c002551d:	89 e5                	mov    %esp,%ebp
c002551f:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0025522:	83 ec 08             	sub    $0x8,%esp
c0025525:	ff 75 0c             	pushl  0xc(%ebp)
c0025528:	ff 75 08             	pushl  0x8(%ebp)
c002552b:	e8 a2 ff ff ff       	call   c00254d2 <check_sector>
c0025530:	83 c4 10             	add    $0x10,%esp
  block->ops->read (block->aux, sector, buffer);
c0025533:	8b 45 08             	mov    0x8(%ebp),%eax
c0025536:	8b 40 20             	mov    0x20(%eax),%eax
c0025539:	8b 00                	mov    (%eax),%eax
c002553b:	8b 55 08             	mov    0x8(%ebp),%edx
c002553e:	8b 52 24             	mov    0x24(%edx),%edx
c0025541:	83 ec 04             	sub    $0x4,%esp
c0025544:	ff 75 10             	pushl  0x10(%ebp)
c0025547:	ff 75 0c             	pushl  0xc(%ebp)
c002554a:	52                   	push   %edx
c002554b:	ff d0                	call   *%eax
c002554d:	83 c4 10             	add    $0x10,%esp
  block->read_cnt++;
c0025550:	8b 45 08             	mov    0x8(%ebp),%eax
c0025553:	8b 50 2c             	mov    0x2c(%eax),%edx
c0025556:	8b 40 28             	mov    0x28(%eax),%eax
c0025559:	83 c0 01             	add    $0x1,%eax
c002555c:	83 d2 00             	adc    $0x0,%edx
c002555f:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0025562:	89 41 28             	mov    %eax,0x28(%ecx)
c0025565:	89 51 2c             	mov    %edx,0x2c(%ecx)
}
c0025568:	90                   	nop
c0025569:	c9                   	leave  
c002556a:	c3                   	ret    

c002556b <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c002556b:	55                   	push   %ebp
c002556c:	89 e5                	mov    %esp,%ebp
c002556e:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0025571:	83 ec 08             	sub    $0x8,%esp
c0025574:	ff 75 0c             	pushl  0xc(%ebp)
c0025577:	ff 75 08             	pushl  0x8(%ebp)
c002557a:	e8 53 ff ff ff       	call   c00254d2 <check_sector>
c002557f:	83 c4 10             	add    $0x10,%esp
  ASSERT (block->type != BLOCK_FOREIGN);
c0025582:	8b 45 08             	mov    0x8(%ebp),%eax
c0025585:	8b 40 18             	mov    0x18(%eax),%eax
c0025588:	83 f8 05             	cmp    $0x5,%eax
c002558b:	75 21                	jne    c00255ae <block_write+0x43>
c002558d:	83 ec 0c             	sub    $0xc,%esp
c0025590:	68 ab 14 03 c0       	push   $0xc00314ab
c0025595:	68 35 14 03 c0       	push   $0xc0031435
c002559a:	68 a4 15 03 c0       	push   $0xc00315a4
c002559f:	68 89 00 00 00       	push   $0x89
c00255a4:	68 4c 14 03 c0       	push   $0xc003144c
c00255a9:	e8 ef 45 00 00       	call   c0029b9d <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c00255ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00255b1:	8b 40 20             	mov    0x20(%eax),%eax
c00255b4:	8b 40 04             	mov    0x4(%eax),%eax
c00255b7:	8b 55 08             	mov    0x8(%ebp),%edx
c00255ba:	8b 52 24             	mov    0x24(%edx),%edx
c00255bd:	83 ec 04             	sub    $0x4,%esp
c00255c0:	ff 75 10             	pushl  0x10(%ebp)
c00255c3:	ff 75 0c             	pushl  0xc(%ebp)
c00255c6:	52                   	push   %edx
c00255c7:	ff d0                	call   *%eax
c00255c9:	83 c4 10             	add    $0x10,%esp
  block->write_cnt++;
c00255cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00255cf:	8b 50 34             	mov    0x34(%eax),%edx
c00255d2:	8b 40 30             	mov    0x30(%eax),%eax
c00255d5:	83 c0 01             	add    $0x1,%eax
c00255d8:	83 d2 00             	adc    $0x0,%edx
c00255db:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00255de:	89 41 30             	mov    %eax,0x30(%ecx)
c00255e1:	89 51 34             	mov    %edx,0x34(%ecx)
}
c00255e4:	90                   	nop
c00255e5:	c9                   	leave  
c00255e6:	c3                   	ret    

c00255e7 <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
c00255e7:	55                   	push   %ebp
c00255e8:	89 e5                	mov    %esp,%ebp
  return block->size;
c00255ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00255ed:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c00255f0:	5d                   	pop    %ebp
c00255f1:	c3                   	ret    

c00255f2 <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
c00255f2:	55                   	push   %ebp
c00255f3:	89 e5                	mov    %esp,%ebp
  return block->name;
c00255f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00255f8:	83 c0 08             	add    $0x8,%eax
}
c00255fb:	5d                   	pop    %ebp
c00255fc:	c3                   	ret    

c00255fd <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
c00255fd:	55                   	push   %ebp
c00255fe:	89 e5                	mov    %esp,%ebp
  return block->type;
c0025600:	8b 45 08             	mov    0x8(%ebp),%eax
c0025603:	8b 40 18             	mov    0x18(%eax),%eax
}
c0025606:	5d                   	pop    %ebp
c0025607:	c3                   	ret    

c0025608 <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c0025608:	55                   	push   %ebp
c0025609:	89 e5                	mov    %esp,%ebp
c002560b:	56                   	push   %esi
c002560c:	53                   	push   %ebx
c002560d:	83 ec 20             	sub    $0x20,%esp
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0025610:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025617:	eb 60                	jmp    c0025679 <block_print_stats+0x71>
    {
      struct block *block = block_by_role[i];
c0025619:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002561c:	8b 04 85 90 a3 03 c0 	mov    -0x3ffc5c70(,%eax,4),%eax
c0025623:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (block != NULL)
c0025626:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002562a:	74 4a                	je     c0025676 <block_print_stats+0x6e>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c002562c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002562f:	8b 50 34             	mov    0x34(%eax),%edx
c0025632:	8b 40 30             	mov    0x30(%eax),%eax
c0025635:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0025638:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002563b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002563e:	8b 58 28             	mov    0x28(%eax),%ebx
c0025641:	8b 70 2c             	mov    0x2c(%eax),%esi
c0025644:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025647:	8b 40 18             	mov    0x18(%eax),%eax
c002564a:	83 ec 0c             	sub    $0xc,%esp
c002564d:	50                   	push   %eax
c002564e:	e8 20 fd ff ff       	call   c0025373 <block_type_name>
c0025653:	83 c4 10             	add    $0x10,%esp
                  block->name, block_type_name (block->type),
c0025656:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025659:	83 c2 08             	add    $0x8,%edx
          printf ("%s (%s): %llu reads, %llu writes\n",
c002565c:	83 ec 04             	sub    $0x4,%esp
c002565f:	ff 75 e4             	pushl  -0x1c(%ebp)
c0025662:	ff 75 e0             	pushl  -0x20(%ebp)
c0025665:	56                   	push   %esi
c0025666:	53                   	push   %ebx
c0025667:	50                   	push   %eax
c0025668:	52                   	push   %edx
c0025669:	68 c8 14 03 c0       	push   $0xc00314c8
c002566e:	e8 6b 21 00 00       	call   c00277de <printf>
c0025673:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0025676:	ff 45 f4             	incl   -0xc(%ebp)
c0025679:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002567d:	7e 9a                	jle    c0025619 <block_print_stats+0x11>
                  block->read_cnt, block->write_cnt);
        }
    }
}
c002567f:	90                   	nop
c0025680:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025683:	5b                   	pop    %ebx
c0025684:	5e                   	pop    %esi
c0025685:	5d                   	pop    %ebp
c0025686:	c3                   	ret    

c0025687 <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c0025687:	55                   	push   %ebp
c0025688:	89 e5                	mov    %esp,%ebp
c002568a:	83 ec 18             	sub    $0x18,%esp
  struct block *block = malloc (sizeof *block);
c002568d:	83 ec 0c             	sub    $0xc,%esp
c0025690:	6a 38                	push   $0x38
c0025692:	e8 23 e4 ff ff       	call   c0023aba <malloc>
c0025697:	83 c4 10             	add    $0x10,%esp
c002569a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (block == NULL)
c002569d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00256a1:	75 19                	jne    c00256bc <block_register+0x35>
    PANIC ("Failed to allocate memory for block device descriptor");
c00256a3:	68 ec 14 03 c0       	push   $0xc00314ec
c00256a8:	68 b0 15 03 c0       	push   $0xc00315b0
c00256ad:	68 c1 00 00 00       	push   $0xc1
c00256b2:	68 4c 14 03 c0       	push   $0xc003144c
c00256b7:	e8 e1 44 00 00       	call   c0029b9d <debug_panic>

  list_push_back (&all_blocks, &block->list_elem);
c00256bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256bf:	83 ec 08             	sub    $0x8,%esp
c00256c2:	50                   	push   %eax
c00256c3:	68 8c 85 03 c0       	push   $0xc003858c
c00256c8:	e8 21 4b 00 00       	call   c002a1ee <list_push_back>
c00256cd:	83 c4 10             	add    $0x10,%esp
  strlcpy (block->name, name, sizeof block->name);
c00256d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256d3:	83 c0 08             	add    $0x8,%eax
c00256d6:	83 ec 04             	sub    $0x4,%esp
c00256d9:	6a 10                	push   $0x10
c00256db:	ff 75 08             	pushl  0x8(%ebp)
c00256de:	50                   	push   %eax
c00256df:	e8 a6 39 00 00       	call   c002908a <strlcpy>
c00256e4:	83 c4 10             	add    $0x10,%esp
  block->type = type;
c00256e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256ea:	8b 55 0c             	mov    0xc(%ebp),%edx
c00256ed:	89 50 18             	mov    %edx,0x18(%eax)
  block->size = size;
c00256f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256f3:	8b 55 14             	mov    0x14(%ebp),%edx
c00256f6:	89 50 1c             	mov    %edx,0x1c(%eax)
  block->ops = ops;
c00256f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256fc:	8b 55 18             	mov    0x18(%ebp),%edx
c00256ff:	89 50 20             	mov    %edx,0x20(%eax)
  block->aux = aux;
c0025702:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025705:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0025708:	89 50 24             	mov    %edx,0x24(%eax)
  block->read_cnt = 0;
c002570b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002570e:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0025715:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  block->write_cnt = 0;
c002571c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002571f:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
c0025726:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c002572d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025730:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025733:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025736:	83 c2 08             	add    $0x8,%edx
c0025739:	83 ec 04             	sub    $0x4,%esp
c002573c:	50                   	push   %eax
c002573d:	52                   	push   %edx
c002573e:	68 22 15 03 c0       	push   $0xc0031522
c0025743:	e8 96 20 00 00       	call   c00277de <printf>
c0025748:	83 c4 10             	add    $0x10,%esp
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c002574b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002574e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025751:	ba 00 00 00 00       	mov    $0x0,%edx
c0025756:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c002575a:	c1 e0 09             	shl    $0x9,%eax
c002575d:	83 ec 08             	sub    $0x8,%esp
c0025760:	52                   	push   %edx
c0025761:	50                   	push   %eax
c0025762:	e8 8d 2d 00 00       	call   c00284f4 <print_human_readable_size>
c0025767:	83 c4 10             	add    $0x10,%esp
  printf (")");
c002576a:	83 ec 0c             	sub    $0xc,%esp
c002576d:	6a 29                	push   $0x29
c002576f:	e8 80 67 00 00       	call   c002bef4 <putchar>
c0025774:	83 c4 10             	add    $0x10,%esp
  if (extra_info != NULL)
c0025777:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002577b:	74 13                	je     c0025790 <block_register+0x109>
    printf (", %s", extra_info);
c002577d:	83 ec 08             	sub    $0x8,%esp
c0025780:	ff 75 10             	pushl  0x10(%ebp)
c0025783:	68 34 15 03 c0       	push   $0xc0031534
c0025788:	e8 51 20 00 00       	call   c00277de <printf>
c002578d:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0025790:	83 ec 0c             	sub    $0xc,%esp
c0025793:	6a 0a                	push   $0xa
c0025795:	e8 5a 67 00 00       	call   c002bef4 <putchar>
c002579a:	83 c4 10             	add    $0x10,%esp

  return block;
c002579d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00257a0:	c9                   	leave  
c00257a1:	c3                   	ret    

c00257a2 <list_elem_to_block>:

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
c00257a2:	55                   	push   %ebp
c00257a3:	89 e5                	mov    %esp,%ebp
c00257a5:	83 ec 08             	sub    $0x8,%esp
  return (list_elem != list_end (&all_blocks)
c00257a8:	83 ec 0c             	sub    $0xc,%esp
c00257ab:	68 8c 85 03 c0       	push   $0xc003858c
c00257b0:	e8 2a 47 00 00       	call   c0029edf <list_end>
c00257b5:	83 c4 10             	add    $0x10,%esp
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c00257b8:	3b 45 08             	cmp    0x8(%ebp),%eax
c00257bb:	74 0b                	je     c00257c8 <list_elem_to_block+0x26>
          ? list_entry (list_elem, struct block, list_elem)
c00257bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00257c0:	83 c0 04             	add    $0x4,%eax
          : NULL);
c00257c3:	83 e8 04             	sub    $0x4,%eax
c00257c6:	eb 05                	jmp    c00257cd <list_elem_to_block+0x2b>
c00257c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00257cd:	c9                   	leave  
c00257ce:	c3                   	ret    

c00257cf <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c00257cf:	55                   	push   %ebp
c00257d0:	89 e5                	mov    %esp,%ebp
c00257d2:	83 ec 18             	sub    $0x18,%esp
  int part_nr = 0;
c00257d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  read_partition_table (block, 0, 0, &part_nr);
c00257dc:	8d 45 f4             	lea    -0xc(%ebp),%eax
c00257df:	50                   	push   %eax
c00257e0:	6a 00                	push   $0x0
c00257e2:	6a 00                	push   $0x0
c00257e4:	ff 75 08             	pushl  0x8(%ebp)
c00257e7:	e8 2c 00 00 00       	call   c0025818 <read_partition_table>
c00257ec:	83 c4 10             	add    $0x10,%esp
  if (part_nr == 0)
c00257ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00257f2:	85 c0                	test   %eax,%eax
c00257f4:	75 1f                	jne    c0025815 <partition_scan+0x46>
    printf ("%s: Device contains no partitions\n", block_name (block));
c00257f6:	83 ec 0c             	sub    $0xc,%esp
c00257f9:	ff 75 08             	pushl  0x8(%ebp)
c00257fc:	e8 f1 fd ff ff       	call   c00255f2 <block_name>
c0025801:	83 c4 10             	add    $0x10,%esp
c0025804:	83 ec 08             	sub    $0x8,%esp
c0025807:	50                   	push   %eax
c0025808:	68 c0 15 03 c0       	push   $0xc00315c0
c002580d:	e8 cc 1f 00 00       	call   c00277de <printf>
c0025812:	83 c4 10             	add    $0x10,%esp
}
c0025815:	90                   	nop
c0025816:	c9                   	leave  
c0025817:	c3                   	ret    

c0025818 <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c0025818:	55                   	push   %ebp
c0025819:	89 e5                	mov    %esp,%ebp
c002581b:	53                   	push   %ebx
c002581c:	83 ec 14             	sub    $0x14,%esp

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c002581f:	83 ec 0c             	sub    $0xc,%esp
c0025822:	ff 75 08             	pushl  0x8(%ebp)
c0025825:	e8 bd fd ff ff       	call   c00255e7 <block_size>
c002582a:	83 c4 10             	add    $0x10,%esp
c002582d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025830:	77 27                	ja     c0025859 <read_partition_table+0x41>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0025832:	83 ec 0c             	sub    $0xc,%esp
c0025835:	ff 75 08             	pushl  0x8(%ebp)
c0025838:	e8 b5 fd ff ff       	call   c00255f2 <block_name>
c002583d:	83 c4 10             	add    $0x10,%esp
c0025840:	83 ec 04             	sub    $0x4,%esp
c0025843:	ff 75 0c             	pushl  0xc(%ebp)
c0025846:	50                   	push   %eax
c0025847:	68 e4 15 03 c0       	push   $0xc00315e4
c002584c:	e8 8d 1f 00 00       	call   c00277de <printf>
c0025851:	83 c4 10             	add    $0x10,%esp
              block_name (block), sector);
      return;
c0025854:	e9 d2 01 00 00       	jmp    c0025a2b <read_partition_table+0x213>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c0025859:	83 ec 0c             	sub    $0xc,%esp
c002585c:	68 00 02 00 00       	push   $0x200
c0025861:	e8 54 e2 ff ff       	call   c0023aba <malloc>
c0025866:	83 c4 10             	add    $0x10,%esp
c0025869:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pt == NULL)
c002586c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025870:	75 16                	jne    c0025888 <read_partition_table+0x70>
    PANIC ("Failed to allocate memory for partition table.");
c0025872:	68 1c 16 03 c0       	push   $0xc003161c
c0025877:	68 a4 17 03 c0       	push   $0xc00317a4
c002587c:	6a 5a                	push   $0x5a
c002587e:	68 4b 16 03 c0       	push   $0xc003164b
c0025883:	e8 15 43 00 00       	call   c0029b9d <debug_panic>
  block_read (block, 0, pt);
c0025888:	83 ec 04             	sub    $0x4,%esp
c002588b:	ff 75 f0             	pushl  -0x10(%ebp)
c002588e:	6a 00                	push   $0x0
c0025890:	ff 75 08             	pushl  0x8(%ebp)
c0025893:	e8 84 fc ff ff       	call   c002551c <block_read>
c0025898:	83 c4 10             	add    $0x10,%esp

  /* Check signature. */
  if (pt->signature != 0xaa55)
c002589b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002589e:	66 8b 80 fe 01 00 00 	mov    0x1fe(%eax),%ax
c00258a5:	66 3d 55 aa          	cmp    $0xaa55,%ax
c00258a9:	74 5c                	je     c0025907 <read_partition_table+0xef>
    {
      if (primary_extended_sector == 0)
c00258ab:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00258af:	75 21                	jne    c00258d2 <read_partition_table+0xba>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c00258b1:	83 ec 0c             	sub    $0xc,%esp
c00258b4:	ff 75 08             	pushl  0x8(%ebp)
c00258b7:	e8 36 fd ff ff       	call   c00255f2 <block_name>
c00258bc:	83 c4 10             	add    $0x10,%esp
c00258bf:	83 ec 08             	sub    $0x8,%esp
c00258c2:	50                   	push   %eax
c00258c3:	68 68 16 03 c0       	push   $0xc0031668
c00258c8:	e8 11 1f 00 00       	call   c00277de <printf>
c00258cd:	83 c4 10             	add    $0x10,%esp
c00258d0:	eb 22                	jmp    c00258f4 <read_partition_table+0xdc>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c00258d2:	83 ec 0c             	sub    $0xc,%esp
c00258d5:	ff 75 08             	pushl  0x8(%ebp)
c00258d8:	e8 15 fd ff ff       	call   c00255f2 <block_name>
c00258dd:	83 c4 10             	add    $0x10,%esp
c00258e0:	83 ec 04             	sub    $0x4,%esp
c00258e3:	ff 75 0c             	pushl  0xc(%ebp)
c00258e6:	50                   	push   %eax
c00258e7:	68 90 16 03 c0       	push   $0xc0031690
c00258ec:	e8 ed 1e 00 00       	call   c00277de <printf>
c00258f1:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c00258f4:	83 ec 0c             	sub    $0xc,%esp
c00258f7:	ff 75 f0             	pushl  -0x10(%ebp)
c00258fa:	e8 bd e4 ff ff       	call   c0023dbc <free>
c00258ff:	83 c4 10             	add    $0x10,%esp
      return;
c0025902:	e9 24 01 00 00       	jmp    c0025a2b <read_partition_table+0x213>
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025907:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002590e:	e9 00 01 00 00       	jmp    c0025a13 <read_partition_table+0x1fb>
    {
      struct partition_table_entry *e = &pt->partitions[i];
c0025913:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025916:	83 c0 1b             	add    $0x1b,%eax
c0025919:	c1 e0 04             	shl    $0x4,%eax
c002591c:	89 c2                	mov    %eax,%edx
c002591e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025921:	01 d0                	add    %edx,%eax
c0025923:	83 c0 0e             	add    $0xe,%eax
c0025926:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (e->size == 0 || e->type == 0)
c0025929:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002592c:	8b 40 0c             	mov    0xc(%eax),%eax
c002592f:	85 c0                	test   %eax,%eax
c0025931:	0f 84 d9 00 00 00    	je     c0025a10 <read_partition_table+0x1f8>
c0025937:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002593a:	8a 40 04             	mov    0x4(%eax),%al
c002593d:	84 c0                	test   %al,%al
c002593f:	0f 84 cb 00 00 00    	je     c0025a10 <read_partition_table+0x1f8>
        {
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
c0025945:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025948:	8a 40 04             	mov    0x4(%eax),%al
c002594b:	3c 05                	cmp    $0x5,%al
c002594d:	74 1e                	je     c002596d <read_partition_table+0x155>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c002594f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025952:	8a 40 04             	mov    0x4(%eax),%al
c0025955:	3c 0f                	cmp    $0xf,%al
c0025957:	74 14                	je     c002596d <read_partition_table+0x155>
               || e->type == 0x85    /* Linux extended partition. */
c0025959:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002595c:	8a 40 04             	mov    0x4(%eax),%al
c002595f:	3c 85                	cmp    $0x85,%al
c0025961:	74 0a                	je     c002596d <read_partition_table+0x155>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025963:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025966:	8a 40 04             	mov    0x4(%eax),%al
c0025969:	3c c5                	cmp    $0xc5,%al
c002596b:	75 65                	jne    c00259d2 <read_partition_table+0x1ba>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c002596d:	83 ec 0c             	sub    $0xc,%esp
c0025970:	ff 75 08             	pushl  0x8(%ebp)
c0025973:	e8 7a fc ff ff       	call   c00255f2 <block_name>
c0025978:	83 c4 10             	add    $0x10,%esp
c002597b:	83 ec 04             	sub    $0x4,%esp
c002597e:	ff 75 0c             	pushl  0xc(%ebp)
c0025981:	50                   	push   %eax
c0025982:	68 c4 16 03 c0       	push   $0xc00316c4
c0025987:	e8 52 1e 00 00       	call   c00277de <printf>
c002598c:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c002598f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0025993:	75 1e                	jne    c00259b3 <read_partition_table+0x19b>
            read_partition_table (block, e->offset, e->offset, part_nr);
c0025995:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025998:	8b 50 08             	mov    0x8(%eax),%edx
c002599b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002599e:	8b 40 08             	mov    0x8(%eax),%eax
c00259a1:	ff 75 14             	pushl  0x14(%ebp)
c00259a4:	52                   	push   %edx
c00259a5:	50                   	push   %eax
c00259a6:	ff 75 08             	pushl  0x8(%ebp)
c00259a9:	e8 6a fe ff ff       	call   c0025818 <read_partition_table>
c00259ae:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c00259b1:	eb 5d                	jmp    c0025a10 <read_partition_table+0x1f8>
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c00259b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259b6:	8b 50 08             	mov    0x8(%eax),%edx
c00259b9:	8b 45 10             	mov    0x10(%ebp),%eax
c00259bc:	01 d0                	add    %edx,%eax
c00259be:	ff 75 14             	pushl  0x14(%ebp)
c00259c1:	ff 75 10             	pushl  0x10(%ebp)
c00259c4:	50                   	push   %eax
c00259c5:	ff 75 08             	pushl  0x8(%ebp)
c00259c8:	e8 4b fe ff ff       	call   c0025818 <read_partition_table>
c00259cd:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c00259d0:	eb 3e                	jmp    c0025a10 <read_partition_table+0x1f8>
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c00259d2:	8b 45 14             	mov    0x14(%ebp),%eax
c00259d5:	8b 00                	mov    (%eax),%eax
c00259d7:	8d 50 01             	lea    0x1(%eax),%edx
c00259da:	8b 45 14             	mov    0x14(%ebp),%eax
c00259dd:	89 10                	mov    %edx,(%eax)

          found_partition (block, e->type, e->offset + sector,
c00259df:	8b 45 14             	mov    0x14(%ebp),%eax
c00259e2:	8b 08                	mov    (%eax),%ecx
c00259e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259e7:	8b 50 0c             	mov    0xc(%eax),%edx
c00259ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259ed:	8b 58 08             	mov    0x8(%eax),%ebx
c00259f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00259f3:	01 c3                	add    %eax,%ebx
c00259f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259f8:	8a 40 04             	mov    0x4(%eax),%al
c00259fb:	0f b6 c0             	movzbl %al,%eax
c00259fe:	83 ec 0c             	sub    $0xc,%esp
c0025a01:	51                   	push   %ecx
c0025a02:	52                   	push   %edx
c0025a03:	53                   	push   %ebx
c0025a04:	50                   	push   %eax
c0025a05:	ff 75 08             	pushl  0x8(%ebp)
c0025a08:	e8 23 00 00 00       	call   c0025a30 <found_partition>
c0025a0d:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025a10:	ff 45 f4             	incl   -0xc(%ebp)
c0025a13:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0025a17:	0f 86 f6 fe ff ff    	jbe    c0025913 <read_partition_table+0xfb>
                           e->size, *part_nr);
        }
    }

  free (pt);
c0025a1d:	83 ec 0c             	sub    $0xc,%esp
c0025a20:	ff 75 f0             	pushl  -0x10(%ebp)
c0025a23:	e8 94 e3 ff ff       	call   c0023dbc <free>
c0025a28:	83 c4 10             	add    $0x10,%esp
}
c0025a2b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025a2e:	c9                   	leave  
c0025a2f:	c3                   	ret    

c0025a30 <found_partition>:
   if so then add it to the proper element of partitions[]. */
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
c0025a30:	55                   	push   %ebp
c0025a31:	89 e5                	mov    %esp,%ebp
c0025a33:	56                   	push   %esi
c0025a34:	53                   	push   %ebx
c0025a35:	81 ec b0 00 00 00    	sub    $0xb0,%esp
c0025a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025a3e:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
  if (start >= block_size (block))
c0025a44:	83 ec 0c             	sub    $0xc,%esp
c0025a47:	ff 75 08             	pushl  0x8(%ebp)
c0025a4a:	e8 98 fb ff ff       	call   c00255e7 <block_size>
c0025a4f:	83 c4 10             	add    $0x10,%esp
c0025a52:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025a55:	77 27                	ja     c0025a7e <found_partition+0x4e>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025a57:	83 ec 0c             	sub    $0xc,%esp
c0025a5a:	ff 75 08             	pushl  0x8(%ebp)
c0025a5d:	e8 90 fb ff ff       	call   c00255f2 <block_name>
c0025a62:	83 c4 10             	add    $0x10,%esp
c0025a65:	ff 75 10             	pushl  0x10(%ebp)
c0025a68:	ff 75 18             	pushl  0x18(%ebp)
c0025a6b:	50                   	push   %eax
c0025a6c:	68 ec 16 03 c0       	push   $0xc00316ec
c0025a71:	e8 68 1d 00 00       	call   c00277de <printf>
c0025a76:	83 c4 10             	add    $0x10,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c0025a79:	e9 76 01 00 00       	jmp    c0025bf4 <found_partition+0x1c4>
  else if (start + size < start || start + size > block_size (block))
c0025a7e:	8b 55 10             	mov    0x10(%ebp),%edx
c0025a81:	8b 45 14             	mov    0x14(%ebp),%eax
c0025a84:	01 d0                	add    %edx,%eax
c0025a86:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025a89:	72 1b                	jb     c0025aa6 <found_partition+0x76>
c0025a8b:	8b 55 10             	mov    0x10(%ebp),%edx
c0025a8e:	8b 45 14             	mov    0x14(%ebp),%eax
c0025a91:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0025a94:	83 ec 0c             	sub    $0xc,%esp
c0025a97:	ff 75 08             	pushl  0x8(%ebp)
c0025a9a:	e8 48 fb ff ff       	call   c00255e7 <block_size>
c0025a9f:	83 c4 10             	add    $0x10,%esp
c0025aa2:	39 c3                	cmp    %eax,%ebx
c0025aa4:	76 42                	jbe    c0025ae8 <found_partition+0xb8>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0025aa6:	83 ec 0c             	sub    $0xc,%esp
c0025aa9:	ff 75 08             	pushl  0x8(%ebp)
c0025aac:	e8 36 fb ff ff       	call   c00255e7 <block_size>
c0025ab1:	83 c4 10             	add    $0x10,%esp
c0025ab4:	89 c3                	mov    %eax,%ebx
c0025ab6:	8b 55 10             	mov    0x10(%ebp),%edx
c0025ab9:	8b 45 14             	mov    0x14(%ebp),%eax
c0025abc:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0025abf:	83 ec 0c             	sub    $0xc,%esp
c0025ac2:	ff 75 08             	pushl  0x8(%ebp)
c0025ac5:	e8 28 fb ff ff       	call   c00255f2 <block_name>
c0025aca:	83 c4 10             	add    $0x10,%esp
c0025acd:	83 ec 0c             	sub    $0xc,%esp
c0025ad0:	53                   	push   %ebx
c0025ad1:	56                   	push   %esi
c0025ad2:	ff 75 18             	pushl  0x18(%ebp)
c0025ad5:	50                   	push   %eax
c0025ad6:	68 24 17 03 c0       	push   $0xc0031724
c0025adb:	e8 fe 1c 00 00       	call   c00277de <printf>
c0025ae0:	83 c4 20             	add    $0x20,%esp
}
c0025ae3:	e9 0c 01 00 00       	jmp    c0025bf4 <found_partition+0x1c4>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025ae8:	80 bd 54 ff ff ff 20 	cmpb   $0x20,-0xac(%ebp)
c0025aef:	74 37                	je     c0025b28 <found_partition+0xf8>
c0025af1:	80 bd 54 ff ff ff 21 	cmpb   $0x21,-0xac(%ebp)
c0025af8:	74 27                	je     c0025b21 <found_partition+0xf1>
c0025afa:	80 bd 54 ff ff ff 22 	cmpb   $0x22,-0xac(%ebp)
c0025b01:	74 17                	je     c0025b1a <found_partition+0xea>
c0025b03:	80 bd 54 ff ff ff 23 	cmpb   $0x23,-0xac(%ebp)
c0025b0a:	75 07                	jne    c0025b13 <found_partition+0xe3>
c0025b0c:	b8 03 00 00 00       	mov    $0x3,%eax
c0025b11:	eb 1a                	jmp    c0025b2d <found_partition+0xfd>
c0025b13:	b8 05 00 00 00       	mov    $0x5,%eax
c0025b18:	eb 13                	jmp    c0025b2d <found_partition+0xfd>
c0025b1a:	b8 02 00 00 00       	mov    $0x2,%eax
c0025b1f:	eb 0c                	jmp    c0025b2d <found_partition+0xfd>
c0025b21:	b8 01 00 00 00       	mov    $0x1,%eax
c0025b26:	eb 05                	jmp    c0025b2d <found_partition+0xfd>
c0025b28:	b8 00 00 00 00       	mov    $0x0,%eax
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c0025b2d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      p = malloc (sizeof *p);
c0025b30:	83 ec 0c             	sub    $0xc,%esp
c0025b33:	6a 08                	push   $0x8
c0025b35:	e8 80 df ff ff       	call   c0023aba <malloc>
c0025b3a:	83 c4 10             	add    $0x10,%esp
c0025b3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (p == NULL)
c0025b40:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025b44:	75 19                	jne    c0025b5f <found_partition+0x12f>
        PANIC ("Failed to allocate memory for partition descriptor");
c0025b46:	68 58 17 03 c0       	push   $0xc0031758
c0025b4b:	68 bc 17 03 c0       	push   $0xc00317bc
c0025b50:	68 b1 00 00 00       	push   $0xb1
c0025b55:	68 4b 16 03 c0       	push   $0xc003164b
c0025b5a:	e8 3e 40 00 00       	call   c0029b9d <debug_panic>
      p->block = block;
c0025b5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025b62:	8b 55 08             	mov    0x8(%ebp),%edx
c0025b65:	89 10                	mov    %edx,(%eax)
      p->start = start;
c0025b67:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025b6a:	8b 55 10             	mov    0x10(%ebp),%edx
c0025b6d:	89 50 04             	mov    %edx,0x4(%eax)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025b70:	83 ec 0c             	sub    $0xc,%esp
c0025b73:	ff 75 08             	pushl  0x8(%ebp)
c0025b76:	e8 77 fa ff ff       	call   c00255f2 <block_name>
c0025b7b:	83 c4 10             	add    $0x10,%esp
c0025b7e:	83 ec 0c             	sub    $0xc,%esp
c0025b81:	ff 75 18             	pushl  0x18(%ebp)
c0025b84:	50                   	push   %eax
c0025b85:	68 8b 17 03 c0       	push   $0xc003178b
c0025b8a:	6a 10                	push   $0x10
c0025b8c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025b8f:	50                   	push   %eax
c0025b90:	e8 20 1c 00 00       	call   c00277b5 <snprintf>
c0025b95:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0025b98:	0f b6 9d 54 ff ff ff 	movzbl -0xac(%ebp),%ebx
c0025b9f:	0f b6 85 54 ff ff ff 	movzbl -0xac(%ebp),%eax
c0025ba6:	83 ec 0c             	sub    $0xc,%esp
c0025ba9:	50                   	push   %eax
c0025baa:	e8 4d 00 00 00       	call   c0025bfc <partition_type_name>
c0025baf:	83 c4 10             	add    $0x10,%esp
c0025bb2:	83 ec 0c             	sub    $0xc,%esp
c0025bb5:	53                   	push   %ebx
c0025bb6:	50                   	push   %eax
c0025bb7:	68 90 17 03 c0       	push   $0xc0031790
c0025bbc:	68 80 00 00 00       	push   $0x80
c0025bc1:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c0025bc7:	50                   	push   %eax
c0025bc8:	e8 e8 1b 00 00       	call   c00277b5 <snprintf>
c0025bcd:	83 c4 20             	add    $0x20,%esp
      block_register (name, type, extra_info, size, &partition_operations, p);
c0025bd0:	83 ec 08             	sub    $0x8,%esp
c0025bd3:	ff 75 f0             	pushl  -0x10(%ebp)
c0025bd6:	68 c0 85 03 c0       	push   $0xc00385c0
c0025bdb:	ff 75 14             	pushl  0x14(%ebp)
c0025bde:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c0025be4:	50                   	push   %eax
c0025be5:	ff 75 f4             	pushl  -0xc(%ebp)
c0025be8:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025beb:	50                   	push   %eax
c0025bec:	e8 96 fa ff ff       	call   c0025687 <block_register>
c0025bf1:	83 c4 20             	add    $0x20,%esp
}
c0025bf4:	90                   	nop
c0025bf5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025bf8:	5b                   	pop    %ebx
c0025bf9:	5e                   	pop    %esi
c0025bfa:	5d                   	pop    %ebp
c0025bfb:	c3                   	ret    

c0025bfc <partition_type_name>:

/* Returns a human-readable name for the given partition TYPE. */
static const char *
partition_type_name (uint8_t type)
{
c0025bfc:	55                   	push   %ebp
c0025bfd:	89 e5                	mov    %esp,%ebp
c0025bff:	83 ec 04             	sub    $0x4,%esp
c0025c02:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c05:	88 45 fc             	mov    %al,-0x4(%ebp)
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025c08:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0025c0c:	8b 04 85 e0 85 03 c0 	mov    -0x3ffc7a20(,%eax,4),%eax
c0025c13:	85 c0                	test   %eax,%eax
c0025c15:	74 0d                	je     c0025c24 <partition_type_name+0x28>
c0025c17:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0025c1b:	8b 04 85 e0 85 03 c0 	mov    -0x3ffc7a20(,%eax,4),%eax
c0025c22:	eb 05                	jmp    c0025c29 <partition_type_name+0x2d>
c0025c24:	b8 9a 17 03 c0       	mov    $0xc003179a,%eax
}
c0025c29:	c9                   	leave  
c0025c2a:	c3                   	ret    

c0025c2b <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0025c2b:	55                   	push   %ebp
c0025c2c:	89 e5                	mov    %esp,%ebp
c0025c2e:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025c31:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c34:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_read (p->block, p->start + sector, buffer);
c0025c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c3a:	8b 50 04             	mov    0x4(%eax),%edx
c0025c3d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025c40:	01 c2                	add    %eax,%edx
c0025c42:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c45:	8b 00                	mov    (%eax),%eax
c0025c47:	83 ec 04             	sub    $0x4,%esp
c0025c4a:	ff 75 10             	pushl  0x10(%ebp)
c0025c4d:	52                   	push   %edx
c0025c4e:	50                   	push   %eax
c0025c4f:	e8 c8 f8 ff ff       	call   c002551c <block_read>
c0025c54:	83 c4 10             	add    $0x10,%esp
}
c0025c57:	90                   	nop
c0025c58:	c9                   	leave  
c0025c59:	c3                   	ret    

c0025c5a <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c0025c5a:	55                   	push   %ebp
c0025c5b:	89 e5                	mov    %esp,%ebp
c0025c5d:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025c60:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c63:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_write (p->block, p->start + sector, buffer);
c0025c66:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c69:	8b 50 04             	mov    0x4(%eax),%edx
c0025c6c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025c6f:	01 c2                	add    %eax,%edx
c0025c71:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c74:	8b 00                	mov    (%eax),%eax
c0025c76:	83 ec 04             	sub    $0x4,%esp
c0025c79:	ff 75 10             	pushl  0x10(%ebp)
c0025c7c:	52                   	push   %edx
c0025c7d:	50                   	push   %eax
c0025c7e:	e8 e8 f8 ff ff       	call   c002556b <block_write>
c0025c83:	83 c4 10             	add    $0x10,%esp
}
c0025c86:	90                   	nop
c0025c87:	c9                   	leave  
c0025c88:	c3                   	ret    

c0025c89 <isspace>:
static inline int isspace (int c) {
c0025c89:	55                   	push   %ebp
c0025c8a:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c0025c8c:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0025c90:	74 1e                	je     c0025cb0 <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c0025c92:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0025c96:	74 18                	je     c0025cb0 <isspace+0x27>
c0025c98:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0025c9c:	74 12                	je     c0025cb0 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c0025c9e:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0025ca2:	74 0c                	je     c0025cb0 <isspace+0x27>
c0025ca4:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0025ca8:	74 06                	je     c0025cb0 <isspace+0x27>
c0025caa:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0025cae:	75 07                	jne    c0025cb7 <isspace+0x2e>
c0025cb0:	b8 01 00 00 00       	mov    $0x1,%eax
c0025cb5:	eb 05                	jmp    c0025cbc <isspace+0x33>
c0025cb7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025cbc:	5d                   	pop    %ebp
c0025cbd:	c3                   	ret    

c0025cbe <inb>:
{
c0025cbe:	55                   	push   %ebp
c0025cbf:	89 e5                	mov    %esp,%ebp
c0025cc1:	83 ec 14             	sub    $0x14,%esp
c0025cc4:	8b 45 08             	mov    0x8(%ebp),%eax
c0025cc7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025ccb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025cce:	89 c2                	mov    %eax,%edx
c0025cd0:	ec                   	in     (%dx),%al
c0025cd1:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0025cd4:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0025cd7:	c9                   	leave  
c0025cd8:	c3                   	ret    

c0025cd9 <insw>:
{
c0025cd9:	55                   	push   %ebp
c0025cda:	89 e5                	mov    %esp,%ebp
c0025cdc:	57                   	push   %edi
c0025cdd:	53                   	push   %ebx
c0025cde:	83 ec 04             	sub    $0x4,%esp
c0025ce1:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ce4:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025ceb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0025cee:	8b 45 10             	mov    0x10(%ebp),%eax
c0025cf1:	89 cb                	mov    %ecx,%ebx
c0025cf3:	89 df                	mov    %ebx,%edi
c0025cf5:	89 c1                	mov    %eax,%ecx
c0025cf7:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c0025cfa:	89 c8                	mov    %ecx,%eax
c0025cfc:	89 fb                	mov    %edi,%ebx
c0025cfe:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0025d01:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0025d04:	90                   	nop
c0025d05:	83 c4 04             	add    $0x4,%esp
c0025d08:	5b                   	pop    %ebx
c0025d09:	5f                   	pop    %edi
c0025d0a:	5d                   	pop    %ebp
c0025d0b:	c3                   	ret    

c0025d0c <outb>:
{
c0025d0c:	55                   	push   %ebp
c0025d0d:	89 e5                	mov    %esp,%ebp
c0025d0f:	83 ec 08             	sub    $0x8,%esp
c0025d12:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d15:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025d18:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0025d1c:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025d1f:	8a 45 f8             	mov    -0x8(%ebp),%al
c0025d22:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0025d25:	ee                   	out    %al,(%dx)
}
c0025d26:	90                   	nop
c0025d27:	c9                   	leave  
c0025d28:	c3                   	ret    

c0025d29 <outsw>:

/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
c0025d29:	55                   	push   %ebp
c0025d2a:	89 e5                	mov    %esp,%ebp
c0025d2c:	56                   	push   %esi
c0025d2d:	53                   	push   %ebx
c0025d2e:	83 ec 04             	sub    $0x4,%esp
c0025d31:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d34:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025d38:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025d3b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0025d3e:	8b 45 10             	mov    0x10(%ebp),%eax
c0025d41:	89 cb                	mov    %ecx,%ebx
c0025d43:	89 de                	mov    %ebx,%esi
c0025d45:	89 c1                	mov    %eax,%ecx
c0025d47:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c0025d4a:	89 c8                	mov    %ecx,%eax
c0025d4c:	89 f3                	mov    %esi,%ebx
c0025d4e:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0025d51:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0025d54:	90                   	nop
c0025d55:	83 c4 04             	add    $0x4,%esp
c0025d58:	5b                   	pop    %ebx
c0025d59:	5e                   	pop    %esi
c0025d5a:	5d                   	pop    %ebp
c0025d5b:	c3                   	ret    

c0025d5c <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c0025d5c:	55                   	push   %ebp
c0025d5d:	89 e5                	mov    %esp,%ebp
c0025d5f:	83 ec 18             	sub    $0x18,%esp
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c0025d62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025d69:	e9 b9 01 00 00       	jmp    c0025f27 <ide_init+0x1cb>
    {
      struct channel *c = &channels[chan_no];
c0025d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025d71:	89 d0                	mov    %edx,%eax
c0025d73:	01 c0                	add    %eax,%eax
c0025d75:	01 d0                	add    %edx,%eax
c0025d77:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0025d7e:	01 d0                	add    %edx,%eax
c0025d80:	c1 e0 02             	shl    $0x2,%eax
c0025d83:	05 a0 a3 03 c0       	add    $0xc003a3a0,%eax
c0025d88:	89 45 ec             	mov    %eax,-0x14(%ebp)
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025d8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025d8e:	ff 75 f4             	pushl  -0xc(%ebp)
c0025d91:	68 90 1c 03 c0       	push   $0xc0031c90
c0025d96:	6a 08                	push   $0x8
c0025d98:	50                   	push   %eax
c0025d99:	e8 17 1a 00 00       	call   c00277b5 <snprintf>
c0025d9e:	83 c4 10             	add    $0x10,%esp
      switch (chan_no) 
c0025da1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025da4:	85 c0                	test   %eax,%eax
c0025da6:	74 07                	je     c0025daf <ide_init+0x53>
c0025da8:	83 f8 01             	cmp    $0x1,%eax
c0025dab:	74 14                	je     c0025dc1 <ide_init+0x65>
c0025dad:	eb 24                	jmp    c0025dd3 <ide_init+0x77>
        {
        case 0:
          c->reg_base = 0x1f0;
c0025daf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025db2:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
          c->irq = 14 + 0x20;
c0025db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025dbb:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
          break;
c0025dbf:	eb 28                	jmp    c0025de9 <ide_init+0x8d>
        case 1:
          c->reg_base = 0x170;
c0025dc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025dc4:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
          c->irq = 15 + 0x20;
c0025dca:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025dcd:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
          break;
c0025dd1:	eb 16                	jmp    c0025de9 <ide_init+0x8d>
        default:
          NOT_REACHED ();
c0025dd3:	68 98 1c 03 c0       	push   $0xc0031c98
c0025dd8:	68 ec 1d 03 c0       	push   $0xc0031dec
c0025ddd:	6a 7c                	push   $0x7c
c0025ddf:	68 ba 1c 03 c0       	push   $0xc0031cba
c0025de4:	e8 b4 3d 00 00       	call   c0029b9d <debug_panic>
        }
      lock_init (&c->lock);
c0025de9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025dec:	83 c0 0c             	add    $0xc,%eax
c0025def:	83 ec 0c             	sub    $0xc,%esp
c0025df2:	50                   	push   %eax
c0025df3:	e8 56 d2 ff ff       	call   c002304e <lock_init>
c0025df8:	83 c4 10             	add    $0x10,%esp
      c->expecting_interrupt = false;
c0025dfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025dfe:	c6 40 2c 00          	movb   $0x0,0x2c(%eax)
      sema_init (&c->completion_wait, 0);
c0025e02:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025e05:	83 c0 30             	add    $0x30,%eax
c0025e08:	83 ec 08             	sub    $0x8,%esp
c0025e0b:	6a 00                	push   $0x0
c0025e0d:	50                   	push   %eax
c0025e0e:	e8 83 cf ff ff       	call   c0022d96 <sema_init>
c0025e13:	83 c4 10             	add    $0x10,%esp
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025e16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025e1d:	eb 5a                	jmp    c0025e79 <ide_init+0x11d>
        {
          struct ata_disk *d = &c->devices[dev_no];
c0025e1f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025e22:	89 d0                	mov    %edx,%eax
c0025e24:	c1 e0 02             	shl    $0x2,%eax
c0025e27:	01 d0                	add    %edx,%eax
c0025e29:	c1 e0 02             	shl    $0x2,%eax
c0025e2c:	8d 50 40             	lea    0x40(%eax),%edx
c0025e2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025e32:	01 d0                	add    %edx,%eax
c0025e34:	83 c0 04             	add    $0x4,%eax
c0025e37:	89 45 e8             	mov    %eax,-0x18(%ebp)
          snprintf (d->name, sizeof d->name,
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
c0025e3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025e3d:	01 c0                	add    %eax,%eax
c0025e3f:	89 c2                	mov    %eax,%edx
c0025e41:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025e44:	01 d0                	add    %edx,%eax
          snprintf (d->name, sizeof d->name,
c0025e46:	8d 50 61             	lea    0x61(%eax),%edx
c0025e49:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025e4c:	52                   	push   %edx
c0025e4d:	68 ce 1c 03 c0       	push   $0xc0031cce
c0025e52:	6a 08                	push   $0x8
c0025e54:	50                   	push   %eax
c0025e55:	e8 5b 19 00 00       	call   c00277b5 <snprintf>
c0025e5a:	83 c4 10             	add    $0x10,%esp
          d->channel = c;
c0025e5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025e60:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0025e63:	89 50 08             	mov    %edx,0x8(%eax)
          d->dev_no = dev_no;
c0025e66:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025e69:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025e6c:	89 50 0c             	mov    %edx,0xc(%eax)
          d->is_ata = false;
c0025e6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025e72:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025e76:	ff 45 f0             	incl   -0x10(%ebp)
c0025e79:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025e7d:	7e a0                	jle    c0025e1f <ide_init+0xc3>
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0025e7f:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0025e82:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025e85:	8a 40 0a             	mov    0xa(%eax),%al
c0025e88:	0f b6 c0             	movzbl %al,%eax
c0025e8b:	83 ec 04             	sub    $0x4,%esp
c0025e8e:	52                   	push   %edx
c0025e8f:	68 9f 69 02 c0       	push   $0xc002699f
c0025e94:	50                   	push   %eax
c0025e95:	e8 1c bd ff ff       	call   c0021bb6 <intr_register_ext>
c0025e9a:	83 c4 10             	add    $0x10,%esp

      /* Reset hardware. */
      reset_channel (c);
c0025e9d:	83 ec 0c             	sub    $0xc,%esp
c0025ea0:	ff 75 ec             	pushl  -0x14(%ebp)
c0025ea3:	e8 8c 00 00 00       	call   c0025f34 <reset_channel>
c0025ea8:	83 c4 10             	add    $0x10,%esp

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c0025eab:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025eae:	83 c0 44             	add    $0x44,%eax
c0025eb1:	83 ec 0c             	sub    $0xc,%esp
c0025eb4:	50                   	push   %eax
c0025eb5:	e8 f8 02 00 00       	call   c00261b2 <check_device_type>
c0025eba:	83 c4 10             	add    $0x10,%esp
c0025ebd:	84 c0                	test   %al,%al
c0025ebf:	74 12                	je     c0025ed3 <ide_init+0x177>
        check_device_type (&c->devices[1]);
c0025ec1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025ec4:	83 c0 58             	add    $0x58,%eax
c0025ec7:	83 ec 0c             	sub    $0xc,%esp
c0025eca:	50                   	push   %eax
c0025ecb:	e8 e2 02 00 00       	call   c00261b2 <check_device_type>
c0025ed0:	83 c4 10             	add    $0x10,%esp

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025ed3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025eda:	eb 42                	jmp    c0025f1e <ide_init+0x1c2>
        if (c->devices[dev_no].is_ata)
c0025edc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0025edf:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025ee2:	89 d0                	mov    %edx,%eax
c0025ee4:	c1 e0 02             	shl    $0x2,%eax
c0025ee7:	01 d0                	add    %edx,%eax
c0025ee9:	c1 e0 02             	shl    $0x2,%eax
c0025eec:	01 c8                	add    %ecx,%eax
c0025eee:	83 c0 54             	add    $0x54,%eax
c0025ef1:	8a 00                	mov    (%eax),%al
c0025ef3:	84 c0                	test   %al,%al
c0025ef5:	74 24                	je     c0025f1b <ide_init+0x1bf>
          identify_ata_device (&c->devices[dev_no]);
c0025ef7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025efa:	89 d0                	mov    %edx,%eax
c0025efc:	c1 e0 02             	shl    $0x2,%eax
c0025eff:	01 d0                	add    %edx,%eax
c0025f01:	c1 e0 02             	shl    $0x2,%eax
c0025f04:	8d 50 40             	lea    0x40(%eax),%edx
c0025f07:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025f0a:	01 d0                	add    %edx,%eax
c0025f0c:	83 c0 04             	add    $0x4,%eax
c0025f0f:	83 ec 0c             	sub    $0xc,%esp
c0025f12:	50                   	push   %eax
c0025f13:	e8 8b 03 00 00       	call   c00262a3 <identify_ata_device>
c0025f18:	83 c4 10             	add    $0x10,%esp
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025f1b:	ff 45 f0             	incl   -0x10(%ebp)
c0025f1e:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025f22:	7e b8                	jle    c0025edc <ide_init+0x180>
  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c0025f24:	ff 45 f4             	incl   -0xc(%ebp)
c0025f27:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025f2b:	0f 86 3d fe ff ff    	jbe    c0025d6e <ide_init+0x12>
    }
}
c0025f31:	90                   	nop
c0025f32:	c9                   	leave  
c0025f33:	c3                   	ret    

c0025f34 <reset_channel>:

/* Resets an ATA channel and waits for any devices present on it
   to finish the reset. */
static void
reset_channel (struct channel *c) 
{
c0025f34:	55                   	push   %ebp
c0025f35:	89 e5                	mov    %esp,%ebp
c0025f37:	83 ec 18             	sub    $0x18,%esp
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025f3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025f41:	e9 22 01 00 00       	jmp    c0026068 <reset_channel+0x134>
    {
      struct ata_disk *d = &c->devices[dev_no];
c0025f46:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025f49:	89 d0                	mov    %edx,%eax
c0025f4b:	c1 e0 02             	shl    $0x2,%eax
c0025f4e:	01 d0                	add    %edx,%eax
c0025f50:	c1 e0 02             	shl    $0x2,%eax
c0025f53:	8d 50 40             	lea    0x40(%eax),%edx
c0025f56:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f59:	01 d0                	add    %edx,%eax
c0025f5b:	83 c0 04             	add    $0x4,%eax
c0025f5e:	89 45 ec             	mov    %eax,-0x14(%ebp)

      select_device (d);
c0025f61:	83 ec 0c             	sub    $0xc,%esp
c0025f64:	ff 75 ec             	pushl  -0x14(%ebp)
c0025f67:	e8 98 09 00 00       	call   c0026904 <select_device>
c0025f6c:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025f6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f72:	8b 40 08             	mov    0x8(%eax),%eax
c0025f75:	83 c0 02             	add    $0x2,%eax
c0025f78:	0f b7 c0             	movzwl %ax,%eax
c0025f7b:	83 ec 08             	sub    $0x8,%esp
c0025f7e:	6a 55                	push   $0x55
c0025f80:	50                   	push   %eax
c0025f81:	e8 86 fd ff ff       	call   c0025d0c <outb>
c0025f86:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025f89:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f8c:	8b 40 08             	mov    0x8(%eax),%eax
c0025f8f:	83 c0 03             	add    $0x3,%eax
c0025f92:	0f b7 c0             	movzwl %ax,%eax
c0025f95:	83 ec 08             	sub    $0x8,%esp
c0025f98:	68 aa 00 00 00       	push   $0xaa
c0025f9d:	50                   	push   %eax
c0025f9e:	e8 69 fd ff ff       	call   c0025d0c <outb>
c0025fa3:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0xaa);
c0025fa6:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fa9:	8b 40 08             	mov    0x8(%eax),%eax
c0025fac:	83 c0 02             	add    $0x2,%eax
c0025faf:	0f b7 c0             	movzwl %ax,%eax
c0025fb2:	83 ec 08             	sub    $0x8,%esp
c0025fb5:	68 aa 00 00 00       	push   $0xaa
c0025fba:	50                   	push   %eax
c0025fbb:	e8 4c fd ff ff       	call   c0025d0c <outb>
c0025fc0:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0x55);
c0025fc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fc6:	8b 40 08             	mov    0x8(%eax),%eax
c0025fc9:	83 c0 03             	add    $0x3,%eax
c0025fcc:	0f b7 c0             	movzwl %ax,%eax
c0025fcf:	83 ec 08             	sub    $0x8,%esp
c0025fd2:	6a 55                	push   $0x55
c0025fd4:	50                   	push   %eax
c0025fd5:	e8 32 fd ff ff       	call   c0025d0c <outb>
c0025fda:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025fdd:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fe0:	8b 40 08             	mov    0x8(%eax),%eax
c0025fe3:	83 c0 02             	add    $0x2,%eax
c0025fe6:	0f b7 c0             	movzwl %ax,%eax
c0025fe9:	83 ec 08             	sub    $0x8,%esp
c0025fec:	6a 55                	push   $0x55
c0025fee:	50                   	push   %eax
c0025fef:	e8 18 fd ff ff       	call   c0025d0c <outb>
c0025ff4:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025ff7:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ffa:	8b 40 08             	mov    0x8(%eax),%eax
c0025ffd:	83 c0 03             	add    $0x3,%eax
c0026000:	0f b7 c0             	movzwl %ax,%eax
c0026003:	83 ec 08             	sub    $0x8,%esp
c0026006:	68 aa 00 00 00       	push   $0xaa
c002600b:	50                   	push   %eax
c002600c:	e8 fb fc ff ff       	call   c0025d0c <outb>
c0026011:	83 c4 10             	add    $0x10,%esp

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0026014:	8b 45 08             	mov    0x8(%ebp),%eax
c0026017:	8b 40 08             	mov    0x8(%eax),%eax
c002601a:	83 c0 02             	add    $0x2,%eax
c002601d:	0f b7 c0             	movzwl %ax,%eax
c0026020:	83 ec 0c             	sub    $0xc,%esp
c0026023:	50                   	push   %eax
c0026024:	e8 95 fc ff ff       	call   c0025cbe <inb>
c0026029:	83 c4 10             	add    $0x10,%esp
                         && inb (reg_lbal (c)) == 0xaa);
c002602c:	3c 55                	cmp    $0x55,%al
c002602e:	75 23                	jne    c0026053 <reset_channel+0x11f>
c0026030:	8b 45 08             	mov    0x8(%ebp),%eax
c0026033:	8b 40 08             	mov    0x8(%eax),%eax
c0026036:	83 c0 03             	add    $0x3,%eax
c0026039:	0f b7 c0             	movzwl %ax,%eax
c002603c:	83 ec 0c             	sub    $0xc,%esp
c002603f:	50                   	push   %eax
c0026040:	e8 79 fc ff ff       	call   c0025cbe <inb>
c0026045:	83 c4 10             	add    $0x10,%esp
c0026048:	3c aa                	cmp    $0xaa,%al
c002604a:	75 07                	jne    c0026053 <reset_channel+0x11f>
c002604c:	b8 01 00 00 00       	mov    $0x1,%eax
c0026051:	eb 05                	jmp    c0026058 <reset_channel+0x124>
c0026053:	b8 00 00 00 00       	mov    $0x0,%eax
c0026058:	83 e0 01             	and    $0x1,%eax
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c002605b:	8d 4d ea             	lea    -0x16(%ebp),%ecx
c002605e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026061:	01 ca                	add    %ecx,%edx
c0026063:	88 02                	mov    %al,(%edx)
  for (dev_no = 0; dev_no < 2; dev_no++)
c0026065:	ff 45 f4             	incl   -0xc(%ebp)
c0026068:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002606c:	0f 8e d4 fe ff ff    	jle    c0025f46 <reset_channel+0x12>
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
c0026072:	8b 45 08             	mov    0x8(%ebp),%eax
c0026075:	8b 40 08             	mov    0x8(%eax),%eax
c0026078:	05 06 02 00 00       	add    $0x206,%eax
c002607d:	0f b7 c0             	movzwl %ax,%eax
c0026080:	83 ec 08             	sub    $0x8,%esp
c0026083:	6a 00                	push   $0x0
c0026085:	50                   	push   %eax
c0026086:	e8 81 fc ff ff       	call   c0025d0c <outb>
c002608b:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c002608e:	83 ec 08             	sub    $0x8,%esp
c0026091:	6a 00                	push   $0x0
c0026093:	6a 0a                	push   $0xa
c0026095:	e8 57 e3 ff ff       	call   c00243f1 <timer_usleep>
c002609a:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), CTL_SRST);
c002609d:	8b 45 08             	mov    0x8(%ebp),%eax
c00260a0:	8b 40 08             	mov    0x8(%eax),%eax
c00260a3:	05 06 02 00 00       	add    $0x206,%eax
c00260a8:	0f b7 c0             	movzwl %ax,%eax
c00260ab:	83 ec 08             	sub    $0x8,%esp
c00260ae:	6a 04                	push   $0x4
c00260b0:	50                   	push   %eax
c00260b1:	e8 56 fc ff ff       	call   c0025d0c <outb>
c00260b6:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c00260b9:	83 ec 08             	sub    $0x8,%esp
c00260bc:	6a 00                	push   $0x0
c00260be:	6a 0a                	push   $0xa
c00260c0:	e8 2c e3 ff ff       	call   c00243f1 <timer_usleep>
c00260c5:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), 0);
c00260c8:	8b 45 08             	mov    0x8(%ebp),%eax
c00260cb:	8b 40 08             	mov    0x8(%eax),%eax
c00260ce:	05 06 02 00 00       	add    $0x206,%eax
c00260d3:	0f b7 c0             	movzwl %ax,%eax
c00260d6:	83 ec 08             	sub    $0x8,%esp
c00260d9:	6a 00                	push   $0x0
c00260db:	50                   	push   %eax
c00260dc:	e8 2b fc ff ff       	call   c0025d0c <outb>
c00260e1:	83 c4 10             	add    $0x10,%esp

  timer_msleep (150);
c00260e4:	83 ec 08             	sub    $0x8,%esp
c00260e7:	6a 00                	push   $0x0
c00260e9:	68 96 00 00 00       	push   $0x96
c00260ee:	e8 d3 e2 ff ff       	call   c00243c6 <timer_msleep>
c00260f3:	83 c4 10             	add    $0x10,%esp

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c00260f6:	8a 45 ea             	mov    -0x16(%ebp),%al
c00260f9:	84 c0                	test   %al,%al
c00260fb:	74 24                	je     c0026121 <reset_channel+0x1ed>
    {
      select_device (&c->devices[0]);
c00260fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0026100:	83 c0 44             	add    $0x44,%eax
c0026103:	83 ec 0c             	sub    $0xc,%esp
c0026106:	50                   	push   %eax
c0026107:	e8 f8 07 00 00       	call   c0026904 <select_device>
c002610c:	83 c4 10             	add    $0x10,%esp
      wait_while_busy (&c->devices[0]); 
c002610f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026112:	83 c0 44             	add    $0x44,%eax
c0026115:	83 ec 0c             	sub    $0xc,%esp
c0026118:	50                   	push   %eax
c0026119:	e8 1d 07 00 00       	call   c002683b <wait_while_busy>
c002611e:	83 c4 10             	add    $0x10,%esp
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c0026121:	8a 45 eb             	mov    -0x15(%ebp),%al
c0026124:	84 c0                	test   %al,%al
c0026126:	0f 84 83 00 00 00    	je     c00261af <reset_channel+0x27b>
    {
      int i;

      select_device (&c->devices[1]);
c002612c:	8b 45 08             	mov    0x8(%ebp),%eax
c002612f:	83 c0 58             	add    $0x58,%eax
c0026132:	83 ec 0c             	sub    $0xc,%esp
c0026135:	50                   	push   %eax
c0026136:	e8 c9 07 00 00       	call   c0026904 <select_device>
c002613b:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c002613e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0026145:	eb 4a                	jmp    c0026191 <reset_channel+0x25d>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0026147:	8b 45 08             	mov    0x8(%ebp),%eax
c002614a:	8b 40 08             	mov    0x8(%eax),%eax
c002614d:	83 c0 02             	add    $0x2,%eax
c0026150:	0f b7 c0             	movzwl %ax,%eax
c0026153:	83 ec 0c             	sub    $0xc,%esp
c0026156:	50                   	push   %eax
c0026157:	e8 62 fb ff ff       	call   c0025cbe <inb>
c002615c:	83 c4 10             	add    $0x10,%esp
c002615f:	3c 01                	cmp    $0x1,%al
c0026161:	75 1c                	jne    c002617f <reset_channel+0x24b>
c0026163:	8b 45 08             	mov    0x8(%ebp),%eax
c0026166:	8b 40 08             	mov    0x8(%eax),%eax
c0026169:	83 c0 03             	add    $0x3,%eax
c002616c:	0f b7 c0             	movzwl %ax,%eax
c002616f:	83 ec 0c             	sub    $0xc,%esp
c0026172:	50                   	push   %eax
c0026173:	e8 46 fb ff ff       	call   c0025cbe <inb>
c0026178:	83 c4 10             	add    $0x10,%esp
c002617b:	3c 01                	cmp    $0x1,%al
c002617d:	74 1d                	je     c002619c <reset_channel+0x268>
            break;
          timer_msleep (10);
c002617f:	83 ec 08             	sub    $0x8,%esp
c0026182:	6a 00                	push   $0x0
c0026184:	6a 0a                	push   $0xa
c0026186:	e8 3b e2 ff ff       	call   c00243c6 <timer_msleep>
c002618b:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c002618e:	ff 45 f0             	incl   -0x10(%ebp)
c0026191:	81 7d f0 b7 0b 00 00 	cmpl   $0xbb7,-0x10(%ebp)
c0026198:	7e ad                	jle    c0026147 <reset_channel+0x213>
c002619a:	eb 01                	jmp    c002619d <reset_channel+0x269>
            break;
c002619c:	90                   	nop
        }
      wait_while_busy (&c->devices[1]);
c002619d:	8b 45 08             	mov    0x8(%ebp),%eax
c00261a0:	83 c0 58             	add    $0x58,%eax
c00261a3:	83 ec 0c             	sub    $0xc,%esp
c00261a6:	50                   	push   %eax
c00261a7:	e8 8f 06 00 00       	call   c002683b <wait_while_busy>
c00261ac:	83 c4 10             	add    $0x10,%esp
    }
}
c00261af:	90                   	nop
c00261b0:	c9                   	leave  
c00261b1:	c3                   	ret    

c00261b2 <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c00261b2:	55                   	push   %ebp
c00261b3:	89 e5                	mov    %esp,%ebp
c00261b5:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00261b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00261bb:	8b 40 08             	mov    0x8(%eax),%eax
c00261be:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint8_t error, lbam, lbah, status;

  select_device (d);
c00261c1:	83 ec 0c             	sub    $0xc,%esp
c00261c4:	ff 75 08             	pushl  0x8(%ebp)
c00261c7:	e8 38 07 00 00       	call   c0026904 <select_device>
c00261cc:	83 c4 10             	add    $0x10,%esp

  error = inb (reg_error (c));
c00261cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00261d2:	8b 40 08             	mov    0x8(%eax),%eax
c00261d5:	40                   	inc    %eax
c00261d6:	0f b7 c0             	movzwl %ax,%eax
c00261d9:	83 ec 0c             	sub    $0xc,%esp
c00261dc:	50                   	push   %eax
c00261dd:	e8 dc fa ff ff       	call   c0025cbe <inb>
c00261e2:	83 c4 10             	add    $0x10,%esp
c00261e5:	88 45 f3             	mov    %al,-0xd(%ebp)
  lbam = inb (reg_lbam (c));
c00261e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00261eb:	8b 40 08             	mov    0x8(%eax),%eax
c00261ee:	83 c0 04             	add    $0x4,%eax
c00261f1:	0f b7 c0             	movzwl %ax,%eax
c00261f4:	83 ec 0c             	sub    $0xc,%esp
c00261f7:	50                   	push   %eax
c00261f8:	e8 c1 fa ff ff       	call   c0025cbe <inb>
c00261fd:	83 c4 10             	add    $0x10,%esp
c0026200:	88 45 f2             	mov    %al,-0xe(%ebp)
  lbah = inb (reg_lbah (c));
c0026203:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026206:	8b 40 08             	mov    0x8(%eax),%eax
c0026209:	83 c0 05             	add    $0x5,%eax
c002620c:	0f b7 c0             	movzwl %ax,%eax
c002620f:	83 ec 0c             	sub    $0xc,%esp
c0026212:	50                   	push   %eax
c0026213:	e8 a6 fa ff ff       	call   c0025cbe <inb>
c0026218:	83 c4 10             	add    $0x10,%esp
c002621b:	88 45 f1             	mov    %al,-0xf(%ebp)
  status = inb (reg_status (c));
c002621e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026221:	8b 40 08             	mov    0x8(%eax),%eax
c0026224:	83 c0 07             	add    $0x7,%eax
c0026227:	0f b7 c0             	movzwl %ax,%eax
c002622a:	83 ec 0c             	sub    $0xc,%esp
c002622d:	50                   	push   %eax
c002622e:	e8 8b fa ff ff       	call   c0025cbe <inb>
c0026233:	83 c4 10             	add    $0x10,%esp
c0026236:	88 45 f0             	mov    %al,-0x10(%ebp)

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0026239:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
c002623d:	74 11                	je     c0026250 <check_device_type+0x9e>
c002623f:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0026243:	75 1d                	jne    c0026262 <check_device_type+0xb0>
c0026245:	8b 45 08             	mov    0x8(%ebp),%eax
c0026248:	8b 40 0c             	mov    0xc(%eax),%eax
c002624b:	83 f8 01             	cmp    $0x1,%eax
c002624e:	74 12                	je     c0026262 <check_device_type+0xb0>
      || (status & STA_DRDY) == 0
c0026250:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0026254:	83 e0 40             	and    $0x40,%eax
c0026257:	85 c0                	test   %eax,%eax
c0026259:	74 07                	je     c0026262 <check_device_type+0xb0>
      || (status & STA_BSY) != 0)
c002625b:	8a 45 f0             	mov    -0x10(%ebp),%al
c002625e:	84 c0                	test   %al,%al
c0026260:	79 10                	jns    c0026272 <check_device_type+0xc0>
    {
      d->is_ata = false;
c0026262:	8b 45 08             	mov    0x8(%ebp),%eax
c0026265:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return error != 0x81;      
c0026269:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c002626d:	0f 95 c0             	setne  %al
c0026270:	eb 2f                	jmp    c00262a1 <check_device_type+0xef>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0026272:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c0026276:	75 06                	jne    c002627e <check_device_type+0xcc>
c0026278:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c002627c:	74 0c                	je     c002628a <check_device_type+0xd8>
c002627e:	80 7d f2 3c          	cmpb   $0x3c,-0xe(%ebp)
c0026282:	75 0d                	jne    c0026291 <check_device_type+0xdf>
c0026284:	80 7d f1 c3          	cmpb   $0xc3,-0xf(%ebp)
c0026288:	75 07                	jne    c0026291 <check_device_type+0xdf>
c002628a:	b8 01 00 00 00       	mov    $0x1,%eax
c002628f:	eb 05                	jmp    c0026296 <check_device_type+0xe4>
c0026291:	b8 00 00 00 00       	mov    $0x0,%eax
c0026296:	83 e0 01             	and    $0x1,%eax
c0026299:	8b 55 08             	mov    0x8(%ebp),%edx
c002629c:	88 42 10             	mov    %al,0x10(%edx)
      return true; 
c002629f:	b0 01                	mov    $0x1,%al
    }
}
c00262a1:	c9                   	leave  
c00262a2:	c3                   	ret    

c00262a3 <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c00262a3:	55                   	push   %ebp
c00262a4:	89 e5                	mov    %esp,%ebp
c00262a6:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
  struct channel *c = d->channel;
c00262ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00262af:	8b 40 08             	mov    0x8(%eax),%eax
c00262b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c00262b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00262b8:	8a 40 10             	mov    0x10(%eax),%al
c00262bb:	84 c0                	test   %al,%al
c00262bd:	75 21                	jne    c00262e0 <identify_ata_device+0x3d>
c00262bf:	83 ec 0c             	sub    $0xc,%esp
c00262c2:	68 d3 1c 03 c0       	push   $0xc0031cd3
c00262c7:	68 dd 1c 03 c0       	push   $0xc0031cdd
c00262cc:	68 f8 1d 03 c0       	push   $0xc0031df8
c00262d1:	68 0d 01 00 00       	push   $0x10d
c00262d6:	68 ba 1c 03 c0       	push   $0xc0031cba
c00262db:	e8 bd 38 00 00       	call   c0029b9d <debug_panic>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
c00262e0:	83 ec 0c             	sub    $0xc,%esp
c00262e3:	ff 75 08             	pushl  0x8(%ebp)
c00262e6:	e8 81 06 00 00       	call   c002696c <select_device_wait>
c00262eb:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c00262ee:	83 ec 08             	sub    $0x8,%esp
c00262f1:	68 ec 00 00 00       	push   $0xec
c00262f6:	ff 75 f4             	pushl  -0xc(%ebp)
c00262f9:	e8 38 04 00 00       	call   c0026736 <issue_pio_command>
c00262fe:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026301:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026304:	83 c0 30             	add    $0x30,%eax
c0026307:	83 ec 0c             	sub    $0xc,%esp
c002630a:	50                   	push   %eax
c002630b:	e8 cd ca ff ff       	call   c0022ddd <sema_down>
c0026310:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0026313:	83 ec 0c             	sub    $0xc,%esp
c0026316:	ff 75 08             	pushl  0x8(%ebp)
c0026319:	e8 1d 05 00 00       	call   c002683b <wait_while_busy>
c002631e:	83 c4 10             	add    $0x10,%esp
c0026321:	83 f0 01             	xor    $0x1,%eax
c0026324:	84 c0                	test   %al,%al
c0026326:	74 0c                	je     c0026334 <identify_ata_device+0x91>
    {
      d->is_ata = false;
c0026328:	8b 45 08             	mov    0x8(%ebp),%eax
c002632b:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c002632f:	e9 fb 00 00 00       	jmp    c002642f <identify_ata_device+0x18c>
    }
  input_sector (c, id);
c0026334:	83 ec 08             	sub    $0x8,%esp
c0026337:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c002633d:	50                   	push   %eax
c002633e:	ff 75 f4             	pushl  -0xc(%ebp)
c0026341:	e8 4e 04 00 00       	call   c0026794 <input_sector>
c0026346:	83 c4 10             	add    $0x10,%esp

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c0026349:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c002634f:	83 c0 78             	add    $0x78,%eax
c0026352:	8b 00                	mov    (%eax),%eax
c0026354:	89 45 f0             	mov    %eax,-0x10(%ebp)
  model = descramble_ata_string (&id[10 * 2], 20);
c0026357:	83 ec 08             	sub    $0x8,%esp
c002635a:	6a 14                	push   $0x14
c002635c:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0026362:	83 c0 14             	add    $0x14,%eax
c0026365:	50                   	push   %eax
c0026366:	e8 c6 00 00 00       	call   c0026431 <descramble_ata_string>
c002636b:	83 c4 10             	add    $0x10,%esp
c002636e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  serial = descramble_ata_string (&id[27 * 2], 40);
c0026371:	83 ec 08             	sub    $0x8,%esp
c0026374:	6a 28                	push   $0x28
c0026376:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c002637c:	83 c0 36             	add    $0x36,%eax
c002637f:	50                   	push   %eax
c0026380:	e8 ac 00 00 00       	call   c0026431 <descramble_ata_string>
c0026385:	83 c4 10             	add    $0x10,%esp
c0026388:	89 45 e8             	mov    %eax,-0x18(%ebp)
  snprintf (extra_info, sizeof extra_info,
c002638b:	83 ec 0c             	sub    $0xc,%esp
c002638e:	ff 75 e8             	pushl  -0x18(%ebp)
c0026391:	ff 75 ec             	pushl  -0x14(%ebp)
c0026394:	68 f4 1c 03 c0       	push   $0xc0031cf4
c0026399:	68 80 00 00 00       	push   $0x80
c002639e:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c00263a4:	50                   	push   %eax
c00263a5:	e8 0b 14 00 00       	call   c00277b5 <snprintf>
c00263aa:	83 c4 20             	add    $0x20,%esp
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c00263ad:	81 7d f0 ff ff 1f 00 	cmpl   $0x1fffff,-0x10(%ebp)
c00263b4:	76 45                	jbe    c00263fb <identify_ata_device+0x158>
    {
      printf ("%s: ignoring ", d->name);
c00263b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00263b9:	83 ec 08             	sub    $0x8,%esp
c00263bc:	50                   	push   %eax
c00263bd:	68 0c 1d 03 c0       	push   $0xc0031d0c
c00263c2:	e8 17 14 00 00       	call   c00277de <printf>
c00263c7:	83 c4 10             	add    $0x10,%esp
      print_human_readable_size (capacity * 512);
c00263ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00263cd:	c1 e0 09             	shl    $0x9,%eax
c00263d0:	ba 00 00 00 00       	mov    $0x0,%edx
c00263d5:	83 ec 08             	sub    $0x8,%esp
c00263d8:	52                   	push   %edx
c00263d9:	50                   	push   %eax
c00263da:	e8 15 21 00 00       	call   c00284f4 <print_human_readable_size>
c00263df:	83 c4 10             	add    $0x10,%esp
      printf ("disk for safety\n");
c00263e2:	83 ec 0c             	sub    $0xc,%esp
c00263e5:	68 1a 1d 03 c0       	push   $0xc0031d1a
c00263ea:	e8 80 5a 00 00       	call   c002be6f <puts>
c00263ef:	83 c4 10             	add    $0x10,%esp
      d->is_ata = false;
c00263f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00263f5:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c00263f9:	eb 34                	jmp    c002642f <identify_ata_device+0x18c>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c00263fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00263fe:	83 ec 08             	sub    $0x8,%esp
c0026401:	ff 75 08             	pushl  0x8(%ebp)
c0026404:	68 e0 89 03 c0       	push   $0xc00389e0
c0026409:	ff 75 f0             	pushl  -0x10(%ebp)
c002640c:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0026412:	52                   	push   %edx
c0026413:	6a 04                	push   $0x4
c0026415:	50                   	push   %eax
c0026416:	e8 6c f2 ff ff       	call   c0025687 <block_register>
c002641b:	83 c4 20             	add    $0x20,%esp
c002641e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                          &ide_operations, d);
  partition_scan (block);
c0026421:	83 ec 0c             	sub    $0xc,%esp
c0026424:	ff 75 e4             	pushl  -0x1c(%ebp)
c0026427:	e8 a3 f3 ff ff       	call   c00257cf <partition_scan>
c002642c:	83 c4 10             	add    $0x10,%esp
}
c002642f:	c9                   	leave  
c0026430:	c3                   	ret    

c0026431 <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0026431:	55                   	push   %ebp
c0026432:	89 e5                	mov    %esp,%ebp
c0026434:	83 ec 10             	sub    $0x10,%esp
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0026437:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002643e:	eb 38                	jmp    c0026478 <descramble_ata_string+0x47>
    {
      char tmp = string[i];
c0026440:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026443:	8b 45 08             	mov    0x8(%ebp),%eax
c0026446:	01 d0                	add    %edx,%eax
c0026448:	8a 00                	mov    (%eax),%al
c002644a:	88 45 fb             	mov    %al,-0x5(%ebp)
      string[i] = string[i + 1];
c002644d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026450:	8b 45 08             	mov    0x8(%ebp),%eax
c0026453:	01 c2                	add    %eax,%edx
c0026455:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026458:	8d 48 01             	lea    0x1(%eax),%ecx
c002645b:	8b 45 08             	mov    0x8(%ebp),%eax
c002645e:	01 c8                	add    %ecx,%eax
c0026460:	8a 00                	mov    (%eax),%al
c0026462:	88 02                	mov    %al,(%edx)
      string[i + 1] = tmp;
c0026464:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026467:	8d 50 01             	lea    0x1(%eax),%edx
c002646a:	8b 45 08             	mov    0x8(%ebp),%eax
c002646d:	01 c2                	add    %eax,%edx
c002646f:	8a 45 fb             	mov    -0x5(%ebp),%al
c0026472:	88 02                	mov    %al,(%edx)
  for (i = 0; i + 1 < size; i += 2)
c0026474:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
c0026478:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002647b:	40                   	inc    %eax
c002647c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002647f:	7c bf                	jl     c0026440 <descramble_ata_string+0xf>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0026481:	ff 4d 0c             	decl   0xc(%ebp)
c0026484:	eb 2b                	jmp    c00264b1 <descramble_ata_string+0x80>
    {
      int c = string[size - 1];
c0026486:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026489:	8d 50 ff             	lea    -0x1(%eax),%edx
c002648c:	8b 45 08             	mov    0x8(%ebp),%eax
c002648f:	01 d0                	add    %edx,%eax
c0026491:	8a 00                	mov    (%eax),%al
c0026493:	0f be c0             	movsbl %al,%eax
c0026496:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (c != '\0' && !isspace (c))
c0026499:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002649d:	74 0f                	je     c00264ae <descramble_ata_string+0x7d>
c002649f:	ff 75 f4             	pushl  -0xc(%ebp)
c00264a2:	e8 e2 f7 ff ff       	call   c0025c89 <isspace>
c00264a7:	83 c4 04             	add    $0x4,%esp
c00264aa:	85 c0                	test   %eax,%eax
c00264ac:	74 0b                	je     c00264b9 <descramble_ata_string+0x88>
  for (size--; size > 0; size--)
c00264ae:	ff 4d 0c             	decl   0xc(%ebp)
c00264b1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00264b5:	7f cf                	jg     c0026486 <descramble_ata_string+0x55>
c00264b7:	eb 01                	jmp    c00264ba <descramble_ata_string+0x89>
        break; 
c00264b9:	90                   	nop
    }
  string[size] = '\0';
c00264ba:	8b 55 0c             	mov    0xc(%ebp),%edx
c00264bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00264c0:	01 d0                	add    %edx,%eax
c00264c2:	c6 00 00             	movb   $0x0,(%eax)

  return string;
c00264c5:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00264c8:	c9                   	leave  
c00264c9:	c3                   	ret    

c00264ca <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c00264ca:	55                   	push   %ebp
c00264cb:	89 e5                	mov    %esp,%ebp
c00264cd:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c00264d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00264d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c00264d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00264d9:	8b 40 08             	mov    0x8(%eax),%eax
c00264dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c00264df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00264e2:	83 c0 0c             	add    $0xc,%eax
c00264e5:	83 ec 0c             	sub    $0xc,%esp
c00264e8:	50                   	push   %eax
c00264e9:	e8 ad cb ff ff       	call   c002309b <lock_acquire>
c00264ee:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c00264f1:	83 ec 08             	sub    $0x8,%esp
c00264f4:	ff 75 0c             	pushl  0xc(%ebp)
c00264f7:	ff 75 f4             	pushl  -0xc(%ebp)
c00264fa:	e8 3b 01 00 00       	call   c002663a <select_sector>
c00264ff:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0026502:	83 ec 08             	sub    $0x8,%esp
c0026505:	6a 20                	push   $0x20
c0026507:	ff 75 f0             	pushl  -0x10(%ebp)
c002650a:	e8 27 02 00 00       	call   c0026736 <issue_pio_command>
c002650f:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026512:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026515:	83 c0 30             	add    $0x30,%eax
c0026518:	83 ec 0c             	sub    $0xc,%esp
c002651b:	50                   	push   %eax
c002651c:	e8 bc c8 ff ff       	call   c0022ddd <sema_down>
c0026521:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0026524:	83 ec 0c             	sub    $0xc,%esp
c0026527:	ff 75 f4             	pushl  -0xc(%ebp)
c002652a:	e8 0c 03 00 00       	call   c002683b <wait_while_busy>
c002652f:	83 c4 10             	add    $0x10,%esp
c0026532:	83 f0 01             	xor    $0x1,%eax
c0026535:	84 c0                	test   %al,%al
c0026537:	74 23                	je     c002655c <ide_read+0x92>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0026539:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002653c:	83 ec 08             	sub    $0x8,%esp
c002653f:	ff 75 0c             	pushl  0xc(%ebp)
c0026542:	50                   	push   %eax
c0026543:	68 2c 1d 03 c0       	push   $0xc0031d2c
c0026548:	68 0c 1e 03 c0       	push   $0xc0031e0c
c002654d:	68 62 01 00 00       	push   $0x162
c0026552:	68 ba 1c 03 c0       	push   $0xc0031cba
c0026557:	e8 41 36 00 00       	call   c0029b9d <debug_panic>
  input_sector (c, buffer);
c002655c:	83 ec 08             	sub    $0x8,%esp
c002655f:	ff 75 10             	pushl  0x10(%ebp)
c0026562:	ff 75 f0             	pushl  -0x10(%ebp)
c0026565:	e8 2a 02 00 00       	call   c0026794 <input_sector>
c002656a:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c002656d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026570:	83 c0 0c             	add    $0xc,%eax
c0026573:	83 ec 0c             	sub    $0xc,%esp
c0026576:	50                   	push   %eax
c0026577:	e8 9d cc ff ff       	call   c0023219 <lock_release>
c002657c:	83 c4 10             	add    $0x10,%esp
}
c002657f:	90                   	nop
c0026580:	c9                   	leave  
c0026581:	c3                   	ret    

c0026582 <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c0026582:	55                   	push   %ebp
c0026583:	89 e5                	mov    %esp,%ebp
c0026585:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0026588:	8b 45 08             	mov    0x8(%ebp),%eax
c002658b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c002658e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026591:	8b 40 08             	mov    0x8(%eax),%eax
c0026594:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0026597:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002659a:	83 c0 0c             	add    $0xc,%eax
c002659d:	83 ec 0c             	sub    $0xc,%esp
c00265a0:	50                   	push   %eax
c00265a1:	e8 f5 ca ff ff       	call   c002309b <lock_acquire>
c00265a6:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c00265a9:	83 ec 08             	sub    $0x8,%esp
c00265ac:	ff 75 0c             	pushl  0xc(%ebp)
c00265af:	ff 75 f4             	pushl  -0xc(%ebp)
c00265b2:	e8 83 00 00 00       	call   c002663a <select_sector>
c00265b7:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c00265ba:	83 ec 08             	sub    $0x8,%esp
c00265bd:	6a 30                	push   $0x30
c00265bf:	ff 75 f0             	pushl  -0x10(%ebp)
c00265c2:	e8 6f 01 00 00       	call   c0026736 <issue_pio_command>
c00265c7:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c00265ca:	83 ec 0c             	sub    $0xc,%esp
c00265cd:	ff 75 f4             	pushl  -0xc(%ebp)
c00265d0:	e8 66 02 00 00       	call   c002683b <wait_while_busy>
c00265d5:	83 c4 10             	add    $0x10,%esp
c00265d8:	83 f0 01             	xor    $0x1,%eax
c00265db:	84 c0                	test   %al,%al
c00265dd:	74 23                	je     c0026602 <ide_write+0x80>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c00265df:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00265e2:	83 ec 08             	sub    $0x8,%esp
c00265e5:	ff 75 0c             	pushl  0xc(%ebp)
c00265e8:	50                   	push   %eax
c00265e9:	68 4c 1d 03 c0       	push   $0xc0031d4c
c00265ee:	68 18 1e 03 c0       	push   $0xc0031e18
c00265f3:	68 75 01 00 00       	push   $0x175
c00265f8:	68 ba 1c 03 c0       	push   $0xc0031cba
c00265fd:	e8 9b 35 00 00       	call   c0029b9d <debug_panic>
  output_sector (c, buffer);
c0026602:	83 ec 08             	sub    $0x8,%esp
c0026605:	ff 75 10             	pushl  0x10(%ebp)
c0026608:	ff 75 f0             	pushl  -0x10(%ebp)
c002660b:	e8 a4 01 00 00       	call   c00267b4 <output_sector>
c0026610:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026613:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026616:	83 c0 30             	add    $0x30,%eax
c0026619:	83 ec 0c             	sub    $0xc,%esp
c002661c:	50                   	push   %eax
c002661d:	e8 bb c7 ff ff       	call   c0022ddd <sema_down>
c0026622:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0026625:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026628:	83 c0 0c             	add    $0xc,%eax
c002662b:	83 ec 0c             	sub    $0xc,%esp
c002662e:	50                   	push   %eax
c002662f:	e8 e5 cb ff ff       	call   c0023219 <lock_release>
c0026634:	83 c4 10             	add    $0x10,%esp
}
c0026637:	90                   	nop
c0026638:	c9                   	leave  
c0026639:	c3                   	ret    

c002663a <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c002663a:	55                   	push   %ebp
c002663b:	89 e5                	mov    %esp,%ebp
c002663d:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026640:	8b 45 08             	mov    0x8(%ebp),%eax
c0026643:	8b 40 08             	mov    0x8(%eax),%eax
c0026646:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sec_no < (1UL << 28));
c0026649:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
c0026650:	76 21                	jbe    c0026673 <select_sector+0x39>
c0026652:	83 ec 0c             	sub    $0xc,%esp
c0026655:	68 6d 1d 03 c0       	push   $0xc0031d6d
c002665a:	68 dd 1c 03 c0       	push   $0xc0031cdd
c002665f:	68 24 1e 03 c0       	push   $0xc0031e24
c0026664:	68 89 01 00 00       	push   $0x189
c0026669:	68 ba 1c 03 c0       	push   $0xc0031cba
c002666e:	e8 2a 35 00 00       	call   c0029b9d <debug_panic>
  
  select_device_wait (d);
c0026673:	83 ec 0c             	sub    $0xc,%esp
c0026676:	ff 75 08             	pushl  0x8(%ebp)
c0026679:	e8 ee 02 00 00       	call   c002696c <select_device_wait>
c002667e:	83 c4 10             	add    $0x10,%esp
  outb (reg_nsect (c), 1);
c0026681:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026684:	8b 40 08             	mov    0x8(%eax),%eax
c0026687:	83 c0 02             	add    $0x2,%eax
c002668a:	0f b7 c0             	movzwl %ax,%eax
c002668d:	83 ec 08             	sub    $0x8,%esp
c0026690:	6a 01                	push   $0x1
c0026692:	50                   	push   %eax
c0026693:	e8 74 f6 ff ff       	call   c0025d0c <outb>
c0026698:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbal (c), sec_no);
c002669b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002669e:	0f b6 d0             	movzbl %al,%edx
c00266a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00266a4:	8b 40 08             	mov    0x8(%eax),%eax
c00266a7:	83 c0 03             	add    $0x3,%eax
c00266aa:	0f b7 c0             	movzwl %ax,%eax
c00266ad:	83 ec 08             	sub    $0x8,%esp
c00266b0:	52                   	push   %edx
c00266b1:	50                   	push   %eax
c00266b2:	e8 55 f6 ff ff       	call   c0025d0c <outb>
c00266b7:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbam (c), sec_no >> 8);
c00266ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00266bd:	c1 e8 08             	shr    $0x8,%eax
c00266c0:	0f b6 d0             	movzbl %al,%edx
c00266c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00266c6:	8b 40 08             	mov    0x8(%eax),%eax
c00266c9:	83 c0 04             	add    $0x4,%eax
c00266cc:	0f b7 c0             	movzwl %ax,%eax
c00266cf:	83 ec 08             	sub    $0x8,%esp
c00266d2:	52                   	push   %edx
c00266d3:	50                   	push   %eax
c00266d4:	e8 33 f6 ff ff       	call   c0025d0c <outb>
c00266d9:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbah (c), (sec_no >> 16));
c00266dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00266df:	c1 e8 10             	shr    $0x10,%eax
c00266e2:	0f b6 d0             	movzbl %al,%edx
c00266e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00266e8:	8b 40 08             	mov    0x8(%eax),%eax
c00266eb:	83 c0 05             	add    $0x5,%eax
c00266ee:	0f b7 c0             	movzwl %ax,%eax
c00266f1:	83 ec 08             	sub    $0x8,%esp
c00266f4:	52                   	push   %edx
c00266f5:	50                   	push   %eax
c00266f6:	e8 11 f6 ff ff       	call   c0025d0c <outb>
c00266fb:	83 c4 10             	add    $0x10,%esp
  outb (reg_device (c),
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c00266fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0026701:	8b 40 0c             	mov    0xc(%eax),%eax
c0026704:	83 f8 01             	cmp    $0x1,%eax
c0026707:	75 04                	jne    c002670d <select_sector+0xd3>
c0026709:	b0 f0                	mov    $0xf0,%al
c002670b:	eb 02                	jmp    c002670f <select_sector+0xd5>
c002670d:	b0 e0                	mov    $0xe0,%al
c002670f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026712:	c1 ea 18             	shr    $0x18,%edx
c0026715:	09 d0                	or     %edx,%eax
  outb (reg_device (c),
c0026717:	0f b6 d0             	movzbl %al,%edx
c002671a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002671d:	8b 40 08             	mov    0x8(%eax),%eax
c0026720:	83 c0 06             	add    $0x6,%eax
c0026723:	0f b7 c0             	movzwl %ax,%eax
c0026726:	83 ec 08             	sub    $0x8,%esp
c0026729:	52                   	push   %edx
c002672a:	50                   	push   %eax
c002672b:	e8 dc f5 ff ff       	call   c0025d0c <outb>
c0026730:	83 c4 10             	add    $0x10,%esp
}
c0026733:	90                   	nop
c0026734:	c9                   	leave  
c0026735:	c3                   	ret    

c0026736 <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c0026736:	55                   	push   %ebp
c0026737:	89 e5                	mov    %esp,%ebp
c0026739:	83 ec 18             	sub    $0x18,%esp
c002673c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002673f:	88 45 f4             	mov    %al,-0xc(%ebp)
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c0026742:	e8 db b1 ff ff       	call   c0021922 <intr_get_level>
c0026747:	83 f8 01             	cmp    $0x1,%eax
c002674a:	74 21                	je     c002676d <issue_pio_command+0x37>
c002674c:	83 ec 0c             	sub    $0xc,%esp
c002674f:	68 82 1d 03 c0       	push   $0xc0031d82
c0026754:	68 dd 1c 03 c0       	push   $0xc0031cdd
c0026759:	68 34 1e 03 c0       	push   $0xc0031e34
c002675e:	68 9b 01 00 00       	push   $0x19b
c0026763:	68 ba 1c 03 c0       	push   $0xc0031cba
c0026768:	e8 30 34 00 00       	call   c0029b9d <debug_panic>

  c->expecting_interrupt = true;
c002676d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026770:	c6 40 2c 01          	movb   $0x1,0x2c(%eax)
  outb (reg_command (c), command);
c0026774:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0026778:	8b 45 08             	mov    0x8(%ebp),%eax
c002677b:	8b 40 08             	mov    0x8(%eax),%eax
c002677e:	83 c0 07             	add    $0x7,%eax
c0026781:	0f b7 c0             	movzwl %ax,%eax
c0026784:	83 ec 08             	sub    $0x8,%esp
c0026787:	52                   	push   %edx
c0026788:	50                   	push   %eax
c0026789:	e8 7e f5 ff ff       	call   c0025d0c <outb>
c002678e:	83 c4 10             	add    $0x10,%esp
}
c0026791:	90                   	nop
c0026792:	c9                   	leave  
c0026793:	c3                   	ret    

c0026794 <input_sector>:

/* Reads a sector from channel C's data register in PIO mode into
   SECTOR, which must have room for BLOCK_SECTOR_SIZE bytes. */
static void
input_sector (struct channel *c, void *sector) 
{
c0026794:	55                   	push   %ebp
c0026795:	89 e5                	mov    %esp,%ebp
  insw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026797:	8b 45 08             	mov    0x8(%ebp),%eax
c002679a:	8b 40 08             	mov    0x8(%eax),%eax
c002679d:	0f b7 c0             	movzwl %ax,%eax
c00267a0:	68 00 01 00 00       	push   $0x100
c00267a5:	ff 75 0c             	pushl  0xc(%ebp)
c00267a8:	50                   	push   %eax
c00267a9:	e8 2b f5 ff ff       	call   c0025cd9 <insw>
c00267ae:	83 c4 0c             	add    $0xc,%esp
}
c00267b1:	90                   	nop
c00267b2:	c9                   	leave  
c00267b3:	c3                   	ret    

c00267b4 <output_sector>:

/* Writes SECTOR to channel C's data register in PIO mode.
   SECTOR must contain BLOCK_SECTOR_SIZE bytes. */
static void
output_sector (struct channel *c, const void *sector) 
{
c00267b4:	55                   	push   %ebp
c00267b5:	89 e5                	mov    %esp,%ebp
  outsw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c00267b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00267ba:	8b 40 08             	mov    0x8(%eax),%eax
c00267bd:	0f b7 c0             	movzwl %ax,%eax
c00267c0:	68 00 01 00 00       	push   $0x100
c00267c5:	ff 75 0c             	pushl  0xc(%ebp)
c00267c8:	50                   	push   %eax
c00267c9:	e8 5b f5 ff ff       	call   c0025d29 <outsw>
c00267ce:	83 c4 0c             	add    $0xc,%esp
}
c00267d1:	90                   	nop
c00267d2:	c9                   	leave  
c00267d3:	c3                   	ret    

c00267d4 <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c00267d4:	55                   	push   %ebp
c00267d5:	89 e5                	mov    %esp,%ebp
c00267d7:	83 ec 18             	sub    $0x18,%esp
  int i;

  for (i = 0; i < 1000; i++) 
c00267da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00267e1:	eb 36                	jmp    c0026819 <wait_until_idle+0x45>
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c00267e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00267e6:	8b 40 08             	mov    0x8(%eax),%eax
c00267e9:	8b 40 08             	mov    0x8(%eax),%eax
c00267ec:	83 c0 07             	add    $0x7,%eax
c00267ef:	0f b7 c0             	movzwl %ax,%eax
c00267f2:	50                   	push   %eax
c00267f3:	e8 c6 f4 ff ff       	call   c0025cbe <inb>
c00267f8:	83 c4 04             	add    $0x4,%esp
c00267fb:	0f b6 c0             	movzbl %al,%eax
c00267fe:	25 88 00 00 00       	and    $0x88,%eax
c0026803:	85 c0                	test   %eax,%eax
c0026805:	74 31                	je     c0026838 <wait_until_idle+0x64>
        return;
      timer_usleep (10);
c0026807:	83 ec 08             	sub    $0x8,%esp
c002680a:	6a 00                	push   $0x0
c002680c:	6a 0a                	push   $0xa
c002680e:	e8 de db ff ff       	call   c00243f1 <timer_usleep>
c0026813:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 1000; i++) 
c0026816:	ff 45 f4             	incl   -0xc(%ebp)
c0026819:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c0026820:	7e c1                	jle    c00267e3 <wait_until_idle+0xf>
    }

  printf ("%s: idle timeout\n", d->name);
c0026822:	8b 45 08             	mov    0x8(%ebp),%eax
c0026825:	83 ec 08             	sub    $0x8,%esp
c0026828:	50                   	push   %eax
c0026829:	68 9f 1d 03 c0       	push   $0xc0031d9f
c002682e:	e8 ab 0f 00 00       	call   c00277de <printf>
c0026833:	83 c4 10             	add    $0x10,%esp
c0026836:	eb 01                	jmp    c0026839 <wait_until_idle+0x65>
        return;
c0026838:	90                   	nop
}
c0026839:	c9                   	leave  
c002683a:	c3                   	ret    

c002683b <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c002683b:	55                   	push   %ebp
c002683c:	89 e5                	mov    %esp,%ebp
c002683e:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026841:	8b 45 08             	mov    0x8(%ebp),%eax
c0026844:	8b 40 08             	mov    0x8(%eax),%eax
c0026847:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < 3000; i++)
c002684a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026851:	e9 8d 00 00 00       	jmp    c00268e3 <wait_while_busy+0xa8>
    {
      if (i == 700)
c0026856:	81 7d f4 bc 02 00 00 	cmpl   $0x2bc,-0xc(%ebp)
c002685d:	75 14                	jne    c0026873 <wait_while_busy+0x38>
        printf ("%s: busy, waiting...", d->name);
c002685f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026862:	83 ec 08             	sub    $0x8,%esp
c0026865:	50                   	push   %eax
c0026866:	68 b1 1d 03 c0       	push   $0xc0031db1
c002686b:	e8 6e 0f 00 00       	call   c00277de <printf>
c0026870:	83 c4 10             	add    $0x10,%esp
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c0026873:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026876:	8b 40 08             	mov    0x8(%eax),%eax
c0026879:	05 06 02 00 00       	add    $0x206,%eax
c002687e:	0f b7 c0             	movzwl %ax,%eax
c0026881:	83 ec 0c             	sub    $0xc,%esp
c0026884:	50                   	push   %eax
c0026885:	e8 34 f4 ff ff       	call   c0025cbe <inb>
c002688a:	83 c4 10             	add    $0x10,%esp
c002688d:	84 c0                	test   %al,%al
c002688f:	78 40                	js     c00268d1 <wait_while_busy+0x96>
        {
          if (i >= 700)
c0026891:	81 7d f4 bb 02 00 00 	cmpl   $0x2bb,-0xc(%ebp)
c0026898:	7e 10                	jle    c00268aa <wait_while_busy+0x6f>
            printf ("ok\n");
c002689a:	83 ec 0c             	sub    $0xc,%esp
c002689d:	68 c6 1d 03 c0       	push   $0xc0031dc6
c00268a2:	e8 c8 55 00 00       	call   c002be6f <puts>
c00268a7:	83 c4 10             	add    $0x10,%esp
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c00268aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00268ad:	8b 40 08             	mov    0x8(%eax),%eax
c00268b0:	05 06 02 00 00       	add    $0x206,%eax
c00268b5:	0f b7 c0             	movzwl %ax,%eax
c00268b8:	83 ec 0c             	sub    $0xc,%esp
c00268bb:	50                   	push   %eax
c00268bc:	e8 fd f3 ff ff       	call   c0025cbe <inb>
c00268c1:	83 c4 10             	add    $0x10,%esp
c00268c4:	0f b6 c0             	movzbl %al,%eax
c00268c7:	83 e0 08             	and    $0x8,%eax
c00268ca:	85 c0                	test   %eax,%eax
c00268cc:	0f 95 c0             	setne  %al
c00268cf:	eb 31                	jmp    c0026902 <wait_while_busy+0xc7>
        }
      timer_msleep (10);
c00268d1:	83 ec 08             	sub    $0x8,%esp
c00268d4:	6a 00                	push   $0x0
c00268d6:	6a 0a                	push   $0xa
c00268d8:	e8 e9 da ff ff       	call   c00243c6 <timer_msleep>
c00268dd:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 3000; i++)
c00268e0:	ff 45 f4             	incl   -0xc(%ebp)
c00268e3:	81 7d f4 b7 0b 00 00 	cmpl   $0xbb7,-0xc(%ebp)
c00268ea:	0f 8e 66 ff ff ff    	jle    c0026856 <wait_while_busy+0x1b>
    }

  printf ("failed\n");
c00268f0:	83 ec 0c             	sub    $0xc,%esp
c00268f3:	68 c9 1d 03 c0       	push   $0xc0031dc9
c00268f8:	e8 72 55 00 00       	call   c002be6f <puts>
c00268fd:	83 c4 10             	add    $0x10,%esp
  return false;
c0026900:	b0 00                	mov    $0x0,%al
}
c0026902:	c9                   	leave  
c0026903:	c3                   	ret    

c0026904 <select_device>:

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c0026904:	55                   	push   %ebp
c0026905:	89 e5                	mov    %esp,%ebp
c0026907:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c002690a:	8b 45 08             	mov    0x8(%ebp),%eax
c002690d:	8b 40 08             	mov    0x8(%eax),%eax
c0026910:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t dev = DEV_MBS;
c0026913:	c6 45 f7 a0          	movb   $0xa0,-0x9(%ebp)
  if (d->dev_no == 1)
c0026917:	8b 45 08             	mov    0x8(%ebp),%eax
c002691a:	8b 40 0c             	mov    0xc(%eax),%eax
c002691d:	83 f8 01             	cmp    $0x1,%eax
c0026920:	75 04                	jne    c0026926 <select_device+0x22>
    dev |= DEV_DEV;
c0026922:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
  outb (reg_device (c), dev);
c0026926:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c002692a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002692d:	8b 40 08             	mov    0x8(%eax),%eax
c0026930:	83 c0 06             	add    $0x6,%eax
c0026933:	0f b7 c0             	movzwl %ax,%eax
c0026936:	52                   	push   %edx
c0026937:	50                   	push   %eax
c0026938:	e8 cf f3 ff ff       	call   c0025d0c <outb>
c002693d:	83 c4 08             	add    $0x8,%esp
  inb (reg_alt_status (c));
c0026940:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026943:	8b 40 08             	mov    0x8(%eax),%eax
c0026946:	05 06 02 00 00       	add    $0x206,%eax
c002694b:	0f b7 c0             	movzwl %ax,%eax
c002694e:	50                   	push   %eax
c002694f:	e8 6a f3 ff ff       	call   c0025cbe <inb>
c0026954:	83 c4 04             	add    $0x4,%esp
  timer_nsleep (400);
c0026957:	83 ec 08             	sub    $0x8,%esp
c002695a:	6a 00                	push   $0x0
c002695c:	68 90 01 00 00       	push   $0x190
c0026961:	e8 b6 da ff ff       	call   c002441c <timer_nsleep>
c0026966:	83 c4 10             	add    $0x10,%esp
}
c0026969:	90                   	nop
c002696a:	c9                   	leave  
c002696b:	c3                   	ret    

c002696c <select_device_wait>:

/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
c002696c:	55                   	push   %ebp
c002696d:	89 e5                	mov    %esp,%ebp
c002696f:	83 ec 08             	sub    $0x8,%esp
  wait_until_idle (d);
c0026972:	83 ec 0c             	sub    $0xc,%esp
c0026975:	ff 75 08             	pushl  0x8(%ebp)
c0026978:	e8 57 fe ff ff       	call   c00267d4 <wait_until_idle>
c002697d:	83 c4 10             	add    $0x10,%esp
  select_device (d);
c0026980:	83 ec 0c             	sub    $0xc,%esp
c0026983:	ff 75 08             	pushl  0x8(%ebp)
c0026986:	e8 79 ff ff ff       	call   c0026904 <select_device>
c002698b:	83 c4 10             	add    $0x10,%esp
  wait_until_idle (d);
c002698e:	83 ec 0c             	sub    $0xc,%esp
c0026991:	ff 75 08             	pushl  0x8(%ebp)
c0026994:	e8 3b fe ff ff       	call   c00267d4 <wait_until_idle>
c0026999:	83 c4 10             	add    $0x10,%esp
}
c002699c:	90                   	nop
c002699d:	c9                   	leave  
c002699e:	c3                   	ret    

c002699f <interrupt_handler>:

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c002699f:	55                   	push   %ebp
c00269a0:	89 e5                	mov    %esp,%ebp
c00269a2:	83 ec 18             	sub    $0x18,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c00269a5:	c7 45 f4 a0 a3 03 c0 	movl   $0xc003a3a0,-0xc(%ebp)
c00269ac:	eb 60                	jmp    c0026a0e <interrupt_handler+0x6f>
    if (f->vec_no == c->irq)
c00269ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00269b1:	8b 50 30             	mov    0x30(%eax),%edx
c00269b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00269b7:	8a 40 0a             	mov    0xa(%eax),%al
c00269ba:	0f b6 c0             	movzbl %al,%eax
c00269bd:	39 c2                	cmp    %eax,%edx
c00269bf:	75 49                	jne    c0026a0a <interrupt_handler+0x6b>
      {
        if (c->expecting_interrupt) 
c00269c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00269c4:	8a 40 2c             	mov    0x2c(%eax),%al
c00269c7:	84 c0                	test   %al,%al
c00269c9:	74 29                	je     c00269f4 <interrupt_handler+0x55>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
c00269cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00269ce:	8b 40 08             	mov    0x8(%eax),%eax
c00269d1:	83 c0 07             	add    $0x7,%eax
c00269d4:	0f b7 c0             	movzwl %ax,%eax
c00269d7:	50                   	push   %eax
c00269d8:	e8 e1 f2 ff ff       	call   c0025cbe <inb>
c00269dd:	83 c4 04             	add    $0x4,%esp
            semaphore_up (&c->completion_wait);      /* Wake up waiter. */
c00269e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00269e3:	83 c0 30             	add    $0x30,%eax
c00269e6:	83 ec 0c             	sub    $0xc,%esp
c00269e9:	50                   	push   %eax
c00269ea:	e8 f8 c4 ff ff       	call   c0022ee7 <semaphore_up>
c00269ef:	83 c4 10             	add    $0x10,%esp
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
c00269f2:	eb 3d                	jmp    c0026a31 <interrupt_handler+0x92>
          printf ("%s: unexpected interrupt\n", c->name);
c00269f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00269f7:	83 ec 08             	sub    $0x8,%esp
c00269fa:	50                   	push   %eax
c00269fb:	68 d0 1d 03 c0       	push   $0xc0031dd0
c0026a00:	e8 d9 0d 00 00       	call   c00277de <printf>
c0026a05:	83 c4 10             	add    $0x10,%esp
        return;
c0026a08:	eb 27                	jmp    c0026a31 <interrupt_handler+0x92>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0026a0a:	83 45 f4 6c          	addl   $0x6c,-0xc(%ebp)
c0026a0e:	b8 78 a4 03 c0       	mov    $0xc003a478,%eax
c0026a13:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0026a16:	72 96                	jb     c00269ae <interrupt_handler+0xf>
      }

  NOT_REACHED ();
c0026a18:	68 98 1c 03 c0       	push   $0xc0031c98
c0026a1d:	68 48 1e 03 c0       	push   $0xc0031e48
c0026a22:	68 0c 02 00 00       	push   $0x20c
c0026a27:	68 ba 1c 03 c0       	push   $0xc0031cba
c0026a2c:	e8 6c 31 00 00       	call   c0029b9d <debug_panic>
}
c0026a31:	c9                   	leave  
c0026a32:	c3                   	ret    

c0026a33 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c0026a33:	55                   	push   %ebp
c0026a34:	89 e5                	mov    %esp,%ebp
c0026a36:	83 ec 08             	sub    $0x8,%esp
  intq_init (&buffer);
c0026a39:	83 ec 0c             	sub    $0xc,%esp
c0026a3c:	68 80 a4 03 c0       	push   $0xc003a480
c0026a41:	e8 03 01 00 00       	call   c0026b49 <intq_init>
c0026a46:	83 c4 10             	add    $0x10,%esp
}
c0026a49:	90                   	nop
c0026a4a:	c9                   	leave  
c0026a4b:	c3                   	ret    

c0026a4c <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c0026a4c:	55                   	push   %ebp
c0026a4d:	89 e5                	mov    %esp,%ebp
c0026a4f:	83 ec 18             	sub    $0x18,%esp
c0026a52:	8b 45 08             	mov    0x8(%ebp),%eax
c0026a55:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0026a58:	e8 c5 ae ff ff       	call   c0021922 <intr_get_level>
c0026a5d:	85 c0                	test   %eax,%eax
c0026a5f:	74 1e                	je     c0026a7f <input_putc+0x33>
c0026a61:	83 ec 0c             	sub    $0xc,%esp
c0026a64:	68 5c 1e 03 c0       	push   $0xc0031e5c
c0026a69:	68 7a 1e 03 c0       	push   $0xc0031e7a
c0026a6e:	68 bc 1e 03 c0       	push   $0xc0031ebc
c0026a73:	6a 15                	push   $0x15
c0026a75:	68 91 1e 03 c0       	push   $0xc0031e91
c0026a7a:	e8 1e 31 00 00       	call   c0029b9d <debug_panic>
  ASSERT (!intq_full (&buffer));
c0026a7f:	83 ec 0c             	sub    $0xc,%esp
c0026a82:	68 80 a4 03 c0       	push   $0xc003a480
c0026a87:	e8 41 01 00 00       	call   c0026bcd <intq_full>
c0026a8c:	83 c4 10             	add    $0x10,%esp
c0026a8f:	83 f0 01             	xor    $0x1,%eax
c0026a92:	84 c0                	test   %al,%al
c0026a94:	75 1e                	jne    c0026ab4 <input_putc+0x68>
c0026a96:	83 ec 0c             	sub    $0xc,%esp
c0026a99:	68 a7 1e 03 c0       	push   $0xc0031ea7
c0026a9e:	68 7a 1e 03 c0       	push   $0xc0031e7a
c0026aa3:	68 bc 1e 03 c0       	push   $0xc0031ebc
c0026aa8:	6a 16                	push   $0x16
c0026aaa:	68 91 1e 03 c0       	push   $0xc0031e91
c0026aaf:	e8 e9 30 00 00       	call   c0029b9d <debug_panic>

  intq_putc (&buffer, key);
c0026ab4:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0026ab8:	83 ec 08             	sub    $0x8,%esp
c0026abb:	50                   	push   %eax
c0026abc:	68 80 a4 03 c0       	push   $0xc003a480
c0026ac1:	e8 35 02 00 00       	call   c0026cfb <intq_putc>
c0026ac6:	83 c4 10             	add    $0x10,%esp
  serial_notify ();
c0026ac9:	e8 24 e6 ff ff       	call   c00250f2 <serial_notify>
}
c0026ace:	90                   	nop
c0026acf:	c9                   	leave  
c0026ad0:	c3                   	ret    

c0026ad1 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c0026ad1:	55                   	push   %ebp
c0026ad2:	89 e5                	mov    %esp,%ebp
c0026ad4:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0026ad7:	e8 bb ae ff ff       	call   c0021997 <intr_disable>
c0026adc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  key = intq_getc (&buffer);
c0026adf:	83 ec 0c             	sub    $0xc,%esp
c0026ae2:	68 80 a4 03 c0       	push   $0xc003a480
c0026ae7:	e8 2f 01 00 00       	call   c0026c1b <intq_getc>
c0026aec:	83 c4 10             	add    $0x10,%esp
c0026aef:	88 45 f3             	mov    %al,-0xd(%ebp)
  serial_notify ();
c0026af2:	e8 fb e5 ff ff       	call   c00250f2 <serial_notify>
  intr_set_level (old_level);
c0026af7:	83 ec 0c             	sub    $0xc,%esp
c0026afa:	ff 75 f4             	pushl  -0xc(%ebp)
c0026afd:	e8 3d ae ff ff       	call   c002193f <intr_set_level>
c0026b02:	83 c4 10             	add    $0x10,%esp
  
  return key;
c0026b05:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c0026b08:	c9                   	leave  
c0026b09:	c3                   	ret    

c0026b0a <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c0026b0a:	55                   	push   %ebp
c0026b0b:	89 e5                	mov    %esp,%ebp
c0026b0d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026b10:	e8 0d ae ff ff       	call   c0021922 <intr_get_level>
c0026b15:	85 c0                	test   %eax,%eax
c0026b17:	74 1e                	je     c0026b37 <input_full+0x2d>
c0026b19:	83 ec 0c             	sub    $0xc,%esp
c0026b1c:	68 5c 1e 03 c0       	push   $0xc0031e5c
c0026b21:	68 7a 1e 03 c0       	push   $0xc0031e7a
c0026b26:	68 c8 1e 03 c0       	push   $0xc0031ec8
c0026b2b:	6a 32                	push   $0x32
c0026b2d:	68 91 1e 03 c0       	push   $0xc0031e91
c0026b32:	e8 66 30 00 00       	call   c0029b9d <debug_panic>
  return intq_full (&buffer);
c0026b37:	83 ec 0c             	sub    $0xc,%esp
c0026b3a:	68 80 a4 03 c0       	push   $0xc003a480
c0026b3f:	e8 89 00 00 00       	call   c0026bcd <intq_full>
c0026b44:	83 c4 10             	add    $0x10,%esp
}
c0026b47:	c9                   	leave  
c0026b48:	c3                   	ret    

c0026b49 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c0026b49:	55                   	push   %ebp
c0026b4a:	89 e5                	mov    %esp,%ebp
c0026b4c:	83 ec 08             	sub    $0x8,%esp
  lock_init (&q->lock);
c0026b4f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b52:	83 ec 0c             	sub    $0xc,%esp
c0026b55:	50                   	push   %eax
c0026b56:	e8 f3 c4 ff ff       	call   c002304e <lock_init>
c0026b5b:	83 c4 10             	add    $0x10,%esp
  q->not_full = q->not_empty = NULL;
c0026b5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b61:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
c0026b68:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b6b:	8b 50 24             	mov    0x24(%eax),%edx
c0026b6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b71:	89 50 20             	mov    %edx,0x20(%eax)
  q->head = q->tail = 0;
c0026b74:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b77:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
c0026b7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b81:	8b 50 6c             	mov    0x6c(%eax),%edx
c0026b84:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b87:	89 50 68             	mov    %edx,0x68(%eax)
}
c0026b8a:	90                   	nop
c0026b8b:	c9                   	leave  
c0026b8c:	c3                   	ret    

c0026b8d <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c0026b8d:	55                   	push   %ebp
c0026b8e:	89 e5                	mov    %esp,%ebp
c0026b90:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026b93:	e8 8a ad ff ff       	call   c0021922 <intr_get_level>
c0026b98:	85 c0                	test   %eax,%eax
c0026b9a:	74 1e                	je     c0026bba <intq_empty+0x2d>
c0026b9c:	83 ec 0c             	sub    $0xc,%esp
c0026b9f:	68 d4 1e 03 c0       	push   $0xc0031ed4
c0026ba4:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026ba9:	68 e8 1f 03 c0       	push   $0xc0031fe8
c0026bae:	6a 16                	push   $0x16
c0026bb0:	68 09 1f 03 c0       	push   $0xc0031f09
c0026bb5:	e8 e3 2f 00 00       	call   c0029b9d <debug_panic>
  return q->head == q->tail;
c0026bba:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bbd:	8b 50 68             	mov    0x68(%eax),%edx
c0026bc0:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bc3:	8b 40 6c             	mov    0x6c(%eax),%eax
c0026bc6:	39 c2                	cmp    %eax,%edx
c0026bc8:	0f 94 c0             	sete   %al
}
c0026bcb:	c9                   	leave  
c0026bcc:	c3                   	ret    

c0026bcd <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c0026bcd:	55                   	push   %ebp
c0026bce:	89 e5                	mov    %esp,%ebp
c0026bd0:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026bd3:	e8 4a ad ff ff       	call   c0021922 <intr_get_level>
c0026bd8:	85 c0                	test   %eax,%eax
c0026bda:	74 1e                	je     c0026bfa <intq_full+0x2d>
c0026bdc:	83 ec 0c             	sub    $0xc,%esp
c0026bdf:	68 d4 1e 03 c0       	push   $0xc0031ed4
c0026be4:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026be9:	68 f4 1f 03 c0       	push   $0xc0031ff4
c0026bee:	6a 1e                	push   $0x1e
c0026bf0:	68 09 1f 03 c0       	push   $0xc0031f09
c0026bf5:	e8 a3 2f 00 00       	call   c0029b9d <debug_panic>
  return next (q->head) == q->tail;
c0026bfa:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bfd:	8b 40 68             	mov    0x68(%eax),%eax
c0026c00:	83 ec 0c             	sub    $0xc,%esp
c0026c03:	50                   	push   %eax
c0026c04:	e8 d6 01 00 00       	call   c0026ddf <next>
c0026c09:	83 c4 10             	add    $0x10,%esp
c0026c0c:	89 c2                	mov    %eax,%edx
c0026c0e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c11:	8b 40 6c             	mov    0x6c(%eax),%eax
c0026c14:	39 c2                	cmp    %eax,%edx
c0026c16:	0f 94 c0             	sete   %al
}
c0026c19:	c9                   	leave  
c0026c1a:	c3                   	ret    

c0026c1b <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c0026c1b:	55                   	push   %ebp
c0026c1c:	89 e5                	mov    %esp,%ebp
c0026c1e:	83 ec 18             	sub    $0x18,%esp
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c0026c21:	e8 fc ac ff ff       	call   c0021922 <intr_get_level>
c0026c26:	85 c0                	test   %eax,%eax
c0026c28:	74 7b                	je     c0026ca5 <intq_getc+0x8a>
c0026c2a:	83 ec 0c             	sub    $0xc,%esp
c0026c2d:	68 d4 1e 03 c0       	push   $0xc0031ed4
c0026c32:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026c37:	68 00 20 03 c0       	push   $0xc0032000
c0026c3c:	6a 2a                	push   $0x2a
c0026c3e:	68 09 1f 03 c0       	push   $0xc0031f09
c0026c43:	e8 55 2f 00 00       	call   c0029b9d <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c0026c48:	e8 17 b0 ff ff       	call   c0021c64 <intr_context>
c0026c4d:	83 f0 01             	xor    $0x1,%eax
c0026c50:	84 c0                	test   %al,%al
c0026c52:	75 1e                	jne    c0026c72 <intq_getc+0x57>
c0026c54:	83 ec 0c             	sub    $0xc,%esp
c0026c57:	68 1e 1f 03 c0       	push   $0xc0031f1e
c0026c5c:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026c61:	68 00 20 03 c0       	push   $0xc0032000
c0026c66:	6a 2d                	push   $0x2d
c0026c68:	68 09 1f 03 c0       	push   $0xc0031f09
c0026c6d:	e8 2b 2f 00 00       	call   c0029b9d <debug_panic>
      lock_acquire (&q->lock);
c0026c72:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c75:	83 ec 0c             	sub    $0xc,%esp
c0026c78:	50                   	push   %eax
c0026c79:	e8 1d c4 ff ff       	call   c002309b <lock_acquire>
c0026c7e:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_empty);
c0026c81:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c84:	83 c0 24             	add    $0x24,%eax
c0026c87:	83 ec 08             	sub    $0x8,%esp
c0026c8a:	50                   	push   %eax
c0026c8b:	ff 75 08             	pushl  0x8(%ebp)
c0026c8e:	e8 63 01 00 00       	call   c0026df6 <wait>
c0026c93:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026c96:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c99:	83 ec 0c             	sub    $0xc,%esp
c0026c9c:	50                   	push   %eax
c0026c9d:	e8 77 c5 ff ff       	call   c0023219 <lock_release>
c0026ca2:	83 c4 10             	add    $0x10,%esp
  while (intq_empty (q)) 
c0026ca5:	83 ec 0c             	sub    $0xc,%esp
c0026ca8:	ff 75 08             	pushl  0x8(%ebp)
c0026cab:	e8 dd fe ff ff       	call   c0026b8d <intq_empty>
c0026cb0:	83 c4 10             	add    $0x10,%esp
c0026cb3:	84 c0                	test   %al,%al
c0026cb5:	75 91                	jne    c0026c48 <intq_getc+0x2d>
    }
  
  byte = q->buf[q->tail];
c0026cb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0026cba:	8b 40 6c             	mov    0x6c(%eax),%eax
c0026cbd:	8b 55 08             	mov    0x8(%ebp),%edx
c0026cc0:	8a 44 02 28          	mov    0x28(%edx,%eax,1),%al
c0026cc4:	88 45 f7             	mov    %al,-0x9(%ebp)
  q->tail = next (q->tail);
c0026cc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0026cca:	8b 40 6c             	mov    0x6c(%eax),%eax
c0026ccd:	83 ec 0c             	sub    $0xc,%esp
c0026cd0:	50                   	push   %eax
c0026cd1:	e8 09 01 00 00       	call   c0026ddf <next>
c0026cd6:	83 c4 10             	add    $0x10,%esp
c0026cd9:	89 c2                	mov    %eax,%edx
c0026cdb:	8b 45 08             	mov    0x8(%ebp),%eax
c0026cde:	89 50 6c             	mov    %edx,0x6c(%eax)
  signal (q, &q->not_full);
c0026ce1:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ce4:	83 c0 20             	add    $0x20,%eax
c0026ce7:	83 ec 08             	sub    $0x8,%esp
c0026cea:	50                   	push   %eax
c0026ceb:	ff 75 08             	pushl  0x8(%ebp)
c0026cee:	e8 c6 01 00 00       	call   c0026eb9 <signal>
c0026cf3:	83 c4 10             	add    $0x10,%esp
  return byte;
c0026cf6:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c0026cf9:	c9                   	leave  
c0026cfa:	c3                   	ret    

c0026cfb <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c0026cfb:	55                   	push   %ebp
c0026cfc:	89 e5                	mov    %esp,%ebp
c0026cfe:	83 ec 18             	sub    $0x18,%esp
c0026d01:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026d04:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0026d07:	e8 16 ac ff ff       	call   c0021922 <intr_get_level>
c0026d0c:	85 c0                	test   %eax,%eax
c0026d0e:	74 7b                	je     c0026d8b <intq_putc+0x90>
c0026d10:	83 ec 0c             	sub    $0xc,%esp
c0026d13:	68 d4 1e 03 c0       	push   $0xc0031ed4
c0026d18:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026d1d:	68 0c 20 03 c0       	push   $0xc003200c
c0026d22:	6a 3f                	push   $0x3f
c0026d24:	68 09 1f 03 c0       	push   $0xc0031f09
c0026d29:	e8 6f 2e 00 00       	call   c0029b9d <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c0026d2e:	e8 31 af ff ff       	call   c0021c64 <intr_context>
c0026d33:	83 f0 01             	xor    $0x1,%eax
c0026d36:	84 c0                	test   %al,%al
c0026d38:	75 1e                	jne    c0026d58 <intq_putc+0x5d>
c0026d3a:	83 ec 0c             	sub    $0xc,%esp
c0026d3d:	68 1e 1f 03 c0       	push   $0xc0031f1e
c0026d42:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026d47:	68 0c 20 03 c0       	push   $0xc003200c
c0026d4c:	6a 42                	push   $0x42
c0026d4e:	68 09 1f 03 c0       	push   $0xc0031f09
c0026d53:	e8 45 2e 00 00       	call   c0029b9d <debug_panic>
      lock_acquire (&q->lock);
c0026d58:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d5b:	83 ec 0c             	sub    $0xc,%esp
c0026d5e:	50                   	push   %eax
c0026d5f:	e8 37 c3 ff ff       	call   c002309b <lock_acquire>
c0026d64:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_full);
c0026d67:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d6a:	83 c0 20             	add    $0x20,%eax
c0026d6d:	83 ec 08             	sub    $0x8,%esp
c0026d70:	50                   	push   %eax
c0026d71:	ff 75 08             	pushl  0x8(%ebp)
c0026d74:	e8 7d 00 00 00       	call   c0026df6 <wait>
c0026d79:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026d7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d7f:	83 ec 0c             	sub    $0xc,%esp
c0026d82:	50                   	push   %eax
c0026d83:	e8 91 c4 ff ff       	call   c0023219 <lock_release>
c0026d88:	83 c4 10             	add    $0x10,%esp
  while (intq_full (q))
c0026d8b:	83 ec 0c             	sub    $0xc,%esp
c0026d8e:	ff 75 08             	pushl  0x8(%ebp)
c0026d91:	e8 37 fe ff ff       	call   c0026bcd <intq_full>
c0026d96:	83 c4 10             	add    $0x10,%esp
c0026d99:	84 c0                	test   %al,%al
c0026d9b:	75 91                	jne    c0026d2e <intq_putc+0x33>
    }

  q->buf[q->head] = byte;
c0026d9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026da0:	8b 40 68             	mov    0x68(%eax),%eax
c0026da3:	8b 55 08             	mov    0x8(%ebp),%edx
c0026da6:	8a 4d f4             	mov    -0xc(%ebp),%cl
c0026da9:	88 4c 02 28          	mov    %cl,0x28(%edx,%eax,1)
  q->head = next (q->head);
c0026dad:	8b 45 08             	mov    0x8(%ebp),%eax
c0026db0:	8b 40 68             	mov    0x68(%eax),%eax
c0026db3:	83 ec 0c             	sub    $0xc,%esp
c0026db6:	50                   	push   %eax
c0026db7:	e8 23 00 00 00       	call   c0026ddf <next>
c0026dbc:	83 c4 10             	add    $0x10,%esp
c0026dbf:	89 c2                	mov    %eax,%edx
c0026dc1:	8b 45 08             	mov    0x8(%ebp),%eax
c0026dc4:	89 50 68             	mov    %edx,0x68(%eax)
  signal (q, &q->not_empty);
c0026dc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0026dca:	83 c0 24             	add    $0x24,%eax
c0026dcd:	83 ec 08             	sub    $0x8,%esp
c0026dd0:	50                   	push   %eax
c0026dd1:	ff 75 08             	pushl  0x8(%ebp)
c0026dd4:	e8 e0 00 00 00       	call   c0026eb9 <signal>
c0026dd9:	83 c4 10             	add    $0x10,%esp
}
c0026ddc:	90                   	nop
c0026ddd:	c9                   	leave  
c0026dde:	c3                   	ret    

c0026ddf <next>:

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
c0026ddf:	55                   	push   %ebp
c0026de0:	89 e5                	mov    %esp,%ebp
  return (pos + 1) % INTQ_BUFSIZE;
c0026de2:	8b 45 08             	mov    0x8(%ebp),%eax
c0026de5:	40                   	inc    %eax
c0026de6:	25 3f 00 00 80       	and    $0x8000003f,%eax
c0026deb:	85 c0                	test   %eax,%eax
c0026ded:	79 05                	jns    c0026df4 <next+0x15>
c0026def:	48                   	dec    %eax
c0026df0:	83 c8 c0             	or     $0xffffffc0,%eax
c0026df3:	40                   	inc    %eax
}
c0026df4:	5d                   	pop    %ebp
c0026df5:	c3                   	ret    

c0026df6 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0026df6:	55                   	push   %ebp
c0026df7:	89 e5                	mov    %esp,%ebp
c0026df9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0026dfc:	e8 63 ae ff ff       	call   c0021c64 <intr_context>
c0026e01:	83 f0 01             	xor    $0x1,%eax
c0026e04:	84 c0                	test   %al,%al
c0026e06:	75 1e                	jne    c0026e26 <wait+0x30>
c0026e08:	83 ec 0c             	sub    $0xc,%esp
c0026e0b:	68 1e 1f 03 c0       	push   $0xc0031f1e
c0026e10:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026e15:	68 18 20 03 c0       	push   $0xc0032018
c0026e1a:	6a 59                	push   $0x59
c0026e1c:	68 09 1f 03 c0       	push   $0xc0031f09
c0026e21:	e8 77 2d 00 00       	call   c0029b9d <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0026e26:	e8 f7 aa ff ff       	call   c0021922 <intr_get_level>
c0026e2b:	85 c0                	test   %eax,%eax
c0026e2d:	74 1e                	je     c0026e4d <wait+0x57>
c0026e2f:	83 ec 0c             	sub    $0xc,%esp
c0026e32:	68 d4 1e 03 c0       	push   $0xc0031ed4
c0026e37:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026e3c:	68 18 20 03 c0       	push   $0xc0032018
c0026e41:	6a 5a                	push   $0x5a
c0026e43:	68 09 1f 03 c0       	push   $0xc0031f09
c0026e48:	e8 50 2d 00 00       	call   c0029b9d <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0026e4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026e50:	83 c0 24             	add    $0x24,%eax
c0026e53:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026e56:	75 12                	jne    c0026e6a <wait+0x74>
c0026e58:	83 ec 0c             	sub    $0xc,%esp
c0026e5b:	ff 75 08             	pushl  0x8(%ebp)
c0026e5e:	e8 2a fd ff ff       	call   c0026b8d <intq_empty>
c0026e63:	83 c4 10             	add    $0x10,%esp
c0026e66:	84 c0                	test   %al,%al
c0026e68:	75 3b                	jne    c0026ea5 <wait+0xaf>
c0026e6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0026e6d:	83 c0 20             	add    $0x20,%eax
c0026e70:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026e73:	75 12                	jne    c0026e87 <wait+0x91>
c0026e75:	83 ec 0c             	sub    $0xc,%esp
c0026e78:	ff 75 08             	pushl  0x8(%ebp)
c0026e7b:	e8 4d fd ff ff       	call   c0026bcd <intq_full>
c0026e80:	83 c4 10             	add    $0x10,%esp
c0026e83:	84 c0                	test   %al,%al
c0026e85:	75 1e                	jne    c0026ea5 <wait+0xaf>
c0026e87:	83 ec 0c             	sub    $0xc,%esp
c0026e8a:	68 30 1f 03 c0       	push   $0xc0031f30
c0026e8f:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026e94:	68 18 20 03 c0       	push   $0xc0032018
c0026e99:	6a 5c                	push   $0x5c
c0026e9b:	68 09 1f 03 c0       	push   $0xc0031f09
c0026ea0:	e8 f8 2c 00 00       	call   c0029b9d <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0026ea5:	e8 0c a2 ff ff       	call   c00210b6 <thread_current>
c0026eaa:	89 c2                	mov    %eax,%edx
c0026eac:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026eaf:	89 10                	mov    %edx,(%eax)
  thread_block ();
c0026eb1:	e8 e0 a0 ff ff       	call   c0020f96 <thread_block>
}
c0026eb6:	90                   	nop
c0026eb7:	c9                   	leave  
c0026eb8:	c3                   	ret    

c0026eb9 <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0026eb9:	55                   	push   %ebp
c0026eba:	89 e5                	mov    %esp,%ebp
c0026ebc:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026ebf:	e8 5e aa ff ff       	call   c0021922 <intr_get_level>
c0026ec4:	85 c0                	test   %eax,%eax
c0026ec6:	74 1e                	je     c0026ee6 <signal+0x2d>
c0026ec8:	83 ec 0c             	sub    $0xc,%esp
c0026ecb:	68 d4 1e 03 c0       	push   $0xc0031ed4
c0026ed0:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026ed5:	68 20 20 03 c0       	push   $0xc0032020
c0026eda:	6a 69                	push   $0x69
c0026edc:	68 09 1f 03 c0       	push   $0xc0031f09
c0026ee1:	e8 b7 2c 00 00       	call   c0029b9d <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026ee6:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ee9:	83 c0 24             	add    $0x24,%eax
c0026eec:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026eef:	75 15                	jne    c0026f06 <signal+0x4d>
c0026ef1:	83 ec 0c             	sub    $0xc,%esp
c0026ef4:	ff 75 08             	pushl  0x8(%ebp)
c0026ef7:	e8 91 fc ff ff       	call   c0026b8d <intq_empty>
c0026efc:	83 c4 10             	add    $0x10,%esp
c0026eff:	83 f0 01             	xor    $0x1,%eax
c0026f02:	84 c0                	test   %al,%al
c0026f04:	75 3e                	jne    c0026f44 <signal+0x8b>
c0026f06:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f09:	83 c0 20             	add    $0x20,%eax
c0026f0c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026f0f:	75 15                	jne    c0026f26 <signal+0x6d>
c0026f11:	83 ec 0c             	sub    $0xc,%esp
c0026f14:	ff 75 08             	pushl  0x8(%ebp)
c0026f17:	e8 b1 fc ff ff       	call   c0026bcd <intq_full>
c0026f1c:	83 c4 10             	add    $0x10,%esp
c0026f1f:	83 f0 01             	xor    $0x1,%eax
c0026f22:	84 c0                	test   %al,%al
c0026f24:	75 1e                	jne    c0026f44 <signal+0x8b>
c0026f26:	83 ec 0c             	sub    $0xc,%esp
c0026f29:	68 8c 1f 03 c0       	push   $0xc0031f8c
c0026f2e:	68 f2 1e 03 c0       	push   $0xc0031ef2
c0026f33:	68 20 20 03 c0       	push   $0xc0032020
c0026f38:	6a 6b                	push   $0x6b
c0026f3a:	68 09 1f 03 c0       	push   $0xc0031f09
c0026f3f:	e8 59 2c 00 00       	call   c0029b9d <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c0026f44:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f47:	8b 00                	mov    (%eax),%eax
c0026f49:	85 c0                	test   %eax,%eax
c0026f4b:	74 1a                	je     c0026f67 <signal+0xae>
    {
      thread_unblock (*waiter);
c0026f4d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f50:	8b 00                	mov    (%eax),%eax
c0026f52:	83 ec 0c             	sub    $0xc,%esp
c0026f55:	50                   	push   %eax
c0026f56:	e8 ac a0 ff ff       	call   c0021007 <thread_unblock>
c0026f5b:	83 c4 10             	add    $0x10,%esp
      *waiter = NULL;
c0026f5e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f61:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c0026f67:	90                   	nop
c0026f68:	c9                   	leave  
c0026f69:	c3                   	ret    

c0026f6a <inb>:
{
c0026f6a:	55                   	push   %ebp
c0026f6b:	89 e5                	mov    %esp,%ebp
c0026f6d:	83 ec 14             	sub    $0x14,%esp
c0026f70:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f73:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026f77:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026f7a:	89 c2                	mov    %eax,%edx
c0026f7c:	ec                   	in     (%dx),%al
c0026f7d:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026f80:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0026f83:	c9                   	leave  
c0026f84:	c3                   	ret    

c0026f85 <outb>:
{
c0026f85:	55                   	push   %ebp
c0026f86:	89 e5                	mov    %esp,%ebp
c0026f88:	83 ec 08             	sub    $0x8,%esp
c0026f8b:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f8e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026f91:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0026f95:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026f98:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026f9b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026f9e:	ee                   	out    %al,(%dx)
}
c0026f9f:	90                   	nop
c0026fa0:	c9                   	leave  
c0026fa1:	c3                   	ret    

c0026fa2 <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0026fa2:	55                   	push   %ebp
c0026fa3:	89 e5                	mov    %esp,%ebp
c0026fa5:	83 ec 28             	sub    $0x28,%esp
     but for historical reasons everyone always uses BCD format
     except on obscure non-PC platforms, so we don't bother
     trying to detect the format in use. */
  do
    {
      sec = bcd_to_bin (cmos_read (RTC_REG_SEC));
c0026fa8:	83 ec 0c             	sub    $0xc,%esp
c0026fab:	6a 00                	push   $0x0
c0026fad:	e8 01 02 00 00       	call   c00271b3 <cmos_read>
c0026fb2:	83 c4 10             	add    $0x10,%esp
c0026fb5:	0f b6 c0             	movzbl %al,%eax
c0026fb8:	83 ec 0c             	sub    $0xc,%esp
c0026fbb:	50                   	push   %eax
c0026fbc:	e8 c7 01 00 00       	call   c0027188 <bcd_to_bin>
c0026fc1:	83 c4 10             	add    $0x10,%esp
c0026fc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
      min = bcd_to_bin (cmos_read (RTC_REG_MIN));
c0026fc7:	83 ec 0c             	sub    $0xc,%esp
c0026fca:	6a 02                	push   $0x2
c0026fcc:	e8 e2 01 00 00       	call   c00271b3 <cmos_read>
c0026fd1:	83 c4 10             	add    $0x10,%esp
c0026fd4:	0f b6 c0             	movzbl %al,%eax
c0026fd7:	83 ec 0c             	sub    $0xc,%esp
c0026fda:	50                   	push   %eax
c0026fdb:	e8 a8 01 00 00       	call   c0027188 <bcd_to_bin>
c0026fe0:	83 c4 10             	add    $0x10,%esp
c0026fe3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
c0026fe6:	83 ec 0c             	sub    $0xc,%esp
c0026fe9:	6a 04                	push   $0x4
c0026feb:	e8 c3 01 00 00       	call   c00271b3 <cmos_read>
c0026ff0:	83 c4 10             	add    $0x10,%esp
c0026ff3:	0f b6 c0             	movzbl %al,%eax
c0026ff6:	83 ec 0c             	sub    $0xc,%esp
c0026ff9:	50                   	push   %eax
c0026ffa:	e8 89 01 00 00       	call   c0027188 <bcd_to_bin>
c0026fff:	83 c4 10             	add    $0x10,%esp
c0027002:	89 45 e0             	mov    %eax,-0x20(%ebp)
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
c0027005:	83 ec 0c             	sub    $0xc,%esp
c0027008:	6a 07                	push   $0x7
c002700a:	e8 a4 01 00 00       	call   c00271b3 <cmos_read>
c002700f:	83 c4 10             	add    $0x10,%esp
c0027012:	0f b6 c0             	movzbl %al,%eax
c0027015:	83 ec 0c             	sub    $0xc,%esp
c0027018:	50                   	push   %eax
c0027019:	e8 6a 01 00 00       	call   c0027188 <bcd_to_bin>
c002701e:	83 c4 10             	add    $0x10,%esp
c0027021:	89 45 dc             	mov    %eax,-0x24(%ebp)
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
c0027024:	83 ec 0c             	sub    $0xc,%esp
c0027027:	6a 08                	push   $0x8
c0027029:	e8 85 01 00 00       	call   c00271b3 <cmos_read>
c002702e:	83 c4 10             	add    $0x10,%esp
c0027031:	0f b6 c0             	movzbl %al,%eax
c0027034:	83 ec 0c             	sub    $0xc,%esp
c0027037:	50                   	push   %eax
c0027038:	e8 4b 01 00 00       	call   c0027188 <bcd_to_bin>
c002703d:	83 c4 10             	add    $0x10,%esp
c0027040:	89 45 d8             	mov    %eax,-0x28(%ebp)
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
c0027043:	83 ec 0c             	sub    $0xc,%esp
c0027046:	6a 09                	push   $0x9
c0027048:	e8 66 01 00 00       	call   c00271b3 <cmos_read>
c002704d:	83 c4 10             	add    $0x10,%esp
c0027050:	0f b6 c0             	movzbl %al,%eax
c0027053:	83 ec 0c             	sub    $0xc,%esp
c0027056:	50                   	push   %eax
c0027057:	e8 2c 01 00 00       	call   c0027188 <bcd_to_bin>
c002705c:	83 c4 10             	add    $0x10,%esp
c002705f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c0027062:	83 ec 0c             	sub    $0xc,%esp
c0027065:	6a 00                	push   $0x0
c0027067:	e8 47 01 00 00       	call   c00271b3 <cmos_read>
c002706c:	83 c4 10             	add    $0x10,%esp
c002706f:	0f b6 c0             	movzbl %al,%eax
c0027072:	83 ec 0c             	sub    $0xc,%esp
c0027075:	50                   	push   %eax
c0027076:	e8 0d 01 00 00       	call   c0027188 <bcd_to_bin>
c002707b:	83 c4 10             	add    $0x10,%esp
c002707e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027081:	0f 85 21 ff ff ff    	jne    c0026fa8 <rtc_get_time+0x6>

  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
c0027087:	83 7d f4 45          	cmpl   $0x45,-0xc(%ebp)
c002708b:	7f 04                	jg     c0027091 <rtc_get_time+0xef>
    year += 100;
c002708d:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
  year -= 70;
c0027091:	83 6d f4 46          	subl   $0x46,-0xc(%ebp)

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0027095:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027098:	89 d0                	mov    %edx,%eax
c002709a:	c1 e0 03             	shl    $0x3,%eax
c002709d:	01 d0                	add    %edx,%eax
c002709f:	c1 e0 03             	shl    $0x3,%eax
c00270a2:	01 d0                	add    %edx,%eax
c00270a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00270ab:	01 c2                	add    %eax,%edx
c00270ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00270b0:	48                   	dec    %eax
c00270b1:	85 c0                	test   %eax,%eax
c00270b3:	79 03                	jns    c00270b8 <rtc_get_time+0x116>
c00270b5:	83 c0 03             	add    $0x3,%eax
c00270b8:	c1 f8 02             	sar    $0x2,%eax
c00270bb:	01 c2                	add    %eax,%edx
c00270bd:	89 d0                	mov    %edx,%eax
c00270bf:	c1 e0 02             	shl    $0x2,%eax
c00270c2:	01 d0                	add    %edx,%eax
c00270c4:	c1 e0 02             	shl    $0x2,%eax
c00270c7:	01 d0                	add    %edx,%eax
c00270c9:	c1 e0 03             	shl    $0x3,%eax
c00270cc:	01 d0                	add    %edx,%eax
c00270ce:	c1 e0 02             	shl    $0x2,%eax
c00270d1:	29 d0                	sub    %edx,%eax
c00270d3:	c1 e0 07             	shl    $0x7,%eax
c00270d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c00270d9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c00270e0:	eb 2a                	jmp    c002710c <rtc_get_time+0x16a>
    time += days_per_month[i - 1] * 24 * 60 * 60;
c00270e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00270e5:	48                   	dec    %eax
c00270e6:	8b 14 85 40 20 03 c0 	mov    -0x3ffcdfc0(,%eax,4),%edx
c00270ed:	89 d0                	mov    %edx,%eax
c00270ef:	c1 e0 02             	shl    $0x2,%eax
c00270f2:	01 d0                	add    %edx,%eax
c00270f4:	c1 e0 02             	shl    $0x2,%eax
c00270f7:	01 d0                	add    %edx,%eax
c00270f9:	c1 e0 03             	shl    $0x3,%eax
c00270fc:	01 d0                	add    %edx,%eax
c00270fe:	c1 e0 02             	shl    $0x2,%eax
c0027101:	29 d0                	sub    %edx,%eax
c0027103:	c1 e0 07             	shl    $0x7,%eax
c0027106:	01 45 f0             	add    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c0027109:	ff 45 ec             	incl   -0x14(%ebp)
c002710c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002710f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0027112:	7e ce                	jle    c00270e2 <rtc_get_time+0x140>
  if (mon > 2 && year % 4 == 0)
c0027114:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
c0027118:	7e 11                	jle    c002712b <rtc_get_time+0x189>
c002711a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002711d:	83 e0 03             	and    $0x3,%eax
c0027120:	85 c0                	test   %eax,%eax
c0027122:	75 07                	jne    c002712b <rtc_get_time+0x189>
    time += 24 * 60 * 60;
c0027124:	81 45 f0 80 51 01 00 	addl   $0x15180,-0x10(%ebp)
  time += (mday - 1) * 24 * 60 * 60;
c002712b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002712e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027131:	89 d0                	mov    %edx,%eax
c0027133:	c1 e0 02             	shl    $0x2,%eax
c0027136:	01 d0                	add    %edx,%eax
c0027138:	c1 e0 02             	shl    $0x2,%eax
c002713b:	01 d0                	add    %edx,%eax
c002713d:	c1 e0 03             	shl    $0x3,%eax
c0027140:	01 d0                	add    %edx,%eax
c0027142:	c1 e0 02             	shl    $0x2,%eax
c0027145:	29 d0                	sub    %edx,%eax
c0027147:	c1 e0 07             	shl    $0x7,%eax
c002714a:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += hour * 60 * 60;
c002714d:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0027150:	89 d0                	mov    %edx,%eax
c0027152:	01 c0                	add    %eax,%eax
c0027154:	01 d0                	add    %edx,%eax
c0027156:	01 c0                	add    %eax,%eax
c0027158:	01 d0                	add    %edx,%eax
c002715a:	c1 e0 05             	shl    $0x5,%eax
c002715d:	01 d0                	add    %edx,%eax
c002715f:	c1 e0 04             	shl    $0x4,%eax
c0027162:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += min * 60;
c0027165:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027168:	89 d0                	mov    %edx,%eax
c002716a:	01 c0                	add    %eax,%eax
c002716c:	01 d0                	add    %edx,%eax
c002716e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0027175:	01 d0                	add    %edx,%eax
c0027177:	c1 e0 02             	shl    $0x2,%eax
c002717a:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += sec;
c002717d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027180:	01 45 f0             	add    %eax,-0x10(%ebp)

  return time;
c0027183:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0027186:	c9                   	leave  
c0027187:	c3                   	ret    

c0027188 <bcd_to_bin>:

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
c0027188:	55                   	push   %ebp
c0027189:	89 e5                	mov    %esp,%ebp
c002718b:	83 ec 04             	sub    $0x4,%esp
c002718e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027191:	88 45 fc             	mov    %al,-0x4(%ebp)
  return (x & 0x0f) + ((x >> 4) * 10);
c0027194:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0027198:	83 e0 0f             	and    $0xf,%eax
c002719b:	89 c1                	mov    %eax,%ecx
c002719d:	8a 45 fc             	mov    -0x4(%ebp),%al
c00271a0:	c0 e8 04             	shr    $0x4,%al
c00271a3:	0f b6 d0             	movzbl %al,%edx
c00271a6:	89 d0                	mov    %edx,%eax
c00271a8:	c1 e0 02             	shl    $0x2,%eax
c00271ab:	01 d0                	add    %edx,%eax
c00271ad:	01 c0                	add    %eax,%eax
c00271af:	01 c8                	add    %ecx,%eax
}
c00271b1:	c9                   	leave  
c00271b2:	c3                   	ret    

c00271b3 <cmos_read>:

/* Reads a byte from the CMOS register with the given INDEX and
   returns the byte read. */
static uint8_t
cmos_read (uint8_t index)
{
c00271b3:	55                   	push   %ebp
c00271b4:	89 e5                	mov    %esp,%ebp
c00271b6:	83 ec 04             	sub    $0x4,%esp
c00271b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00271bc:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb (CMOS_REG_SET, index);
c00271bf:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00271c3:	50                   	push   %eax
c00271c4:	6a 70                	push   $0x70
c00271c6:	e8 ba fd ff ff       	call   c0026f85 <outb>
c00271cb:	83 c4 08             	add    $0x8,%esp
  return inb (CMOS_REG_IO);
c00271ce:	6a 71                	push   $0x71
c00271d0:	e8 95 fd ff ff       	call   c0026f6a <inb>
c00271d5:	83 c4 04             	add    $0x4,%esp
}
c00271d8:	c9                   	leave  
c00271d9:	c3                   	ret    

c00271da <inb>:
{
c00271da:	55                   	push   %ebp
c00271db:	89 e5                	mov    %esp,%ebp
c00271dd:	83 ec 14             	sub    $0x14,%esp
c00271e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00271e3:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00271e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00271ea:	89 c2                	mov    %eax,%edx
c00271ec:	ec                   	in     (%dx),%al
c00271ed:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00271f0:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c00271f3:	c9                   	leave  
c00271f4:	c3                   	ret    

c00271f5 <outb>:
{
c00271f5:	55                   	push   %ebp
c00271f6:	89 e5                	mov    %esp,%ebp
c00271f8:	83 ec 08             	sub    $0x8,%esp
c00271fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00271fe:	8b 55 0c             	mov    0xc(%ebp),%edx
c0027201:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0027205:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0027208:	8a 45 f8             	mov    -0x8(%ebp),%al
c002720b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002720e:	ee                   	out    %al,(%dx)
}
c002720f:	90                   	nop
c0027210:	c9                   	leave  
c0027211:	c3                   	ret    

c0027212 <outw>:
{
c0027212:	55                   	push   %ebp
c0027213:	89 e5                	mov    %esp,%ebp
c0027215:	83 ec 08             	sub    $0x8,%esp
c0027218:	8b 55 08             	mov    0x8(%ebp),%edx
c002721b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002721e:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0027222:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0027226:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0027229:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002722c:	66 ef                	out    %ax,(%dx)
}
c002722e:	90                   	nop
c002722f:	c9                   	leave  
c0027230:	c3                   	ret    

c0027231 <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c0027231:	55                   	push   %ebp
c0027232:	89 e5                	mov    %esp,%ebp
c0027234:	83 ec 08             	sub    $0x8,%esp
  switch (how)
c0027237:	a1 f0 a4 03 c0       	mov    0xc003a4f0,%eax
c002723c:	83 f8 01             	cmp    $0x1,%eax
c002723f:	74 07                	je     c0027248 <shutdown+0x17>
c0027241:	83 f8 02             	cmp    $0x2,%eax
c0027244:	74 07                	je     c002724d <shutdown+0x1c>
      shutdown_reboot ();
      break;

    default:
      /* Nothing to do. */
      break;
c0027246:	eb 0a                	jmp    c0027252 <shutdown+0x21>
      shutdown_power_off ();
c0027248:	e8 9c 00 00 00       	call   c00272e9 <shutdown_power_off>
      shutdown_reboot ();
c002724d:	e8 11 00 00 00       	call   c0027263 <shutdown_reboot>
    }
}
c0027252:	90                   	nop
c0027253:	c9                   	leave  
c0027254:	c3                   	ret    

c0027255 <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c0027255:	55                   	push   %ebp
c0027256:	89 e5                	mov    %esp,%ebp
  how = type;
c0027258:	8b 45 08             	mov    0x8(%ebp),%eax
c002725b:	a3 f0 a4 03 c0       	mov    %eax,0xc003a4f0
}
c0027260:	90                   	nop
c0027261:	5d                   	pop    %ebp
c0027262:	c3                   	ret    

c0027263 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0027263:	55                   	push   %ebp
c0027264:	89 e5                	mov    %esp,%ebp
c0027266:	83 ec 18             	sub    $0x18,%esp
  printf ("Rebooting...\n");
c0027269:	83 ec 0c             	sub    $0xc,%esp
c002726c:	68 70 20 03 c0       	push   $0xc0032070
c0027271:	e8 f9 4b 00 00       	call   c002be6f <puts>
c0027276:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0027279:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0027280:	eb 29                	jmp    c00272ab <shutdown_reboot+0x48>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0027282:	83 ec 0c             	sub    $0xc,%esp
c0027285:	6a 64                	push   $0x64
c0027287:	e8 4e ff ff ff       	call   c00271da <inb>
c002728c:	83 c4 10             	add    $0x10,%esp
c002728f:	0f b6 c0             	movzbl %al,%eax
c0027292:	83 e0 02             	and    $0x2,%eax
c0027295:	85 c0                	test   %eax,%eax
c0027297:	74 1d                	je     c00272b6 <shutdown_reboot+0x53>
            break;
          timer_udelay (2);
c0027299:	83 ec 08             	sub    $0x8,%esp
c002729c:	6a 00                	push   $0x0
c002729e:	6a 02                	push   $0x2
c00272a0:	e8 cd d1 ff ff       	call   c0024472 <timer_udelay>
c00272a5:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 0x10000; i++)
c00272a8:	ff 45 f4             	incl   -0xc(%ebp)
c00272ab:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c00272b2:	7e ce                	jle    c0027282 <shutdown_reboot+0x1f>
c00272b4:	eb 01                	jmp    c00272b7 <shutdown_reboot+0x54>
            break;
c00272b6:	90                   	nop
        }

      timer_udelay (50);
c00272b7:	83 ec 08             	sub    $0x8,%esp
c00272ba:	6a 00                	push   $0x0
c00272bc:	6a 32                	push   $0x32
c00272be:	e8 af d1 ff ff       	call   c0024472 <timer_udelay>
c00272c3:	83 c4 10             	add    $0x10,%esp

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
c00272c6:	83 ec 08             	sub    $0x8,%esp
c00272c9:	68 fe 00 00 00       	push   $0xfe
c00272ce:	6a 64                	push   $0x64
c00272d0:	e8 20 ff ff ff       	call   c00271f5 <outb>
c00272d5:	83 c4 10             	add    $0x10,%esp
      timer_udelay (50);
c00272d8:	83 ec 08             	sub    $0x8,%esp
c00272db:	6a 00                	push   $0x0
c00272dd:	6a 32                	push   $0x32
c00272df:	e8 8e d1 ff ff       	call   c0024472 <timer_udelay>
c00272e4:	83 c4 10             	add    $0x10,%esp
    {
c00272e7:	eb 90                	jmp    c0027279 <shutdown_reboot+0x16>

c00272e9 <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c00272e9:	55                   	push   %ebp
c00272ea:	89 e5                	mov    %esp,%ebp
c00272ec:	57                   	push   %edi
c00272ed:	56                   	push   %esi
c00272ee:	53                   	push   %ebx
c00272ef:	83 ec 1c             	sub    $0x1c,%esp
  const char s[] = "Shutdown";
c00272f2:	8d 45 db             	lea    -0x25(%ebp),%eax
c00272f5:	bb 9e 20 03 c0       	mov    $0xc003209e,%ebx
c00272fa:	ba 09 00 00 00       	mov    $0x9,%edx
c00272ff:	89 c7                	mov    %eax,%edi
c0027301:	89 de                	mov    %ebx,%esi
c0027303:	89 d1                	mov    %edx,%ecx
c0027305:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  const char *p;

#ifdef FILESYS
  filesys_done ();
c0027307:	e8 85 70 00 00       	call   c002e391 <filesys_done>
#endif

  print_stats ();
c002730c:	e8 7d 00 00 00       	call   c002738e <print_stats>

  printf ("Powering off...\n");
c0027311:	83 ec 0c             	sub    $0xc,%esp
c0027314:	68 7d 20 03 c0       	push   $0xc003207d
c0027319:	e8 51 4b 00 00       	call   c002be6f <puts>
c002731e:	83 c4 10             	add    $0x10,%esp
  serial_flush ();
c0027321:	e8 75 dd ff ff       	call   c002509b <serial_flush>

  /* ACPI power-off */
  outw (0xB004, 0x2000);
c0027326:	83 ec 08             	sub    $0x8,%esp
c0027329:	68 00 20 00 00       	push   $0x2000
c002732e:	68 04 b0 00 00       	push   $0xb004
c0027333:	e8 da fe ff ff       	call   c0027212 <outw>
c0027338:	83 c4 10             	add    $0x10,%esp

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c002733b:	8d 45 db             	lea    -0x25(%ebp),%eax
c002733e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0027341:	eb 1c                	jmp    c002735f <shutdown_power_off+0x76>
    outb (0x8900, *p);
c0027343:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027346:	8a 00                	mov    (%eax),%al
c0027348:	0f b6 c0             	movzbl %al,%eax
c002734b:	83 ec 08             	sub    $0x8,%esp
c002734e:	50                   	push   %eax
c002734f:	68 00 89 00 00       	push   $0x8900
c0027354:	e8 9c fe ff ff       	call   c00271f5 <outb>
c0027359:	83 c4 10             	add    $0x10,%esp
  for (p = s; *p != '\0'; p++)
c002735c:	ff 45 e4             	incl   -0x1c(%ebp)
c002735f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027362:	8a 00                	mov    (%eax),%al
c0027364:	84 c0                	test   %al,%al
c0027366:	75 db                	jne    c0027343 <shutdown_power_off+0x5a>
  /* For newer versions of qemu, you must run with -device
   * isa-debug-exit, which exits on any write to an IO port (by
   * default 0x501).  Qemu's exit code is double the value plus one,
   * so there is no way to exit cleanly.  We use 0x31 which should
   * result in a qemu exit code of 0x63.  */
  outb (0x501, 0x31);
c0027368:	83 ec 08             	sub    $0x8,%esp
c002736b:	6a 31                	push   $0x31
c002736d:	68 01 05 00 00       	push   $0x501
c0027372:	e8 7e fe ff ff       	call   c00271f5 <outb>
c0027377:	83 c4 10             	add    $0x10,%esp

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c002737a:	fa                   	cli    
c002737b:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c002737c:	83 ec 0c             	sub    $0xc,%esp
c002737f:	68 8d 20 03 c0       	push   $0xc003208d
c0027384:	e8 e6 4a 00 00       	call   c002be6f <puts>
c0027389:	83 c4 10             	add    $0x10,%esp
  for (;;);
c002738c:	eb fe                	jmp    c002738c <shutdown_power_off+0xa3>

c002738e <print_stats>:
}

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
c002738e:	55                   	push   %ebp
c002738f:	89 e5                	mov    %esp,%ebp
c0027391:	83 ec 08             	sub    $0x8,%esp
  timer_print_stats ();
c0027394:	e8 2f d1 ff ff       	call   c00244c8 <timer_print_stats>
  thread_print_stats ();
c0027399:	e8 74 9a ff ff       	call   c0020e12 <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
c002739e:	e8 65 e2 ff ff       	call   c0025608 <block_print_stats>
#endif
  console_print_stats ();
c00273a3:	e8 9b 49 00 00       	call   c002bd43 <console_print_stats>
  kbd_print_stats ();
c00273a8:	e8 29 d4 ff ff       	call   c00247d6 <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
c00273ad:	e8 d9 60 00 00       	call   c002d48b <exception_print_stats>
#endif
}
c00273b2:	90                   	nop
c00273b3:	c9                   	leave  
c00273b4:	c3                   	ret    

c00273b5 <inb>:
{
c00273b5:	55                   	push   %ebp
c00273b6:	89 e5                	mov    %esp,%ebp
c00273b8:	83 ec 14             	sub    $0x14,%esp
c00273bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00273be:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00273c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00273c5:	89 c2                	mov    %eax,%edx
c00273c7:	ec                   	in     (%dx),%al
c00273c8:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00273cb:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c00273ce:	c9                   	leave  
c00273cf:	c3                   	ret    

c00273d0 <outb>:
{
c00273d0:	55                   	push   %ebp
c00273d1:	89 e5                	mov    %esp,%ebp
c00273d3:	83 ec 08             	sub    $0x8,%esp
c00273d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00273d9:	8b 55 0c             	mov    0xc(%ebp),%edx
c00273dc:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00273e0:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00273e3:	8a 45 f8             	mov    -0x8(%ebp),%al
c00273e6:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00273e9:	ee                   	out    %al,(%dx)
}
c00273ea:	90                   	nop
c00273eb:	c9                   	leave  
c00273ec:	c3                   	ret    

c00273ed <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c00273ed:	55                   	push   %ebp
c00273ee:	89 e5                	mov    %esp,%ebp
c00273f0:	83 ec 18             	sub    $0x18,%esp
  if (frequency >= 20 && frequency <= 20000)
c00273f3:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
c00273f7:	7e 54                	jle    c002744d <speaker_on+0x60>
c00273f9:	81 7d 08 20 4e 00 00 	cmpl   $0x4e20,0x8(%ebp)
c0027400:	7f 4b                	jg     c002744d <speaker_on+0x60>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c0027402:	e8 90 a5 ff ff       	call   c0021997 <intr_disable>
c0027407:	89 45 f4             	mov    %eax,-0xc(%ebp)
      pit_configure_channel (2, 3, frequency);
c002740a:	83 ec 04             	sub    $0x4,%esp
c002740d:	ff 75 08             	pushl  0x8(%ebp)
c0027410:	6a 03                	push   $0x3
c0027412:	6a 02                	push   $0x2
c0027414:	e8 9c cc ff ff       	call   c00240b5 <pit_configure_channel>
c0027419:	83 c4 10             	add    $0x10,%esp
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c002741c:	83 ec 0c             	sub    $0xc,%esp
c002741f:	6a 61                	push   $0x61
c0027421:	e8 8f ff ff ff       	call   c00273b5 <inb>
c0027426:	83 c4 10             	add    $0x10,%esp
c0027429:	83 c8 03             	or     $0x3,%eax
c002742c:	0f b6 c0             	movzbl %al,%eax
c002742f:	83 ec 08             	sub    $0x8,%esp
c0027432:	50                   	push   %eax
c0027433:	6a 61                	push   $0x61
c0027435:	e8 96 ff ff ff       	call   c00273d0 <outb>
c002743a:	83 c4 10             	add    $0x10,%esp
      intr_set_level (old_level);
c002743d:	83 ec 0c             	sub    $0xc,%esp
c0027440:	ff 75 f4             	pushl  -0xc(%ebp)
c0027443:	e8 f7 a4 ff ff       	call   c002193f <intr_set_level>
c0027448:	83 c4 10             	add    $0x10,%esp
    {
c002744b:	eb 05                	jmp    c0027452 <speaker_on+0x65>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c002744d:	e8 03 00 00 00       	call   c0027455 <speaker_off>
    }
}
c0027452:	90                   	nop
c0027453:	c9                   	leave  
c0027454:	c3                   	ret    

c0027455 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0027455:	55                   	push   %ebp
c0027456:	89 e5                	mov    %esp,%ebp
c0027458:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c002745b:	e8 37 a5 ff ff       	call   c0021997 <intr_disable>
c0027460:	89 45 f4             	mov    %eax,-0xc(%ebp)
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
c0027463:	83 ec 0c             	sub    $0xc,%esp
c0027466:	6a 61                	push   $0x61
c0027468:	e8 48 ff ff ff       	call   c00273b5 <inb>
c002746d:	83 c4 10             	add    $0x10,%esp
c0027470:	0f b6 c0             	movzbl %al,%eax
c0027473:	25 fc 00 00 00       	and    $0xfc,%eax
c0027478:	83 ec 08             	sub    $0x8,%esp
c002747b:	50                   	push   %eax
c002747c:	6a 61                	push   $0x61
c002747e:	e8 4d ff ff ff       	call   c00273d0 <outb>
c0027483:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0027486:	83 ec 0c             	sub    $0xc,%esp
c0027489:	ff 75 f4             	pushl  -0xc(%ebp)
c002748c:	e8 ae a4 ff ff       	call   c002193f <intr_set_level>
c0027491:	83 c4 10             	add    $0x10,%esp
}
c0027494:	90                   	nop
c0027495:	c9                   	leave  
c0027496:	c3                   	ret    

c0027497 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0027497:	55                   	push   %ebp
c0027498:	89 e5                	mov    %esp,%ebp
c002749a:	83 ec 08             	sub    $0x8,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c002749d:	e8 80 a4 ff ff       	call   c0021922 <intr_get_level>
c00274a2:	83 f8 01             	cmp    $0x1,%eax
c00274a5:	75 27                	jne    c00274ce <speaker_beep+0x37>
    {
      speaker_on (440);
c00274a7:	83 ec 0c             	sub    $0xc,%esp
c00274aa:	68 b8 01 00 00       	push   $0x1b8
c00274af:	e8 39 ff ff ff       	call   c00273ed <speaker_on>
c00274b4:	83 c4 10             	add    $0x10,%esp
      timer_msleep (250);
c00274b7:	83 ec 08             	sub    $0x8,%esp
c00274ba:	6a 00                	push   $0x0
c00274bc:	68 fa 00 00 00       	push   $0xfa
c00274c1:	e8 00 cf ff ff       	call   c00243c6 <timer_msleep>
c00274c6:	83 c4 10             	add    $0x10,%esp
      speaker_off ();
c00274c9:	e8 87 ff ff ff       	call   c0027455 <speaker_off>
    }
}
c00274ce:	90                   	nop
c00274cf:	c9                   	leave  
c00274d0:	c3                   	ret    

c00274d1 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c00274d1:	55                   	push   %ebp
c00274d2:	89 e5                	mov    %esp,%ebp
c00274d4:	83 ec 18             	sub    $0x18,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c00274d7:	8b 45 04             	mov    0x4(%ebp),%eax
c00274da:	83 ec 08             	sub    $0x8,%esp
c00274dd:	50                   	push   %eax
c00274de:	68 a8 20 03 c0       	push   $0xc00320a8
c00274e3:	e8 f6 02 00 00       	call   c00277de <printf>
c00274e8:	83 c4 10             	add    $0x10,%esp
  for (frame = __builtin_frame_address (1);
c00274eb:	8b 45 00             	mov    0x0(%ebp),%eax
c00274ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00274f1:	eb 21                	jmp    c0027514 <debug_backtrace+0x43>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
    printf (" %p", frame[1]);
c00274f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00274f6:	83 c0 04             	add    $0x4,%eax
c00274f9:	8b 00                	mov    (%eax),%eax
c00274fb:	83 ec 08             	sub    $0x8,%esp
c00274fe:	50                   	push   %eax
c00274ff:	68 b7 20 03 c0       	push   $0xc00320b7
c0027504:	e8 d5 02 00 00       	call   c00277de <printf>
c0027509:	83 c4 10             	add    $0x10,%esp
       frame = frame[0]) 
c002750c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002750f:	8b 00                	mov    (%eax),%eax
c0027511:	89 45 f4             	mov    %eax,-0xc(%ebp)
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0027514:	8b 45 f4             	mov    -0xc(%ebp),%eax
  for (frame = __builtin_frame_address (1);
c0027517:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002751c:	76 09                	jbe    c0027527 <debug_backtrace+0x56>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c002751e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027521:	8b 00                	mov    (%eax),%eax
c0027523:	85 c0                	test   %eax,%eax
c0027525:	75 cc                	jne    c00274f3 <debug_backtrace+0x22>
  printf (".\n");
c0027527:	83 ec 0c             	sub    $0xc,%esp
c002752a:	68 bb 20 03 c0       	push   $0xc00320bb
c002752f:	e8 3b 49 00 00       	call   c002be6f <puts>
c0027534:	83 c4 10             	add    $0x10,%esp

  if (!explained) 
c0027537:	a0 f4 a4 03 c0       	mov    0xc003a4f4,%al
c002753c:	83 f0 01             	xor    $0x1,%eax
c002753f:	84 c0                	test   %al,%al
c0027541:	74 17                	je     c002755a <debug_backtrace+0x89>
    {
      explained = true;
c0027543:	c6 05 f4 a4 03 c0 01 	movb   $0x1,0xc003a4f4
      printf ("The `backtrace' program can make call stacks useful.\n"
c002754a:	83 ec 0c             	sub    $0xc,%esp
c002754d:	68 c0 20 03 c0       	push   $0xc00320c0
c0027552:	e8 18 49 00 00       	call   c002be6f <puts>
c0027557:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c002755a:	90                   	nop
c002755b:	c9                   	leave  
c002755c:	c3                   	ret    

c002755d <swap_byte>:
static bool inited;     

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
c002755d:	55                   	push   %ebp
c002755e:	89 e5                	mov    %esp,%ebp
c0027560:	83 ec 10             	sub    $0x10,%esp
  uint8_t t = *a;
c0027563:	8b 45 08             	mov    0x8(%ebp),%eax
c0027566:	8a 00                	mov    (%eax),%al
c0027568:	88 45 ff             	mov    %al,-0x1(%ebp)
  *a = *b;
c002756b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002756e:	8a 10                	mov    (%eax),%dl
c0027570:	8b 45 08             	mov    0x8(%ebp),%eax
c0027573:	88 10                	mov    %dl,(%eax)
  *b = t;
c0027575:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027578:	8a 55 ff             	mov    -0x1(%ebp),%dl
c002757b:	88 10                	mov    %dl,(%eax)
}
c002757d:	90                   	nop
c002757e:	c9                   	leave  
c002757f:	c3                   	ret    

c0027580 <random_init>:

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0027580:	55                   	push   %ebp
c0027581:	89 e5                	mov    %esp,%ebp
c0027583:	83 ec 10             	sub    $0x10,%esp
  uint8_t *seedp = (uint8_t *) &seed;
c0027586:	8d 45 08             	lea    0x8(%ebp),%eax
c0027589:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c002758c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0027593:	eb 12                	jmp    c00275a7 <random_init+0x27>
    s[i] = i;
c0027595:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027598:	88 c2                	mov    %al,%dl
c002759a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002759d:	05 00 a5 03 c0       	add    $0xc003a500,%eax
c00275a2:	88 10                	mov    %dl,(%eax)
  for (i = 0; i < 256; i++) 
c00275a4:	ff 45 fc             	incl   -0x4(%ebp)
c00275a7:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c00275ae:	7e e5                	jle    c0027595 <random_init+0x15>
  for (i = j = 0; i < 256; i++) 
c00275b0:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
c00275b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00275bb:	eb 3d                	jmp    c00275fa <random_init+0x7a>
    {
      j += s[i] + seedp[i % sizeof seed];
c00275bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00275c0:	05 00 a5 03 c0       	add    $0xc003a500,%eax
c00275c5:	8a 10                	mov    (%eax),%dl
c00275c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00275ca:	83 e0 03             	and    $0x3,%eax
c00275cd:	89 c1                	mov    %eax,%ecx
c00275cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00275d2:	01 c8                	add    %ecx,%eax
c00275d4:	8a 00                	mov    (%eax),%al
c00275d6:	01 d0                	add    %edx,%eax
c00275d8:	00 45 fb             	add    %al,-0x5(%ebp)
      swap_byte (s + i, s + j);
c00275db:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c00275df:	8d 90 00 a5 03 c0    	lea    -0x3ffc5b00(%eax),%edx
c00275e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00275e8:	05 00 a5 03 c0       	add    $0xc003a500,%eax
c00275ed:	52                   	push   %edx
c00275ee:	50                   	push   %eax
c00275ef:	e8 69 ff ff ff       	call   c002755d <swap_byte>
c00275f4:	83 c4 08             	add    $0x8,%esp
  for (i = j = 0; i < 256; i++) 
c00275f7:	ff 45 fc             	incl   -0x4(%ebp)
c00275fa:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0027601:	7e ba                	jle    c00275bd <random_init+0x3d>
    }

  s_i = s_j = 0;
c0027603:	c6 05 01 a6 03 c0 00 	movb   $0x0,0xc003a601
c002760a:	a0 01 a6 03 c0       	mov    0xc003a601,%al
c002760f:	a2 00 a6 03 c0       	mov    %al,0xc003a600
  inited = true;
c0027614:	c6 05 02 a6 03 c0 01 	movb   $0x1,0xc003a602
}
c002761b:	90                   	nop
c002761c:	c9                   	leave  
c002761d:	c3                   	ret    

c002761e <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c002761e:	55                   	push   %ebp
c002761f:	89 e5                	mov    %esp,%ebp
c0027621:	83 ec 10             	sub    $0x10,%esp
  uint8_t *buf;

  if (!inited)
c0027624:	a0 02 a6 03 c0       	mov    0xc003a602,%al
c0027629:	83 f0 01             	xor    $0x1,%eax
c002762c:	84 c0                	test   %al,%al
c002762e:	74 0a                	je     c002763a <random_bytes+0x1c>
    random_init (0);
c0027630:	6a 00                	push   $0x0
c0027632:	e8 49 ff ff ff       	call   c0027580 <random_init>
c0027637:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c002763a:	8b 45 08             	mov    0x8(%ebp),%eax
c002763d:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0027640:	eb 7d                	jmp    c00276bf <random_bytes+0xa1>
    {
      uint8_t s_k;
      
      s_i++;
c0027642:	a0 00 a6 03 c0       	mov    0xc003a600,%al
c0027647:	40                   	inc    %eax
c0027648:	a2 00 a6 03 c0       	mov    %al,0xc003a600
      s_j += s[s_i];
c002764d:	a0 00 a6 03 c0       	mov    0xc003a600,%al
c0027652:	0f b6 c0             	movzbl %al,%eax
c0027655:	8a 90 00 a5 03 c0    	mov    -0x3ffc5b00(%eax),%dl
c002765b:	a0 01 a6 03 c0       	mov    0xc003a601,%al
c0027660:	01 d0                	add    %edx,%eax
c0027662:	a2 01 a6 03 c0       	mov    %al,0xc003a601
      swap_byte (s + s_i, s + s_j);
c0027667:	a0 01 a6 03 c0       	mov    0xc003a601,%al
c002766c:	0f b6 c0             	movzbl %al,%eax
c002766f:	8d 90 00 a5 03 c0    	lea    -0x3ffc5b00(%eax),%edx
c0027675:	a0 00 a6 03 c0       	mov    0xc003a600,%al
c002767a:	0f b6 c0             	movzbl %al,%eax
c002767d:	05 00 a5 03 c0       	add    $0xc003a500,%eax
c0027682:	52                   	push   %edx
c0027683:	50                   	push   %eax
c0027684:	e8 d4 fe ff ff       	call   c002755d <swap_byte>
c0027689:	83 c4 08             	add    $0x8,%esp

      s_k = s[s_i] + s[s_j];
c002768c:	a0 00 a6 03 c0       	mov    0xc003a600,%al
c0027691:	0f b6 c0             	movzbl %al,%eax
c0027694:	8a 90 00 a5 03 c0    	mov    -0x3ffc5b00(%eax),%dl
c002769a:	a0 01 a6 03 c0       	mov    0xc003a601,%al
c002769f:	0f b6 c0             	movzbl %al,%eax
c00276a2:	8a 80 00 a5 03 c0    	mov    -0x3ffc5b00(%eax),%al
c00276a8:	01 d0                	add    %edx,%eax
c00276aa:	88 45 fb             	mov    %al,-0x5(%ebp)
      *buf = s[s_k];
c00276ad:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c00276b1:	8a 90 00 a5 03 c0    	mov    -0x3ffc5b00(%eax),%dl
c00276b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00276ba:	88 10                	mov    %dl,(%eax)
  for (buf = buf_; size-- > 0; buf++)
c00276bc:	ff 45 fc             	incl   -0x4(%ebp)
c00276bf:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276c2:	8d 50 ff             	lea    -0x1(%eax),%edx
c00276c5:	89 55 0c             	mov    %edx,0xc(%ebp)
c00276c8:	85 c0                	test   %eax,%eax
c00276ca:	0f 85 72 ff ff ff    	jne    c0027642 <random_bytes+0x24>
    }
}
c00276d0:	90                   	nop
c00276d1:	c9                   	leave  
c00276d2:	c3                   	ret    

c00276d3 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c00276d3:	55                   	push   %ebp
c00276d4:	89 e5                	mov    %esp,%ebp
c00276d6:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c00276d9:	6a 04                	push   $0x4
c00276db:	8d 45 fc             	lea    -0x4(%ebp),%eax
c00276de:	50                   	push   %eax
c00276df:	e8 3a ff ff ff       	call   c002761e <random_bytes>
c00276e4:	83 c4 08             	add    $0x8,%esp
  return ul;
c00276e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00276ea:	c9                   	leave  
c00276eb:	c3                   	ret    

c00276ec <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c00276ec:	55                   	push   %ebp
c00276ed:	89 e5                	mov    %esp,%ebp
c00276ef:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c00276f3:	7e 0d                	jle    c0027702 <isdigit+0x16>
c00276f5:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c00276f9:	7f 07                	jg     c0027702 <isdigit+0x16>
c00276fb:	b8 01 00 00 00       	mov    $0x1,%eax
c0027700:	eb 05                	jmp    c0027707 <isdigit+0x1b>
c0027702:	b8 00 00 00 00       	mov    $0x0,%eax
c0027707:	5d                   	pop    %ebp
c0027708:	c3                   	ret    

c0027709 <isprint>:
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027709:	55                   	push   %ebp
c002770a:	89 e5                	mov    %esp,%ebp
c002770c:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0027710:	7e 0d                	jle    c002771f <isprint+0x16>
c0027712:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c0027716:	7f 07                	jg     c002771f <isprint+0x16>
c0027718:	b8 01 00 00 00       	mov    $0x1,%eax
c002771d:	eb 05                	jmp    c0027724 <isprint+0x1b>
c002771f:	b8 00 00 00 00       	mov    $0x0,%eax
c0027724:	5d                   	pop    %ebp
c0027725:	c3                   	ret    

c0027726 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c0027726:	55                   	push   %ebp
c0027727:	89 e5                	mov    %esp,%ebp
c0027729:	83 ec 18             	sub    $0x18,%esp
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c002772c:	8b 45 08             	mov    0x8(%ebp),%eax
c002772f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  aux.length = 0;
c0027732:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027739:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002773d:	74 06                	je     c0027745 <vsnprintf+0x1f>
c002773f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027742:	48                   	dec    %eax
c0027743:	eb 05                	jmp    c002774a <vsnprintf+0x24>
c0027745:	b8 00 00 00 00       	mov    $0x0,%eax
c002774a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c002774d:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0027750:	50                   	push   %eax
c0027751:	68 75 77 02 c0       	push   $0xc0027775
c0027756:	ff 75 14             	pushl  0x14(%ebp)
c0027759:	ff 75 10             	pushl  0x10(%ebp)
c002775c:	e8 a3 00 00 00       	call   c0027804 <__vprintf>
c0027761:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
c0027764:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0027768:	74 06                	je     c0027770 <vsnprintf+0x4a>
    *aux.p = '\0';
c002776a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002776d:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
c0027770:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0027773:	c9                   	leave  
c0027774:	c3                   	ret    

c0027775 <vsnprintf_helper>:

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0027775:	55                   	push   %ebp
c0027776:	89 e5                	mov    %esp,%ebp
c0027778:	83 ec 14             	sub    $0x14,%esp
c002777b:	8b 45 08             	mov    0x8(%ebp),%eax
c002777e:	88 45 ec             	mov    %al,-0x14(%ebp)
  struct vsnprintf_aux *aux = aux_;
c0027781:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027784:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (aux->length++ < aux->max_length)
c0027787:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002778a:	8b 40 04             	mov    0x4(%eax),%eax
c002778d:	8d 48 01             	lea    0x1(%eax),%ecx
c0027790:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027793:	89 4a 04             	mov    %ecx,0x4(%edx)
c0027796:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027799:	8b 52 08             	mov    0x8(%edx),%edx
c002779c:	39 d0                	cmp    %edx,%eax
c002779e:	7d 12                	jge    c00277b2 <vsnprintf_helper+0x3d>
    *aux->p++ = ch;
c00277a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00277a3:	8b 00                	mov    (%eax),%eax
c00277a5:	8d 48 01             	lea    0x1(%eax),%ecx
c00277a8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00277ab:	89 0a                	mov    %ecx,(%edx)
c00277ad:	8a 55 ec             	mov    -0x14(%ebp),%dl
c00277b0:	88 10                	mov    %dl,(%eax)
}
c00277b2:	90                   	nop
c00277b3:	c9                   	leave  
c00277b4:	c3                   	ret    

c00277b5 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c00277b5:	55                   	push   %ebp
c00277b6:	89 e5                	mov    %esp,%ebp
c00277b8:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c00277bb:	8d 45 14             	lea    0x14(%ebp),%eax
c00277be:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vsnprintf (buffer, buf_size, format, args);
c00277c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00277c4:	50                   	push   %eax
c00277c5:	ff 75 10             	pushl  0x10(%ebp)
c00277c8:	ff 75 0c             	pushl  0xc(%ebp)
c00277cb:	ff 75 08             	pushl  0x8(%ebp)
c00277ce:	e8 53 ff ff ff       	call   c0027726 <vsnprintf>
c00277d3:	83 c4 10             	add    $0x10,%esp
c00277d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c00277d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00277dc:	c9                   	leave  
c00277dd:	c3                   	ret    

c00277de <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c00277de:	55                   	push   %ebp
c00277df:	89 e5                	mov    %esp,%ebp
c00277e1:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c00277e4:	8d 45 0c             	lea    0xc(%ebp),%eax
c00277e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vprintf (format, args);
c00277ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00277ed:	83 ec 08             	sub    $0x8,%esp
c00277f0:	50                   	push   %eax
c00277f1:	ff 75 08             	pushl  0x8(%ebp)
c00277f4:	e8 43 46 00 00       	call   c002be3c <vprintf>
c00277f9:	83 c4 10             	add    $0x10,%esp
c00277fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c00277ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0027802:	c9                   	leave  
c0027803:	c3                   	ret    

c0027804 <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c0027804:	55                   	push   %ebp
c0027805:	89 e5                	mov    %esp,%ebp
c0027807:	53                   	push   %ebx
c0027808:	83 ec 34             	sub    $0x34,%esp
  for (; *format != '\0'; format++)
c002780b:	e9 25 04 00 00       	jmp    c0027c35 <__vprintf+0x431>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c0027810:	8b 45 08             	mov    0x8(%ebp),%eax
c0027813:	8a 00                	mov    (%eax),%al
c0027815:	3c 25                	cmp    $0x25,%al
c0027817:	74 1c                	je     c0027835 <__vprintf+0x31>
        {
          output (*format, aux);
c0027819:	8b 45 08             	mov    0x8(%ebp),%eax
c002781c:	8a 00                	mov    (%eax),%al
c002781e:	0f be c0             	movsbl %al,%eax
c0027821:	83 ec 08             	sub    $0x8,%esp
c0027824:	ff 75 14             	pushl  0x14(%ebp)
c0027827:	50                   	push   %eax
c0027828:	8b 45 10             	mov    0x10(%ebp),%eax
c002782b:	ff d0                	call   *%eax
c002782d:	83 c4 10             	add    $0x10,%esp
          continue;
c0027830:	e9 fd 03 00 00       	jmp    c0027c32 <__vprintf+0x42e>
        }
      format++;
c0027835:	ff 45 08             	incl   0x8(%ebp)

      /* %% => %. */
      if (*format == '%') 
c0027838:	8b 45 08             	mov    0x8(%ebp),%eax
c002783b:	8a 00                	mov    (%eax),%al
c002783d:	3c 25                	cmp    $0x25,%al
c002783f:	75 15                	jne    c0027856 <__vprintf+0x52>
        {
          output ('%', aux);
c0027841:	83 ec 08             	sub    $0x8,%esp
c0027844:	ff 75 14             	pushl  0x14(%ebp)
c0027847:	6a 25                	push   $0x25
c0027849:	8b 45 10             	mov    0x10(%ebp),%eax
c002784c:	ff d0                	call   *%eax
c002784e:	83 c4 10             	add    $0x10,%esp
          continue;
c0027851:	e9 dc 03 00 00       	jmp    c0027c32 <__vprintf+0x42e>
        }

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);
c0027856:	83 ec 04             	sub    $0x4,%esp
c0027859:	8d 45 0c             	lea    0xc(%ebp),%eax
c002785c:	50                   	push   %eax
c002785d:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027860:	50                   	push   %eax
c0027861:	ff 75 08             	pushl  0x8(%ebp)
c0027864:	e8 df 03 00 00       	call   c0027c48 <parse_conversion>
c0027869:	83 c4 10             	add    $0x10,%esp
c002786c:	89 45 08             	mov    %eax,0x8(%ebp)

      /* Do conversion. */
      switch (*format) 
c002786f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027872:	8a 00                	mov    (%eax),%al
c0027874:	0f be c0             	movsbl %al,%eax
c0027877:	83 e8 45             	sub    $0x45,%eax
c002787a:	83 f8 33             	cmp    $0x33,%eax
c002787d:	0f 87 92 03 00 00    	ja     c0027c15 <__vprintf+0x411>
c0027883:	8b 04 85 44 22 03 c0 	mov    -0x3ffcddbc(,%eax,4),%eax
c002788a:	ff e0                	jmp    *%eax
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c002788c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002788f:	83 f8 08             	cmp    $0x8,%eax
c0027892:	0f 87 d8 00 00 00    	ja     c0027970 <__vprintf+0x16c>
c0027898:	8b 04 85 14 23 03 c0 	mov    -0x3ffcdcec(,%eax,4),%eax
c002789f:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c00278a1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278a4:	8d 50 04             	lea    0x4(%eax),%edx
c00278a7:	89 55 0c             	mov    %edx,0xc(%ebp)
c00278aa:	8b 00                	mov    (%eax),%eax
c00278ac:	0f be c0             	movsbl %al,%eax
c00278af:	99                   	cltd   
c00278b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00278b3:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00278b6:	e9 cf 00 00 00       	jmp    c002798a <__vprintf+0x186>
              case SHORT:
                value = (short) va_arg (args, int);
c00278bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278be:	8d 50 04             	lea    0x4(%eax),%edx
c00278c1:	89 55 0c             	mov    %edx,0xc(%ebp)
c00278c4:	8b 00                	mov    (%eax),%eax
c00278c6:	98                   	cwtl   
c00278c7:	99                   	cltd   
c00278c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00278cb:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00278ce:	e9 b7 00 00 00       	jmp    c002798a <__vprintf+0x186>
              case INT:
                value = va_arg (args, int);
c00278d3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278d6:	8d 50 04             	lea    0x4(%eax),%edx
c00278d9:	89 55 0c             	mov    %edx,0xc(%ebp)
c00278dc:	8b 00                	mov    (%eax),%eax
c00278de:	99                   	cltd   
c00278df:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00278e2:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00278e5:	e9 a0 00 00 00       	jmp    c002798a <__vprintf+0x186>
              case INTMAX:
                value = va_arg (args, intmax_t);
c00278ea:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278ed:	8d 50 08             	lea    0x8(%eax),%edx
c00278f0:	89 55 0c             	mov    %edx,0xc(%ebp)
c00278f3:	8b 50 04             	mov    0x4(%eax),%edx
c00278f6:	8b 00                	mov    (%eax),%eax
c00278f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00278fb:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00278fe:	e9 87 00 00 00       	jmp    c002798a <__vprintf+0x186>
              case LONG:
                value = va_arg (args, long);
c0027903:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027906:	8d 50 04             	lea    0x4(%eax),%edx
c0027909:	89 55 0c             	mov    %edx,0xc(%ebp)
c002790c:	8b 00                	mov    (%eax),%eax
c002790e:	99                   	cltd   
c002790f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027912:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027915:	eb 73                	jmp    c002798a <__vprintf+0x186>
              case LONGLONG:
                value = va_arg (args, long long);
c0027917:	8b 45 0c             	mov    0xc(%ebp),%eax
c002791a:	8d 50 08             	lea    0x8(%eax),%edx
c002791d:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027920:	8b 50 04             	mov    0x4(%eax),%edx
c0027923:	8b 00                	mov    (%eax),%eax
c0027925:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027928:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c002792b:	eb 5d                	jmp    c002798a <__vprintf+0x186>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c002792d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027930:	8d 50 04             	lea    0x4(%eax),%edx
c0027933:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027936:	8b 00                	mov    (%eax),%eax
c0027938:	99                   	cltd   
c0027939:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002793c:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c002793f:	eb 49                	jmp    c002798a <__vprintf+0x186>
              case SIZET:
                value = va_arg (args, size_t);
c0027941:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027944:	8d 50 04             	lea    0x4(%eax),%edx
c0027947:	89 55 0c             	mov    %edx,0xc(%ebp)
c002794a:	8b 00                	mov    (%eax),%eax
c002794c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002794f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                if (value > SIZE_MAX / 2)
c0027956:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002795a:	78 2d                	js     c0027989 <__vprintf+0x185>
c002795c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0027960:	7f 09                	jg     c002796b <__vprintf+0x167>
c0027962:	81 7d f0 ff ff ff 7f 	cmpl   $0x7fffffff,-0x10(%ebp)
c0027969:	76 1e                	jbe    c0027989 <__vprintf+0x185>
                  value = value - SIZE_MAX - 1;
c002796b:	ff 4d f4             	decl   -0xc(%ebp)
                break;
c002796e:	eb 19                	jmp    c0027989 <__vprintf+0x185>
              default:
                NOT_REACHED ();
c0027970:	68 dc 21 03 c0       	push   $0xc00321dc
c0027975:	68 10 24 03 c0       	push   $0xc0032410
c002797a:	68 dc 00 00 00       	push   $0xdc
c002797f:	68 fe 21 03 c0       	push   $0xc00321fe
c0027984:	e8 14 22 00 00       	call   c0029b9d <debug_panic>
                break;
c0027989:	90                   	nop
              }

            format_integer (value < 0 ? -value : value,
c002798a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002798d:	c1 e8 1f             	shr    $0x1f,%eax
c0027990:	0f b6 c8             	movzbl %al,%ecx
c0027993:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027996:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027999:	85 d2                	test   %edx,%edx
c002799b:	79 07                	jns    c00279a4 <__vprintf+0x1a0>
c002799d:	f7 d8                	neg    %eax
c002799f:	83 d2 00             	adc    $0x0,%edx
c00279a2:	f7 da                	neg    %edx
c00279a4:	ff 75 14             	pushl  0x14(%ebp)
c00279a7:	ff 75 10             	pushl  0x10(%ebp)
c00279aa:	8d 5d cc             	lea    -0x34(%ebp),%ebx
c00279ad:	53                   	push   %ebx
c00279ae:	68 68 21 03 c0       	push   $0xc0032168
c00279b3:	51                   	push   %ecx
c00279b4:	6a 01                	push   $0x1
c00279b6:	52                   	push   %edx
c00279b7:	50                   	push   %eax
c00279b8:	e8 3f 05 00 00       	call   c0027efc <format_integer>
c00279bd:	83 c4 20             	add    $0x20,%esp
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c00279c0:	e9 6d 02 00 00       	jmp    c0027c32 <__vprintf+0x42e>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
c00279c5:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00279c8:	83 f8 08             	cmp    $0x8,%eax
c00279cb:	0f 87 d3 00 00 00    	ja     c0027aa4 <__vprintf+0x2a0>
c00279d1:	8b 04 85 38 23 03 c0 	mov    -0x3ffcdcc8(,%eax,4),%eax
c00279d8:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c00279da:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279dd:	8d 50 04             	lea    0x4(%eax),%edx
c00279e0:	89 55 0c             	mov    %edx,0xc(%ebp)
c00279e3:	8b 00                	mov    (%eax),%eax
c00279e5:	0f b6 c0             	movzbl %al,%eax
c00279e8:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00279eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c00279f2:	e9 c6 00 00 00       	jmp    c0027abd <__vprintf+0x2b9>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c00279f7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279fa:	8d 50 04             	lea    0x4(%eax),%edx
c00279fd:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a00:	8b 00                	mov    (%eax),%eax
c0027a02:	0f b7 c0             	movzwl %ax,%eax
c0027a05:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027a08:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027a0f:	e9 a9 00 00 00       	jmp    c0027abd <__vprintf+0x2b9>
              case INT:
                value = va_arg (args, unsigned);
c0027a14:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a17:	8d 50 04             	lea    0x4(%eax),%edx
c0027a1a:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a1d:	8b 00                	mov    (%eax),%eax
c0027a1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027a22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027a29:	e9 8f 00 00 00       	jmp    c0027abd <__vprintf+0x2b9>
              case INTMAX:
                value = va_arg (args, uintmax_t);
c0027a2e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a31:	8d 50 08             	lea    0x8(%eax),%edx
c0027a34:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a37:	8b 50 04             	mov    0x4(%eax),%edx
c0027a3a:	8b 00                	mov    (%eax),%eax
c0027a3c:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027a3f:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c0027a42:	eb 79                	jmp    c0027abd <__vprintf+0x2b9>
              case LONG:
                value = va_arg (args, unsigned long);
c0027a44:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a47:	8d 50 04             	lea    0x4(%eax),%edx
c0027a4a:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a4d:	8b 00                	mov    (%eax),%eax
c0027a4f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027a52:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027a59:	eb 62                	jmp    c0027abd <__vprintf+0x2b9>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c0027a5b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a5e:	8d 50 08             	lea    0x8(%eax),%edx
c0027a61:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a64:	8b 50 04             	mov    0x4(%eax),%edx
c0027a67:	8b 00                	mov    (%eax),%eax
c0027a69:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027a6c:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c0027a6f:	eb 4c                	jmp    c0027abd <__vprintf+0x2b9>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c0027a71:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a74:	8d 50 04             	lea    0x4(%eax),%edx
c0027a77:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a7a:	8b 00                	mov    (%eax),%eax
c0027a7c:	99                   	cltd   
c0027a7d:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027a80:	89 55 ec             	mov    %edx,-0x14(%ebp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0027a83:	83 65 e8 ff          	andl   $0xffffffff,-0x18(%ebp)
c0027a87:	83 65 ec 00          	andl   $0x0,-0x14(%ebp)
#endif
                break;
c0027a8b:	eb 30                	jmp    c0027abd <__vprintf+0x2b9>
              case SIZET:
                value = va_arg (args, size_t);
c0027a8d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a90:	8d 50 04             	lea    0x4(%eax),%edx
c0027a93:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a96:	8b 00                	mov    (%eax),%eax
c0027a98:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027a9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027aa2:	eb 19                	jmp    c0027abd <__vprintf+0x2b9>
              default:
                NOT_REACHED ();
c0027aa4:	68 dc 21 03 c0       	push   $0xc00321dc
c0027aa9:	68 10 24 03 c0       	push   $0xc0032410
c0027aae:	68 0b 01 00 00       	push   $0x10b
c0027ab3:	68 fe 21 03 c0       	push   $0xc00321fe
c0027ab8:	e8 e0 20 00 00       	call   c0029b9d <debug_panic>
              }

            switch (*format) 
c0027abd:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ac0:	8a 00                	mov    (%eax),%al
c0027ac2:	0f be c0             	movsbl %al,%eax
c0027ac5:	83 f8 6f             	cmp    $0x6f,%eax
c0027ac8:	74 18                	je     c0027ae2 <__vprintf+0x2de>
c0027aca:	83 f8 6f             	cmp    $0x6f,%eax
c0027acd:	7f 07                	jg     c0027ad6 <__vprintf+0x2d2>
c0027acf:	83 f8 58             	cmp    $0x58,%eax
c0027ad2:	74 29                	je     c0027afd <__vprintf+0x2f9>
c0027ad4:	eb 30                	jmp    c0027b06 <__vprintf+0x302>
c0027ad6:	83 f8 75             	cmp    $0x75,%eax
c0027ad9:	74 10                	je     c0027aeb <__vprintf+0x2e7>
c0027adb:	83 f8 78             	cmp    $0x78,%eax
c0027ade:	74 14                	je     c0027af4 <__vprintf+0x2f0>
c0027ae0:	eb 24                	jmp    c0027b06 <__vprintf+0x302>
              {
              case 'o': b = &base_o; break;
c0027ae2:	c7 45 e4 84 21 03 c0 	movl   $0xc0032184,-0x1c(%ebp)
c0027ae9:	eb 34                	jmp    c0027b1f <__vprintf+0x31b>
              case 'u': b = &base_d; break;
c0027aeb:	c7 45 e4 68 21 03 c0 	movl   $0xc0032168,-0x1c(%ebp)
c0027af2:	eb 2b                	jmp    c0027b1f <__vprintf+0x31b>
              case 'x': b = &base_x; break;
c0027af4:	c7 45 e4 a8 21 03 c0 	movl   $0xc00321a8,-0x1c(%ebp)
c0027afb:	eb 22                	jmp    c0027b1f <__vprintf+0x31b>
              case 'X': b = &base_X; break;
c0027afd:	c7 45 e4 cc 21 03 c0 	movl   $0xc00321cc,-0x1c(%ebp)
c0027b04:	eb 19                	jmp    c0027b1f <__vprintf+0x31b>
              default: NOT_REACHED ();
c0027b06:	68 dc 21 03 c0       	push   $0xc00321dc
c0027b0b:	68 10 24 03 c0       	push   $0xc0032410
c0027b10:	68 14 01 00 00       	push   $0x114
c0027b15:	68 fe 21 03 c0       	push   $0xc00321fe
c0027b1a:	e8 7e 20 00 00       	call   c0029b9d <debug_panic>
              }

            format_integer (value, false, false, b, &c, output, aux);
c0027b1f:	ff 75 14             	pushl  0x14(%ebp)
c0027b22:	ff 75 10             	pushl  0x10(%ebp)
c0027b25:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027b28:	50                   	push   %eax
c0027b29:	ff 75 e4             	pushl  -0x1c(%ebp)
c0027b2c:	6a 00                	push   $0x0
c0027b2e:	6a 00                	push   $0x0
c0027b30:	ff 75 ec             	pushl  -0x14(%ebp)
c0027b33:	ff 75 e8             	pushl  -0x18(%ebp)
c0027b36:	e8 c1 03 00 00       	call   c0027efc <format_integer>
c0027b3b:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027b3e:	e9 ef 00 00 00       	jmp    c0027c32 <__vprintf+0x42e>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c0027b43:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027b46:	8d 50 04             	lea    0x4(%eax),%edx
c0027b49:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027b4c:	8b 00                	mov    (%eax),%eax
c0027b4e:	88 45 cb             	mov    %al,-0x35(%ebp)
            format_string (&ch, 1, &c, output, aux);
c0027b51:	83 ec 0c             	sub    $0xc,%esp
c0027b54:	ff 75 14             	pushl  0x14(%ebp)
c0027b57:	ff 75 10             	pushl  0x10(%ebp)
c0027b5a:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027b5d:	50                   	push   %eax
c0027b5e:	6a 01                	push   $0x1
c0027b60:	8d 45 cb             	lea    -0x35(%ebp),%eax
c0027b63:	50                   	push   %eax
c0027b64:	e8 ed 06 00 00       	call   c0028256 <format_string>
c0027b69:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027b6c:	e9 c1 00 00 00       	jmp    c0027c32 <__vprintf+0x42e>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c0027b71:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027b74:	8d 50 04             	lea    0x4(%eax),%edx
c0027b77:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027b7a:	8b 00                	mov    (%eax),%eax
c0027b7c:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if (s == NULL)
c0027b7f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027b83:	75 07                	jne    c0027b8c <__vprintf+0x388>
              s = "(null)";
c0027b85:	c7 45 e0 10 22 03 c0 	movl   $0xc0032210,-0x20(%ebp)

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027b8c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0027b8f:	83 ec 08             	sub    $0x8,%esp
c0027b92:	50                   	push   %eax
c0027b93:	ff 75 e0             	pushl  -0x20(%ebp)
c0027b96:	e8 c2 14 00 00       	call   c002905d <strnlen>
c0027b9b:	83 c4 10             	add    $0x10,%esp
c0027b9e:	89 c2                	mov    %eax,%edx
c0027ba0:	83 ec 0c             	sub    $0xc,%esp
c0027ba3:	ff 75 14             	pushl  0x14(%ebp)
c0027ba6:	ff 75 10             	pushl  0x10(%ebp)
c0027ba9:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027bac:	50                   	push   %eax
c0027bad:	52                   	push   %edx
c0027bae:	ff 75 e0             	pushl  -0x20(%ebp)
c0027bb1:	e8 a0 06 00 00       	call   c0028256 <format_string>
c0027bb6:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027bb9:	eb 77                	jmp    c0027c32 <__vprintf+0x42e>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c0027bbb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027bbe:	8d 50 04             	lea    0x4(%eax),%edx
c0027bc1:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027bc4:	8b 00                	mov    (%eax),%eax
c0027bc6:	89 45 dc             	mov    %eax,-0x24(%ebp)

            c.flags = POUND;
c0027bc9:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%ebp)
            format_integer ((uintptr_t) p, false, false,
c0027bd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027bd3:	ba 00 00 00 00       	mov    $0x0,%edx
c0027bd8:	ff 75 14             	pushl  0x14(%ebp)
c0027bdb:	ff 75 10             	pushl  0x10(%ebp)
c0027bde:	8d 4d cc             	lea    -0x34(%ebp),%ecx
c0027be1:	51                   	push   %ecx
c0027be2:	68 a8 21 03 c0       	push   $0xc00321a8
c0027be7:	6a 00                	push   $0x0
c0027be9:	6a 00                	push   $0x0
c0027beb:	52                   	push   %edx
c0027bec:	50                   	push   %eax
c0027bed:	e8 0a 03 00 00       	call   c0027efc <format_integer>
c0027bf2:	83 c4 20             	add    $0x20,%esp
                            &base_x, &c, output, aux);
          }
          break;
c0027bf5:	eb 3b                	jmp    c0027c32 <__vprintf+0x42e>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027bf7:	8b 45 08             	mov    0x8(%ebp),%eax
c0027bfa:	8a 00                	mov    (%eax),%al
c0027bfc:	0f be c0             	movsbl %al,%eax
c0027bff:	50                   	push   %eax
c0027c00:	ff 75 14             	pushl  0x14(%ebp)
c0027c03:	ff 75 10             	pushl  0x10(%ebp)
c0027c06:	68 17 22 03 c0       	push   $0xc0032217
c0027c0b:	e8 e1 06 00 00       	call   c00282f1 <__printf>
c0027c10:	83 c4 10             	add    $0x10,%esp
          break;
c0027c13:	eb 1d                	jmp    c0027c32 <__vprintf+0x42e>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c0027c15:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c18:	8a 00                	mov    (%eax),%al
c0027c1a:	0f be c0             	movsbl %al,%eax
c0027c1d:	50                   	push   %eax
c0027c1e:	ff 75 14             	pushl  0x14(%ebp)
c0027c21:	ff 75 10             	pushl  0x10(%ebp)
c0027c24:	68 2d 22 03 c0       	push   $0xc003222d
c0027c29:	e8 c3 06 00 00       	call   c00282f1 <__printf>
c0027c2e:	83 c4 10             	add    $0x10,%esp
          break;
c0027c31:	90                   	nop
  for (; *format != '\0'; format++)
c0027c32:	ff 45 08             	incl   0x8(%ebp)
c0027c35:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c38:	8a 00                	mov    (%eax),%al
c0027c3a:	84 c0                	test   %al,%al
c0027c3c:	0f 85 ce fb ff ff    	jne    c0027810 <__vprintf+0xc>
        }
    }
}
c0027c42:	90                   	nop
c0027c43:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027c46:	c9                   	leave  
c0027c47:	c3                   	ret    

c0027c48 <parse_conversion>:
   that indicates the conversion (e.g. the `d' in `%d').  Uses
   *ARGS for `*' field widths and precisions. */
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
c0027c48:	55                   	push   %ebp
c0027c49:	89 e5                	mov    %esp,%ebp
  /* Parse flag characters. */
  c->flags = 0;
c0027c4b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c4e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (;;) 
    {
      switch (*format++) 
c0027c54:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c57:	8d 50 01             	lea    0x1(%eax),%edx
c0027c5a:	89 55 08             	mov    %edx,0x8(%ebp)
c0027c5d:	8a 00                	mov    (%eax),%al
c0027c5f:	0f be c0             	movsbl %al,%eax
c0027c62:	83 e8 20             	sub    $0x20,%eax
c0027c65:	83 f8 10             	cmp    $0x10,%eax
c0027c68:	77 6f                	ja     c0027cd9 <parse_conversion+0x91>
c0027c6a:	8b 04 85 5c 23 03 c0 	mov    -0x3ffcdca4(,%eax,4),%eax
c0027c71:	ff e0                	jmp    *%eax
        {
        case '-':
          c->flags |= MINUS;
c0027c73:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c76:	8b 00                	mov    (%eax),%eax
c0027c78:	83 c8 01             	or     $0x1,%eax
c0027c7b:	89 c2                	mov    %eax,%edx
c0027c7d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c80:	89 10                	mov    %edx,(%eax)
          break;
c0027c82:	eb 67                	jmp    c0027ceb <parse_conversion+0xa3>
        case '+':
          c->flags |= PLUS;
c0027c84:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c87:	8b 00                	mov    (%eax),%eax
c0027c89:	83 c8 02             	or     $0x2,%eax
c0027c8c:	89 c2                	mov    %eax,%edx
c0027c8e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c91:	89 10                	mov    %edx,(%eax)
          break;
c0027c93:	eb 56                	jmp    c0027ceb <parse_conversion+0xa3>
        case ' ':
          c->flags |= SPACE;
c0027c95:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c98:	8b 00                	mov    (%eax),%eax
c0027c9a:	83 c8 04             	or     $0x4,%eax
c0027c9d:	89 c2                	mov    %eax,%edx
c0027c9f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ca2:	89 10                	mov    %edx,(%eax)
          break;
c0027ca4:	eb 45                	jmp    c0027ceb <parse_conversion+0xa3>
        case '#':
          c->flags |= POUND;
c0027ca6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ca9:	8b 00                	mov    (%eax),%eax
c0027cab:	83 c8 08             	or     $0x8,%eax
c0027cae:	89 c2                	mov    %eax,%edx
c0027cb0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cb3:	89 10                	mov    %edx,(%eax)
          break;
c0027cb5:	eb 34                	jmp    c0027ceb <parse_conversion+0xa3>
        case '0':
          c->flags |= ZERO;
c0027cb7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cba:	8b 00                	mov    (%eax),%eax
c0027cbc:	83 c8 10             	or     $0x10,%eax
c0027cbf:	89 c2                	mov    %eax,%edx
c0027cc1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cc4:	89 10                	mov    %edx,(%eax)
          break;
c0027cc6:	eb 23                	jmp    c0027ceb <parse_conversion+0xa3>
        case '\'':
          c->flags |= GROUP;
c0027cc8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ccb:	8b 00                	mov    (%eax),%eax
c0027ccd:	83 c8 20             	or     $0x20,%eax
c0027cd0:	89 c2                	mov    %eax,%edx
c0027cd2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cd5:	89 10                	mov    %edx,(%eax)
          break;
c0027cd7:	eb 12                	jmp    c0027ceb <parse_conversion+0xa3>
        default:
          format--;
c0027cd9:	ff 4d 08             	decl   0x8(%ebp)
          goto not_a_flag;
c0027cdc:	90                   	nop
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c0027cdd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ce0:	8b 00                	mov    (%eax),%eax
c0027ce2:	83 e0 01             	and    $0x1,%eax
c0027ce5:	85 c0                	test   %eax,%eax
c0027ce7:	74 16                	je     c0027cff <parse_conversion+0xb7>
c0027ce9:	eb 05                	jmp    c0027cf0 <parse_conversion+0xa8>
      switch (*format++) 
c0027ceb:	e9 64 ff ff ff       	jmp    c0027c54 <parse_conversion+0xc>
    c->flags &= ~ZERO;
c0027cf0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cf3:	8b 00                	mov    (%eax),%eax
c0027cf5:	83 e0 ef             	and    $0xffffffef,%eax
c0027cf8:	89 c2                	mov    %eax,%edx
c0027cfa:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cfd:	89 10                	mov    %edx,(%eax)
  if (c->flags & PLUS)
c0027cff:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d02:	8b 00                	mov    (%eax),%eax
c0027d04:	83 e0 02             	and    $0x2,%eax
c0027d07:	85 c0                	test   %eax,%eax
c0027d09:	74 0f                	je     c0027d1a <parse_conversion+0xd2>
    c->flags &= ~SPACE;
c0027d0b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d0e:	8b 00                	mov    (%eax),%eax
c0027d10:	83 e0 fb             	and    $0xfffffffb,%eax
c0027d13:	89 c2                	mov    %eax,%edx
c0027d15:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d18:	89 10                	mov    %edx,(%eax)

  /* Parse field width. */
  c->width = 0;
c0027d1a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d1d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (*format == '*')
c0027d24:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d27:	8a 00                	mov    (%eax),%al
c0027d29:	3c 2a                	cmp    $0x2a,%al
c0027d2b:	75 41                	jne    c0027d6e <parse_conversion+0x126>
    {
      format++;
c0027d2d:	ff 45 08             	incl   0x8(%ebp)
      c->width = va_arg (*args, int);
c0027d30:	8b 45 10             	mov    0x10(%ebp),%eax
c0027d33:	8b 00                	mov    (%eax),%eax
c0027d35:	8d 48 04             	lea    0x4(%eax),%ecx
c0027d38:	8b 55 10             	mov    0x10(%ebp),%edx
c0027d3b:	89 0a                	mov    %ecx,(%edx)
c0027d3d:	8b 10                	mov    (%eax),%edx
c0027d3f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d42:	89 50 04             	mov    %edx,0x4(%eax)
c0027d45:	eb 3c                	jmp    c0027d83 <parse_conversion+0x13b>
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c0027d47:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d4a:	8b 50 04             	mov    0x4(%eax),%edx
c0027d4d:	89 d0                	mov    %edx,%eax
c0027d4f:	c1 e0 02             	shl    $0x2,%eax
c0027d52:	01 d0                	add    %edx,%eax
c0027d54:	01 c0                	add    %eax,%eax
c0027d56:	89 c2                	mov    %eax,%edx
c0027d58:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d5b:	8a 00                	mov    (%eax),%al
c0027d5d:	0f be c0             	movsbl %al,%eax
c0027d60:	01 d0                	add    %edx,%eax
c0027d62:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027d65:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d68:	89 50 04             	mov    %edx,0x4(%eax)
      for (; isdigit (*format); format++)
c0027d6b:	ff 45 08             	incl   0x8(%ebp)
c0027d6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d71:	8a 00                	mov    (%eax),%al
c0027d73:	0f be c0             	movsbl %al,%eax
c0027d76:	50                   	push   %eax
c0027d77:	e8 70 f9 ff ff       	call   c00276ec <isdigit>
c0027d7c:	83 c4 04             	add    $0x4,%esp
c0027d7f:	85 c0                	test   %eax,%eax
c0027d81:	75 c4                	jne    c0027d47 <parse_conversion+0xff>
    }
  if (c->width < 0) 
c0027d83:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d86:	8b 40 04             	mov    0x4(%eax),%eax
c0027d89:	85 c0                	test   %eax,%eax
c0027d8b:	79 1f                	jns    c0027dac <parse_conversion+0x164>
    {
      c->width = -c->width;
c0027d8d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d90:	8b 40 04             	mov    0x4(%eax),%eax
c0027d93:	f7 d8                	neg    %eax
c0027d95:	89 c2                	mov    %eax,%edx
c0027d97:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d9a:	89 50 04             	mov    %edx,0x4(%eax)
      c->flags |= MINUS;
c0027d9d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027da0:	8b 00                	mov    (%eax),%eax
c0027da2:	83 c8 01             	or     $0x1,%eax
c0027da5:	89 c2                	mov    %eax,%edx
c0027da7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027daa:	89 10                	mov    %edx,(%eax)
    }
      
  /* Parse precision. */
  c->precision = -1;
c0027dac:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027daf:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  if (*format == '.') 
c0027db6:	8b 45 08             	mov    0x8(%ebp),%eax
c0027db9:	8a 00                	mov    (%eax),%al
c0027dbb:	3c 2e                	cmp    $0x2e,%al
c0027dbd:	0f 85 82 00 00 00    	jne    c0027e45 <parse_conversion+0x1fd>
    {
      format++;
c0027dc3:	ff 45 08             	incl   0x8(%ebp)
      if (*format == '*') 
c0027dc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0027dc9:	8a 00                	mov    (%eax),%al
c0027dcb:	3c 2a                	cmp    $0x2a,%al
c0027dcd:	75 1a                	jne    c0027de9 <parse_conversion+0x1a1>
        {
          format++;
c0027dcf:	ff 45 08             	incl   0x8(%ebp)
          c->precision = va_arg (*args, int);
c0027dd2:	8b 45 10             	mov    0x10(%ebp),%eax
c0027dd5:	8b 00                	mov    (%eax),%eax
c0027dd7:	8d 48 04             	lea    0x4(%eax),%ecx
c0027dda:	8b 55 10             	mov    0x10(%ebp),%edx
c0027ddd:	89 0a                	mov    %ecx,(%edx)
c0027ddf:	8b 10                	mov    (%eax),%edx
c0027de1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027de4:	89 50 08             	mov    %edx,0x8(%eax)
c0027de7:	eb 48                	jmp    c0027e31 <parse_conversion+0x1e9>
        }
      else 
        {
          c->precision = 0;
c0027de9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027dec:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          for (; isdigit (*format); format++)
c0027df3:	eb 27                	jmp    c0027e1c <parse_conversion+0x1d4>
            c->precision = c->precision * 10 + *format - '0';
c0027df5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027df8:	8b 50 08             	mov    0x8(%eax),%edx
c0027dfb:	89 d0                	mov    %edx,%eax
c0027dfd:	c1 e0 02             	shl    $0x2,%eax
c0027e00:	01 d0                	add    %edx,%eax
c0027e02:	01 c0                	add    %eax,%eax
c0027e04:	89 c2                	mov    %eax,%edx
c0027e06:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e09:	8a 00                	mov    (%eax),%al
c0027e0b:	0f be c0             	movsbl %al,%eax
c0027e0e:	01 d0                	add    %edx,%eax
c0027e10:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027e13:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e16:	89 50 08             	mov    %edx,0x8(%eax)
          for (; isdigit (*format); format++)
c0027e19:	ff 45 08             	incl   0x8(%ebp)
c0027e1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e1f:	8a 00                	mov    (%eax),%al
c0027e21:	0f be c0             	movsbl %al,%eax
c0027e24:	50                   	push   %eax
c0027e25:	e8 c2 f8 ff ff       	call   c00276ec <isdigit>
c0027e2a:	83 c4 04             	add    $0x4,%esp
c0027e2d:	85 c0                	test   %eax,%eax
c0027e2f:	75 c4                	jne    c0027df5 <parse_conversion+0x1ad>
        }
      if (c->precision < 0) 
c0027e31:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e34:	8b 40 08             	mov    0x8(%eax),%eax
c0027e37:	85 c0                	test   %eax,%eax
c0027e39:	79 0a                	jns    c0027e45 <parse_conversion+0x1fd>
        c->precision = -1;
c0027e3b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e3e:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    }
  if (c->precision >= 0)
c0027e45:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e48:	8b 40 08             	mov    0x8(%eax),%eax
c0027e4b:	85 c0                	test   %eax,%eax
c0027e4d:	78 0f                	js     c0027e5e <parse_conversion+0x216>
    c->flags &= ~ZERO;
c0027e4f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e52:	8b 00                	mov    (%eax),%eax
c0027e54:	83 e0 ef             	and    $0xffffffef,%eax
c0027e57:	89 c2                	mov    %eax,%edx
c0027e59:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e5c:	89 10                	mov    %edx,(%eax)

  /* Parse type. */
  c->type = INT;
c0027e5e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e61:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  switch (*format++) 
c0027e68:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e6b:	8d 50 01             	lea    0x1(%eax),%edx
c0027e6e:	89 55 08             	mov    %edx,0x8(%ebp)
c0027e71:	8a 00                	mov    (%eax),%al
c0027e73:	0f be c0             	movsbl %al,%eax
c0027e76:	83 e8 68             	sub    $0x68,%eax
c0027e79:	83 f8 12             	cmp    $0x12,%eax
c0027e7c:	77 75                	ja     c0027ef3 <parse_conversion+0x2ab>
c0027e7e:	8b 04 85 a0 23 03 c0 	mov    -0x3ffcdc60(,%eax,4),%eax
c0027e85:	ff e0                	jmp    *%eax
    {
    case 'h':
      if (*format == 'h') 
c0027e87:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e8a:	8a 00                	mov    (%eax),%al
c0027e8c:	3c 68                	cmp    $0x68,%al
c0027e8e:	75 0f                	jne    c0027e9f <parse_conversion+0x257>
        {
          format++;
c0027e90:	ff 45 08             	incl   0x8(%ebp)
          c->type = CHAR;
c0027e93:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e96:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        }
      else
        c->type = SHORT;
      break;
c0027e9d:	eb 58                	jmp    c0027ef7 <parse_conversion+0x2af>
        c->type = SHORT;
c0027e9f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ea2:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
      break;
c0027ea9:	eb 4c                	jmp    c0027ef7 <parse_conversion+0x2af>
      
    case 'j':
      c->type = INTMAX;
c0027eab:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027eae:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      break;
c0027eb5:	eb 40                	jmp    c0027ef7 <parse_conversion+0x2af>

    case 'l':
      if (*format == 'l')
c0027eb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0027eba:	8a 00                	mov    (%eax),%al
c0027ebc:	3c 6c                	cmp    $0x6c,%al
c0027ebe:	75 0f                	jne    c0027ecf <parse_conversion+0x287>
        {
          format++;
c0027ec0:	ff 45 08             	incl   0x8(%ebp)
          c->type = LONGLONG;
c0027ec3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ec6:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
        }
      else
        c->type = LONG;
      break;
c0027ecd:	eb 28                	jmp    c0027ef7 <parse_conversion+0x2af>
        c->type = LONG;
c0027ecf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ed2:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
      break;
c0027ed9:	eb 1c                	jmp    c0027ef7 <parse_conversion+0x2af>

    case 't':
      c->type = PTRDIFFT;
c0027edb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ede:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
      break;
c0027ee5:	eb 10                	jmp    c0027ef7 <parse_conversion+0x2af>

    case 'z':
      c->type = SIZET;
c0027ee7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027eea:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
      break;
c0027ef1:	eb 04                	jmp    c0027ef7 <parse_conversion+0x2af>

    default:
      format--;
c0027ef3:	ff 4d 08             	decl   0x8(%ebp)
      break;
c0027ef6:	90                   	nop
    }

  return format;
c0027ef7:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0027efa:	c9                   	leave  
c0027efb:	c3                   	ret    

c0027efc <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c0027efc:	55                   	push   %ebp
c0027efd:	89 e5                	mov    %esp,%ebp
c0027eff:	57                   	push   %edi
c0027f00:	56                   	push   %esi
c0027f01:	53                   	push   %ebx
c0027f02:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
c0027f08:	8b 45 10             	mov    0x10(%ebp),%eax
c0027f0b:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
c0027f11:	8b 5d 14             	mov    0x14(%ebp),%ebx
c0027f14:	8b 45 08             	mov    0x8(%ebp),%eax
c0027f17:	89 45 80             	mov    %eax,-0x80(%ebp)
c0027f1a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027f1d:	89 45 84             	mov    %eax,-0x7c(%ebp)
c0027f20:	8a 85 6c ff ff ff    	mov    -0x94(%ebp),%al
c0027f26:	88 85 7c ff ff ff    	mov    %al,-0x84(%ebp)
c0027f2c:	88 9d 78 ff ff ff    	mov    %bl,-0x88(%ebp)
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c0027f32:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (is_signed) 
c0027f39:	80 bd 7c ff ff ff 00 	cmpb   $0x0,-0x84(%ebp)
c0027f40:	74 5c                	je     c0027f9e <format_integer+0xa2>
    {
      if (c->flags & PLUS)
c0027f42:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027f45:	8b 00                	mov    (%eax),%eax
c0027f47:	83 e0 02             	and    $0x2,%eax
c0027f4a:	85 c0                	test   %eax,%eax
c0027f4c:	74 1a                	je     c0027f68 <format_integer+0x6c>
        sign = negative ? '-' : '+';
c0027f4e:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027f55:	74 07                	je     c0027f5e <format_integer+0x62>
c0027f57:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027f5c:	eb 05                	jmp    c0027f63 <format_integer+0x67>
c0027f5e:	b8 2b 00 00 00       	mov    $0x2b,%eax
c0027f63:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027f66:	eb 36                	jmp    c0027f9e <format_integer+0xa2>
      else if (c->flags & SPACE)
c0027f68:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027f6b:	8b 00                	mov    (%eax),%eax
c0027f6d:	83 e0 04             	and    $0x4,%eax
c0027f70:	85 c0                	test   %eax,%eax
c0027f72:	74 1a                	je     c0027f8e <format_integer+0x92>
        sign = negative ? '-' : ' ';
c0027f74:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027f7b:	74 07                	je     c0027f84 <format_integer+0x88>
c0027f7d:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027f82:	eb 05                	jmp    c0027f89 <format_integer+0x8d>
c0027f84:	b8 20 00 00 00       	mov    $0x20,%eax
c0027f89:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027f8c:	eb 10                	jmp    c0027f9e <format_integer+0xa2>
      else if (negative)
c0027f8e:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027f95:	74 07                	je     c0027f9e <format_integer+0xa2>
        sign = '-';
c0027f97:	c7 45 e0 2d 00 00 00 	movl   $0x2d,-0x20(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c0027f9e:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027fa1:	8b 00                	mov    (%eax),%eax
c0027fa3:	83 e0 08             	and    $0x8,%eax
c0027fa6:	85 c0                	test   %eax,%eax
c0027fa8:	74 20                	je     c0027fca <format_integer+0xce>
c0027faa:	8b 45 80             	mov    -0x80(%ebp),%eax
c0027fad:	80 f4 00             	xor    $0x0,%ah
c0027fb0:	89 c2                	mov    %eax,%edx
c0027fb2:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027fb5:	80 f4 00             	xor    $0x0,%ah
c0027fb8:	89 c1                	mov    %eax,%ecx
c0027fba:	89 c8                	mov    %ecx,%eax
c0027fbc:	09 d0                	or     %edx,%eax
c0027fbe:	85 c0                	test   %eax,%eax
c0027fc0:	74 08                	je     c0027fca <format_integer+0xce>
c0027fc2:	8b 45 18             	mov    0x18(%ebp),%eax
c0027fc5:	8b 40 08             	mov    0x8(%eax),%eax
c0027fc8:	eb 05                	jmp    c0027fcf <format_integer+0xd3>
c0027fca:	b8 00 00 00 00       	mov    $0x0,%eax
c0027fcf:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c0027fd2:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027fd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  digit_cnt = 0;
c0027fd8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  while (value > 0) 
c0027fdf:	e9 82 00 00 00       	jmp    c0028066 <format_integer+0x16a>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0027fe4:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027fe7:	8b 00                	mov    (%eax),%eax
c0027fe9:	83 e0 20             	and    $0x20,%eax
c0027fec:	85 c0                	test   %eax,%eax
c0027fee:	74 24                	je     c0028014 <format_integer+0x118>
c0027ff0:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0027ff4:	7e 1e                	jle    c0028014 <format_integer+0x118>
c0027ff6:	8b 45 18             	mov    0x18(%ebp),%eax
c0027ff9:	8b 48 0c             	mov    0xc(%eax),%ecx
c0027ffc:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027fff:	99                   	cltd   
c0028000:	f7 f9                	idiv   %ecx
c0028002:	89 d0                	mov    %edx,%eax
c0028004:	85 c0                	test   %eax,%eax
c0028006:	75 0c                	jne    c0028014 <format_integer+0x118>
        *cp++ = ',';
c0028008:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002800b:	8d 50 01             	lea    0x1(%eax),%edx
c002800e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0028011:	c6 00 2c             	movb   $0x2c,(%eax)
      *cp++ = b->digits[value % b->base];
c0028014:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0028017:	8d 46 01             	lea    0x1(%esi),%eax
c002801a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c002801d:	8b 45 18             	mov    0x18(%ebp),%eax
c0028020:	8b 78 04             	mov    0x4(%eax),%edi
c0028023:	8b 45 18             	mov    0x18(%ebp),%eax
c0028026:	8b 00                	mov    (%eax),%eax
c0028028:	89 c1                	mov    %eax,%ecx
c002802a:	89 c3                	mov    %eax,%ebx
c002802c:	c1 fb 1f             	sar    $0x1f,%ebx
c002802f:	8b 45 80             	mov    -0x80(%ebp),%eax
c0028032:	8b 55 84             	mov    -0x7c(%ebp),%edx
c0028035:	53                   	push   %ebx
c0028036:	51                   	push   %ecx
c0028037:	52                   	push   %edx
c0028038:	50                   	push   %eax
c0028039:	e8 02 16 00 00       	call   c0029640 <__umoddi3>
c002803e:	83 c4 10             	add    $0x10,%esp
c0028041:	01 f8                	add    %edi,%eax
c0028043:	8a 00                	mov    (%eax),%al
c0028045:	88 06                	mov    %al,(%esi)
      value /= b->base;
c0028047:	8b 45 18             	mov    0x18(%ebp),%eax
c002804a:	8b 00                	mov    (%eax),%eax
c002804c:	99                   	cltd   
c002804d:	52                   	push   %edx
c002804e:	50                   	push   %eax
c002804f:	ff 75 84             	pushl  -0x7c(%ebp)
c0028052:	ff 75 80             	pushl  -0x80(%ebp)
c0028055:	e8 b2 15 00 00       	call   c002960c <__udivdi3>
c002805a:	83 c4 10             	add    $0x10,%esp
c002805d:	89 45 80             	mov    %eax,-0x80(%ebp)
c0028060:	89 55 84             	mov    %edx,-0x7c(%ebp)
      digit_cnt++;
c0028063:	ff 45 d8             	incl   -0x28(%ebp)
  while (value > 0) 
c0028066:	8b 45 80             	mov    -0x80(%ebp),%eax
c0028069:	80 f4 00             	xor    $0x0,%ah
c002806c:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
c0028072:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0028075:	80 f4 00             	xor    $0x0,%ah
c0028078:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
c002807e:	8b 9d 70 ff ff ff    	mov    -0x90(%ebp),%ebx
c0028084:	8b b5 74 ff ff ff    	mov    -0x8c(%ebp),%esi
c002808a:	89 f0                	mov    %esi,%eax
c002808c:	09 d8                	or     %ebx,%eax
c002808e:	85 c0                	test   %eax,%eax
c0028090:	0f 85 4e ff ff ff    	jne    c0027fe4 <format_integer+0xe8>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c0028096:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0028099:	8b 40 08             	mov    0x8(%eax),%eax
c002809c:	85 c0                	test   %eax,%eax
c002809e:	78 08                	js     c00280a8 <format_integer+0x1ac>
c00280a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00280a3:	8b 40 08             	mov    0x8(%eax),%eax
c00280a6:	eb 05                	jmp    c00280ad <format_integer+0x1b1>
c00280a8:	b8 01 00 00 00       	mov    $0x1,%eax
c00280ad:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00280b0:	eb 0c                	jmp    c00280be <format_integer+0x1c2>
    *cp++ = '0';
c00280b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00280b5:	8d 50 01             	lea    0x1(%eax),%edx
c00280b8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00280bb:	c6 00 30             	movb   $0x30,(%eax)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00280be:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00280c1:	8d 45 90             	lea    -0x70(%ebp),%eax
c00280c4:	29 c2                	sub    %eax,%edx
c00280c6:	89 d0                	mov    %edx,%eax
c00280c8:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c00280cb:	7d 0b                	jge    c00280d8 <format_integer+0x1dc>
c00280cd:	8d 45 90             	lea    -0x70(%ebp),%eax
c00280d0:	83 c0 3f             	add    $0x3f,%eax
c00280d3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00280d6:	77 da                	ja     c00280b2 <format_integer+0x1b6>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00280d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00280db:	8b 00                	mov    (%eax),%eax
c00280dd:	83 e0 08             	and    $0x8,%eax
c00280e0:	85 c0                	test   %eax,%eax
c00280e2:	74 28                	je     c002810c <format_integer+0x210>
c00280e4:	8b 45 18             	mov    0x18(%ebp),%eax
c00280e7:	8b 00                	mov    (%eax),%eax
c00280e9:	83 f8 08             	cmp    $0x8,%eax
c00280ec:	75 1e                	jne    c002810c <format_integer+0x210>
c00280ee:	8d 45 90             	lea    -0x70(%ebp),%eax
c00280f1:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c00280f4:	74 0a                	je     c0028100 <format_integer+0x204>
c00280f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00280f9:	48                   	dec    %eax
c00280fa:	8a 00                	mov    (%eax),%al
c00280fc:	3c 30                	cmp    $0x30,%al
c00280fe:	74 0c                	je     c002810c <format_integer+0x210>
    *cp++ = '0';
c0028100:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028103:	8d 50 01             	lea    0x1(%eax),%edx
c0028106:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0028109:	c6 00 30             	movb   $0x30,(%eax)

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c002810c:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002810f:	8b 40 04             	mov    0x4(%eax),%eax
c0028112:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0028115:	8d 55 90             	lea    -0x70(%ebp),%edx
c0028118:	29 d1                	sub    %edx,%ecx
c002811a:	89 ca                	mov    %ecx,%edx
c002811c:	29 d0                	sub    %edx,%eax
c002811e:	89 c2                	mov    %eax,%edx
c0028120:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0028124:	74 07                	je     c002812d <format_integer+0x231>
c0028126:	b8 02 00 00 00       	mov    $0x2,%eax
c002812b:	eb 05                	jmp    c0028132 <format_integer+0x236>
c002812d:	b8 00 00 00 00       	mov    $0x0,%eax
c0028132:	29 c2                	sub    %eax,%edx
c0028134:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0028138:	0f 95 c0             	setne  %al
c002813b:	0f b6 c0             	movzbl %al,%eax
c002813e:	29 c2                	sub    %eax,%edx
c0028140:	89 d0                	mov    %edx,%eax
c0028142:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (pad_cnt < 0)
c0028145:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0028149:	79 07                	jns    c0028152 <format_integer+0x256>
    pad_cnt = 0;
c002814b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c0028152:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0028155:	8b 00                	mov    (%eax),%eax
c0028157:	83 e0 11             	and    $0x11,%eax
c002815a:	85 c0                	test   %eax,%eax
c002815c:	75 14                	jne    c0028172 <format_integer+0x276>
    output_dup (' ', pad_cnt, output, aux);
c002815e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0028161:	ff 75 24             	pushl  0x24(%ebp)
c0028164:	ff 75 20             	pushl  0x20(%ebp)
c0028167:	50                   	push   %eax
c0028168:	6a 20                	push   $0x20
c002816a:	e8 b6 00 00 00       	call   c0028225 <output_dup>
c002816f:	83 c4 10             	add    $0x10,%esp
  if (sign)
c0028172:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0028176:	74 15                	je     c002818d <format_integer+0x291>
    output (sign, aux);
c0028178:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002817b:	0f be c0             	movsbl %al,%eax
c002817e:	83 ec 08             	sub    $0x8,%esp
c0028181:	ff 75 24             	pushl  0x24(%ebp)
c0028184:	50                   	push   %eax
c0028185:	8b 45 20             	mov    0x20(%ebp),%eax
c0028188:	ff d0                	call   *%eax
c002818a:	83 c4 10             	add    $0x10,%esp
  if (x) 
c002818d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0028191:	74 25                	je     c00281b8 <format_integer+0x2bc>
    {
      output ('0', aux);
c0028193:	83 ec 08             	sub    $0x8,%esp
c0028196:	ff 75 24             	pushl  0x24(%ebp)
c0028199:	6a 30                	push   $0x30
c002819b:	8b 45 20             	mov    0x20(%ebp),%eax
c002819e:	ff d0                	call   *%eax
c00281a0:	83 c4 10             	add    $0x10,%esp
      output (x, aux); 
c00281a3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00281a6:	0f be c0             	movsbl %al,%eax
c00281a9:	83 ec 08             	sub    $0x8,%esp
c00281ac:	ff 75 24             	pushl  0x24(%ebp)
c00281af:	50                   	push   %eax
c00281b0:	8b 45 20             	mov    0x20(%ebp),%eax
c00281b3:	ff d0                	call   *%eax
c00281b5:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c00281b8:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00281bb:	8b 00                	mov    (%eax),%eax
c00281bd:	83 e0 10             	and    $0x10,%eax
c00281c0:	85 c0                	test   %eax,%eax
c00281c2:	74 30                	je     c00281f4 <format_integer+0x2f8>
    output_dup ('0', pad_cnt, output, aux);
c00281c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00281c7:	ff 75 24             	pushl  0x24(%ebp)
c00281ca:	ff 75 20             	pushl  0x20(%ebp)
c00281cd:	50                   	push   %eax
c00281ce:	6a 30                	push   $0x30
c00281d0:	e8 50 00 00 00       	call   c0028225 <output_dup>
c00281d5:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c00281d8:	eb 1a                	jmp    c00281f4 <format_integer+0x2f8>
    output (*--cp, aux);
c00281da:	ff 4d e4             	decl   -0x1c(%ebp)
c00281dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00281e0:	8a 00                	mov    (%eax),%al
c00281e2:	0f be c0             	movsbl %al,%eax
c00281e5:	83 ec 08             	sub    $0x8,%esp
c00281e8:	ff 75 24             	pushl  0x24(%ebp)
c00281eb:	50                   	push   %eax
c00281ec:	8b 45 20             	mov    0x20(%ebp),%eax
c00281ef:	ff d0                	call   *%eax
c00281f1:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c00281f4:	8d 45 90             	lea    -0x70(%ebp),%eax
c00281f7:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c00281fa:	77 de                	ja     c00281da <format_integer+0x2de>
  if (c->flags & MINUS)
c00281fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00281ff:	8b 00                	mov    (%eax),%eax
c0028201:	83 e0 01             	and    $0x1,%eax
c0028204:	85 c0                	test   %eax,%eax
c0028206:	74 14                	je     c002821c <format_integer+0x320>
    output_dup (' ', pad_cnt, output, aux);
c0028208:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002820b:	ff 75 24             	pushl  0x24(%ebp)
c002820e:	ff 75 20             	pushl  0x20(%ebp)
c0028211:	50                   	push   %eax
c0028212:	6a 20                	push   $0x20
c0028214:	e8 0c 00 00 00       	call   c0028225 <output_dup>
c0028219:	83 c4 10             	add    $0x10,%esp
}
c002821c:	90                   	nop
c002821d:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0028220:	5b                   	pop    %ebx
c0028221:	5e                   	pop    %esi
c0028222:	5f                   	pop    %edi
c0028223:	5d                   	pop    %ebp
c0028224:	c3                   	ret    

c0028225 <output_dup>:

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0028225:	55                   	push   %ebp
c0028226:	89 e5                	mov    %esp,%ebp
c0028228:	83 ec 18             	sub    $0x18,%esp
c002822b:	8b 45 08             	mov    0x8(%ebp),%eax
c002822e:	88 45 f4             	mov    %al,-0xc(%ebp)
  while (cnt-- > 0)
c0028231:	eb 13                	jmp    c0028246 <output_dup+0x21>
    output (ch, aux);
c0028233:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0028237:	83 ec 08             	sub    $0x8,%esp
c002823a:	ff 75 14             	pushl  0x14(%ebp)
c002823d:	50                   	push   %eax
c002823e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028241:	ff d0                	call   *%eax
c0028243:	83 c4 10             	add    $0x10,%esp
  while (cnt-- > 0)
c0028246:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028249:	8d 50 ff             	lea    -0x1(%eax),%edx
c002824c:	89 55 0c             	mov    %edx,0xc(%ebp)
c002824f:	85 c0                	test   %eax,%eax
c0028251:	75 e0                	jne    c0028233 <output_dup+0xe>
}
c0028253:	90                   	nop
c0028254:	c9                   	leave  
c0028255:	c3                   	ret    

c0028256 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0028256:	55                   	push   %ebp
c0028257:	89 e5                	mov    %esp,%ebp
c0028259:	83 ec 18             	sub    $0x18,%esp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c002825c:	8b 45 10             	mov    0x10(%ebp),%eax
c002825f:	8b 40 04             	mov    0x4(%eax),%eax
c0028262:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028265:	7e 26                	jle    c002828d <format_string+0x37>
c0028267:	8b 45 10             	mov    0x10(%ebp),%eax
c002826a:	8b 00                	mov    (%eax),%eax
c002826c:	83 e0 01             	and    $0x1,%eax
c002826f:	85 c0                	test   %eax,%eax
c0028271:	75 1a                	jne    c002828d <format_string+0x37>
    output_dup (' ', c->width - length, output, aux);
c0028273:	8b 45 10             	mov    0x10(%ebp),%eax
c0028276:	8b 40 04             	mov    0x4(%eax),%eax
c0028279:	2b 45 0c             	sub    0xc(%ebp),%eax
c002827c:	ff 75 18             	pushl  0x18(%ebp)
c002827f:	ff 75 14             	pushl  0x14(%ebp)
c0028282:	50                   	push   %eax
c0028283:	6a 20                	push   $0x20
c0028285:	e8 9b ff ff ff       	call   c0028225 <output_dup>
c002828a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c002828d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028294:	eb 1f                	jmp    c00282b5 <format_string+0x5f>
    output (string[i], aux);
c0028296:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0028299:	8b 45 08             	mov    0x8(%ebp),%eax
c002829c:	01 d0                	add    %edx,%eax
c002829e:	8a 00                	mov    (%eax),%al
c00282a0:	0f be c0             	movsbl %al,%eax
c00282a3:	83 ec 08             	sub    $0x8,%esp
c00282a6:	ff 75 18             	pushl  0x18(%ebp)
c00282a9:	50                   	push   %eax
c00282aa:	8b 45 14             	mov    0x14(%ebp),%eax
c00282ad:	ff d0                	call   *%eax
c00282af:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c00282b2:	ff 45 f4             	incl   -0xc(%ebp)
c00282b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00282b8:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00282bb:	7c d9                	jl     c0028296 <format_string+0x40>
  if (c->width > length && (c->flags & MINUS) != 0)
c00282bd:	8b 45 10             	mov    0x10(%ebp),%eax
c00282c0:	8b 40 04             	mov    0x4(%eax),%eax
c00282c3:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00282c6:	7e 26                	jle    c00282ee <format_string+0x98>
c00282c8:	8b 45 10             	mov    0x10(%ebp),%eax
c00282cb:	8b 00                	mov    (%eax),%eax
c00282cd:	83 e0 01             	and    $0x1,%eax
c00282d0:	85 c0                	test   %eax,%eax
c00282d2:	74 1a                	je     c00282ee <format_string+0x98>
    output_dup (' ', c->width - length, output, aux);
c00282d4:	8b 45 10             	mov    0x10(%ebp),%eax
c00282d7:	8b 40 04             	mov    0x4(%eax),%eax
c00282da:	2b 45 0c             	sub    0xc(%ebp),%eax
c00282dd:	ff 75 18             	pushl  0x18(%ebp)
c00282e0:	ff 75 14             	pushl  0x14(%ebp)
c00282e3:	50                   	push   %eax
c00282e4:	6a 20                	push   $0x20
c00282e6:	e8 3a ff ff ff       	call   c0028225 <output_dup>
c00282eb:	83 c4 10             	add    $0x10,%esp
}
c00282ee:	90                   	nop
c00282ef:	c9                   	leave  
c00282f0:	c3                   	ret    

c00282f1 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c00282f1:	55                   	push   %ebp
c00282f2:	89 e5                	mov    %esp,%ebp
c00282f4:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start (args, aux);
c00282f7:	8d 45 14             	lea    0x14(%ebp),%eax
c00282fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  __vprintf (format, args, output, aux);
c00282fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028300:	ff 75 10             	pushl  0x10(%ebp)
c0028303:	ff 75 0c             	pushl  0xc(%ebp)
c0028306:	50                   	push   %eax
c0028307:	ff 75 08             	pushl  0x8(%ebp)
c002830a:	e8 f5 f4 ff ff       	call   c0027804 <__vprintf>
c002830f:	83 c4 10             	add    $0x10,%esp
  va_end (args);
}
c0028312:	90                   	nop
c0028313:	c9                   	leave  
c0028314:	c3                   	ret    

c0028315 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0028315:	55                   	push   %ebp
c0028316:	89 e5                	mov    %esp,%ebp
c0028318:	83 ec 38             	sub    $0x38,%esp
c002831b:	8b 45 14             	mov    0x14(%ebp),%eax
c002831e:	88 45 d4             	mov    %al,-0x2c(%ebp)
  const uint8_t *buf = buf_;
c0028321:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028324:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const size_t per_line = 16; /* Maximum bytes per line. */
c0028327:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  while (size > 0)
c002832e:	e9 b4 01 00 00       	jmp    c00284e7 <hex_dump+0x1d2>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c0028333:	8b 45 08             	mov    0x8(%ebp),%eax
c0028336:	ba 00 00 00 00       	mov    $0x0,%edx
c002833b:	f7 75 e8             	divl   -0x18(%ebp)
c002833e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      end = per_line;
c0028341:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028344:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (end - start > size)
c0028347:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002834a:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002834d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028350:	76 0b                	jbe    c002835d <hex_dump+0x48>
        end = start + size;
c0028352:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0028355:	8b 45 10             	mov    0x10(%ebp),%eax
c0028358:	01 d0                	add    %edx,%eax
c002835a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      n = end - start;
c002835d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028360:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0028363:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0028366:	8b 45 08             	mov    0x8(%ebp),%eax
c0028369:	ba 00 00 00 00       	mov    $0x0,%edx
c002836e:	f7 75 e8             	divl   -0x18(%ebp)
c0028371:	0f af 45 e8          	imul   -0x18(%ebp),%eax
c0028375:	ba 00 00 00 00       	mov    $0x0,%edx
c002837a:	83 ec 04             	sub    $0x4,%esp
c002837d:	52                   	push   %edx
c002837e:	50                   	push   %eax
c002837f:	68 ec 23 03 c0       	push   $0xc00323ec
c0028384:	e8 55 f4 ff ff       	call   c00277de <printf>
c0028389:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c002838c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0028393:	eb 13                	jmp    c00283a8 <hex_dump+0x93>
        printf ("   ");
c0028395:	83 ec 0c             	sub    $0xc,%esp
c0028398:	68 f4 23 03 c0       	push   $0xc00323f4
c002839d:	e8 3c f4 ff ff       	call   c00277de <printf>
c00283a2:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c00283a5:	ff 45 ec             	incl   -0x14(%ebp)
c00283a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00283ab:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00283ae:	72 e5                	jb     c0028395 <hex_dump+0x80>
      for (; i < end; i++) 
c00283b0:	eb 3e                	jmp    c00283f0 <hex_dump+0xdb>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c00283b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00283b5:	d1 e8                	shr    %eax
c00283b7:	48                   	dec    %eax
        printf ("%02hhx%c",
c00283b8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00283bb:	75 07                	jne    c00283c4 <hex_dump+0xaf>
c00283bd:	ba 2d 00 00 00       	mov    $0x2d,%edx
c00283c2:	eb 05                	jmp    c00283c9 <hex_dump+0xb4>
c00283c4:	ba 20 00 00 00       	mov    $0x20,%edx
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c00283c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00283cc:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c00283cf:	89 c1                	mov    %eax,%ecx
c00283d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00283d4:	01 c8                	add    %ecx,%eax
c00283d6:	8a 00                	mov    (%eax),%al
        printf ("%02hhx%c",
c00283d8:	0f b6 c0             	movzbl %al,%eax
c00283db:	83 ec 04             	sub    $0x4,%esp
c00283de:	52                   	push   %edx
c00283df:	50                   	push   %eax
c00283e0:	68 f8 23 03 c0       	push   $0xc00323f8
c00283e5:	e8 f4 f3 ff ff       	call   c00277de <printf>
c00283ea:	83 c4 10             	add    $0x10,%esp
      for (; i < end; i++) 
c00283ed:	ff 45 ec             	incl   -0x14(%ebp)
c00283f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00283f3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00283f6:	72 ba                	jb     c00283b2 <hex_dump+0x9d>
      if (ascii) 
c00283f8:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c00283fc:	0f 84 c6 00 00 00    	je     c00284c8 <hex_dump+0x1b3>
        {
          for (; i < per_line; i++)
c0028402:	eb 13                	jmp    c0028417 <hex_dump+0x102>
            printf ("   ");
c0028404:	83 ec 0c             	sub    $0xc,%esp
c0028407:	68 f4 23 03 c0       	push   $0xc00323f4
c002840c:	e8 cd f3 ff ff       	call   c00277de <printf>
c0028411:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0028414:	ff 45 ec             	incl   -0x14(%ebp)
c0028417:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002841a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002841d:	72 e5                	jb     c0028404 <hex_dump+0xef>
          printf ("|");
c002841f:	83 ec 0c             	sub    $0xc,%esp
c0028422:	6a 7c                	push   $0x7c
c0028424:	e8 cb 3a 00 00       	call   c002bef4 <putchar>
c0028429:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c002842c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0028433:	eb 10                	jmp    c0028445 <hex_dump+0x130>
            printf (" ");
c0028435:	83 ec 0c             	sub    $0xc,%esp
c0028438:	6a 20                	push   $0x20
c002843a:	e8 b5 3a 00 00       	call   c002bef4 <putchar>
c002843f:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0028442:	ff 45 ec             	incl   -0x14(%ebp)
c0028445:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028448:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002844b:	72 e8                	jb     c0028435 <hex_dump+0x120>
          for (; i < end; i++)
c002844d:	eb 4a                	jmp    c0028499 <hex_dump+0x184>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c002844f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028452:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0028455:	89 c2                	mov    %eax,%edx
c0028457:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002845a:	01 d0                	add    %edx,%eax
c002845c:	8a 00                	mov    (%eax),%al
c002845e:	0f b6 c0             	movzbl %al,%eax
c0028461:	83 ec 0c             	sub    $0xc,%esp
c0028464:	50                   	push   %eax
c0028465:	e8 9f f2 ff ff       	call   c0027709 <isprint>
c002846a:	83 c4 10             	add    $0x10,%esp
            printf ("%c",
c002846d:	85 c0                	test   %eax,%eax
c002846f:	74 14                	je     c0028485 <hex_dump+0x170>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0028471:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028474:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0028477:	89 c2                	mov    %eax,%edx
c0028479:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002847c:	01 d0                	add    %edx,%eax
c002847e:	8a 00                	mov    (%eax),%al
            printf ("%c",
c0028480:	0f b6 c0             	movzbl %al,%eax
c0028483:	eb 05                	jmp    c002848a <hex_dump+0x175>
c0028485:	b8 2e 00 00 00       	mov    $0x2e,%eax
c002848a:	83 ec 0c             	sub    $0xc,%esp
c002848d:	50                   	push   %eax
c002848e:	e8 61 3a 00 00       	call   c002bef4 <putchar>
c0028493:	83 c4 10             	add    $0x10,%esp
          for (; i < end; i++)
c0028496:	ff 45 ec             	incl   -0x14(%ebp)
c0028499:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002849c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002849f:	72 ae                	jb     c002844f <hex_dump+0x13a>
          for (; i < per_line; i++)
c00284a1:	eb 10                	jmp    c00284b3 <hex_dump+0x19e>
            printf (" ");
c00284a3:	83 ec 0c             	sub    $0xc,%esp
c00284a6:	6a 20                	push   $0x20
c00284a8:	e8 47 3a 00 00       	call   c002bef4 <putchar>
c00284ad:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c00284b0:	ff 45 ec             	incl   -0x14(%ebp)
c00284b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00284b6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00284b9:	72 e8                	jb     c00284a3 <hex_dump+0x18e>
          printf ("|");
c00284bb:	83 ec 0c             	sub    $0xc,%esp
c00284be:	6a 7c                	push   $0x7c
c00284c0:	e8 2f 3a 00 00       	call   c002bef4 <putchar>
c00284c5:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c00284c8:	83 ec 0c             	sub    $0xc,%esp
c00284cb:	6a 0a                	push   $0xa
c00284cd:	e8 22 3a 00 00       	call   c002bef4 <putchar>
c00284d2:	83 c4 10             	add    $0x10,%esp

      ofs += n;
c00284d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00284d8:	01 45 08             	add    %eax,0x8(%ebp)
      buf += n;
c00284db:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00284de:	01 45 f4             	add    %eax,-0xc(%ebp)
      size -= n;
c00284e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00284e4:	29 45 10             	sub    %eax,0x10(%ebp)
  while (size > 0)
c00284e7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00284eb:	0f 85 42 fe ff ff    	jne    c0028333 <hex_dump+0x1e>
    }
}
c00284f1:	90                   	nop
c00284f2:	c9                   	leave  
c00284f3:	c3                   	ret    

c00284f4 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c00284f4:	55                   	push   %ebp
c00284f5:	89 e5                	mov    %esp,%ebp
c00284f7:	83 ec 28             	sub    $0x28,%esp
c00284fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00284fd:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c0028500:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0028503:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  if (size == 1)
c0028506:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0028509:	83 f1 01             	xor    $0x1,%ecx
c002850c:	89 c8                	mov    %ecx,%eax
c002850e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0028511:	80 f5 00             	xor    $0x0,%ch
c0028514:	89 ca                	mov    %ecx,%edx
c0028516:	09 d0                	or     %edx,%eax
c0028518:	85 c0                	test   %eax,%eax
c002851a:	75 12                	jne    c002852e <print_human_readable_size+0x3a>
    printf ("1 byte");
c002851c:	83 ec 0c             	sub    $0xc,%esp
c002851f:	68 01 24 03 c0       	push   $0xc0032401
c0028524:	e8 b5 f2 ff ff       	call   c00277de <printf>
c0028529:	83 c4 10             	add    $0x10,%esp

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
    }
}
c002852c:	eb 5a                	jmp    c0028588 <print_human_readable_size+0x94>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002852e:	c7 45 f4 e8 89 03 c0 	movl   $0xc00389e8,-0xc(%ebp)
c0028535:	eb 17                	jmp    c002854e <print_human_readable_size+0x5a>
        size /= 1024;
c0028537:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002853a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002853d:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0028541:	c1 ea 0a             	shr    $0xa,%edx
c0028544:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0028547:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002854a:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002854e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028552:	72 1b                	jb     c002856f <print_human_readable_size+0x7b>
c0028554:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028558:	77 09                	ja     c0028563 <print_human_readable_size+0x6f>
c002855a:	81 7d e0 ff 03 00 00 	cmpl   $0x3ff,-0x20(%ebp)
c0028561:	76 0c                	jbe    c002856f <print_human_readable_size+0x7b>
c0028563:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028566:	83 c0 04             	add    $0x4,%eax
c0028569:	8b 00                	mov    (%eax),%eax
c002856b:	85 c0                	test   %eax,%eax
c002856d:	75 c8                	jne    c0028537 <print_human_readable_size+0x43>
      printf ("%"PRIu64" %s", size, *fp);
c002856f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028572:	8b 00                	mov    (%eax),%eax
c0028574:	50                   	push   %eax
c0028575:	ff 75 e4             	pushl  -0x1c(%ebp)
c0028578:	ff 75 e0             	pushl  -0x20(%ebp)
c002857b:	68 08 24 03 c0       	push   $0xc0032408
c0028580:	e8 59 f2 ff ff       	call   c00277de <printf>
c0028585:	83 c4 10             	add    $0x10,%esp
}
c0028588:	90                   	nop
c0028589:	c9                   	leave  
c002858a:	c3                   	ret    

c002858b <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c002858b:	55                   	push   %ebp
c002858c:	89 e5                	mov    %esp,%ebp
c002858e:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0028592:	7e 0d                	jle    c00285a1 <isdigit+0x16>
c0028594:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0028598:	7f 07                	jg     c00285a1 <isdigit+0x16>
c002859a:	b8 01 00 00 00       	mov    $0x1,%eax
c002859f:	eb 05                	jmp    c00285a6 <isdigit+0x1b>
c00285a1:	b8 00 00 00 00       	mov    $0x0,%eax
c00285a6:	5d                   	pop    %ebp
c00285a7:	c3                   	ret    

c00285a8 <isspace>:
static inline int isspace (int c) {
c00285a8:	55                   	push   %ebp
c00285a9:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c00285ab:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c00285af:	74 1e                	je     c00285cf <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c00285b1:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c00285b5:	74 18                	je     c00285cf <isspace+0x27>
c00285b7:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c00285bb:	74 12                	je     c00285cf <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c00285bd:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c00285c1:	74 0c                	je     c00285cf <isspace+0x27>
c00285c3:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c00285c7:	74 06                	je     c00285cf <isspace+0x27>
c00285c9:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c00285cd:	75 07                	jne    c00285d6 <isspace+0x2e>
c00285cf:	b8 01 00 00 00       	mov    $0x1,%eax
c00285d4:	eb 05                	jmp    c00285db <isspace+0x33>
c00285d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00285db:	5d                   	pop    %ebp
c00285dc:	c3                   	ret    

c00285dd <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c00285dd:	55                   	push   %ebp
c00285de:	89 e5                	mov    %esp,%ebp
c00285e0:	83 ec 18             	sub    $0x18,%esp
  bool negative;
  int value;

  ASSERT (s != NULL);
c00285e3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00285e7:	75 21                	jne    c002860a <atoi+0x2d>
c00285e9:	83 ec 0c             	sub    $0xc,%esp
c00285ec:	68 2c 24 03 c0       	push   $0xc003242c
c00285f1:	68 36 24 03 c0       	push   $0xc0032436
c00285f6:	68 94 24 03 c0       	push   $0xc0032494
c00285fb:	6a 0f                	push   $0xf
c00285fd:	68 4d 24 03 c0       	push   $0xc003244d
c0028602:	e8 96 15 00 00       	call   c0029b9d <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c0028607:	ff 45 08             	incl   0x8(%ebp)
  while (isspace ((unsigned char) *s))
c002860a:	8b 45 08             	mov    0x8(%ebp),%eax
c002860d:	8a 00                	mov    (%eax),%al
c002860f:	0f b6 c0             	movzbl %al,%eax
c0028612:	83 ec 0c             	sub    $0xc,%esp
c0028615:	50                   	push   %eax
c0028616:	e8 8d ff ff ff       	call   c00285a8 <isspace>
c002861b:	83 c4 10             	add    $0x10,%esp
c002861e:	85 c0                	test   %eax,%eax
c0028620:	75 e5                	jne    c0028607 <atoi+0x2a>

  /* Parse sign. */
  negative = false;
c0028622:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (*s == '+')
c0028626:	8b 45 08             	mov    0x8(%ebp),%eax
c0028629:	8a 00                	mov    (%eax),%al
c002862b:	3c 2b                	cmp    $0x2b,%al
c002862d:	75 05                	jne    c0028634 <atoi+0x57>
    s++;
c002862f:	ff 45 08             	incl   0x8(%ebp)
c0028632:	eb 10                	jmp    c0028644 <atoi+0x67>
  else if (*s == '-')
c0028634:	8b 45 08             	mov    0x8(%ebp),%eax
c0028637:	8a 00                	mov    (%eax),%al
c0028639:	3c 2d                	cmp    $0x2d,%al
c002863b:	75 07                	jne    c0028644 <atoi+0x67>
    {
      negative = true;
c002863d:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
      s++;
c0028641:	ff 45 08             	incl   0x8(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0028644:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002864b:	eb 23                	jmp    c0028670 <atoi+0x93>
    value = value * 10 - (*s - '0');
c002864d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028650:	89 d0                	mov    %edx,%eax
c0028652:	c1 e0 02             	shl    $0x2,%eax
c0028655:	01 d0                	add    %edx,%eax
c0028657:	01 c0                	add    %eax,%eax
c0028659:	89 c2                	mov    %eax,%edx
c002865b:	8b 45 08             	mov    0x8(%ebp),%eax
c002865e:	8a 00                	mov    (%eax),%al
c0028660:	0f be c0             	movsbl %al,%eax
c0028663:	83 e8 30             	sub    $0x30,%eax
c0028666:	29 c2                	sub    %eax,%edx
c0028668:	89 d0                	mov    %edx,%eax
c002866a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (value = 0; isdigit (*s); s++)
c002866d:	ff 45 08             	incl   0x8(%ebp)
c0028670:	8b 45 08             	mov    0x8(%ebp),%eax
c0028673:	8a 00                	mov    (%eax),%al
c0028675:	0f be c0             	movsbl %al,%eax
c0028678:	83 ec 0c             	sub    $0xc,%esp
c002867b:	50                   	push   %eax
c002867c:	e8 0a ff ff ff       	call   c002858b <isdigit>
c0028681:	83 c4 10             	add    $0x10,%esp
c0028684:	85 c0                	test   %eax,%eax
c0028686:	75 c5                	jne    c002864d <atoi+0x70>
  if (!negative)
c0028688:	8a 45 f7             	mov    -0x9(%ebp),%al
c002868b:	83 f0 01             	xor    $0x1,%eax
c002868e:	84 c0                	test   %al,%al
c0028690:	74 03                	je     c0028695 <atoi+0xb8>
    value = -value;
c0028692:	f7 5d f0             	negl   -0x10(%ebp)

  return value;
c0028695:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028698:	c9                   	leave  
c0028699:	c3                   	ret    

c002869a <compare_thunk>:

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c002869a:	55                   	push   %ebp
c002869b:	89 e5                	mov    %esp,%ebp
c002869d:	83 ec 18             	sub    $0x18,%esp
  int (**compare) (const void *, const void *) = aux;
c00286a0:	8b 45 10             	mov    0x10(%ebp),%eax
c00286a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return (*compare) (a, b);
c00286a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286a9:	8b 00                	mov    (%eax),%eax
c00286ab:	83 ec 08             	sub    $0x8,%esp
c00286ae:	ff 75 0c             	pushl  0xc(%ebp)
c00286b1:	ff 75 08             	pushl  0x8(%ebp)
c00286b4:	ff d0                	call   *%eax
c00286b6:	83 c4 10             	add    $0x10,%esp
}
c00286b9:	c9                   	leave  
c00286ba:	c3                   	ret    

c00286bb <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c00286bb:	55                   	push   %ebp
c00286bc:	89 e5                	mov    %esp,%ebp
c00286be:	83 ec 08             	sub    $0x8,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c00286c1:	83 ec 0c             	sub    $0xc,%esp
c00286c4:	8d 45 14             	lea    0x14(%ebp),%eax
c00286c7:	50                   	push   %eax
c00286c8:	68 9a 86 02 c0       	push   $0xc002869a
c00286cd:	ff 75 10             	pushl  0x10(%ebp)
c00286d0:	ff 75 0c             	pushl  0xc(%ebp)
c00286d3:	ff 75 08             	pushl  0x8(%ebp)
c00286d6:	e8 51 01 00 00       	call   c002882c <sort>
c00286db:	83 c4 20             	add    $0x20,%esp
}
c00286de:	90                   	nop
c00286df:	c9                   	leave  
c00286e0:	c3                   	ret    

c00286e1 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c00286e1:	55                   	push   %ebp
c00286e2:	89 e5                	mov    %esp,%ebp
c00286e4:	83 ec 10             	sub    $0x10,%esp
  unsigned char *a = array + (a_idx - 1) * size;
c00286e7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00286ea:	48                   	dec    %eax
c00286eb:	0f af 45 14          	imul   0x14(%ebp),%eax
c00286ef:	89 c2                	mov    %eax,%edx
c00286f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00286f4:	01 d0                	add    %edx,%eax
c00286f6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned char *b = array + (b_idx - 1) * size;
c00286f9:	8b 45 10             	mov    0x10(%ebp),%eax
c00286fc:	48                   	dec    %eax
c00286fd:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028701:	89 c2                	mov    %eax,%edx
c0028703:	8b 45 08             	mov    0x8(%ebp),%eax
c0028706:	01 d0                	add    %edx,%eax
c0028708:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t i;

  for (i = 0; i < size; i++)
c002870b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0028712:	eb 31                	jmp    c0028745 <do_swap+0x64>
    {
      unsigned char t = a[i];
c0028714:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0028717:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002871a:	01 d0                	add    %edx,%eax
c002871c:	8a 00                	mov    (%eax),%al
c002871e:	88 45 f3             	mov    %al,-0xd(%ebp)
      a[i] = b[i];
c0028721:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0028724:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028727:	01 c2                	add    %eax,%edx
c0028729:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c002872c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002872f:	01 c8                	add    %ecx,%eax
c0028731:	8a 00                	mov    (%eax),%al
c0028733:	88 02                	mov    %al,(%edx)
      b[i] = t;
c0028735:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0028738:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002873b:	01 c2                	add    %eax,%edx
c002873d:	8a 45 f3             	mov    -0xd(%ebp),%al
c0028740:	88 02                	mov    %al,(%edx)
  for (i = 0; i < size; i++)
c0028742:	ff 45 fc             	incl   -0x4(%ebp)
c0028745:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028748:	3b 45 14             	cmp    0x14(%ebp),%eax
c002874b:	72 c7                	jb     c0028714 <do_swap+0x33>
    }
}
c002874d:	90                   	nop
c002874e:	c9                   	leave  
c002874f:	c3                   	ret    

c0028750 <do_compare>:
   strcmp()-type result. */
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
c0028750:	55                   	push   %ebp
c0028751:	89 e5                	mov    %esp,%ebp
c0028753:	83 ec 08             	sub    $0x8,%esp
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0028756:	8b 45 10             	mov    0x10(%ebp),%eax
c0028759:	48                   	dec    %eax
c002875a:	0f af 45 14          	imul   0x14(%ebp),%eax
c002875e:	89 c2                	mov    %eax,%edx
c0028760:	8b 45 08             	mov    0x8(%ebp),%eax
c0028763:	01 c2                	add    %eax,%edx
c0028765:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028768:	48                   	dec    %eax
c0028769:	0f af 45 14          	imul   0x14(%ebp),%eax
c002876d:	89 c1                	mov    %eax,%ecx
c002876f:	8b 45 08             	mov    0x8(%ebp),%eax
c0028772:	01 c8                	add    %ecx,%eax
c0028774:	83 ec 04             	sub    $0x4,%esp
c0028777:	ff 75 1c             	pushl  0x1c(%ebp)
c002877a:	52                   	push   %edx
c002877b:	50                   	push   %eax
c002877c:	8b 45 18             	mov    0x18(%ebp),%eax
c002877f:	ff d0                	call   *%eax
c0028781:	83 c4 10             	add    $0x10,%esp
}
c0028784:	c9                   	leave  
c0028785:	c3                   	ret    

c0028786 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0028786:	55                   	push   %ebp
c0028787:	89 e5                	mov    %esp,%ebp
c0028789:	83 ec 18             	sub    $0x18,%esp
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c002878c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002878f:	01 c0                	add    %eax,%eax
c0028791:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t right = 2 * i + 1;
c0028794:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028797:	01 c0                	add    %eax,%eax
c0028799:	40                   	inc    %eax
c002879a:	89 45 ec             	mov    %eax,-0x14(%ebp)
      size_t max = i;
c002879d:	8b 45 0c             	mov    0xc(%ebp),%eax
c00287a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c00287a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00287a6:	3b 45 10             	cmp    0x10(%ebp),%eax
c00287a9:	77 27                	ja     c00287d2 <heapify+0x4c>
c00287ab:	83 ec 08             	sub    $0x8,%esp
c00287ae:	ff 75 1c             	pushl  0x1c(%ebp)
c00287b1:	ff 75 18             	pushl  0x18(%ebp)
c00287b4:	ff 75 14             	pushl  0x14(%ebp)
c00287b7:	ff 75 f4             	pushl  -0xc(%ebp)
c00287ba:	ff 75 f0             	pushl  -0x10(%ebp)
c00287bd:	ff 75 08             	pushl  0x8(%ebp)
c00287c0:	e8 8b ff ff ff       	call   c0028750 <do_compare>
c00287c5:	83 c4 20             	add    $0x20,%esp
c00287c8:	85 c0                	test   %eax,%eax
c00287ca:	7e 06                	jle    c00287d2 <heapify+0x4c>
        max = left;
c00287cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00287cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (right <= cnt
c00287d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00287d5:	3b 45 10             	cmp    0x10(%ebp),%eax
c00287d8:	77 27                	ja     c0028801 <heapify+0x7b>
          && do_compare (array, right, max, size, compare, aux) > 0) 
c00287da:	83 ec 08             	sub    $0x8,%esp
c00287dd:	ff 75 1c             	pushl  0x1c(%ebp)
c00287e0:	ff 75 18             	pushl  0x18(%ebp)
c00287e3:	ff 75 14             	pushl  0x14(%ebp)
c00287e6:	ff 75 f4             	pushl  -0xc(%ebp)
c00287e9:	ff 75 ec             	pushl  -0x14(%ebp)
c00287ec:	ff 75 08             	pushl  0x8(%ebp)
c00287ef:	e8 5c ff ff ff       	call   c0028750 <do_compare>
c00287f4:	83 c4 20             	add    $0x20,%esp
c00287f7:	85 c0                	test   %eax,%eax
c00287f9:	7e 06                	jle    c0028801 <heapify+0x7b>
        max = right;
c00287fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00287fe:	89 45 f4             	mov    %eax,-0xc(%ebp)

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0028801:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028804:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028807:	74 1f                	je     c0028828 <heapify+0xa2>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0028809:	ff 75 14             	pushl  0x14(%ebp)
c002880c:	ff 75 f4             	pushl  -0xc(%ebp)
c002880f:	ff 75 0c             	pushl  0xc(%ebp)
c0028812:	ff 75 08             	pushl  0x8(%ebp)
c0028815:	e8 c7 fe ff ff       	call   c00286e1 <do_swap>
c002881a:	83 c4 10             	add    $0x10,%esp
      i = max;
c002881d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028820:	89 45 0c             	mov    %eax,0xc(%ebp)
    {
c0028823:	e9 64 ff ff ff       	jmp    c002878c <heapify+0x6>
        break;
c0028828:	90                   	nop
    }
}
c0028829:	90                   	nop
c002882a:	c9                   	leave  
c002882b:	c3                   	ret    

c002882c <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c002882c:	55                   	push   %ebp
c002882d:	89 e5                	mov    %esp,%ebp
c002882f:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c0028832:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028836:	75 27                	jne    c002885f <sort+0x33>
c0028838:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002883c:	74 21                	je     c002885f <sort+0x33>
c002883e:	83 ec 0c             	sub    $0xc,%esp
c0028841:	68 60 24 03 c0       	push   $0xc0032460
c0028846:	68 36 24 03 c0       	push   $0xc0032436
c002884b:	68 9c 24 03 c0       	push   $0xc003249c
c0028850:	68 8a 00 00 00       	push   $0x8a
c0028855:	68 4d 24 03 c0       	push   $0xc003244d
c002885a:	e8 3e 13 00 00       	call   c0029b9d <debug_panic>
  ASSERT (compare != NULL);
c002885f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0028863:	75 21                	jne    c0028886 <sort+0x5a>
c0028865:	83 ec 0c             	sub    $0xc,%esp
c0028868:	68 7a 24 03 c0       	push   $0xc003247a
c002886d:	68 36 24 03 c0       	push   $0xc0032436
c0028872:	68 9c 24 03 c0       	push   $0xc003249c
c0028877:	68 8b 00 00 00       	push   $0x8b
c002887c:	68 4d 24 03 c0       	push   $0xc003244d
c0028881:	e8 17 13 00 00       	call   c0029b9d <debug_panic>
  ASSERT (size > 0);
c0028886:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002888a:	75 21                	jne    c00288ad <sort+0x81>
c002888c:	83 ec 0c             	sub    $0xc,%esp
c002888f:	68 8a 24 03 c0       	push   $0xc003248a
c0028894:	68 36 24 03 c0       	push   $0xc0032436
c0028899:	68 9c 24 03 c0       	push   $0xc003249c
c002889e:	68 8c 00 00 00       	push   $0x8c
c00288a3:	68 4d 24 03 c0       	push   $0xc003244d
c00288a8:	e8 f0 12 00 00       	call   c0029b9d <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c00288ad:	8b 45 0c             	mov    0xc(%ebp),%eax
c00288b0:	d1 e8                	shr    %eax
c00288b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00288b5:	eb 20                	jmp    c00288d7 <sort+0xab>
    heapify (array, i, cnt, size, compare, aux);
c00288b7:	83 ec 08             	sub    $0x8,%esp
c00288ba:	ff 75 18             	pushl  0x18(%ebp)
c00288bd:	ff 75 14             	pushl  0x14(%ebp)
c00288c0:	ff 75 10             	pushl  0x10(%ebp)
c00288c3:	ff 75 0c             	pushl  0xc(%ebp)
c00288c6:	ff 75 f4             	pushl  -0xc(%ebp)
c00288c9:	ff 75 08             	pushl  0x8(%ebp)
c00288cc:	e8 b5 fe ff ff       	call   c0028786 <heapify>
c00288d1:	83 c4 20             	add    $0x20,%esp
  for (i = cnt / 2; i > 0; i--)
c00288d4:	ff 4d f4             	decl   -0xc(%ebp)
c00288d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00288db:	75 da                	jne    c00288b7 <sort+0x8b>

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c00288dd:	8b 45 0c             	mov    0xc(%ebp),%eax
c00288e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00288e3:	eb 34                	jmp    c0028919 <sort+0xed>
    {
      do_swap (array, 1, i, size);
c00288e5:	ff 75 10             	pushl  0x10(%ebp)
c00288e8:	ff 75 f4             	pushl  -0xc(%ebp)
c00288eb:	6a 01                	push   $0x1
c00288ed:	ff 75 08             	pushl  0x8(%ebp)
c00288f0:	e8 ec fd ff ff       	call   c00286e1 <do_swap>
c00288f5:	83 c4 10             	add    $0x10,%esp
      heapify (array, 1, i - 1, size, compare, aux); 
c00288f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00288fb:	48                   	dec    %eax
c00288fc:	83 ec 08             	sub    $0x8,%esp
c00288ff:	ff 75 18             	pushl  0x18(%ebp)
c0028902:	ff 75 14             	pushl  0x14(%ebp)
c0028905:	ff 75 10             	pushl  0x10(%ebp)
c0028908:	50                   	push   %eax
c0028909:	6a 01                	push   $0x1
c002890b:	ff 75 08             	pushl  0x8(%ebp)
c002890e:	e8 73 fe ff ff       	call   c0028786 <heapify>
c0028913:	83 c4 20             	add    $0x20,%esp
  for (i = cnt; i > 1; i--) 
c0028916:	ff 4d f4             	decl   -0xc(%ebp)
c0028919:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002891d:	77 c6                	ja     c00288e5 <sort+0xb9>
    }
}
c002891f:	90                   	nop
c0028920:	c9                   	leave  
c0028921:	c3                   	ret    

c0028922 <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c0028922:	55                   	push   %ebp
c0028923:	89 e5                	mov    %esp,%ebp
c0028925:	83 ec 08             	sub    $0x8,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c0028928:	83 ec 08             	sub    $0x8,%esp
c002892b:	8d 45 18             	lea    0x18(%ebp),%eax
c002892e:	50                   	push   %eax
c002892f:	68 9a 86 02 c0       	push   $0xc002869a
c0028934:	ff 75 14             	pushl  0x14(%ebp)
c0028937:	ff 75 10             	pushl  0x10(%ebp)
c002893a:	ff 75 0c             	pushl  0xc(%ebp)
c002893d:	ff 75 08             	pushl  0x8(%ebp)
c0028940:	e8 05 00 00 00       	call   c002894a <binary_search>
c0028945:	83 c4 20             	add    $0x20,%esp
}
c0028948:	c9                   	leave  
c0028949:	c3                   	ret    

c002894a <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c002894a:	55                   	push   %ebp
c002894b:	89 e5                	mov    %esp,%ebp
c002894d:	83 ec 28             	sub    $0x28,%esp
  const unsigned char *first = array;
c0028950:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028953:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *last = array + size * cnt;
c0028956:	8b 45 14             	mov    0x14(%ebp),%eax
c0028959:	0f af 45 10          	imul   0x10(%ebp),%eax
c002895d:	89 c2                	mov    %eax,%edx
c002895f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028962:	01 d0                	add    %edx,%eax
c0028964:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while (first < last) 
c0028967:	eb 65                	jmp    c00289ce <binary_search+0x84>
    {
      size_t range = (last - first) / size;
c0028969:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002896c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002896f:	29 c2                	sub    %eax,%edx
c0028971:	89 d0                	mov    %edx,%eax
c0028973:	ba 00 00 00 00       	mov    $0x0,%edx
c0028978:	f7 75 14             	divl   0x14(%ebp)
c002897b:	89 45 ec             	mov    %eax,-0x14(%ebp)
      const unsigned char *middle = first + (range / 2) * size;
c002897e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028981:	d1 e8                	shr    %eax
c0028983:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028987:	89 c2                	mov    %eax,%edx
c0028989:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002898c:	01 d0                	add    %edx,%eax
c002898e:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int cmp = compare (key, middle, aux);
c0028991:	83 ec 04             	sub    $0x4,%esp
c0028994:	ff 75 1c             	pushl  0x1c(%ebp)
c0028997:	ff 75 e8             	pushl  -0x18(%ebp)
c002899a:	ff 75 08             	pushl  0x8(%ebp)
c002899d:	8b 45 18             	mov    0x18(%ebp),%eax
c00289a0:	ff d0                	call   *%eax
c00289a2:	83 c4 10             	add    $0x10,%esp
c00289a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if (cmp < 0) 
c00289a8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00289ac:	79 08                	jns    c00289b6 <binary_search+0x6c>
        last = middle;
c00289ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00289b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00289b4:	eb 18                	jmp    c00289ce <binary_search+0x84>
      else if (cmp > 0) 
c00289b6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00289ba:	7e 0d                	jle    c00289c9 <binary_search+0x7f>
        first = middle + size;
c00289bc:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00289bf:	8b 45 14             	mov    0x14(%ebp),%eax
c00289c2:	01 d0                	add    %edx,%eax
c00289c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00289c7:	eb 05                	jmp    c00289ce <binary_search+0x84>
      else
        return (void *) middle;
c00289c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00289cc:	eb 0d                	jmp    c00289db <binary_search+0x91>
  while (first < last) 
c00289ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289d1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00289d4:	72 93                	jb     c0028969 <binary_search+0x1f>
    }
  
  return NULL;
c00289d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00289db:	c9                   	leave  
c00289dc:	c3                   	ret    

c00289dd <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c00289dd:	55                   	push   %ebp
c00289de:	89 e5                	mov    %esp,%ebp
c00289e0:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c00289e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00289e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c00289e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00289ec:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c00289ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00289f3:	75 24                	jne    c0028a19 <memcpy+0x3c>
c00289f5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00289f9:	74 1e                	je     c0028a19 <memcpy+0x3c>
c00289fb:	83 ec 0c             	sub    $0xc,%esp
c00289fe:	68 a4 24 03 c0       	push   $0xc00324a4
c0028a03:	68 bd 24 03 c0       	push   $0xc00324bd
c0028a08:	68 b4 25 03 c0       	push   $0xc00325b4
c0028a0d:	6a 0c                	push   $0xc
c0028a0f:	68 d4 24 03 c0       	push   $0xc00324d4
c0028a14:	e8 84 11 00 00       	call   c0029b9d <debug_panic>
  ASSERT (src != NULL || size == 0);
c0028a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028a1d:	75 3a                	jne    c0028a59 <memcpy+0x7c>
c0028a1f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028a23:	74 34                	je     c0028a59 <memcpy+0x7c>
c0028a25:	83 ec 0c             	sub    $0xc,%esp
c0028a28:	68 e7 24 03 c0       	push   $0xc00324e7
c0028a2d:	68 bd 24 03 c0       	push   $0xc00324bd
c0028a32:	68 b4 25 03 c0       	push   $0xc00325b4
c0028a37:	6a 0d                	push   $0xd
c0028a39:	68 d4 24 03 c0       	push   $0xc00324d4
c0028a3e:	e8 5a 11 00 00       	call   c0029b9d <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c0028a43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028a46:	8d 50 01             	lea    0x1(%eax),%edx
c0028a49:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028a4c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028a4f:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028a52:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028a55:	8a 12                	mov    (%edx),%dl
c0028a57:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c0028a59:	8b 45 10             	mov    0x10(%ebp),%eax
c0028a5c:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028a5f:	89 55 10             	mov    %edx,0x10(%ebp)
c0028a62:	85 c0                	test   %eax,%eax
c0028a64:	75 dd                	jne    c0028a43 <memcpy+0x66>

  return dst_;
c0028a66:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0028a69:	c9                   	leave  
c0028a6a:	c3                   	ret    

c0028a6b <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c0028a6b:	55                   	push   %ebp
c0028a6c:	89 e5                	mov    %esp,%ebp
c0028a6e:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028a71:	8b 45 08             	mov    0x8(%ebp),%eax
c0028a74:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028a77:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028a7a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028a7d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028a81:	75 24                	jne    c0028aa7 <memmove+0x3c>
c0028a83:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028a87:	74 1e                	je     c0028aa7 <memmove+0x3c>
c0028a89:	83 ec 0c             	sub    $0xc,%esp
c0028a8c:	68 a4 24 03 c0       	push   $0xc00324a4
c0028a91:	68 bd 24 03 c0       	push   $0xc00324bd
c0028a96:	68 bc 25 03 c0       	push   $0xc00325bc
c0028a9b:	6a 1d                	push   $0x1d
c0028a9d:	68 d4 24 03 c0       	push   $0xc00324d4
c0028aa2:	e8 f6 10 00 00       	call   c0029b9d <debug_panic>
  ASSERT (src != NULL || size == 0);
c0028aa7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028aab:	75 24                	jne    c0028ad1 <memmove+0x66>
c0028aad:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028ab1:	74 1e                	je     c0028ad1 <memmove+0x66>
c0028ab3:	83 ec 0c             	sub    $0xc,%esp
c0028ab6:	68 e7 24 03 c0       	push   $0xc00324e7
c0028abb:	68 bd 24 03 c0       	push   $0xc00324bd
c0028ac0:	68 bc 25 03 c0       	push   $0xc00325bc
c0028ac5:	6a 1e                	push   $0x1e
c0028ac7:	68 d4 24 03 c0       	push   $0xc00324d4
c0028acc:	e8 cc 10 00 00       	call   c0029b9d <debug_panic>

  if (dst < src) 
c0028ad1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ad4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028ad7:	73 27                	jae    c0028b00 <memmove+0x95>
    {
      while (size-- > 0)
c0028ad9:	eb 16                	jmp    c0028af1 <memmove+0x86>
        *dst++ = *src++;
c0028adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ade:	8d 50 01             	lea    0x1(%eax),%edx
c0028ae1:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028ae4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028ae7:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028aea:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028aed:	8a 12                	mov    (%edx),%dl
c0028aef:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c0028af1:	8b 45 10             	mov    0x10(%ebp),%eax
c0028af4:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028af7:	89 55 10             	mov    %edx,0x10(%ebp)
c0028afa:	85 c0                	test   %eax,%eax
c0028afc:	75 dd                	jne    c0028adb <memmove+0x70>
c0028afe:	eb 2b                	jmp    c0028b2b <memmove+0xc0>
    }
  else 
    {
      dst += size;
c0028b00:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b03:	01 45 f4             	add    %eax,-0xc(%ebp)
      src += size;
c0028b06:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b09:	01 45 f0             	add    %eax,-0x10(%ebp)
      while (size-- > 0)
c0028b0c:	eb 10                	jmp    c0028b1e <memmove+0xb3>
        *--dst = *--src;
c0028b0e:	ff 4d f4             	decl   -0xc(%ebp)
c0028b11:	ff 4d f0             	decl   -0x10(%ebp)
c0028b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b17:	8a 10                	mov    (%eax),%dl
c0028b19:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b1c:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c0028b1e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b21:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028b24:	89 55 10             	mov    %edx,0x10(%ebp)
c0028b27:	85 c0                	test   %eax,%eax
c0028b29:	75 e3                	jne    c0028b0e <memmove+0xa3>
    }

  return dst;
c0028b2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028b2e:	c9                   	leave  
c0028b2f:	c3                   	ret    

c0028b30 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0028b30:	55                   	push   %ebp
c0028b31:	89 e5                	mov    %esp,%ebp
c0028b33:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = a_;
c0028b36:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b39:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = b_;
c0028b3c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028b3f:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL || size == 0);
c0028b42:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028b46:	75 24                	jne    c0028b6c <memcmp+0x3c>
c0028b48:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028b4c:	74 1e                	je     c0028b6c <memcmp+0x3c>
c0028b4e:	83 ec 0c             	sub    $0xc,%esp
c0028b51:	68 00 25 03 c0       	push   $0xc0032500
c0028b56:	68 bd 24 03 c0       	push   $0xc00324bd
c0028b5b:	68 c4 25 03 c0       	push   $0xc00325c4
c0028b60:	6a 3a                	push   $0x3a
c0028b62:	68 d4 24 03 c0       	push   $0xc00324d4
c0028b67:	e8 31 10 00 00       	call   c0029b9d <debug_panic>
  ASSERT (b != NULL || size == 0);
c0028b6c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028b70:	75 54                	jne    c0028bc6 <memcmp+0x96>
c0028b72:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028b76:	74 4e                	je     c0028bc6 <memcmp+0x96>
c0028b78:	83 ec 0c             	sub    $0xc,%esp
c0028b7b:	68 17 25 03 c0       	push   $0xc0032517
c0028b80:	68 bd 24 03 c0       	push   $0xc00324bd
c0028b85:	68 c4 25 03 c0       	push   $0xc00325c4
c0028b8a:	6a 3b                	push   $0x3b
c0028b8c:	68 d4 24 03 c0       	push   $0xc00324d4
c0028b91:	e8 07 10 00 00       	call   c0029b9d <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c0028b96:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b99:	8a 10                	mov    (%eax),%dl
c0028b9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b9e:	8a 00                	mov    (%eax),%al
c0028ba0:	38 c2                	cmp    %al,%dl
c0028ba2:	74 1c                	je     c0028bc0 <memcmp+0x90>
      return *a > *b ? +1 : -1;
c0028ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ba7:	8a 10                	mov    (%eax),%dl
c0028ba9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028bac:	8a 00                	mov    (%eax),%al
c0028bae:	38 c2                	cmp    %al,%dl
c0028bb0:	76 07                	jbe    c0028bb9 <memcmp+0x89>
c0028bb2:	b8 01 00 00 00       	mov    $0x1,%eax
c0028bb7:	eb 1f                	jmp    c0028bd8 <memcmp+0xa8>
c0028bb9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0028bbe:	eb 18                	jmp    c0028bd8 <memcmp+0xa8>
  for (; size-- > 0; a++, b++)
c0028bc0:	ff 45 f4             	incl   -0xc(%ebp)
c0028bc3:	ff 45 f0             	incl   -0x10(%ebp)
c0028bc6:	8b 45 10             	mov    0x10(%ebp),%eax
c0028bc9:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028bcc:	89 55 10             	mov    %edx,0x10(%ebp)
c0028bcf:	85 c0                	test   %eax,%eax
c0028bd1:	75 c3                	jne    c0028b96 <memcmp+0x66>
  return 0;
c0028bd3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028bd8:	c9                   	leave  
c0028bd9:	c3                   	ret    

c0028bda <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c0028bda:	55                   	push   %ebp
c0028bdb:	89 e5                	mov    %esp,%ebp
c0028bdd:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = (const unsigned char *) a_;
c0028be0:	8b 45 08             	mov    0x8(%ebp),%eax
c0028be3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = (const unsigned char *) b_;
c0028be6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028be9:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL);
c0028bec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028bf0:	75 1e                	jne    c0028c10 <strcmp+0x36>
c0028bf2:	83 ec 0c             	sub    $0xc,%esp
c0028bf5:	68 2e 25 03 c0       	push   $0xc003252e
c0028bfa:	68 bd 24 03 c0       	push   $0xc00324bd
c0028bff:	68 cc 25 03 c0       	push   $0xc00325cc
c0028c04:	6a 4e                	push   $0x4e
c0028c06:	68 d4 24 03 c0       	push   $0xc00324d4
c0028c0b:	e8 8d 0f 00 00       	call   c0029b9d <debug_panic>
  ASSERT (b != NULL);
c0028c10:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028c14:	75 24                	jne    c0028c3a <strcmp+0x60>
c0028c16:	83 ec 0c             	sub    $0xc,%esp
c0028c19:	68 38 25 03 c0       	push   $0xc0032538
c0028c1e:	68 bd 24 03 c0       	push   $0xc00324bd
c0028c23:	68 cc 25 03 c0       	push   $0xc00325cc
c0028c28:	6a 4f                	push   $0x4f
c0028c2a:	68 d4 24 03 c0       	push   $0xc00324d4
c0028c2f:	e8 69 0f 00 00       	call   c0029b9d <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c0028c34:	ff 45 f4             	incl   -0xc(%ebp)
      b++;
c0028c37:	ff 45 f0             	incl   -0x10(%ebp)
  while (*a != '\0' && *a == *b) 
c0028c3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c3d:	8a 00                	mov    (%eax),%al
c0028c3f:	84 c0                	test   %al,%al
c0028c41:	74 0e                	je     c0028c51 <strcmp+0x77>
c0028c43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c46:	8a 10                	mov    (%eax),%dl
c0028c48:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028c4b:	8a 00                	mov    (%eax),%al
c0028c4d:	38 c2                	cmp    %al,%dl
c0028c4f:	74 e3                	je     c0028c34 <strcmp+0x5a>
    }

  return *a < *b ? -1 : *a > *b;
c0028c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c54:	8a 10                	mov    (%eax),%dl
c0028c56:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028c59:	8a 00                	mov    (%eax),%al
c0028c5b:	38 c2                	cmp    %al,%dl
c0028c5d:	72 14                	jb     c0028c73 <strcmp+0x99>
c0028c5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c62:	8a 10                	mov    (%eax),%dl
c0028c64:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028c67:	8a 00                	mov    (%eax),%al
c0028c69:	38 c2                	cmp    %al,%dl
c0028c6b:	0f 97 c0             	seta   %al
c0028c6e:	0f b6 c0             	movzbl %al,%eax
c0028c71:	eb 05                	jmp    c0028c78 <strcmp+0x9e>
c0028c73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0028c78:	c9                   	leave  
c0028c79:	c3                   	ret    

c0028c7a <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c0028c7a:	55                   	push   %ebp
c0028c7b:	89 e5                	mov    %esp,%ebp
c0028c7d:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *block = block_;
c0028c80:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c83:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned char ch = ch_;
c0028c86:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028c89:	88 45 f3             	mov    %al,-0xd(%ebp)

  ASSERT (block != NULL || size == 0);
c0028c8c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028c90:	75 36                	jne    c0028cc8 <memchr+0x4e>
c0028c92:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028c96:	74 30                	je     c0028cc8 <memchr+0x4e>
c0028c98:	83 ec 0c             	sub    $0xc,%esp
c0028c9b:	68 42 25 03 c0       	push   $0xc0032542
c0028ca0:	68 bd 24 03 c0       	push   $0xc00324bd
c0028ca5:	68 d4 25 03 c0       	push   $0xc00325d4
c0028caa:	6a 63                	push   $0x63
c0028cac:	68 d4 24 03 c0       	push   $0xc00324d4
c0028cb1:	e8 e7 0e 00 00       	call   c0029b9d <debug_panic>

  for (; size-- > 0; block++)
    if (*block == ch)
c0028cb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028cb9:	8a 00                	mov    (%eax),%al
c0028cbb:	3a 45 f3             	cmp    -0xd(%ebp),%al
c0028cbe:	75 05                	jne    c0028cc5 <memchr+0x4b>
      return (void *) block;
c0028cc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028cc3:	eb 15                	jmp    c0028cda <memchr+0x60>
  for (; size-- > 0; block++)
c0028cc5:	ff 45 f4             	incl   -0xc(%ebp)
c0028cc8:	8b 45 10             	mov    0x10(%ebp),%eax
c0028ccb:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028cce:	89 55 10             	mov    %edx,0x10(%ebp)
c0028cd1:	85 c0                	test   %eax,%eax
c0028cd3:	75 e1                	jne    c0028cb6 <memchr+0x3c>

  return NULL;
c0028cd5:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028cda:	c9                   	leave  
c0028cdb:	c3                   	ret    

c0028cdc <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c0028cdc:	55                   	push   %ebp
c0028cdd:	89 e5                	mov    %esp,%ebp
c0028cdf:	83 ec 18             	sub    $0x18,%esp
  char c = c_;
c0028ce2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028ce5:	88 45 f7             	mov    %al,-0x9(%ebp)

  ASSERT (string != NULL);
c0028ce8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028cec:	75 1e                	jne    c0028d0c <strchr+0x30>
c0028cee:	83 ec 0c             	sub    $0xc,%esp
c0028cf1:	68 5d 25 03 c0       	push   $0xc003255d
c0028cf6:	68 bd 24 03 c0       	push   $0xc00324bd
c0028cfb:	68 dc 25 03 c0       	push   $0xc00325dc
c0028d00:	6a 75                	push   $0x75
c0028d02:	68 d4 24 03 c0       	push   $0xc00324d4
c0028d07:	e8 91 0e 00 00       	call   c0029b9d <debug_panic>

  for (;;) 
    if (*string == c)
c0028d0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d0f:	8a 00                	mov    (%eax),%al
c0028d11:	3a 45 f7             	cmp    -0x9(%ebp),%al
c0028d14:	75 05                	jne    c0028d1b <strchr+0x3f>
      return (char *) string;
c0028d16:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d19:	eb 15                	jmp    c0028d30 <strchr+0x54>
    else if (*string == '\0')
c0028d1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d1e:	8a 00                	mov    (%eax),%al
c0028d20:	84 c0                	test   %al,%al
c0028d22:	75 07                	jne    c0028d2b <strchr+0x4f>
      return NULL;
c0028d24:	b8 00 00 00 00       	mov    $0x0,%eax
c0028d29:	eb 05                	jmp    c0028d30 <strchr+0x54>
    else
      string++;
c0028d2b:	ff 45 08             	incl   0x8(%ebp)
    if (*string == c)
c0028d2e:	eb dc                	jmp    c0028d0c <strchr+0x30>
}
c0028d30:	c9                   	leave  
c0028d31:	c3                   	ret    

c0028d32 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c0028d32:	55                   	push   %ebp
c0028d33:	89 e5                	mov    %esp,%ebp
c0028d35:	83 ec 18             	sub    $0x18,%esp
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028d38:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028d3f:	eb 23                	jmp    c0028d64 <strcspn+0x32>
    if (strchr (stop, string[length]) != NULL)
c0028d41:	8b 55 08             	mov    0x8(%ebp),%edx
c0028d44:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028d47:	01 d0                	add    %edx,%eax
c0028d49:	8a 00                	mov    (%eax),%al
c0028d4b:	0f be c0             	movsbl %al,%eax
c0028d4e:	83 ec 08             	sub    $0x8,%esp
c0028d51:	50                   	push   %eax
c0028d52:	ff 75 0c             	pushl  0xc(%ebp)
c0028d55:	e8 82 ff ff ff       	call   c0028cdc <strchr>
c0028d5a:	83 c4 10             	add    $0x10,%esp
c0028d5d:	85 c0                	test   %eax,%eax
c0028d5f:	75 13                	jne    c0028d74 <strcspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c0028d61:	ff 45 f4             	incl   -0xc(%ebp)
c0028d64:	8b 55 08             	mov    0x8(%ebp),%edx
c0028d67:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028d6a:	01 d0                	add    %edx,%eax
c0028d6c:	8a 00                	mov    (%eax),%al
c0028d6e:	84 c0                	test   %al,%al
c0028d70:	75 cf                	jne    c0028d41 <strcspn+0xf>
c0028d72:	eb 01                	jmp    c0028d75 <strcspn+0x43>
      break;
c0028d74:	90                   	nop
  return length;
c0028d75:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028d78:	c9                   	leave  
c0028d79:	c3                   	ret    

c0028d7a <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c0028d7a:	55                   	push   %ebp
c0028d7b:	89 e5                	mov    %esp,%ebp
c0028d7d:	83 ec 08             	sub    $0x8,%esp
  for (; *string != '\0'; string++)
c0028d80:	eb 23                	jmp    c0028da5 <strpbrk+0x2b>
    if (strchr (stop, *string) != NULL)
c0028d82:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d85:	8a 00                	mov    (%eax),%al
c0028d87:	0f be c0             	movsbl %al,%eax
c0028d8a:	83 ec 08             	sub    $0x8,%esp
c0028d8d:	50                   	push   %eax
c0028d8e:	ff 75 0c             	pushl  0xc(%ebp)
c0028d91:	e8 46 ff ff ff       	call   c0028cdc <strchr>
c0028d96:	83 c4 10             	add    $0x10,%esp
c0028d99:	85 c0                	test   %eax,%eax
c0028d9b:	74 05                	je     c0028da2 <strpbrk+0x28>
      return (char *) string;
c0028d9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028da0:	eb 11                	jmp    c0028db3 <strpbrk+0x39>
  for (; *string != '\0'; string++)
c0028da2:	ff 45 08             	incl   0x8(%ebp)
c0028da5:	8b 45 08             	mov    0x8(%ebp),%eax
c0028da8:	8a 00                	mov    (%eax),%al
c0028daa:	84 c0                	test   %al,%al
c0028dac:	75 d4                	jne    c0028d82 <strpbrk+0x8>
  return NULL;
c0028dae:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028db3:	c9                   	leave  
c0028db4:	c3                   	ret    

c0028db5 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0028db5:	55                   	push   %ebp
c0028db6:	89 e5                	mov    %esp,%ebp
c0028db8:	83 ec 10             	sub    $0x10,%esp
  char c = c_;
c0028dbb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028dbe:	88 45 fb             	mov    %al,-0x5(%ebp)
  const char *p = NULL;
c0028dc1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (; *string != '\0'; string++)
c0028dc8:	eb 13                	jmp    c0028ddd <strrchr+0x28>
    if (*string == c)
c0028dca:	8b 45 08             	mov    0x8(%ebp),%eax
c0028dcd:	8a 00                	mov    (%eax),%al
c0028dcf:	3a 45 fb             	cmp    -0x5(%ebp),%al
c0028dd2:	75 06                	jne    c0028dda <strrchr+0x25>
      p = string;
c0028dd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0028dd7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  for (; *string != '\0'; string++)
c0028dda:	ff 45 08             	incl   0x8(%ebp)
c0028ddd:	8b 45 08             	mov    0x8(%ebp),%eax
c0028de0:	8a 00                	mov    (%eax),%al
c0028de2:	84 c0                	test   %al,%al
c0028de4:	75 e4                	jne    c0028dca <strrchr+0x15>
  return (char *) p;
c0028de6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028de9:	c9                   	leave  
c0028dea:	c3                   	ret    

c0028deb <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c0028deb:	55                   	push   %ebp
c0028dec:	89 e5                	mov    %esp,%ebp
c0028dee:	83 ec 18             	sub    $0x18,%esp
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c0028df1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028df8:	eb 23                	jmp    c0028e1d <strspn+0x32>
    if (strchr (skip, string[length]) == NULL)
c0028dfa:	8b 55 08             	mov    0x8(%ebp),%edx
c0028dfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028e00:	01 d0                	add    %edx,%eax
c0028e02:	8a 00                	mov    (%eax),%al
c0028e04:	0f be c0             	movsbl %al,%eax
c0028e07:	83 ec 08             	sub    $0x8,%esp
c0028e0a:	50                   	push   %eax
c0028e0b:	ff 75 0c             	pushl  0xc(%ebp)
c0028e0e:	e8 c9 fe ff ff       	call   c0028cdc <strchr>
c0028e13:	83 c4 10             	add    $0x10,%esp
c0028e16:	85 c0                	test   %eax,%eax
c0028e18:	74 13                	je     c0028e2d <strspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c0028e1a:	ff 45 f4             	incl   -0xc(%ebp)
c0028e1d:	8b 55 08             	mov    0x8(%ebp),%edx
c0028e20:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028e23:	01 d0                	add    %edx,%eax
c0028e25:	8a 00                	mov    (%eax),%al
c0028e27:	84 c0                	test   %al,%al
c0028e29:	75 cf                	jne    c0028dfa <strspn+0xf>
c0028e2b:	eb 01                	jmp    c0028e2e <strspn+0x43>
      break;
c0028e2d:	90                   	nop
  return length;
c0028e2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028e31:	c9                   	leave  
c0028e32:	c3                   	ret    

c0028e33 <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c0028e33:	55                   	push   %ebp
c0028e34:	89 e5                	mov    %esp,%ebp
c0028e36:	83 ec 18             	sub    $0x18,%esp
  size_t haystack_len = strlen (haystack);
c0028e39:	83 ec 0c             	sub    $0xc,%esp
c0028e3c:	ff 75 08             	pushl  0x8(%ebp)
c0028e3f:	e8 cc 01 00 00       	call   c0029010 <strlen>
c0028e44:	83 c4 10             	add    $0x10,%esp
c0028e47:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t needle_len = strlen (needle);
c0028e4a:	83 ec 0c             	sub    $0xc,%esp
c0028e4d:	ff 75 0c             	pushl  0xc(%ebp)
c0028e50:	e8 bb 01 00 00       	call   c0029010 <strlen>
c0028e55:	83 c4 10             	add    $0x10,%esp
c0028e58:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (haystack_len >= needle_len) 
c0028e5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028e5e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0028e61:	72 3f                	jb     c0028ea2 <strstr+0x6f>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c0028e63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028e6a:	eb 2b                	jmp    c0028e97 <strstr+0x64>
        if (!memcmp (haystack + i, needle, needle_len))
c0028e6c:	8b 55 08             	mov    0x8(%ebp),%edx
c0028e6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028e72:	01 d0                	add    %edx,%eax
c0028e74:	83 ec 04             	sub    $0x4,%esp
c0028e77:	ff 75 ec             	pushl  -0x14(%ebp)
c0028e7a:	ff 75 0c             	pushl  0xc(%ebp)
c0028e7d:	50                   	push   %eax
c0028e7e:	e8 ad fc ff ff       	call   c0028b30 <memcmp>
c0028e83:	83 c4 10             	add    $0x10,%esp
c0028e86:	85 c0                	test   %eax,%eax
c0028e88:	75 0a                	jne    c0028e94 <strstr+0x61>
          return (char *) haystack + i;
c0028e8a:	8b 55 08             	mov    0x8(%ebp),%edx
c0028e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028e90:	01 d0                	add    %edx,%eax
c0028e92:	eb 13                	jmp    c0028ea7 <strstr+0x74>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0028e94:	ff 45 f4             	incl   -0xc(%ebp)
c0028e97:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028e9a:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028e9d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028ea0:	73 ca                	jae    c0028e6c <strstr+0x39>
    }

  return NULL;
c0028ea2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028ea7:	c9                   	leave  
c0028ea8:	c3                   	ret    

c0028ea9 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0028ea9:	55                   	push   %ebp
c0028eaa:	89 e5                	mov    %esp,%ebp
c0028eac:	83 ec 18             	sub    $0x18,%esp
  char *token;
  
  ASSERT (delimiters != NULL);
c0028eaf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028eb3:	75 21                	jne    c0028ed6 <strtok_r+0x2d>
c0028eb5:	83 ec 0c             	sub    $0xc,%esp
c0028eb8:	68 6c 25 03 c0       	push   $0xc003256c
c0028ebd:	68 bd 24 03 c0       	push   $0xc00324bd
c0028ec2:	68 e4 25 03 c0       	push   $0xc00325e4
c0028ec7:	68 ef 00 00 00       	push   $0xef
c0028ecc:	68 d4 24 03 c0       	push   $0xc00324d4
c0028ed1:	e8 c7 0c 00 00       	call   c0029b9d <debug_panic>
  ASSERT (save_ptr != NULL);
c0028ed6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028eda:	75 21                	jne    c0028efd <strtok_r+0x54>
c0028edc:	83 ec 0c             	sub    $0xc,%esp
c0028edf:	68 7f 25 03 c0       	push   $0xc003257f
c0028ee4:	68 bd 24 03 c0       	push   $0xc00324bd
c0028ee9:	68 e4 25 03 c0       	push   $0xc00325e4
c0028eee:	68 f0 00 00 00       	push   $0xf0
c0028ef3:	68 d4 24 03 c0       	push   $0xc00324d4
c0028ef8:	e8 a0 0c 00 00       	call   c0029b9d <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0028efd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028f01:	75 08                	jne    c0028f0b <strtok_r+0x62>
    s = *save_ptr;
c0028f03:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f06:	8b 00                	mov    (%eax),%eax
c0028f08:	89 45 08             	mov    %eax,0x8(%ebp)
  ASSERT (s != NULL);
c0028f0b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028f0f:	75 3c                	jne    c0028f4d <strtok_r+0xa4>
c0028f11:	83 ec 0c             	sub    $0xc,%esp
c0028f14:	68 90 25 03 c0       	push   $0xc0032590
c0028f19:	68 bd 24 03 c0       	push   $0xc00324bd
c0028f1e:	68 e4 25 03 c0       	push   $0xc00325e4
c0028f23:	68 f6 00 00 00       	push   $0xf6
c0028f28:	68 d4 24 03 c0       	push   $0xc00324d4
c0028f2d:	e8 6b 0c 00 00       	call   c0029b9d <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0028f32:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f35:	8a 00                	mov    (%eax),%al
c0028f37:	84 c0                	test   %al,%al
c0028f39:	75 0f                	jne    c0028f4a <strtok_r+0xa1>
        {
          *save_ptr = s;
c0028f3b:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f3e:	8b 55 08             	mov    0x8(%ebp),%edx
c0028f41:	89 10                	mov    %edx,(%eax)
          return NULL;
c0028f43:	b8 00 00 00 00       	mov    $0x0,%eax
c0028f48:	eb 6b                	jmp    c0028fb5 <strtok_r+0x10c>
        }

      s++;
c0028f4a:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) != NULL) 
c0028f4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f50:	8a 00                	mov    (%eax),%al
c0028f52:	0f be c0             	movsbl %al,%eax
c0028f55:	83 ec 08             	sub    $0x8,%esp
c0028f58:	50                   	push   %eax
c0028f59:	ff 75 0c             	pushl  0xc(%ebp)
c0028f5c:	e8 7b fd ff ff       	call   c0028cdc <strchr>
c0028f61:	83 c4 10             	add    $0x10,%esp
c0028f64:	85 c0                	test   %eax,%eax
c0028f66:	75 ca                	jne    c0028f32 <strtok_r+0x89>
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
c0028f68:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (strchr (delimiters, *s) == NULL)
c0028f6e:	eb 03                	jmp    c0028f73 <strtok_r+0xca>
    s++;
c0028f70:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) == NULL)
c0028f73:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f76:	8a 00                	mov    (%eax),%al
c0028f78:	0f be c0             	movsbl %al,%eax
c0028f7b:	83 ec 08             	sub    $0x8,%esp
c0028f7e:	50                   	push   %eax
c0028f7f:	ff 75 0c             	pushl  0xc(%ebp)
c0028f82:	e8 55 fd ff ff       	call   c0028cdc <strchr>
c0028f87:	83 c4 10             	add    $0x10,%esp
c0028f8a:	85 c0                	test   %eax,%eax
c0028f8c:	74 e2                	je     c0028f70 <strtok_r+0xc7>
  if (*s != '\0') 
c0028f8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f91:	8a 00                	mov    (%eax),%al
c0028f93:	84 c0                	test   %al,%al
c0028f95:	74 13                	je     c0028faa <strtok_r+0x101>
    {
      *s = '\0';
c0028f97:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f9a:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0028f9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fa0:	8d 50 01             	lea    0x1(%eax),%edx
c0028fa3:	8b 45 10             	mov    0x10(%ebp),%eax
c0028fa6:	89 10                	mov    %edx,(%eax)
c0028fa8:	eb 08                	jmp    c0028fb2 <strtok_r+0x109>
    }
  else 
    *save_ptr = s;
c0028faa:	8b 45 10             	mov    0x10(%ebp),%eax
c0028fad:	8b 55 08             	mov    0x8(%ebp),%edx
c0028fb0:	89 10                	mov    %edx,(%eax)
  return token;
c0028fb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028fb5:	c9                   	leave  
c0028fb6:	c3                   	ret    

c0028fb7 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0028fb7:	55                   	push   %ebp
c0028fb8:	89 e5                	mov    %esp,%ebp
c0028fba:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028fbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fc0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028fc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028fc7:	75 35                	jne    c0028ffe <memset+0x47>
c0028fc9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028fcd:	74 2f                	je     c0028ffe <memset+0x47>
c0028fcf:	83 ec 0c             	sub    $0xc,%esp
c0028fd2:	68 a4 24 03 c0       	push   $0xc00324a4
c0028fd7:	68 bd 24 03 c0       	push   $0xc00324bd
c0028fdc:	68 f0 25 03 c0       	push   $0xc00325f0
c0028fe1:	68 1b 01 00 00       	push   $0x11b
c0028fe6:	68 d4 24 03 c0       	push   $0xc00324d4
c0028feb:	e8 ad 0b 00 00       	call   c0029b9d <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c0028ff0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ff3:	8d 50 01             	lea    0x1(%eax),%edx
c0028ff6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028ff9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0028ffc:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c0028ffe:	8b 45 10             	mov    0x10(%ebp),%eax
c0029001:	8d 50 ff             	lea    -0x1(%eax),%edx
c0029004:	89 55 10             	mov    %edx,0x10(%ebp)
c0029007:	85 c0                	test   %eax,%eax
c0029009:	75 e5                	jne    c0028ff0 <memset+0x39>

  return dst_;
c002900b:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002900e:	c9                   	leave  
c002900f:	c3                   	ret    

c0029010 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0029010:	55                   	push   %ebp
c0029011:	89 e5                	mov    %esp,%ebp
c0029013:	83 ec 18             	sub    $0x18,%esp
  const char *p;

  ASSERT (string != NULL);
c0029016:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002901a:	75 21                	jne    c002903d <strlen+0x2d>
c002901c:	83 ec 0c             	sub    $0xc,%esp
c002901f:	68 5d 25 03 c0       	push   $0xc003255d
c0029024:	68 bd 24 03 c0       	push   $0xc00324bd
c0029029:	68 f8 25 03 c0       	push   $0xc00325f8
c002902e:	68 29 01 00 00       	push   $0x129
c0029033:	68 d4 24 03 c0       	push   $0xc00324d4
c0029038:	e8 60 0b 00 00       	call   c0029b9d <debug_panic>

  for (p = string; *p != '\0'; p++)
c002903d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029040:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029043:	eb 03                	jmp    c0029048 <strlen+0x38>
c0029045:	ff 45 f4             	incl   -0xc(%ebp)
c0029048:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002904b:	8a 00                	mov    (%eax),%al
c002904d:	84 c0                	test   %al,%al
c002904f:	75 f4                	jne    c0029045 <strlen+0x35>
    continue;
  return p - string;
c0029051:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029054:	8b 45 08             	mov    0x8(%ebp),%eax
c0029057:	29 c2                	sub    %eax,%edx
c0029059:	89 d0                	mov    %edx,%eax
}
c002905b:	c9                   	leave  
c002905c:	c3                   	ret    

c002905d <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c002905d:	55                   	push   %ebp
c002905e:	89 e5                	mov    %esp,%ebp
c0029060:	83 ec 10             	sub    $0x10,%esp
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0029063:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002906a:	eb 03                	jmp    c002906f <strnlen+0x12>
c002906c:	ff 45 fc             	incl   -0x4(%ebp)
c002906f:	8b 55 08             	mov    0x8(%ebp),%edx
c0029072:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029075:	01 d0                	add    %edx,%eax
c0029077:	8a 00                	mov    (%eax),%al
c0029079:	84 c0                	test   %al,%al
c002907b:	74 08                	je     c0029085 <strnlen+0x28>
c002907d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029080:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029083:	72 e7                	jb     c002906c <strnlen+0xf>
    continue;
  return length;
c0029085:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0029088:	c9                   	leave  
c0029089:	c3                   	ret    

c002908a <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c002908a:	55                   	push   %ebp
c002908b:	89 e5                	mov    %esp,%ebp
c002908d:	83 ec 18             	sub    $0x18,%esp
  size_t src_len;

  ASSERT (dst != NULL);
c0029090:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029094:	75 21                	jne    c00290b7 <strlcpy+0x2d>
c0029096:	83 ec 0c             	sub    $0xc,%esp
c0029099:	68 9a 25 03 c0       	push   $0xc003259a
c002909e:	68 bd 24 03 c0       	push   $0xc00324bd
c00290a3:	68 00 26 03 c0       	push   $0xc0032600
c00290a8:	68 4a 01 00 00       	push   $0x14a
c00290ad:	68 d4 24 03 c0       	push   $0xc00324d4
c00290b2:	e8 e6 0a 00 00       	call   c0029b9d <debug_panic>
  ASSERT (src != NULL);
c00290b7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00290bb:	75 21                	jne    c00290de <strlcpy+0x54>
c00290bd:	83 ec 0c             	sub    $0xc,%esp
c00290c0:	68 a6 25 03 c0       	push   $0xc00325a6
c00290c5:	68 bd 24 03 c0       	push   $0xc00324bd
c00290ca:	68 00 26 03 c0       	push   $0xc0032600
c00290cf:	68 4b 01 00 00       	push   $0x14b
c00290d4:	68 d4 24 03 c0       	push   $0xc00324d4
c00290d9:	e8 bf 0a 00 00       	call   c0029b9d <debug_panic>

  src_len = strlen (src);
c00290de:	83 ec 0c             	sub    $0xc,%esp
c00290e1:	ff 75 0c             	pushl  0xc(%ebp)
c00290e4:	e8 27 ff ff ff       	call   c0029010 <strlen>
c00290e9:	83 c4 10             	add    $0x10,%esp
c00290ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (size > 0) 
c00290ef:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00290f3:	74 34                	je     c0029129 <strlcpy+0x9f>
    {
      size_t dst_len = size - 1;
c00290f5:	8b 45 10             	mov    0x10(%ebp),%eax
c00290f8:	48                   	dec    %eax
c00290f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < dst_len)
c00290fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00290ff:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029102:	73 06                	jae    c002910a <strlcpy+0x80>
        dst_len = src_len;
c0029104:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029107:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst, src, dst_len);
c002910a:	83 ec 04             	sub    $0x4,%esp
c002910d:	ff 75 f4             	pushl  -0xc(%ebp)
c0029110:	ff 75 0c             	pushl  0xc(%ebp)
c0029113:	ff 75 08             	pushl  0x8(%ebp)
c0029116:	e8 c2 f8 ff ff       	call   c00289dd <memcpy>
c002911b:	83 c4 10             	add    $0x10,%esp
      dst[dst_len] = '\0';
c002911e:	8b 55 08             	mov    0x8(%ebp),%edx
c0029121:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029124:	01 d0                	add    %edx,%eax
c0029126:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len;
c0029129:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002912c:	c9                   	leave  
c002912d:	c3                   	ret    

c002912e <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c002912e:	55                   	push   %ebp
c002912f:	89 e5                	mov    %esp,%ebp
c0029131:	83 ec 18             	sub    $0x18,%esp
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0029134:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029138:	75 21                	jne    c002915b <strlcat+0x2d>
c002913a:	83 ec 0c             	sub    $0xc,%esp
c002913d:	68 9a 25 03 c0       	push   $0xc003259a
c0029142:	68 bd 24 03 c0       	push   $0xc00324bd
c0029147:	68 08 26 03 c0       	push   $0xc0032608
c002914c:	68 68 01 00 00       	push   $0x168
c0029151:	68 d4 24 03 c0       	push   $0xc00324d4
c0029156:	e8 42 0a 00 00       	call   c0029b9d <debug_panic>
  ASSERT (src != NULL);
c002915b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002915f:	75 21                	jne    c0029182 <strlcat+0x54>
c0029161:	83 ec 0c             	sub    $0xc,%esp
c0029164:	68 a6 25 03 c0       	push   $0xc00325a6
c0029169:	68 bd 24 03 c0       	push   $0xc00324bd
c002916e:	68 08 26 03 c0       	push   $0xc0032608
c0029173:	68 69 01 00 00       	push   $0x169
c0029178:	68 d4 24 03 c0       	push   $0xc00324d4
c002917d:	e8 1b 0a 00 00       	call   c0029b9d <debug_panic>

  src_len = strlen (src);
c0029182:	83 ec 0c             	sub    $0xc,%esp
c0029185:	ff 75 0c             	pushl  0xc(%ebp)
c0029188:	e8 83 fe ff ff       	call   c0029010 <strlen>
c002918d:	83 c4 10             	add    $0x10,%esp
c0029190:	89 45 f0             	mov    %eax,-0x10(%ebp)
  dst_len = strlen (dst);
c0029193:	83 ec 0c             	sub    $0xc,%esp
c0029196:	ff 75 08             	pushl  0x8(%ebp)
c0029199:	e8 72 fe ff ff       	call   c0029010 <strlen>
c002919e:	83 c4 10             	add    $0x10,%esp
c00291a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size > 0 && dst_len < size) 
c00291a4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00291a8:	74 4a                	je     c00291f4 <strlcat+0xc6>
c00291aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00291ad:	3b 45 10             	cmp    0x10(%ebp),%eax
c00291b0:	73 42                	jae    c00291f4 <strlcat+0xc6>
    {
      size_t copy_cnt = size - dst_len - 1;
c00291b2:	8b 45 10             	mov    0x10(%ebp),%eax
c00291b5:	2b 45 ec             	sub    -0x14(%ebp),%eax
c00291b8:	48                   	dec    %eax
c00291b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < copy_cnt)
c00291bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00291bf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00291c2:	73 06                	jae    c00291ca <strlcat+0x9c>
        copy_cnt = src_len;
c00291c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00291c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst + dst_len, src, copy_cnt);
c00291ca:	8b 55 08             	mov    0x8(%ebp),%edx
c00291cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00291d0:	01 d0                	add    %edx,%eax
c00291d2:	83 ec 04             	sub    $0x4,%esp
c00291d5:	ff 75 f4             	pushl  -0xc(%ebp)
c00291d8:	ff 75 0c             	pushl  0xc(%ebp)
c00291db:	50                   	push   %eax
c00291dc:	e8 fc f7 ff ff       	call   c00289dd <memcpy>
c00291e1:	83 c4 10             	add    $0x10,%esp
      dst[dst_len + copy_cnt] = '\0';
c00291e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00291e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00291ea:	01 c2                	add    %eax,%edx
c00291ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00291ef:	01 d0                	add    %edx,%eax
c00291f1:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len + dst_len;
c00291f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00291f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00291fa:	01 d0                	add    %edx,%eax
}
c00291fc:	c9                   	leave  
c00291fd:	c3                   	ret    

c00291fe <divl>:
   yield a 32-bit quotient.  Returns the quotient.
   Traps with a divide error (#DE) if the quotient does not fit
   in 32 bits. */
static inline uint32_t
divl (uint64_t n, uint32_t d)
{
c00291fe:	55                   	push   %ebp
c00291ff:	89 e5                	mov    %esp,%ebp
c0029201:	83 ec 18             	sub    $0x18,%esp
c0029204:	8b 45 08             	mov    0x8(%ebp),%eax
c0029207:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002920a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002920d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t n1 = n >> 32;
c0029210:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029213:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0029216:	89 d0                	mov    %edx,%eax
c0029218:	31 d2                	xor    %edx,%edx
c002921a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  uint32_t n0 = n;
c002921d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029220:	89 45 f8             	mov    %eax,-0x8(%ebp)
  uint32_t q, r;

  asm ("divl %4"
c0029223:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0029226:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029229:	f7 75 10             	divl   0x10(%ebp)
c002922c:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002922f:	89 45 f0             	mov    %eax,-0x10(%ebp)
       : "=d" (r), "=a" (q)
       : "0" (n1), "1" (n0), "rm" (d));

  return q;
c0029232:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0029235:	c9                   	leave  
c0029236:	c3                   	ret    

c0029237 <nlz>:

/* Returns the number of leading zero bits in X,
   which must be nonzero. */
static int
nlz (uint32_t x) 
{
c0029237:	55                   	push   %ebp
c0029238:	89 e5                	mov    %esp,%ebp
c002923a:	83 ec 10             	sub    $0x10,%esp
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c002923d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (x <= 0x0000FFFF)
c0029244:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
c002924b:	77 08                	ja     c0029255 <nlz+0x1e>
    {
      n += 16;
c002924d:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
      x <<= 16; 
c0029251:	c1 65 08 10          	shll   $0x10,0x8(%ebp)
    }
  if (x <= 0x00FFFFFF)
c0029255:	81 7d 08 ff ff ff 00 	cmpl   $0xffffff,0x8(%ebp)
c002925c:	77 08                	ja     c0029266 <nlz+0x2f>
    {
      n += 8;
c002925e:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
      x <<= 8; 
c0029262:	c1 65 08 08          	shll   $0x8,0x8(%ebp)
    }
  if (x <= 0x0FFFFFFF)
c0029266:	81 7d 08 ff ff ff 0f 	cmpl   $0xfffffff,0x8(%ebp)
c002926d:	77 08                	ja     c0029277 <nlz+0x40>
    {
      n += 4;
c002926f:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
      x <<= 4;
c0029273:	c1 65 08 04          	shll   $0x4,0x8(%ebp)
    }
  if (x <= 0x3FFFFFFF)
c0029277:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
c002927e:	77 08                	ja     c0029288 <nlz+0x51>
    {
      n += 2;
c0029280:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
      x <<= 2; 
c0029284:	c1 65 08 02          	shll   $0x2,0x8(%ebp)
    }
  if (x <= 0x7FFFFFFF)
c0029288:	8b 45 08             	mov    0x8(%ebp),%eax
c002928b:	85 c0                	test   %eax,%eax
c002928d:	78 03                	js     c0029292 <nlz+0x5b>
    n++;
c002928f:	ff 45 fc             	incl   -0x4(%ebp)
  return n;
c0029292:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0029295:	c9                   	leave  
c0029296:	c3                   	ret    

c0029297 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0029297:	55                   	push   %ebp
c0029298:	89 e5                	mov    %esp,%ebp
c002929a:	57                   	push   %edi
c002929b:	56                   	push   %esi
c002929c:	53                   	push   %ebx
c002929d:	83 ec 44             	sub    $0x44,%esp
c00292a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00292a3:	89 45 b8             	mov    %eax,-0x48(%ebp)
c00292a6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00292a9:	89 45 bc             	mov    %eax,-0x44(%ebp)
c00292ac:	8b 45 10             	mov    0x10(%ebp),%eax
c00292af:	89 45 b0             	mov    %eax,-0x50(%ebp)
c00292b2:	8b 45 14             	mov    0x14(%ebp),%eax
c00292b5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if ((d >> 32) == 0) 
c00292b8:	8b 45 b0             	mov    -0x50(%ebp),%eax
c00292bb:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c00292be:	89 d0                	mov    %edx,%eax
c00292c0:	31 d2                	xor    %edx,%edx
c00292c2:	89 c7                	mov    %eax,%edi
c00292c4:	83 f7 00             	xor    $0x0,%edi
c00292c7:	89 f9                	mov    %edi,%ecx
c00292c9:	89 d0                	mov    %edx,%eax
c00292cb:	80 f4 00             	xor    $0x0,%ah
c00292ce:	89 c3                	mov    %eax,%ebx
c00292d0:	89 d8                	mov    %ebx,%eax
c00292d2:	09 c8                	or     %ecx,%eax
c00292d4:	85 c0                	test   %eax,%eax
c00292d6:	0f 85 a3 00 00 00    	jne    c002937f <udiv64+0xe8>
             <=> [(bd - 1)/d] < b
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
c00292dc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c00292e3:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      uint32_t n1 = n >> 32;
c00292ea:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00292ed:	8b 55 bc             	mov    -0x44(%ebp),%edx
c00292f0:	89 d0                	mov    %edx,%eax
c00292f2:	31 d2                	xor    %edx,%edx
c00292f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      uint32_t n0 = n; 
c00292f7:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00292fa:	89 45 e0             	mov    %eax,-0x20(%ebp)
      uint32_t d0 = d;
c00292fd:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0029300:	89 45 dc             	mov    %eax,-0x24(%ebp)

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0029303:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0029306:	ba 00 00 00 00       	mov    $0x0,%edx
c002930b:	f7 75 dc             	divl   -0x24(%ebp)
c002930e:	89 d0                	mov    %edx,%eax
c0029310:	ba 00 00 00 00       	mov    $0x0,%edx
c0029315:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0029318:	89 cb                	mov    %ecx,%ebx
c002931a:	0f af da             	imul   %edx,%ebx
c002931d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0029320:	0f af c8             	imul   %eax,%ecx
c0029323:	01 d9                	add    %ebx,%ecx
c0029325:	f7 65 e8             	mull   -0x18(%ebp)
c0029328:	01 d1                	add    %edx,%ecx
c002932a:	89 ca                	mov    %ecx,%edx
c002932c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002932f:	bb 00 00 00 00       	mov    $0x0,%ebx
c0029334:	01 c8                	add    %ecx,%eax
c0029336:	11 da                	adc    %ebx,%edx
c0029338:	83 ec 04             	sub    $0x4,%esp
c002933b:	ff 75 dc             	pushl  -0x24(%ebp)
c002933e:	52                   	push   %edx
c002933f:	50                   	push   %eax
c0029340:	e8 b9 fe ff ff       	call   c00291fe <divl>
c0029345:	83 c4 10             	add    $0x10,%esp
c0029348:	89 c1                	mov    %eax,%ecx
c002934a:	bb 00 00 00 00       	mov    $0x0,%ebx
c002934f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0029352:	ba 00 00 00 00       	mov    $0x0,%edx
c0029357:	f7 75 dc             	divl   -0x24(%ebp)
c002935a:	ba 00 00 00 00       	mov    $0x0,%edx
c002935f:	8b 75 e8             	mov    -0x18(%ebp),%esi
c0029362:	89 f7                	mov    %esi,%edi
c0029364:	0f af fa             	imul   %edx,%edi
c0029367:	8b 75 ec             	mov    -0x14(%ebp),%esi
c002936a:	0f af f0             	imul   %eax,%esi
c002936d:	01 fe                	add    %edi,%esi
c002936f:	f7 65 e8             	mull   -0x18(%ebp)
c0029372:	01 d6                	add    %edx,%esi
c0029374:	89 f2                	mov    %esi,%edx
c0029376:	01 c8                	add    %ecx,%eax
c0029378:	11 da                	adc    %ebx,%edx
c002937a:	e9 e7 00 00 00       	jmp    c0029466 <udiv64+0x1cf>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c002937f:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0029382:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0029385:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0029388:	77 19                	ja     c00293a3 <udiv64+0x10c>
c002938a:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c002938d:	72 05                	jb     c0029394 <udiv64+0xfd>
c002938f:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0029392:	73 0f                	jae    c00293a3 <udiv64+0x10c>
        return 0;
c0029394:	b8 00 00 00 00       	mov    $0x0,%eax
c0029399:	ba 00 00 00 00       	mov    $0x0,%edx
c002939e:	e9 c3 00 00 00       	jmp    c0029466 <udiv64+0x1cf>
      else 
        {
          uint32_t d1 = d >> 32;
c00293a3:	8b 45 b0             	mov    -0x50(%ebp),%eax
c00293a6:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c00293a9:	89 d0                	mov    %edx,%eax
c00293ab:	31 d2                	xor    %edx,%edx
c00293ad:	89 45 d8             	mov    %eax,-0x28(%ebp)
          int s = nlz (d1);
c00293b0:	83 ec 04             	sub    $0x4,%esp
c00293b3:	ff 75 d8             	pushl  -0x28(%ebp)
c00293b6:	e8 7c fe ff ff       	call   c0029237 <nlz>
c00293bb:	83 c4 08             	add    $0x8,%esp
c00293be:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c00293c1:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c00293c4:	8b 45 b0             	mov    -0x50(%ebp),%eax
c00293c7:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c00293ca:	0f a5 c2             	shld   %cl,%eax,%edx
c00293cd:	d3 e0                	shl    %cl,%eax
c00293cf:	f6 c1 20             	test   $0x20,%cl
c00293d2:	74 04                	je     c00293d8 <udiv64+0x141>
c00293d4:	89 c2                	mov    %eax,%edx
c00293d6:	31 c0                	xor    %eax,%eax
c00293d8:	89 d0                	mov    %edx,%eax
c00293da:	31 d2                	xor    %edx,%edx
c00293dc:	89 c1                	mov    %eax,%ecx
c00293de:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00293e1:	8b 55 bc             	mov    -0x44(%ebp),%edx
c00293e4:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c00293e8:	d1 ea                	shr    %edx
c00293ea:	83 ec 04             	sub    $0x4,%esp
c00293ed:	51                   	push   %ecx
c00293ee:	52                   	push   %edx
c00293ef:	50                   	push   %eax
c00293f0:	e8 09 fe ff ff       	call   c00291fe <divl>
c00293f5:	83 c4 10             	add    $0x10,%esp
c00293f8:	89 c2                	mov    %eax,%edx
c00293fa:	b8 1f 00 00 00       	mov    $0x1f,%eax
c00293ff:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c0029402:	88 c1                	mov    %al,%cl
c0029404:	d3 ea                	shr    %cl,%edx
c0029406:	89 d0                	mov    %edx,%eax
c0029408:	89 45 c8             	mov    %eax,-0x38(%ebp)
c002940b:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0029412:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0029415:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0029418:	83 c0 ff             	add    $0xffffffff,%eax
c002941b:	83 d2 ff             	adc    $0xffffffff,%edx
c002941e:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c0029421:	89 cb                	mov    %ecx,%ebx
c0029423:	0f af da             	imul   %edx,%ebx
c0029426:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c0029429:	0f af c8             	imul   %eax,%ecx
c002942c:	01 d9                	add    %ebx,%ecx
c002942e:	f7 65 b0             	mull   -0x50(%ebp)
c0029431:	01 d1                	add    %edx,%ecx
c0029433:	89 ca                	mov    %ecx,%edx
c0029435:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0029438:	8b 5d bc             	mov    -0x44(%ebp),%ebx
c002943b:	29 c1                	sub    %eax,%ecx
c002943d:	19 d3                	sbb    %edx,%ebx
c002943f:	89 c8                	mov    %ecx,%eax
c0029441:	89 da                	mov    %ebx,%edx
c0029443:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0029446:	77 18                	ja     c0029460 <udiv64+0x1c9>
c0029448:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c002944b:	72 05                	jb     c0029452 <udiv64+0x1bb>
c002944d:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0029450:	73 0e                	jae    c0029460 <udiv64+0x1c9>
c0029452:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0029455:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0029458:	83 c0 ff             	add    $0xffffffff,%eax
c002945b:	83 d2 ff             	adc    $0xffffffff,%edx
c002945e:	eb 06                	jmp    c0029466 <udiv64+0x1cf>
c0029460:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0029463:	8b 55 cc             	mov    -0x34(%ebp),%edx
        }
    }
}
c0029466:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0029469:	5b                   	pop    %ebx
c002946a:	5e                   	pop    %esi
c002946b:	5f                   	pop    %edi
c002946c:	5d                   	pop    %ebp
c002946d:	c3                   	ret    

c002946e <umod64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
c002946e:	55                   	push   %ebp
c002946f:	89 e5                	mov    %esp,%ebp
c0029471:	53                   	push   %ebx
c0029472:	83 ec 14             	sub    $0x14,%esp
c0029475:	8b 45 08             	mov    0x8(%ebp),%eax
c0029478:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002947b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002947e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029481:	8b 45 10             	mov    0x10(%ebp),%eax
c0029484:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0029487:	8b 45 14             	mov    0x14(%ebp),%eax
c002948a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * udiv64 (n, d);
c002948d:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0029490:	ff 75 ec             	pushl  -0x14(%ebp)
c0029493:	ff 75 e8             	pushl  -0x18(%ebp)
c0029496:	ff 75 f4             	pushl  -0xc(%ebp)
c0029499:	ff 75 f0             	pushl  -0x10(%ebp)
c002949c:	e8 f6 fd ff ff       	call   c0029297 <udiv64>
c00294a1:	83 c4 10             	add    $0x10,%esp
c00294a4:	89 c2                	mov    %eax,%edx
c00294a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00294a9:	0f af c2             	imul   %edx,%eax
c00294ac:	29 c3                	sub    %eax,%ebx
c00294ae:	89 d8                	mov    %ebx,%eax
}
c00294b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00294b3:	c9                   	leave  
c00294b4:	c3                   	ret    

c00294b5 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c00294b5:	55                   	push   %ebp
c00294b6:	89 e5                	mov    %esp,%ebp
c00294b8:	83 ec 30             	sub    $0x30,%esp
c00294bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00294be:	89 45 d8             	mov    %eax,-0x28(%ebp)
c00294c1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
c00294c7:	8b 45 10             	mov    0x10(%ebp),%eax
c00294ca:	89 45 d0             	mov    %eax,-0x30(%ebp)
c00294cd:	8b 45 14             	mov    0x14(%ebp),%eax
c00294d0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c00294d3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00294d7:	79 0f                	jns    c00294e8 <sdiv64+0x33>
c00294d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00294dc:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00294df:	f7 d8                	neg    %eax
c00294e1:	83 d2 00             	adc    $0x0,%edx
c00294e4:	f7 da                	neg    %edx
c00294e6:	eb 06                	jmp    c00294ee <sdiv64+0x39>
c00294e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00294eb:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00294ee:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00294f1:	89 55 fc             	mov    %edx,-0x4(%ebp)
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c00294f4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c00294f8:	79 0f                	jns    c0029509 <sdiv64+0x54>
c00294fa:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00294fd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0029500:	f7 d8                	neg    %eax
c0029502:	83 d2 00             	adc    $0x0,%edx
c0029505:	f7 da                	neg    %edx
c0029507:	eb 06                	jmp    c002950f <sdiv64+0x5a>
c0029509:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002950c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002950f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029512:	89 55 f4             	mov    %edx,-0xc(%ebp)
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0029515:	ff 75 f4             	pushl  -0xc(%ebp)
c0029518:	ff 75 f0             	pushl  -0x10(%ebp)
c002951b:	ff 75 fc             	pushl  -0x4(%ebp)
c002951e:	ff 75 f8             	pushl  -0x8(%ebp)
c0029521:	e8 71 fd ff ff       	call   c0029297 <udiv64>
c0029526:	83 c4 10             	add    $0x10,%esp
c0029529:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002952c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c002952f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0029532:	f7 d0                	not    %eax
c0029534:	c1 e8 1f             	shr    $0x1f,%eax
c0029537:	88 c2                	mov    %al,%dl
c0029539:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002953c:	c1 e8 1f             	shr    $0x1f,%eax
c002953f:	31 d0                	xor    %edx,%eax
c0029541:	84 c0                	test   %al,%al
c0029543:	74 08                	je     c002954d <sdiv64+0x98>
c0029545:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029548:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002954b:	eb 0d                	jmp    c002955a <sdiv64+0xa5>
c002954d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029550:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0029553:	f7 d8                	neg    %eax
c0029555:	83 d2 00             	adc    $0x0,%edx
c0029558:	f7 da                	neg    %edx
}
c002955a:	c9                   	leave  
c002955b:	c3                   	ret    

c002955c <smod64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
c002955c:	55                   	push   %ebp
c002955d:	89 e5                	mov    %esp,%ebp
c002955f:	53                   	push   %ebx
c0029560:	83 ec 14             	sub    $0x14,%esp
c0029563:	8b 45 08             	mov    0x8(%ebp),%eax
c0029566:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029569:	8b 45 0c             	mov    0xc(%ebp),%eax
c002956c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002956f:	8b 45 10             	mov    0x10(%ebp),%eax
c0029572:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0029575:	8b 45 14             	mov    0x14(%ebp),%eax
c0029578:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * sdiv64 (n, d);
c002957b:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c002957e:	ff 75 ec             	pushl  -0x14(%ebp)
c0029581:	ff 75 e8             	pushl  -0x18(%ebp)
c0029584:	ff 75 f4             	pushl  -0xc(%ebp)
c0029587:	ff 75 f0             	pushl  -0x10(%ebp)
c002958a:	e8 26 ff ff ff       	call   c00294b5 <sdiv64>
c002958f:	83 c4 10             	add    $0x10,%esp
c0029592:	89 c2                	mov    %eax,%edx
c0029594:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029597:	0f af c2             	imul   %edx,%eax
c002959a:	29 c3                	sub    %eax,%ebx
c002959c:	89 d8                	mov    %ebx,%eax
}
c002959e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00295a1:	c9                   	leave  
c00295a2:	c3                   	ret    

c00295a3 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c00295a3:	55                   	push   %ebp
c00295a4:	89 e5                	mov    %esp,%ebp
c00295a6:	83 ec 10             	sub    $0x10,%esp
c00295a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00295ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00295af:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00295b5:	8b 45 10             	mov    0x10(%ebp),%eax
c00295b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00295bb:	8b 45 14             	mov    0x14(%ebp),%eax
c00295be:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return sdiv64 (n, d);
c00295c1:	ff 75 f4             	pushl  -0xc(%ebp)
c00295c4:	ff 75 f0             	pushl  -0x10(%ebp)
c00295c7:	ff 75 fc             	pushl  -0x4(%ebp)
c00295ca:	ff 75 f8             	pushl  -0x8(%ebp)
c00295cd:	e8 e3 fe ff ff       	call   c00294b5 <sdiv64>
c00295d2:	83 c4 10             	add    $0x10,%esp
}
c00295d5:	c9                   	leave  
c00295d6:	c3                   	ret    

c00295d7 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c00295d7:	55                   	push   %ebp
c00295d8:	89 e5                	mov    %esp,%ebp
c00295da:	83 ec 10             	sub    $0x10,%esp
c00295dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00295e0:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00295e3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00295e9:	8b 45 10             	mov    0x10(%ebp),%eax
c00295ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00295ef:	8b 45 14             	mov    0x14(%ebp),%eax
c00295f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return smod64 (n, d);
c00295f5:	ff 75 f4             	pushl  -0xc(%ebp)
c00295f8:	ff 75 f0             	pushl  -0x10(%ebp)
c00295fb:	ff 75 fc             	pushl  -0x4(%ebp)
c00295fe:	ff 75 f8             	pushl  -0x8(%ebp)
c0029601:	e8 56 ff ff ff       	call   c002955c <smod64>
c0029606:	83 c4 10             	add    $0x10,%esp
c0029609:	99                   	cltd   
}
c002960a:	c9                   	leave  
c002960b:	c3                   	ret    

c002960c <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c002960c:	55                   	push   %ebp
c002960d:	89 e5                	mov    %esp,%ebp
c002960f:	83 ec 10             	sub    $0x10,%esp
c0029612:	8b 45 08             	mov    0x8(%ebp),%eax
c0029615:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029618:	8b 45 0c             	mov    0xc(%ebp),%eax
c002961b:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002961e:	8b 45 10             	mov    0x10(%ebp),%eax
c0029621:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029624:	8b 45 14             	mov    0x14(%ebp),%eax
c0029627:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return udiv64 (n, d);
c002962a:	ff 75 f4             	pushl  -0xc(%ebp)
c002962d:	ff 75 f0             	pushl  -0x10(%ebp)
c0029630:	ff 75 fc             	pushl  -0x4(%ebp)
c0029633:	ff 75 f8             	pushl  -0x8(%ebp)
c0029636:	e8 5c fc ff ff       	call   c0029297 <udiv64>
c002963b:	83 c4 10             	add    $0x10,%esp
}
c002963e:	c9                   	leave  
c002963f:	c3                   	ret    

c0029640 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0029640:	55                   	push   %ebp
c0029641:	89 e5                	mov    %esp,%ebp
c0029643:	83 ec 10             	sub    $0x10,%esp
c0029646:	8b 45 08             	mov    0x8(%ebp),%eax
c0029649:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002964c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002964f:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029652:	8b 45 10             	mov    0x10(%ebp),%eax
c0029655:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029658:	8b 45 14             	mov    0x14(%ebp),%eax
c002965b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return umod64 (n, d);
c002965e:	ff 75 f4             	pushl  -0xc(%ebp)
c0029661:	ff 75 f0             	pushl  -0x10(%ebp)
c0029664:	ff 75 fc             	pushl  -0x4(%ebp)
c0029667:	ff 75 f8             	pushl  -0x8(%ebp)
c002966a:	e8 ff fd ff ff       	call   c002946e <umod64>
c002966f:	83 c4 10             	add    $0x10,%esp
c0029672:	ba 00 00 00 00       	mov    $0x0,%edx
}
c0029677:	c9                   	leave  
c0029678:	c3                   	ret    

c0029679 <calculate_chksum>:
PACKED;

/* Returns the checksum for the given ustar format HEADER. */
static unsigned int
calculate_chksum (const struct ustar_header *h)
{
c0029679:	55                   	push   %ebp
c002967a:	89 e5                	mov    %esp,%ebp
c002967c:	83 ec 20             	sub    $0x20,%esp
  const uint8_t *header = (const uint8_t *) h;
c002967f:	8b 45 08             	mov    0x8(%ebp),%eax
c0029682:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int chksum;
  size_t i;

  chksum = 0;
c0029685:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c002968c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0029693:	eb 57                	jmp    c00296ec <calculate_chksum+0x73>
    {
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
c0029695:	c7 45 f0 94 00 00 00 	movl   $0x94,-0x10(%ebp)
      const size_t chksum_end = chksum_start + sizeof h->chksum;
c002969c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002969f:	83 c0 08             	add    $0x8,%eax
c00296a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
c00296a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00296a8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00296ab:	72 0f                	jb     c00296bc <calculate_chksum+0x43>
c00296ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00296b0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00296b3:	73 07                	jae    c00296bc <calculate_chksum+0x43>
c00296b5:	b8 01 00 00 00       	mov    $0x1,%eax
c00296ba:	eb 05                	jmp    c00296c1 <calculate_chksum+0x48>
c00296bc:	b8 00 00 00 00       	mov    $0x0,%eax
c00296c1:	88 45 eb             	mov    %al,-0x15(%ebp)
c00296c4:	80 65 eb 01          	andb   $0x1,-0x15(%ebp)
      chksum += in_chksum_field ? ' ' : header[i];
c00296c8:	8a 45 eb             	mov    -0x15(%ebp),%al
c00296cb:	83 f0 01             	xor    $0x1,%eax
c00296ce:	84 c0                	test   %al,%al
c00296d0:	74 0f                	je     c00296e1 <calculate_chksum+0x68>
c00296d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00296d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00296d8:	01 d0                	add    %edx,%eax
c00296da:	8a 00                	mov    (%eax),%al
c00296dc:	0f b6 c0             	movzbl %al,%eax
c00296df:	eb 05                	jmp    c00296e6 <calculate_chksum+0x6d>
c00296e1:	b8 20 00 00 00       	mov    $0x20,%eax
c00296e6:	01 45 fc             	add    %eax,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c00296e9:	ff 45 f8             	incl   -0x8(%ebp)
c00296ec:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
c00296f3:	76 a0                	jbe    c0029695 <calculate_chksum+0x1c>
    }
  return chksum;
c00296f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00296f8:	c9                   	leave  
c00296f9:	c3                   	ret    

c00296fa <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c00296fa:	55                   	push   %ebp
c00296fb:	89 e5                	mov    %esp,%ebp
c00296fd:	83 ec 08             	sub    $0x8,%esp
  while (*file_name == '/'
c0029700:	eb 14                	jmp    c0029716 <strip_antisocial_prefixes+0x1c>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c0029702:	83 ec 08             	sub    $0x8,%esp
c0029705:	6a 2f                	push   $0x2f
c0029707:	ff 75 08             	pushl  0x8(%ebp)
c002970a:	e8 cd f5 ff ff       	call   c0028cdc <strchr>
c002970f:	83 c4 10             	add    $0x10,%esp
c0029712:	40                   	inc    %eax
c0029713:	89 45 08             	mov    %eax,0x8(%ebp)
  while (*file_name == '/'
c0029716:	8b 45 08             	mov    0x8(%ebp),%eax
c0029719:	8a 00                	mov    (%eax),%al
c002971b:	3c 2f                	cmp    $0x2f,%al
c002971d:	74 e3                	je     c0029702 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "./", 2)
c002971f:	83 ec 04             	sub    $0x4,%esp
c0029722:	6a 02                	push   $0x2
c0029724:	68 10 26 03 c0       	push   $0xc0032610
c0029729:	ff 75 08             	pushl  0x8(%ebp)
c002972c:	e8 ff f3 ff ff       	call   c0028b30 <memcmp>
c0029731:	83 c4 10             	add    $0x10,%esp
c0029734:	85 c0                	test   %eax,%eax
c0029736:	74 ca                	je     c0029702 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "../", 3))
c0029738:	83 ec 04             	sub    $0x4,%esp
c002973b:	6a 03                	push   $0x3
c002973d:	68 13 26 03 c0       	push   $0xc0032613
c0029742:	ff 75 08             	pushl  0x8(%ebp)
c0029745:	e8 e6 f3 ff ff       	call   c0028b30 <memcmp>
c002974a:	83 c4 10             	add    $0x10,%esp
c002974d:	85 c0                	test   %eax,%eax
c002974f:	74 b1                	je     c0029702 <strip_antisocial_prefixes+0x8>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0029751:	8b 45 08             	mov    0x8(%ebp),%eax
c0029754:	8a 00                	mov    (%eax),%al
c0029756:	84 c0                	test   %al,%al
c0029758:	74 1c                	je     c0029776 <strip_antisocial_prefixes+0x7c>
c002975a:	83 ec 08             	sub    $0x8,%esp
c002975d:	68 17 26 03 c0       	push   $0xc0032617
c0029762:	ff 75 08             	pushl  0x8(%ebp)
c0029765:	e8 70 f4 ff ff       	call   c0028bda <strcmp>
c002976a:	83 c4 10             	add    $0x10,%esp
c002976d:	85 c0                	test   %eax,%eax
c002976f:	74 05                	je     c0029776 <strip_antisocial_prefixes+0x7c>
c0029771:	8b 45 08             	mov    0x8(%ebp),%eax
c0029774:	eb 05                	jmp    c002977b <strip_antisocial_prefixes+0x81>
c0029776:	b8 1a 26 03 c0       	mov    $0xc003261a,%eax
}
c002977b:	c9                   	leave  
c002977c:	c3                   	ret    

c002977d <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c002977d:	55                   	push   %ebp
c002977e:	89 e5                	mov    %esp,%ebp
c0029780:	83 ec 18             	sub    $0x18,%esp
  struct ustar_header *h = (struct ustar_header *) header;
c0029783:	8b 45 14             	mov    0x14(%ebp),%eax
c0029786:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0029789:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c002978d:	74 24                	je     c00297b3 <ustar_make_header+0x36>
c002978f:	83 7d 0c 35          	cmpl   $0x35,0xc(%ebp)
c0029793:	74 1e                	je     c00297b3 <ustar_make_header+0x36>
c0029795:	83 ec 0c             	sub    $0xc,%esp
c0029798:	68 1c 26 03 c0       	push   $0xc003261c
c002979d:	68 4d 26 03 c0       	push   $0xc003264d
c00297a2:	68 50 27 03 c0       	push   $0xc0032750
c00297a7:	6a 59                	push   $0x59
c00297a9:	68 64 26 03 c0       	push   $0xc0032664
c00297ae:	e8 ea 03 00 00       	call   c0029b9d <debug_panic>

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c00297b3:	83 ec 0c             	sub    $0xc,%esp
c00297b6:	ff 75 08             	pushl  0x8(%ebp)
c00297b9:	e8 3c ff ff ff       	call   c00296fa <strip_antisocial_prefixes>
c00297be:	83 c4 10             	add    $0x10,%esp
c00297c1:	89 45 08             	mov    %eax,0x8(%ebp)
  if (strlen (file_name) > 99)
c00297c4:	83 ec 0c             	sub    $0xc,%esp
c00297c7:	ff 75 08             	pushl  0x8(%ebp)
c00297ca:	e8 41 f8 ff ff       	call   c0029010 <strlen>
c00297cf:	83 c4 10             	add    $0x10,%esp
c00297d2:	83 f8 63             	cmp    $0x63,%eax
c00297d5:	76 1a                	jbe    c00297f1 <ustar_make_header+0x74>
    {
      printf ("%s: file name too long\n", file_name);
c00297d7:	83 ec 08             	sub    $0x8,%esp
c00297da:	ff 75 08             	pushl  0x8(%ebp)
c00297dd:	68 76 26 03 c0       	push   $0xc0032676
c00297e2:	e8 f7 df ff ff       	call   c00277de <printf>
c00297e7:	83 c4 10             	add    $0x10,%esp
      return false;
c00297ea:	b0 00                	mov    $0x0,%al
c00297ec:	e9 5f 01 00 00       	jmp    c0029950 <ustar_make_header+0x1d3>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c00297f1:	83 ec 04             	sub    $0x4,%esp
c00297f4:	68 00 02 00 00       	push   $0x200
c00297f9:	6a 00                	push   $0x0
c00297fb:	ff 75 f4             	pushl  -0xc(%ebp)
c00297fe:	e8 b4 f7 ff ff       	call   c0028fb7 <memset>
c0029803:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->name, file_name, sizeof h->name);
c0029806:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029809:	83 ec 04             	sub    $0x4,%esp
c002980c:	6a 64                	push   $0x64
c002980e:	ff 75 08             	pushl  0x8(%ebp)
c0029811:	50                   	push   %eax
c0029812:	e8 73 f8 ff ff       	call   c002908a <strlcpy>
c0029817:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c002981a:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c002981e:	75 07                	jne    c0029827 <ustar_make_header+0xaa>
c0029820:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c0029825:	eb 05                	jmp    c002982c <ustar_make_header+0xaf>
c0029827:	b8 ed 01 00 00       	mov    $0x1ed,%eax
c002982c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002982f:	83 c2 64             	add    $0x64,%edx
c0029832:	50                   	push   %eax
c0029833:	68 8e 26 03 c0       	push   $0xc003268e
c0029838:	6a 08                	push   $0x8
c002983a:	52                   	push   %edx
c002983b:	e8 75 df ff ff       	call   c00277b5 <snprintf>
c0029840:	83 c4 10             	add    $0x10,%esp
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0029843:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029846:	83 c0 6c             	add    $0x6c,%eax
c0029849:	83 ec 04             	sub    $0x4,%esp
c002984c:	6a 08                	push   $0x8
c002984e:	68 93 26 03 c0       	push   $0xc0032693
c0029853:	50                   	push   %eax
c0029854:	e8 31 f8 ff ff       	call   c002908a <strlcpy>
c0029859:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->gid, "0000000", sizeof h->gid);
c002985c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002985f:	83 c0 74             	add    $0x74,%eax
c0029862:	83 ec 04             	sub    $0x4,%esp
c0029865:	6a 08                	push   $0x8
c0029867:	68 93 26 03 c0       	push   $0xc0032693
c002986c:	50                   	push   %eax
c002986d:	e8 18 f8 ff ff       	call   c002908a <strlcpy>
c0029872:	83 c4 10             	add    $0x10,%esp
  snprintf (h->size, sizeof h->size, "%011o", size);
c0029875:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029878:	83 c0 7c             	add    $0x7c,%eax
c002987b:	ff 75 10             	pushl  0x10(%ebp)
c002987e:	68 9b 26 03 c0       	push   $0xc003269b
c0029883:	6a 0c                	push   $0xc
c0029885:	50                   	push   %eax
c0029886:	e8 2a df ff ff       	call   c00277b5 <snprintf>
c002988b:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c002988e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029891:	05 88 00 00 00       	add    $0x88,%eax
c0029896:	68 00 8c b7 43       	push   $0x43b78c00
c002989b:	68 9b 26 03 c0       	push   $0xc003269b
c00298a0:	6a 0c                	push   $0xc
c00298a2:	50                   	push   %eax
c00298a3:	e8 0d df ff ff       	call   c00277b5 <snprintf>
c00298a8:	83 c4 10             	add    $0x10,%esp
  h->typeflag = type;
c00298ab:	8b 45 0c             	mov    0xc(%ebp),%eax
c00298ae:	88 c2                	mov    %al,%dl
c00298b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298b3:	88 90 9c 00 00 00    	mov    %dl,0x9c(%eax)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c00298b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298bc:	05 01 01 00 00       	add    $0x101,%eax
c00298c1:	83 ec 04             	sub    $0x4,%esp
c00298c4:	6a 06                	push   $0x6
c00298c6:	68 a1 26 03 c0       	push   $0xc00326a1
c00298cb:	50                   	push   %eax
c00298cc:	e8 b9 f7 ff ff       	call   c002908a <strlcpy>
c00298d1:	83 c4 10             	add    $0x10,%esp
  h->version[0] = h->version[1] = '0';
c00298d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298d7:	c6 80 08 01 00 00 30 	movb   $0x30,0x108(%eax)
c00298de:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298e1:	8a 90 08 01 00 00    	mov    0x108(%eax),%dl
c00298e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298ea:	88 90 07 01 00 00    	mov    %dl,0x107(%eax)
  strlcpy (h->gname, "root", sizeof h->gname);
c00298f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298f3:	05 29 01 00 00       	add    $0x129,%eax
c00298f8:	83 ec 04             	sub    $0x4,%esp
c00298fb:	6a 20                	push   $0x20
c00298fd:	68 a7 26 03 c0       	push   $0xc00326a7
c0029902:	50                   	push   %eax
c0029903:	e8 82 f7 ff ff       	call   c002908a <strlcpy>
c0029908:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->uname, "root", sizeof h->uname);
c002990b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002990e:	05 09 01 00 00       	add    $0x109,%eax
c0029913:	83 ec 04             	sub    $0x4,%esp
c0029916:	6a 20                	push   $0x20
c0029918:	68 a7 26 03 c0       	push   $0xc00326a7
c002991d:	50                   	push   %eax
c002991e:	e8 67 f7 ff ff       	call   c002908a <strlcpy>
c0029923:	83 c4 10             	add    $0x10,%esp

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0029926:	83 ec 0c             	sub    $0xc,%esp
c0029929:	ff 75 f4             	pushl  -0xc(%ebp)
c002992c:	e8 48 fd ff ff       	call   c0029679 <calculate_chksum>
c0029931:	83 c4 10             	add    $0x10,%esp
c0029934:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029937:	81 c2 94 00 00 00    	add    $0x94,%edx
c002993d:	50                   	push   %eax
c002993e:	68 8e 26 03 c0       	push   $0xc003268e
c0029943:	6a 08                	push   $0x8
c0029945:	52                   	push   %edx
c0029946:	e8 6a de ff ff       	call   c00277b5 <snprintf>
c002994b:	83 c4 10             	add    $0x10,%esp

  return true;
c002994e:	b0 01                	mov    $0x1,%al
}
c0029950:	c9                   	leave  
c0029951:	c3                   	ret    

c0029952 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c0029952:	55                   	push   %ebp
c0029953:	89 e5                	mov    %esp,%ebp
c0029955:	83 ec 10             	sub    $0x10,%esp
  size_t ofs;

  *value = 0;
c0029958:	8b 45 10             	mov    0x10(%ebp),%eax
c002995b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c0029961:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0029968:	eb 5d                	jmp    c00299c7 <parse_octal_field+0x75>
    {
      char c = s[ofs];
c002996a:	8b 55 08             	mov    0x8(%ebp),%edx
c002996d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029970:	01 d0                	add    %edx,%eax
c0029972:	8a 00                	mov    (%eax),%al
c0029974:	88 45 fb             	mov    %al,-0x5(%ebp)
      if (c >= '0' && c <= '7')
c0029977:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
c002997b:	7e 31                	jle    c00299ae <parse_octal_field+0x5c>
c002997d:	80 7d fb 37          	cmpb   $0x37,-0x5(%ebp)
c0029981:	7f 2b                	jg     c00299ae <parse_octal_field+0x5c>
        {
          if (*value > ULONG_MAX / 8)
c0029983:	8b 45 10             	mov    0x10(%ebp),%eax
c0029986:	8b 00                	mov    (%eax),%eax
c0029988:	3d ff ff ff 1f       	cmp    $0x1fffffff,%eax
c002998d:	76 04                	jbe    c0029993 <parse_octal_field+0x41>
            {
              /* Overflow. */
              return false;
c002998f:	b0 00                	mov    $0x0,%al
c0029991:	eb 3e                	jmp    c00299d1 <parse_octal_field+0x7f>
            }
          *value = c - '0' + *value * 8;
c0029993:	0f be 55 fb          	movsbl -0x5(%ebp),%edx
c0029997:	8b 45 10             	mov    0x10(%ebp),%eax
c002999a:	8b 00                	mov    (%eax),%eax
c002999c:	c1 e0 03             	shl    $0x3,%eax
c002999f:	01 d0                	add    %edx,%eax
c00299a1:	8d 50 d0             	lea    -0x30(%eax),%edx
c00299a4:	8b 45 10             	mov    0x10(%ebp),%eax
c00299a7:	89 10                	mov    %edx,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c00299a9:	ff 45 fc             	incl   -0x4(%ebp)
c00299ac:	eb 19                	jmp    c00299c7 <parse_octal_field+0x75>
        }
      else if (c == ' ' || c == '\0')
c00299ae:	80 7d fb 20          	cmpb   $0x20,-0x5(%ebp)
c00299b2:	74 06                	je     c00299ba <parse_octal_field+0x68>
c00299b4:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c00299b8:	75 09                	jne    c00299c3 <parse_octal_field+0x71>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c00299ba:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c00299be:	0f 95 c0             	setne  %al
c00299c1:	eb 0e                	jmp    c00299d1 <parse_octal_field+0x7f>
        }
      else
        {
          /* Bad character. */
          return false;
c00299c3:	b0 00                	mov    $0x0,%al
c00299c5:	eb 0a                	jmp    c00299d1 <parse_octal_field+0x7f>
  for (ofs = 0; ofs < size; ofs++)
c00299c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00299ca:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00299cd:	72 9b                	jb     c002996a <parse_octal_field+0x18>
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c00299cf:	b0 00                	mov    $0x0,%al
}
c00299d1:	c9                   	leave  
c00299d2:	c3                   	ret    

c00299d3 <is_all_zeros>:

/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
c00299d3:	55                   	push   %ebp
c00299d4:	89 e5                	mov    %esp,%ebp
  while (cnt-- > 0)
c00299d6:	eb 13                	jmp    c00299eb <is_all_zeros+0x18>
    if (*block++ != 0)
c00299d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00299db:	8d 50 01             	lea    0x1(%eax),%edx
c00299de:	89 55 08             	mov    %edx,0x8(%ebp)
c00299e1:	8a 00                	mov    (%eax),%al
c00299e3:	84 c0                	test   %al,%al
c00299e5:	74 04                	je     c00299eb <is_all_zeros+0x18>
      return false;
c00299e7:	b0 00                	mov    $0x0,%al
c00299e9:	eb 0f                	jmp    c00299fa <is_all_zeros+0x27>
  while (cnt-- > 0)
c00299eb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00299ee:	8d 50 ff             	lea    -0x1(%eax),%edx
c00299f1:	89 55 0c             	mov    %edx,0xc(%ebp)
c00299f4:	85 c0                	test   %eax,%eax
c00299f6:	75 e0                	jne    c00299d8 <is_all_zeros+0x5>
  return true;
c00299f8:	b0 01                	mov    $0x1,%al
}
c00299fa:	5d                   	pop    %ebp
c00299fb:	c3                   	ret    

c00299fc <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c00299fc:	55                   	push   %ebp
c00299fd:	89 e5                	mov    %esp,%ebp
c00299ff:	83 ec 18             	sub    $0x18,%esp
  const struct ustar_header *h = (const struct ustar_header *) header;
c0029a02:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a05:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned long int chksum, size_ul;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
c0029a08:	68 00 02 00 00       	push   $0x200
c0029a0d:	ff 75 08             	pushl  0x8(%ebp)
c0029a10:	e8 be ff ff ff       	call   c00299d3 <is_all_zeros>
c0029a15:	83 c4 08             	add    $0x8,%esp
c0029a18:	84 c0                	test   %al,%al
c0029a1a:	74 25                	je     c0029a41 <ustar_parse_header+0x45>
    {
      *file_name = NULL;
c0029a1c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a1f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0029a25:	8b 45 10             	mov    0x10(%ebp),%eax
c0029a28:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c0029a2e:	8b 45 14             	mov    0x14(%ebp),%eax
c0029a31:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0029a37:	b8 00 00 00 00       	mov    $0x0,%eax
c0029a3c:	e9 5a 01 00 00       	jmp    c0029b9b <ustar_parse_header+0x19f>
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c0029a41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029a44:	05 01 01 00 00       	add    $0x101,%eax
c0029a49:	83 ec 04             	sub    $0x4,%esp
c0029a4c:	6a 06                	push   $0x6
c0029a4e:	68 a1 26 03 c0       	push   $0xc00326a1
c0029a53:	50                   	push   %eax
c0029a54:	e8 d7 f0 ff ff       	call   c0028b30 <memcmp>
c0029a59:	83 c4 10             	add    $0x10,%esp
c0029a5c:	85 c0                	test   %eax,%eax
c0029a5e:	74 0a                	je     c0029a6a <ustar_parse_header+0x6e>
    return "not a ustar archive";
c0029a60:	b8 ac 26 03 c0       	mov    $0xc00326ac,%eax
c0029a65:	e9 31 01 00 00       	jmp    c0029b9b <ustar_parse_header+0x19f>
  else if (h->version[0] != '0' || h->version[1] != '0')
c0029a6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029a6d:	8a 80 07 01 00 00    	mov    0x107(%eax),%al
c0029a73:	3c 30                	cmp    $0x30,%al
c0029a75:	75 0d                	jne    c0029a84 <ustar_parse_header+0x88>
c0029a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029a7a:	8a 80 08 01 00 00    	mov    0x108(%eax),%al
c0029a80:	3c 30                	cmp    $0x30,%al
c0029a82:	74 0a                	je     c0029a8e <ustar_parse_header+0x92>
    return "invalid ustar version";
c0029a84:	b8 c0 26 03 c0       	mov    $0xc00326c0,%eax
c0029a89:	e9 0d 01 00 00       	jmp    c0029b9b <ustar_parse_header+0x19f>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0029a8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029a91:	8d 90 94 00 00 00    	lea    0x94(%eax),%edx
c0029a97:	83 ec 04             	sub    $0x4,%esp
c0029a9a:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0029a9d:	50                   	push   %eax
c0029a9e:	6a 08                	push   $0x8
c0029aa0:	52                   	push   %edx
c0029aa1:	e8 ac fe ff ff       	call   c0029952 <parse_octal_field>
c0029aa6:	83 c4 10             	add    $0x10,%esp
c0029aa9:	83 f0 01             	xor    $0x1,%eax
c0029aac:	84 c0                	test   %al,%al
c0029aae:	74 0a                	je     c0029aba <ustar_parse_header+0xbe>
    return "corrupt chksum field";
c0029ab0:	b8 d6 26 03 c0       	mov    $0xc00326d6,%eax
c0029ab5:	e9 e1 00 00 00       	jmp    c0029b9b <ustar_parse_header+0x19f>
  else if (chksum != calculate_chksum (h))
c0029aba:	83 ec 0c             	sub    $0xc,%esp
c0029abd:	ff 75 f4             	pushl  -0xc(%ebp)
c0029ac0:	e8 b4 fb ff ff       	call   c0029679 <calculate_chksum>
c0029ac5:	83 c4 10             	add    $0x10,%esp
c0029ac8:	89 c2                	mov    %eax,%edx
c0029aca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029acd:	39 c2                	cmp    %eax,%edx
c0029acf:	74 0a                	je     c0029adb <ustar_parse_header+0xdf>
    return "checksum mismatch";
c0029ad1:	b8 eb 26 03 c0       	mov    $0xc00326eb,%eax
c0029ad6:	e9 c0 00 00 00       	jmp    c0029b9b <ustar_parse_header+0x19f>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0029adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ade:	8a 40 63             	mov    0x63(%eax),%al
c0029ae1:	84 c0                	test   %al,%al
c0029ae3:	75 0d                	jne    c0029af2 <ustar_parse_header+0xf6>
c0029ae5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ae8:	8a 80 59 01 00 00    	mov    0x159(%eax),%al
c0029aee:	84 c0                	test   %al,%al
c0029af0:	74 0a                	je     c0029afc <ustar_parse_header+0x100>
    return "file name too long";
c0029af2:	b8 fd 26 03 c0       	mov    $0xc00326fd,%eax
c0029af7:	e9 9f 00 00 00       	jmp    c0029b9b <ustar_parse_header+0x19f>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0029afc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029aff:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029b05:	3c 30                	cmp    $0x30,%al
c0029b07:	74 14                	je     c0029b1d <ustar_parse_header+0x121>
c0029b09:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b0c:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029b12:	3c 35                	cmp    $0x35,%al
c0029b14:	74 07                	je     c0029b1d <ustar_parse_header+0x121>
    return "unimplemented file type";
c0029b16:	b8 10 27 03 c0       	mov    $0xc0032710,%eax
c0029b1b:	eb 7e                	jmp    c0029b9b <ustar_parse_header+0x19f>
  if (h->typeflag == USTAR_REGULAR)
c0029b1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b20:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029b26:	3c 30                	cmp    $0x30,%al
c0029b28:	75 34                	jne    c0029b5e <ustar_parse_header+0x162>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0029b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b2d:	8d 50 7c             	lea    0x7c(%eax),%edx
c0029b30:	83 ec 04             	sub    $0x4,%esp
c0029b33:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0029b36:	50                   	push   %eax
c0029b37:	6a 0c                	push   $0xc
c0029b39:	52                   	push   %edx
c0029b3a:	e8 13 fe ff ff       	call   c0029952 <parse_octal_field>
c0029b3f:	83 c4 10             	add    $0x10,%esp
c0029b42:	83 f0 01             	xor    $0x1,%eax
c0029b45:	84 c0                	test   %al,%al
c0029b47:	74 07                	je     c0029b50 <ustar_parse_header+0x154>
        return "corrupt file size field";
c0029b49:	b8 28 27 03 c0       	mov    $0xc0032728,%eax
c0029b4e:	eb 4b                	jmp    c0029b9b <ustar_parse_header+0x19f>
      else if (size_ul > INT_MAX)
c0029b50:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029b53:	85 c0                	test   %eax,%eax
c0029b55:	79 0e                	jns    c0029b65 <ustar_parse_header+0x169>
        return "file too large";
c0029b57:	b8 40 27 03 c0       	mov    $0xc0032740,%eax
c0029b5c:	eb 3d                	jmp    c0029b9b <ustar_parse_header+0x19f>
    }
  else
    size_ul = 0;
c0029b5e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c0029b65:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b68:	83 ec 0c             	sub    $0xc,%esp
c0029b6b:	50                   	push   %eax
c0029b6c:	e8 89 fb ff ff       	call   c00296fa <strip_antisocial_prefixes>
c0029b71:	83 c4 10             	add    $0x10,%esp
c0029b74:	89 c2                	mov    %eax,%edx
c0029b76:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029b79:	89 10                	mov    %edx,(%eax)
  *type = h->typeflag;
c0029b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b7e:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029b84:	0f be d0             	movsbl %al,%edx
c0029b87:	8b 45 10             	mov    0x10(%ebp),%eax
c0029b8a:	89 10                	mov    %edx,(%eax)
  *size = size_ul;
c0029b8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029b8f:	89 c2                	mov    %eax,%edx
c0029b91:	8b 45 14             	mov    0x14(%ebp),%eax
c0029b94:	89 10                	mov    %edx,(%eax)
  return NULL;
c0029b96:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029b9b:	c9                   	leave  
c0029b9c:	c3                   	ret    

c0029b9d <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c0029b9d:	55                   	push   %ebp
c0029b9e:	89 e5                	mov    %esp,%ebp
c0029ba0:	83 ec 18             	sub    $0x18,%esp
  static int level;
  va_list args;

  intr_disable ();
c0029ba3:	e8 ef 7d ff ff       	call   c0021997 <intr_disable>
  console_panic ();
c0029ba8:	e8 89 21 00 00       	call   c002bd36 <console_panic>

  level++;
c0029bad:	a1 04 a6 03 c0       	mov    0xc003a604,%eax
c0029bb2:	40                   	inc    %eax
c0029bb3:	a3 04 a6 03 c0       	mov    %eax,0xc003a604
  if (level == 1) 
c0029bb8:	a1 04 a6 03 c0       	mov    0xc003a604,%eax
c0029bbd:	83 f8 01             	cmp    $0x1,%eax
c0029bc0:	75 42                	jne    c0029c04 <debug_panic+0x67>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0029bc2:	ff 75 10             	pushl  0x10(%ebp)
c0029bc5:	ff 75 0c             	pushl  0xc(%ebp)
c0029bc8:	ff 75 08             	pushl  0x8(%ebp)
c0029bcb:	68 64 27 03 c0       	push   $0xc0032764
c0029bd0:	e8 09 dc ff ff       	call   c00277de <printf>
c0029bd5:	83 c4 10             	add    $0x10,%esp

      va_start (args, message);
c0029bd8:	8d 45 18             	lea    0x18(%ebp),%eax
c0029bdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
      vprintf (message, args);
c0029bde:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029be1:	83 ec 08             	sub    $0x8,%esp
c0029be4:	50                   	push   %eax
c0029be5:	ff 75 14             	pushl  0x14(%ebp)
c0029be8:	e8 4f 22 00 00       	call   c002be3c <vprintf>
c0029bed:	83 c4 10             	add    $0x10,%esp
      printf ("\n");
c0029bf0:	83 ec 0c             	sub    $0xc,%esp
c0029bf3:	6a 0a                	push   $0xa
c0029bf5:	e8 fa 22 00 00       	call   c002bef4 <putchar>
c0029bfa:	83 c4 10             	add    $0x10,%esp
      va_end (args);

      debug_backtrace ();
c0029bfd:	e8 cf d8 ff ff       	call   c00274d1 <debug_backtrace>
c0029c02:	eb 20                	jmp    c0029c24 <debug_panic+0x87>
    }
  else if (level == 2)
c0029c04:	a1 04 a6 03 c0       	mov    0xc003a604,%eax
c0029c09:	83 f8 02             	cmp    $0x2,%eax
c0029c0c:	75 16                	jne    c0029c24 <debug_panic+0x87>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c0029c0e:	ff 75 10             	pushl  0x10(%ebp)
c0029c11:	ff 75 0c             	pushl  0xc(%ebp)
c0029c14:	ff 75 08             	pushl  0x8(%ebp)
c0029c17:	68 84 27 03 c0       	push   $0xc0032784
c0029c1c:	e8 bd db ff ff       	call   c00277de <printf>
c0029c21:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c0029c24:	e8 72 b4 ff ff       	call   c002509b <serial_flush>
  shutdown ();
c0029c29:	e8 03 d6 ff ff       	call   c0027231 <shutdown>
  for (;;);
c0029c2e:	eb fe                	jmp    c0029c2e <debug_panic+0x91>

c0029c30 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0029c30:	55                   	push   %ebp
c0029c31:	89 e5                	mov    %esp,%ebp
c0029c33:	83 ec 18             	sub    $0x18,%esp
  void *retaddr = NULL, **frame = NULL;
c0029c36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0029c3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  const char *status = "UNKNOWN";
c0029c44:	c7 45 ec ae 27 03 c0 	movl   $0xc00327ae,-0x14(%ebp)

  switch (t->status) {
c0029c4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c4e:	8b 40 04             	mov    0x4(%eax),%eax
c0029c51:	83 f8 01             	cmp    $0x1,%eax
c0029c54:	74 15                	je     c0029c6b <print_stacktrace+0x3b>
c0029c56:	83 f8 01             	cmp    $0x1,%eax
c0029c59:	72 07                	jb     c0029c62 <print_stacktrace+0x32>
c0029c5b:	83 f8 02             	cmp    $0x2,%eax
c0029c5e:	74 14                	je     c0029c74 <print_stacktrace+0x44>
    case THREAD_BLOCKED:  
      status = "BLOCKED";
      break;

    default:
      break;
c0029c60:	eb 1a                	jmp    c0029c7c <print_stacktrace+0x4c>
      status = "RUNNING";
c0029c62:	c7 45 ec b6 27 03 c0 	movl   $0xc00327b6,-0x14(%ebp)
      break;
c0029c69:	eb 11                	jmp    c0029c7c <print_stacktrace+0x4c>
      status = "READY";
c0029c6b:	c7 45 ec be 27 03 c0 	movl   $0xc00327be,-0x14(%ebp)
      break;
c0029c72:	eb 08                	jmp    c0029c7c <print_stacktrace+0x4c>
      status = "BLOCKED";
c0029c74:	c7 45 ec c4 27 03 c0 	movl   $0xc00327c4,-0x14(%ebp)
      break;
c0029c7b:	90                   	nop
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0029c7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c7f:	83 c0 08             	add    $0x8,%eax
c0029c82:	83 ec 04             	sub    $0x4,%esp
c0029c85:	ff 75 ec             	pushl  -0x14(%ebp)
c0029c88:	50                   	push   %eax
c0029c89:	68 cc 27 03 c0       	push   $0xc00327cc
c0029c8e:	e8 4b db ff ff       	call   c00277de <printf>
c0029c93:	83 c4 10             	add    $0x10,%esp

  if (t == thread_current()) 
c0029c96:	e8 1b 74 ff ff       	call   c00210b6 <thread_current>
c0029c9b:	3b 45 08             	cmp    0x8(%ebp),%eax
c0029c9e:	75 0e                	jne    c0029cae <print_stacktrace+0x7e>
    {
      frame = __builtin_frame_address (1);
c0029ca0:	8b 45 00             	mov    0x0(%ebp),%eax
c0029ca3:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = __builtin_return_address (0);
c0029ca6:	8b 45 04             	mov    0x4(%ebp),%eax
c0029ca9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029cac:	eb 4d                	jmp    c0029cfb <print_stacktrace+0xcb>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0029cae:	8b 45 08             	mov    0x8(%ebp),%eax
c0029cb1:	8b 40 18             	mov    0x18(%eax),%eax
c0029cb4:	89 45 e8             	mov    %eax,-0x18(%ebp)
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0029cb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0029cba:	8b 40 18             	mov    0x18(%eax),%eax
c0029cbd:	8b 55 08             	mov    0x8(%ebp),%edx
c0029cc0:	81 c2 00 10 00 00    	add    $0x1000,%edx
c0029cc6:	39 d0                	cmp    %edx,%eax
c0029cc8:	74 0d                	je     c0029cd7 <print_stacktrace+0xa7>
c0029cca:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029ccd:	8b 40 10             	mov    0x10(%eax),%eax
c0029cd0:	3d f8 18 02 c0       	cmp    $0xc00218f8,%eax
c0029cd5:	75 12                	jne    c0029ce9 <print_stacktrace+0xb9>
        {
          printf (" thread was never scheduled.\n");
c0029cd7:	83 ec 0c             	sub    $0xc,%esp
c0029cda:	68 f3 27 03 c0       	push   $0xc00327f3
c0029cdf:	e8 8b 21 00 00       	call   c002be6f <puts>
c0029ce4:	83 c4 10             	add    $0x10,%esp
          return;
c0029ce7:	eb 6b                	jmp    c0029d54 <print_stacktrace+0x124>
        }

      frame = (void **) saved_frame->ebp;
c0029ce9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029cec:	8b 40 08             	mov    0x8(%eax),%eax
c0029cef:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = (void *) saved_frame->eip;
c0029cf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029cf5:	8b 40 10             	mov    0x10(%eax),%eax
c0029cf8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

  printf (" %p", retaddr);
c0029cfb:	83 ec 08             	sub    $0x8,%esp
c0029cfe:	ff 75 f4             	pushl  -0xc(%ebp)
c0029d01:	68 10 28 03 c0       	push   $0xc0032810
c0029d06:	e8 d3 da ff ff       	call   c00277de <printf>
c0029d0b:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0029d0e:	eb 21                	jmp    c0029d31 <print_stacktrace+0x101>
    printf (" %p", frame[1]);
c0029d10:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029d13:	83 c0 04             	add    $0x4,%eax
c0029d16:	8b 00                	mov    (%eax),%eax
c0029d18:	83 ec 08             	sub    $0x8,%esp
c0029d1b:	50                   	push   %eax
c0029d1c:	68 10 28 03 c0       	push   $0xc0032810
c0029d21:	e8 b8 da ff ff       	call   c00277de <printf>
c0029d26:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0029d29:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029d2c:	8b 00                	mov    (%eax),%eax
c0029d2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029d31:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029d34:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c0029d39:	76 09                	jbe    c0029d44 <print_stacktrace+0x114>
c0029d3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029d3e:	8b 00                	mov    (%eax),%eax
c0029d40:	85 c0                	test   %eax,%eax
c0029d42:	75 cc                	jne    c0029d10 <print_stacktrace+0xe0>
  printf (".\n");
c0029d44:	83 ec 0c             	sub    $0xc,%esp
c0029d47:	68 14 28 03 c0       	push   $0xc0032814
c0029d4c:	e8 1e 21 00 00       	call   c002be6f <puts>
c0029d51:	83 c4 10             	add    $0x10,%esp
}
c0029d54:	c9                   	leave  
c0029d55:	c3                   	ret    

c0029d56 <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c0029d56:	55                   	push   %ebp
c0029d57:	89 e5                	mov    %esp,%ebp
c0029d59:	83 ec 18             	sub    $0x18,%esp
  enum intr_level oldlevel = intr_disable ();
c0029d5c:	e8 36 7c ff ff       	call   c0021997 <intr_disable>
c0029d61:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_foreach (print_stacktrace, 0);
c0029d64:	83 ec 08             	sub    $0x8,%esp
c0029d67:	6a 00                	push   $0x0
c0029d69:	68 30 9c 02 c0       	push   $0xc0029c30
c0029d6e:	e8 3b 75 ff ff       	call   c00212ae <thread_foreach>
c0029d73:	83 c4 10             	add    $0x10,%esp
  intr_set_level (oldlevel);
c0029d76:	83 ec 0c             	sub    $0xc,%esp
c0029d79:	ff 75 f4             	pushl  -0xc(%ebp)
c0029d7c:	e8 be 7b ff ff       	call   c002193f <intr_set_level>
c0029d81:	83 c4 10             	add    $0x10,%esp
}
c0029d84:	90                   	nop
c0029d85:	c9                   	leave  
c0029d86:	c3                   	ret    

c0029d87 <is_head>:
                       list_less_func *less, void *aux) UNUSED;

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
c0029d87:	55                   	push   %ebp
c0029d88:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029d8a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029d8e:	74 1a                	je     c0029daa <is_head+0x23>
c0029d90:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d93:	8b 00                	mov    (%eax),%eax
c0029d95:	85 c0                	test   %eax,%eax
c0029d97:	75 11                	jne    c0029daa <is_head+0x23>
c0029d99:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d9c:	8b 40 04             	mov    0x4(%eax),%eax
c0029d9f:	85 c0                	test   %eax,%eax
c0029da1:	74 07                	je     c0029daa <is_head+0x23>
c0029da3:	b8 01 00 00 00       	mov    $0x1,%eax
c0029da8:	eb 05                	jmp    c0029daf <is_head+0x28>
c0029daa:	b8 00 00 00 00       	mov    $0x0,%eax
c0029daf:	83 e0 01             	and    $0x1,%eax
}
c0029db2:	5d                   	pop    %ebp
c0029db3:	c3                   	ret    

c0029db4 <is_interior>:

/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
c0029db4:	55                   	push   %ebp
c0029db5:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029db7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029dbb:	74 1a                	je     c0029dd7 <is_interior+0x23>
c0029dbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0029dc0:	8b 00                	mov    (%eax),%eax
c0029dc2:	85 c0                	test   %eax,%eax
c0029dc4:	74 11                	je     c0029dd7 <is_interior+0x23>
c0029dc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0029dc9:	8b 40 04             	mov    0x4(%eax),%eax
c0029dcc:	85 c0                	test   %eax,%eax
c0029dce:	74 07                	je     c0029dd7 <is_interior+0x23>
c0029dd0:	b8 01 00 00 00       	mov    $0x1,%eax
c0029dd5:	eb 05                	jmp    c0029ddc <is_interior+0x28>
c0029dd7:	b8 00 00 00 00       	mov    $0x0,%eax
c0029ddc:	83 e0 01             	and    $0x1,%eax
}
c0029ddf:	5d                   	pop    %ebp
c0029de0:	c3                   	ret    

c0029de1 <is_tail>:

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
c0029de1:	55                   	push   %ebp
c0029de2:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029de4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029de8:	74 1a                	je     c0029e04 <is_tail+0x23>
c0029dea:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ded:	8b 00                	mov    (%eax),%eax
c0029def:	85 c0                	test   %eax,%eax
c0029df1:	74 11                	je     c0029e04 <is_tail+0x23>
c0029df3:	8b 45 08             	mov    0x8(%ebp),%eax
c0029df6:	8b 40 04             	mov    0x4(%eax),%eax
c0029df9:	85 c0                	test   %eax,%eax
c0029dfb:	75 07                	jne    c0029e04 <is_tail+0x23>
c0029dfd:	b8 01 00 00 00       	mov    $0x1,%eax
c0029e02:	eb 05                	jmp    c0029e09 <is_tail+0x28>
c0029e04:	b8 00 00 00 00       	mov    $0x0,%eax
c0029e09:	83 e0 01             	and    $0x1,%eax
}
c0029e0c:	5d                   	pop    %ebp
c0029e0d:	c3                   	ret    

c0029e0e <list_init>:

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c0029e0e:	55                   	push   %ebp
c0029e0f:	89 e5                	mov    %esp,%ebp
c0029e11:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029e14:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029e18:	75 1e                	jne    c0029e38 <list_init+0x2a>
c0029e1a:	83 ec 0c             	sub    $0xc,%esp
c0029e1d:	68 18 28 03 c0       	push   $0xc0032818
c0029e22:	68 25 28 03 c0       	push   $0xc0032825
c0029e27:	68 f0 29 03 c0       	push   $0xc00329f0
c0029e2c:	6a 3f                	push   $0x3f
c0029e2e:	68 3c 28 03 c0       	push   $0xc003283c
c0029e33:	e8 65 fd ff ff       	call   c0029b9d <debug_panic>
  list->head.prev = NULL;
c0029e38:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e3b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c0029e41:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e44:	8d 50 08             	lea    0x8(%eax),%edx
c0029e47:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e4a:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c0029e4d:	8b 55 08             	mov    0x8(%ebp),%edx
c0029e50:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e53:	89 50 08             	mov    %edx,0x8(%eax)
  list->tail.next = NULL;
c0029e56:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e59:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0029e60:	90                   	nop
c0029e61:	c9                   	leave  
c0029e62:	c3                   	ret    

c0029e63 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c0029e63:	55                   	push   %ebp
c0029e64:	89 e5                	mov    %esp,%ebp
c0029e66:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029e69:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029e6d:	75 1e                	jne    c0029e8d <list_begin+0x2a>
c0029e6f:	83 ec 0c             	sub    $0xc,%esp
c0029e72:	68 18 28 03 c0       	push   $0xc0032818
c0029e77:	68 25 28 03 c0       	push   $0xc0032825
c0029e7c:	68 fc 29 03 c0       	push   $0xc00329fc
c0029e81:	6a 4a                	push   $0x4a
c0029e83:	68 3c 28 03 c0       	push   $0xc003283c
c0029e88:	e8 10 fd ff ff       	call   c0029b9d <debug_panic>
  return list->head.next;
c0029e8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e90:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029e93:	c9                   	leave  
c0029e94:	c3                   	ret    

c0029e95 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c0029e95:	55                   	push   %ebp
c0029e96:	89 e5                	mov    %esp,%ebp
c0029e98:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_head (elem) || is_interior (elem));
c0029e9b:	ff 75 08             	pushl  0x8(%ebp)
c0029e9e:	e8 e4 fe ff ff       	call   c0029d87 <is_head>
c0029ea3:	83 c4 04             	add    $0x4,%esp
c0029ea6:	84 c0                	test   %al,%al
c0029ea8:	75 2d                	jne    c0029ed7 <list_next+0x42>
c0029eaa:	ff 75 08             	pushl  0x8(%ebp)
c0029ead:	e8 02 ff ff ff       	call   c0029db4 <is_interior>
c0029eb2:	83 c4 04             	add    $0x4,%esp
c0029eb5:	84 c0                	test   %al,%al
c0029eb7:	75 1e                	jne    c0029ed7 <list_next+0x42>
c0029eb9:	83 ec 0c             	sub    $0xc,%esp
c0029ebc:	68 54 28 03 c0       	push   $0xc0032854
c0029ec1:	68 25 28 03 c0       	push   $0xc0032825
c0029ec6:	68 08 2a 03 c0       	push   $0xc0032a08
c0029ecb:	6a 54                	push   $0x54
c0029ecd:	68 3c 28 03 c0       	push   $0xc003283c
c0029ed2:	e8 c6 fc ff ff       	call   c0029b9d <debug_panic>
  return elem->next;
c0029ed7:	8b 45 08             	mov    0x8(%ebp),%eax
c0029eda:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029edd:	c9                   	leave  
c0029ede:	c3                   	ret    

c0029edf <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c0029edf:	55                   	push   %ebp
c0029ee0:	89 e5                	mov    %esp,%ebp
c0029ee2:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029ee5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029ee9:	75 1e                	jne    c0029f09 <list_end+0x2a>
c0029eeb:	83 ec 0c             	sub    $0xc,%esp
c0029eee:	68 18 28 03 c0       	push   $0xc0032818
c0029ef3:	68 25 28 03 c0       	push   $0xc0032825
c0029ef8:	68 14 2a 03 c0       	push   $0xc0032a14
c0029efd:	6a 60                	push   $0x60
c0029eff:	68 3c 28 03 c0       	push   $0xc003283c
c0029f04:	e8 94 fc ff ff       	call   c0029b9d <debug_panic>
  return &list->tail;
c0029f09:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f0c:	83 c0 08             	add    $0x8,%eax
}
c0029f0f:	c9                   	leave  
c0029f10:	c3                   	ret    

c0029f11 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c0029f11:	55                   	push   %ebp
c0029f12:	89 e5                	mov    %esp,%ebp
c0029f14:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029f17:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029f1b:	75 1e                	jne    c0029f3b <list_rbegin+0x2a>
c0029f1d:	83 ec 0c             	sub    $0xc,%esp
c0029f20:	68 18 28 03 c0       	push   $0xc0032818
c0029f25:	68 25 28 03 c0       	push   $0xc0032825
c0029f2a:	68 20 2a 03 c0       	push   $0xc0032a20
c0029f2f:	6a 69                	push   $0x69
c0029f31:	68 3c 28 03 c0       	push   $0xc003283c
c0029f36:	e8 62 fc ff ff       	call   c0029b9d <debug_panic>
  return list->tail.prev;
c0029f3b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f3e:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029f41:	c9                   	leave  
c0029f42:	c3                   	ret    

c0029f43 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c0029f43:	55                   	push   %ebp
c0029f44:	89 e5                	mov    %esp,%ebp
c0029f46:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem) || is_tail (elem));
c0029f49:	ff 75 08             	pushl  0x8(%ebp)
c0029f4c:	e8 63 fe ff ff       	call   c0029db4 <is_interior>
c0029f51:	83 c4 04             	add    $0x4,%esp
c0029f54:	84 c0                	test   %al,%al
c0029f56:	75 2d                	jne    c0029f85 <list_prev+0x42>
c0029f58:	ff 75 08             	pushl  0x8(%ebp)
c0029f5b:	e8 81 fe ff ff       	call   c0029de1 <is_tail>
c0029f60:	83 c4 04             	add    $0x4,%esp
c0029f63:	84 c0                	test   %al,%al
c0029f65:	75 1e                	jne    c0029f85 <list_prev+0x42>
c0029f67:	83 ec 0c             	sub    $0xc,%esp
c0029f6a:	68 7c 28 03 c0       	push   $0xc003287c
c0029f6f:	68 25 28 03 c0       	push   $0xc0032825
c0029f74:	68 2c 2a 03 c0       	push   $0xc0032a2c
c0029f79:	6a 73                	push   $0x73
c0029f7b:	68 3c 28 03 c0       	push   $0xc003283c
c0029f80:	e8 18 fc ff ff       	call   c0029b9d <debug_panic>
  return elem->prev;
c0029f85:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f88:	8b 00                	mov    (%eax),%eax
}
c0029f8a:	c9                   	leave  
c0029f8b:	c3                   	ret    

c0029f8c <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c0029f8c:	55                   	push   %ebp
c0029f8d:	89 e5                	mov    %esp,%ebp
c0029f8f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029f92:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029f96:	75 21                	jne    c0029fb9 <list_rend+0x2d>
c0029f98:	83 ec 0c             	sub    $0xc,%esp
c0029f9b:	68 18 28 03 c0       	push   $0xc0032818
c0029fa0:	68 25 28 03 c0       	push   $0xc0032825
c0029fa5:	68 38 2a 03 c0       	push   $0xc0032a38
c0029faa:	68 87 00 00 00       	push   $0x87
c0029faf:	68 3c 28 03 c0       	push   $0xc003283c
c0029fb4:	e8 e4 fb ff ff       	call   c0029b9d <debug_panic>
  return &list->head;
c0029fb9:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029fbc:	c9                   	leave  
c0029fbd:	c3                   	ret    

c0029fbe <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c0029fbe:	55                   	push   %ebp
c0029fbf:	89 e5                	mov    %esp,%ebp
c0029fc1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029fc4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029fc8:	75 21                	jne    c0029feb <list_head+0x2d>
c0029fca:	83 ec 0c             	sub    $0xc,%esp
c0029fcd:	68 18 28 03 c0       	push   $0xc0032818
c0029fd2:	68 25 28 03 c0       	push   $0xc0032825
c0029fd7:	68 44 2a 03 c0       	push   $0xc0032a44
c0029fdc:	68 99 00 00 00       	push   $0x99
c0029fe1:	68 3c 28 03 c0       	push   $0xc003283c
c0029fe6:	e8 b2 fb ff ff       	call   c0029b9d <debug_panic>
  return &list->head;
c0029feb:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029fee:	c9                   	leave  
c0029fef:	c3                   	ret    

c0029ff0 <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c0029ff0:	55                   	push   %ebp
c0029ff1:	89 e5                	mov    %esp,%ebp
c0029ff3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029ff6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029ffa:	75 21                	jne    c002a01d <list_tail+0x2d>
c0029ffc:	83 ec 0c             	sub    $0xc,%esp
c0029fff:	68 18 28 03 c0       	push   $0xc0032818
c002a004:	68 25 28 03 c0       	push   $0xc0032825
c002a009:	68 50 2a 03 c0       	push   $0xc0032a50
c002a00e:	68 a1 00 00 00       	push   $0xa1
c002a013:	68 3c 28 03 c0       	push   $0xc003283c
c002a018:	e8 80 fb ff ff       	call   c0029b9d <debug_panic>
  return &list->tail;
c002a01d:	8b 45 08             	mov    0x8(%ebp),%eax
c002a020:	83 c0 08             	add    $0x8,%eax
}
c002a023:	c9                   	leave  
c002a024:	c3                   	ret    

c002a025 <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c002a025:	55                   	push   %ebp
c002a026:	89 e5                	mov    %esp,%ebp
c002a028:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c002a02b:	ff 75 08             	pushl  0x8(%ebp)
c002a02e:	e8 81 fd ff ff       	call   c0029db4 <is_interior>
c002a033:	83 c4 04             	add    $0x4,%esp
c002a036:	84 c0                	test   %al,%al
c002a038:	75 30                	jne    c002a06a <list_insert+0x45>
c002a03a:	ff 75 08             	pushl  0x8(%ebp)
c002a03d:	e8 9f fd ff ff       	call   c0029de1 <is_tail>
c002a042:	83 c4 04             	add    $0x4,%esp
c002a045:	84 c0                	test   %al,%al
c002a047:	75 21                	jne    c002a06a <list_insert+0x45>
c002a049:	83 ec 0c             	sub    $0xc,%esp
c002a04c:	68 a4 28 03 c0       	push   $0xc00328a4
c002a051:	68 25 28 03 c0       	push   $0xc0032825
c002a056:	68 5c 2a 03 c0       	push   $0xc0032a5c
c002a05b:	68 ab 00 00 00       	push   $0xab
c002a060:	68 3c 28 03 c0       	push   $0xc003283c
c002a065:	e8 33 fb ff ff       	call   c0029b9d <debug_panic>
  ASSERT (elem != NULL);
c002a06a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a06e:	75 21                	jne    c002a091 <list_insert+0x6c>
c002a070:	83 ec 0c             	sub    $0xc,%esp
c002a073:	68 cd 28 03 c0       	push   $0xc00328cd
c002a078:	68 25 28 03 c0       	push   $0xc0032825
c002a07d:	68 5c 2a 03 c0       	push   $0xc0032a5c
c002a082:	68 ac 00 00 00       	push   $0xac
c002a087:	68 3c 28 03 c0       	push   $0xc003283c
c002a08c:	e8 0c fb ff ff       	call   c0029b9d <debug_panic>

  elem->prev = before->prev;
c002a091:	8b 45 08             	mov    0x8(%ebp),%eax
c002a094:	8b 10                	mov    (%eax),%edx
c002a096:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a099:	89 10                	mov    %edx,(%eax)
  elem->next = before;
c002a09b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a09e:	8b 55 08             	mov    0x8(%ebp),%edx
c002a0a1:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = elem;
c002a0a4:	8b 45 08             	mov    0x8(%ebp),%eax
c002a0a7:	8b 00                	mov    (%eax),%eax
c002a0a9:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a0ac:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = elem;
c002a0af:	8b 45 08             	mov    0x8(%ebp),%eax
c002a0b2:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a0b5:	89 10                	mov    %edx,(%eax)
}
c002a0b7:	90                   	nop
c002a0b8:	c9                   	leave  
c002a0b9:	c3                   	ret    

c002a0ba <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c002a0ba:	55                   	push   %ebp
c002a0bb:	89 e5                	mov    %esp,%ebp
c002a0bd:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c002a0c0:	ff 75 08             	pushl  0x8(%ebp)
c002a0c3:	e8 ec fc ff ff       	call   c0029db4 <is_interior>
c002a0c8:	83 c4 04             	add    $0x4,%esp
c002a0cb:	84 c0                	test   %al,%al
c002a0cd:	75 30                	jne    c002a0ff <list_splice+0x45>
c002a0cf:	ff 75 08             	pushl  0x8(%ebp)
c002a0d2:	e8 0a fd ff ff       	call   c0029de1 <is_tail>
c002a0d7:	83 c4 04             	add    $0x4,%esp
c002a0da:	84 c0                	test   %al,%al
c002a0dc:	75 21                	jne    c002a0ff <list_splice+0x45>
c002a0de:	83 ec 0c             	sub    $0xc,%esp
c002a0e1:	68 a4 28 03 c0       	push   $0xc00328a4
c002a0e6:	68 25 28 03 c0       	push   $0xc0032825
c002a0eb:	68 68 2a 03 c0       	push   $0xc0032a68
c002a0f0:	68 bb 00 00 00       	push   $0xbb
c002a0f5:	68 3c 28 03 c0       	push   $0xc003283c
c002a0fa:	e8 9e fa ff ff       	call   c0029b9d <debug_panic>
  if (first == last)
c002a0ff:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a102:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a105:	0f 84 ba 00 00 00    	je     c002a1c5 <list_splice+0x10b>
    return;
  last = list_prev (last);
c002a10b:	83 ec 0c             	sub    $0xc,%esp
c002a10e:	ff 75 10             	pushl  0x10(%ebp)
c002a111:	e8 2d fe ff ff       	call   c0029f43 <list_prev>
c002a116:	83 c4 10             	add    $0x10,%esp
c002a119:	89 45 10             	mov    %eax,0x10(%ebp)

  ASSERT (is_interior (first));
c002a11c:	83 ec 0c             	sub    $0xc,%esp
c002a11f:	ff 75 0c             	pushl  0xc(%ebp)
c002a122:	e8 8d fc ff ff       	call   c0029db4 <is_interior>
c002a127:	83 c4 10             	add    $0x10,%esp
c002a12a:	84 c0                	test   %al,%al
c002a12c:	75 21                	jne    c002a14f <list_splice+0x95>
c002a12e:	83 ec 0c             	sub    $0xc,%esp
c002a131:	68 da 28 03 c0       	push   $0xc00328da
c002a136:	68 25 28 03 c0       	push   $0xc0032825
c002a13b:	68 68 2a 03 c0       	push   $0xc0032a68
c002a140:	68 c0 00 00 00       	push   $0xc0
c002a145:	68 3c 28 03 c0       	push   $0xc003283c
c002a14a:	e8 4e fa ff ff       	call   c0029b9d <debug_panic>
  ASSERT (is_interior (last));
c002a14f:	83 ec 0c             	sub    $0xc,%esp
c002a152:	ff 75 10             	pushl  0x10(%ebp)
c002a155:	e8 5a fc ff ff       	call   c0029db4 <is_interior>
c002a15a:	83 c4 10             	add    $0x10,%esp
c002a15d:	84 c0                	test   %al,%al
c002a15f:	75 21                	jne    c002a182 <list_splice+0xc8>
c002a161:	83 ec 0c             	sub    $0xc,%esp
c002a164:	68 ee 28 03 c0       	push   $0xc00328ee
c002a169:	68 25 28 03 c0       	push   $0xc0032825
c002a16e:	68 68 2a 03 c0       	push   $0xc0032a68
c002a173:	68 c1 00 00 00       	push   $0xc1
c002a178:	68 3c 28 03 c0       	push   $0xc003283c
c002a17d:	e8 1b fa ff ff       	call   c0029b9d <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c002a182:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a185:	8b 00                	mov    (%eax),%eax
c002a187:	8b 55 10             	mov    0x10(%ebp),%edx
c002a18a:	8b 52 04             	mov    0x4(%edx),%edx
c002a18d:	89 50 04             	mov    %edx,0x4(%eax)
  last->next->prev = first->prev;
c002a190:	8b 45 10             	mov    0x10(%ebp),%eax
c002a193:	8b 40 04             	mov    0x4(%eax),%eax
c002a196:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a199:	8b 12                	mov    (%edx),%edx
c002a19b:	89 10                	mov    %edx,(%eax)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c002a19d:	8b 45 08             	mov    0x8(%ebp),%eax
c002a1a0:	8b 10                	mov    (%eax),%edx
c002a1a2:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a1a5:	89 10                	mov    %edx,(%eax)
  last->next = before;
c002a1a7:	8b 45 10             	mov    0x10(%ebp),%eax
c002a1aa:	8b 55 08             	mov    0x8(%ebp),%edx
c002a1ad:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = first;
c002a1b0:	8b 45 08             	mov    0x8(%ebp),%eax
c002a1b3:	8b 00                	mov    (%eax),%eax
c002a1b5:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a1b8:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = last;
c002a1bb:	8b 45 08             	mov    0x8(%ebp),%eax
c002a1be:	8b 55 10             	mov    0x10(%ebp),%edx
c002a1c1:	89 10                	mov    %edx,(%eax)
c002a1c3:	eb 01                	jmp    c002a1c6 <list_splice+0x10c>
    return;
c002a1c5:	90                   	nop
}
c002a1c6:	c9                   	leave  
c002a1c7:	c3                   	ret    

c002a1c8 <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c002a1c8:	55                   	push   %ebp
c002a1c9:	89 e5                	mov    %esp,%ebp
c002a1cb:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_begin (list), elem);
c002a1ce:	83 ec 0c             	sub    $0xc,%esp
c002a1d1:	ff 75 08             	pushl  0x8(%ebp)
c002a1d4:	e8 8a fc ff ff       	call   c0029e63 <list_begin>
c002a1d9:	83 c4 10             	add    $0x10,%esp
c002a1dc:	83 ec 08             	sub    $0x8,%esp
c002a1df:	ff 75 0c             	pushl  0xc(%ebp)
c002a1e2:	50                   	push   %eax
c002a1e3:	e8 3d fe ff ff       	call   c002a025 <list_insert>
c002a1e8:	83 c4 10             	add    $0x10,%esp
}
c002a1eb:	90                   	nop
c002a1ec:	c9                   	leave  
c002a1ed:	c3                   	ret    

c002a1ee <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c002a1ee:	55                   	push   %ebp
c002a1ef:	89 e5                	mov    %esp,%ebp
c002a1f1:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_end (list), elem);
c002a1f4:	83 ec 0c             	sub    $0xc,%esp
c002a1f7:	ff 75 08             	pushl  0x8(%ebp)
c002a1fa:	e8 e0 fc ff ff       	call   c0029edf <list_end>
c002a1ff:	83 c4 10             	add    $0x10,%esp
c002a202:	83 ec 08             	sub    $0x8,%esp
c002a205:	ff 75 0c             	pushl  0xc(%ebp)
c002a208:	50                   	push   %eax
c002a209:	e8 17 fe ff ff       	call   c002a025 <list_insert>
c002a20e:	83 c4 10             	add    $0x10,%esp
}
c002a211:	90                   	nop
c002a212:	c9                   	leave  
c002a213:	c3                   	ret    

c002a214 <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c002a214:	55                   	push   %ebp
c002a215:	89 e5                	mov    %esp,%ebp
c002a217:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem));
c002a21a:	ff 75 08             	pushl  0x8(%ebp)
c002a21d:	e8 92 fb ff ff       	call   c0029db4 <is_interior>
c002a222:	83 c4 04             	add    $0x4,%esp
c002a225:	84 c0                	test   %al,%al
c002a227:	75 21                	jne    c002a24a <list_remove+0x36>
c002a229:	83 ec 0c             	sub    $0xc,%esp
c002a22c:	68 01 29 03 c0       	push   $0xc0032901
c002a231:	68 25 28 03 c0       	push   $0xc0032825
c002a236:	68 74 2a 03 c0       	push   $0xc0032a74
c002a23b:	68 fb 00 00 00       	push   $0xfb
c002a240:	68 3c 28 03 c0       	push   $0xc003283c
c002a245:	e8 53 f9 ff ff       	call   c0029b9d <debug_panic>
  elem->prev->next = elem->next;
c002a24a:	8b 45 08             	mov    0x8(%ebp),%eax
c002a24d:	8b 00                	mov    (%eax),%eax
c002a24f:	8b 55 08             	mov    0x8(%ebp),%edx
c002a252:	8b 52 04             	mov    0x4(%edx),%edx
c002a255:	89 50 04             	mov    %edx,0x4(%eax)
  elem->next->prev = elem->prev;
c002a258:	8b 45 08             	mov    0x8(%ebp),%eax
c002a25b:	8b 40 04             	mov    0x4(%eax),%eax
c002a25e:	8b 55 08             	mov    0x8(%ebp),%edx
c002a261:	8b 12                	mov    (%edx),%edx
c002a263:	89 10                	mov    %edx,(%eax)
  return elem->next;
c002a265:	8b 45 08             	mov    0x8(%ebp),%eax
c002a268:	8b 40 04             	mov    0x4(%eax),%eax
}
c002a26b:	c9                   	leave  
c002a26c:	c3                   	ret    

c002a26d <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c002a26d:	55                   	push   %ebp
c002a26e:	89 e5                	mov    %esp,%ebp
c002a270:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *front = list_front (list);
c002a273:	83 ec 0c             	sub    $0xc,%esp
c002a276:	ff 75 08             	pushl  0x8(%ebp)
c002a279:	e8 43 00 00 00       	call   c002a2c1 <list_front>
c002a27e:	83 c4 10             	add    $0x10,%esp
c002a281:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (front);
c002a284:	83 ec 0c             	sub    $0xc,%esp
c002a287:	ff 75 f4             	pushl  -0xc(%ebp)
c002a28a:	e8 85 ff ff ff       	call   c002a214 <list_remove>
c002a28f:	83 c4 10             	add    $0x10,%esp
  return front;
c002a292:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a295:	c9                   	leave  
c002a296:	c3                   	ret    

c002a297 <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c002a297:	55                   	push   %ebp
c002a298:	89 e5                	mov    %esp,%ebp
c002a29a:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *back = list_back (list);
c002a29d:	83 ec 0c             	sub    $0xc,%esp
c002a2a0:	ff 75 08             	pushl  0x8(%ebp)
c002a2a3:	e8 5d 00 00 00       	call   c002a305 <list_back>
c002a2a8:	83 c4 10             	add    $0x10,%esp
c002a2ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (back);
c002a2ae:	83 ec 0c             	sub    $0xc,%esp
c002a2b1:	ff 75 f4             	pushl  -0xc(%ebp)
c002a2b4:	e8 5b ff ff ff       	call   c002a214 <list_remove>
c002a2b9:	83 c4 10             	add    $0x10,%esp
  return back;
c002a2bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a2bf:	c9                   	leave  
c002a2c0:	c3                   	ret    

c002a2c1 <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c002a2c1:	55                   	push   %ebp
c002a2c2:	89 e5                	mov    %esp,%ebp
c002a2c4:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c002a2c7:	83 ec 0c             	sub    $0xc,%esp
c002a2ca:	ff 75 08             	pushl  0x8(%ebp)
c002a2cd:	e8 c3 00 00 00       	call   c002a395 <list_empty>
c002a2d2:	83 c4 10             	add    $0x10,%esp
c002a2d5:	83 f0 01             	xor    $0x1,%eax
c002a2d8:	84 c0                	test   %al,%al
c002a2da:	75 21                	jne    c002a2fd <list_front+0x3c>
c002a2dc:	83 ec 0c             	sub    $0xc,%esp
c002a2df:	68 14 29 03 c0       	push   $0xc0032914
c002a2e4:	68 25 28 03 c0       	push   $0xc0032825
c002a2e9:	68 80 2a 03 c0       	push   $0xc0032a80
c002a2ee:	68 1a 01 00 00       	push   $0x11a
c002a2f3:	68 3c 28 03 c0       	push   $0xc003283c
c002a2f8:	e8 a0 f8 ff ff       	call   c0029b9d <debug_panic>
  return list->head.next;
c002a2fd:	8b 45 08             	mov    0x8(%ebp),%eax
c002a300:	8b 40 04             	mov    0x4(%eax),%eax
}
c002a303:	c9                   	leave  
c002a304:	c3                   	ret    

c002a305 <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c002a305:	55                   	push   %ebp
c002a306:	89 e5                	mov    %esp,%ebp
c002a308:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c002a30b:	83 ec 0c             	sub    $0xc,%esp
c002a30e:	ff 75 08             	pushl  0x8(%ebp)
c002a311:	e8 7f 00 00 00       	call   c002a395 <list_empty>
c002a316:	83 c4 10             	add    $0x10,%esp
c002a319:	83 f0 01             	xor    $0x1,%eax
c002a31c:	84 c0                	test   %al,%al
c002a31e:	75 21                	jne    c002a341 <list_back+0x3c>
c002a320:	83 ec 0c             	sub    $0xc,%esp
c002a323:	68 14 29 03 c0       	push   $0xc0032914
c002a328:	68 25 28 03 c0       	push   $0xc0032825
c002a32d:	68 8c 2a 03 c0       	push   $0xc0032a8c
c002a332:	68 23 01 00 00       	push   $0x123
c002a337:	68 3c 28 03 c0       	push   $0xc003283c
c002a33c:	e8 5c f8 ff ff       	call   c0029b9d <debug_panic>
  return list->tail.prev;
c002a341:	8b 45 08             	mov    0x8(%ebp),%eax
c002a344:	8b 40 08             	mov    0x8(%eax),%eax
}
c002a347:	c9                   	leave  
c002a348:	c3                   	ret    

c002a349 <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c002a349:	55                   	push   %ebp
c002a34a:	89 e5                	mov    %esp,%ebp
c002a34c:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  size_t cnt = 0;
c002a34f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a356:	83 ec 0c             	sub    $0xc,%esp
c002a359:	ff 75 08             	pushl  0x8(%ebp)
c002a35c:	e8 02 fb ff ff       	call   c0029e63 <list_begin>
c002a361:	83 c4 10             	add    $0x10,%esp
c002a364:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a367:	eb 14                	jmp    c002a37d <list_size+0x34>
    cnt++;
c002a369:	ff 45 f0             	incl   -0x10(%ebp)
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a36c:	83 ec 0c             	sub    $0xc,%esp
c002a36f:	ff 75 f4             	pushl  -0xc(%ebp)
c002a372:	e8 1e fb ff ff       	call   c0029e95 <list_next>
c002a377:	83 c4 10             	add    $0x10,%esp
c002a37a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a37d:	83 ec 0c             	sub    $0xc,%esp
c002a380:	ff 75 08             	pushl  0x8(%ebp)
c002a383:	e8 57 fb ff ff       	call   c0029edf <list_end>
c002a388:	83 c4 10             	add    $0x10,%esp
c002a38b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a38e:	75 d9                	jne    c002a369 <list_size+0x20>
  return cnt;
c002a390:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002a393:	c9                   	leave  
c002a394:	c3                   	ret    

c002a395 <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c002a395:	55                   	push   %ebp
c002a396:	89 e5                	mov    %esp,%ebp
c002a398:	53                   	push   %ebx
c002a399:	83 ec 04             	sub    $0x4,%esp
  return list_begin (list) == list_end (list);
c002a39c:	83 ec 0c             	sub    $0xc,%esp
c002a39f:	ff 75 08             	pushl  0x8(%ebp)
c002a3a2:	e8 bc fa ff ff       	call   c0029e63 <list_begin>
c002a3a7:	83 c4 10             	add    $0x10,%esp
c002a3aa:	89 c3                	mov    %eax,%ebx
c002a3ac:	83 ec 0c             	sub    $0xc,%esp
c002a3af:	ff 75 08             	pushl  0x8(%ebp)
c002a3b2:	e8 28 fb ff ff       	call   c0029edf <list_end>
c002a3b7:	83 c4 10             	add    $0x10,%esp
c002a3ba:	39 c3                	cmp    %eax,%ebx
c002a3bc:	0f 94 c0             	sete   %al
}
c002a3bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a3c2:	c9                   	leave  
c002a3c3:	c3                   	ret    

c002a3c4 <swap>:

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
c002a3c4:	55                   	push   %ebp
c002a3c5:	89 e5                	mov    %esp,%ebp
c002a3c7:	83 ec 10             	sub    $0x10,%esp
  struct list_elem *t = *a;
c002a3ca:	8b 45 08             	mov    0x8(%ebp),%eax
c002a3cd:	8b 00                	mov    (%eax),%eax
c002a3cf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *a = *b;
c002a3d2:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a3d5:	8b 10                	mov    (%eax),%edx
c002a3d7:	8b 45 08             	mov    0x8(%ebp),%eax
c002a3da:	89 10                	mov    %edx,(%eax)
  *b = t;
c002a3dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a3df:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a3e2:	89 10                	mov    %edx,(%eax)
}
c002a3e4:	90                   	nop
c002a3e5:	c9                   	leave  
c002a3e6:	c3                   	ret    

c002a3e7 <list_reverse>:

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c002a3e7:	55                   	push   %ebp
c002a3e8:	89 e5                	mov    %esp,%ebp
c002a3ea:	83 ec 18             	sub    $0x18,%esp
  if (!list_empty (list)) 
c002a3ed:	83 ec 0c             	sub    $0xc,%esp
c002a3f0:	ff 75 08             	pushl  0x8(%ebp)
c002a3f3:	e8 9d ff ff ff       	call   c002a395 <list_empty>
c002a3f8:	83 c4 10             	add    $0x10,%esp
c002a3fb:	83 f0 01             	xor    $0x1,%eax
c002a3fe:	84 c0                	test   %al,%al
c002a400:	74 79                	je     c002a47b <list_reverse+0x94>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002a402:	83 ec 0c             	sub    $0xc,%esp
c002a405:	ff 75 08             	pushl  0x8(%ebp)
c002a408:	e8 56 fa ff ff       	call   c0029e63 <list_begin>
c002a40d:	83 c4 10             	add    $0x10,%esp
c002a410:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a413:	eb 1e                	jmp    c002a433 <list_reverse+0x4c>
        swap (&e->prev, &e->next);
c002a415:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a418:	8d 50 04             	lea    0x4(%eax),%edx
c002a41b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a41e:	83 ec 08             	sub    $0x8,%esp
c002a421:	52                   	push   %edx
c002a422:	50                   	push   %eax
c002a423:	e8 9c ff ff ff       	call   c002a3c4 <swap>
c002a428:	83 c4 10             	add    $0x10,%esp
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002a42b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a42e:	8b 00                	mov    (%eax),%eax
c002a430:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a433:	83 ec 0c             	sub    $0xc,%esp
c002a436:	ff 75 08             	pushl  0x8(%ebp)
c002a439:	e8 a1 fa ff ff       	call   c0029edf <list_end>
c002a43e:	83 c4 10             	add    $0x10,%esp
c002a441:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a444:	75 cf                	jne    c002a415 <list_reverse+0x2e>
      swap (&list->head.next, &list->tail.prev);
c002a446:	8b 45 08             	mov    0x8(%ebp),%eax
c002a449:	8d 50 08             	lea    0x8(%eax),%edx
c002a44c:	8b 45 08             	mov    0x8(%ebp),%eax
c002a44f:	83 c0 04             	add    $0x4,%eax
c002a452:	83 ec 08             	sub    $0x8,%esp
c002a455:	52                   	push   %edx
c002a456:	50                   	push   %eax
c002a457:	e8 68 ff ff ff       	call   c002a3c4 <swap>
c002a45c:	83 c4 10             	add    $0x10,%esp
      swap (&list->head.next->prev, &list->tail.prev->next);
c002a45f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a462:	8b 40 08             	mov    0x8(%eax),%eax
c002a465:	8d 50 04             	lea    0x4(%eax),%edx
c002a468:	8b 45 08             	mov    0x8(%ebp),%eax
c002a46b:	8b 40 04             	mov    0x4(%eax),%eax
c002a46e:	83 ec 08             	sub    $0x8,%esp
c002a471:	52                   	push   %edx
c002a472:	50                   	push   %eax
c002a473:	e8 4c ff ff ff       	call   c002a3c4 <swap>
c002a478:	83 c4 10             	add    $0x10,%esp
    }
}
c002a47b:	90                   	nop
c002a47c:	c9                   	leave  
c002a47d:	c3                   	ret    

c002a47e <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c002a47e:	55                   	push   %ebp
c002a47f:	89 e5                	mov    %esp,%ebp
c002a481:	83 ec 08             	sub    $0x8,%esp
  if (a != b)
c002a484:	8b 45 08             	mov    0x8(%ebp),%eax
c002a487:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a48a:	74 43                	je     c002a4cf <is_sorted+0x51>
    while ((a = list_next (a)) != b) 
c002a48c:	eb 28                	jmp    c002a4b6 <is_sorted+0x38>
      if (less (a, list_prev (a), aux))
c002a48e:	83 ec 0c             	sub    $0xc,%esp
c002a491:	ff 75 08             	pushl  0x8(%ebp)
c002a494:	e8 aa fa ff ff       	call   c0029f43 <list_prev>
c002a499:	83 c4 10             	add    $0x10,%esp
c002a49c:	83 ec 04             	sub    $0x4,%esp
c002a49f:	ff 75 14             	pushl  0x14(%ebp)
c002a4a2:	50                   	push   %eax
c002a4a3:	ff 75 08             	pushl  0x8(%ebp)
c002a4a6:	8b 45 10             	mov    0x10(%ebp),%eax
c002a4a9:	ff d0                	call   *%eax
c002a4ab:	83 c4 10             	add    $0x10,%esp
c002a4ae:	84 c0                	test   %al,%al
c002a4b0:	74 04                	je     c002a4b6 <is_sorted+0x38>
        return false;
c002a4b2:	b0 00                	mov    $0x0,%al
c002a4b4:	eb 1b                	jmp    c002a4d1 <is_sorted+0x53>
    while ((a = list_next (a)) != b) 
c002a4b6:	83 ec 0c             	sub    $0xc,%esp
c002a4b9:	ff 75 08             	pushl  0x8(%ebp)
c002a4bc:	e8 d4 f9 ff ff       	call   c0029e95 <list_next>
c002a4c1:	83 c4 10             	add    $0x10,%esp
c002a4c4:	89 45 08             	mov    %eax,0x8(%ebp)
c002a4c7:	8b 45 08             	mov    0x8(%ebp),%eax
c002a4ca:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a4cd:	75 bf                	jne    c002a48e <is_sorted+0x10>
  return true;
c002a4cf:	b0 01                	mov    $0x1,%al
}
c002a4d1:	c9                   	leave  
c002a4d2:	c3                   	ret    

c002a4d3 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c002a4d3:	55                   	push   %ebp
c002a4d4:	89 e5                	mov    %esp,%ebp
c002a4d6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c002a4d9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a4dd:	75 21                	jne    c002a500 <find_end_of_run+0x2d>
c002a4df:	83 ec 0c             	sub    $0xc,%esp
c002a4e2:	68 27 29 03 c0       	push   $0xc0032927
c002a4e7:	68 25 28 03 c0       	push   $0xc0032825
c002a4ec:	68 98 2a 03 c0       	push   $0xc0032a98
c002a4f1:	68 69 01 00 00       	push   $0x169
c002a4f6:	68 3c 28 03 c0       	push   $0xc003283c
c002a4fb:	e8 9d f6 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (b != NULL);
c002a500:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a504:	75 21                	jne    c002a527 <find_end_of_run+0x54>
c002a506:	83 ec 0c             	sub    $0xc,%esp
c002a509:	68 31 29 03 c0       	push   $0xc0032931
c002a50e:	68 25 28 03 c0       	push   $0xc0032825
c002a513:	68 98 2a 03 c0       	push   $0xc0032a98
c002a518:	68 6a 01 00 00       	push   $0x16a
c002a51d:	68 3c 28 03 c0       	push   $0xc003283c
c002a522:	e8 76 f6 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (less != NULL);
c002a527:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a52b:	75 21                	jne    c002a54e <find_end_of_run+0x7b>
c002a52d:	83 ec 0c             	sub    $0xc,%esp
c002a530:	68 3b 29 03 c0       	push   $0xc003293b
c002a535:	68 25 28 03 c0       	push   $0xc0032825
c002a53a:	68 98 2a 03 c0       	push   $0xc0032a98
c002a53f:	68 6b 01 00 00       	push   $0x16b
c002a544:	68 3c 28 03 c0       	push   $0xc003283c
c002a549:	e8 4f f6 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (a != b);
c002a54e:	8b 45 08             	mov    0x8(%ebp),%eax
c002a551:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a554:	75 21                	jne    c002a577 <find_end_of_run+0xa4>
c002a556:	83 ec 0c             	sub    $0xc,%esp
c002a559:	68 48 29 03 c0       	push   $0xc0032948
c002a55e:	68 25 28 03 c0       	push   $0xc0032825
c002a563:	68 98 2a 03 c0       	push   $0xc0032a98
c002a568:	68 6c 01 00 00       	push   $0x16c
c002a56d:	68 3c 28 03 c0       	push   $0xc003283c
c002a572:	e8 26 f6 ff ff       	call   c0029b9d <debug_panic>
  
  do 
    {
      a = list_next (a);
c002a577:	83 ec 0c             	sub    $0xc,%esp
c002a57a:	ff 75 08             	pushl  0x8(%ebp)
c002a57d:	e8 13 f9 ff ff       	call   c0029e95 <list_next>
c002a582:	83 c4 10             	add    $0x10,%esp
c002a585:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  while (a != b && !less (a, list_prev (a), aux));
c002a588:	8b 45 08             	mov    0x8(%ebp),%eax
c002a58b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a58e:	74 27                	je     c002a5b7 <find_end_of_run+0xe4>
c002a590:	83 ec 0c             	sub    $0xc,%esp
c002a593:	ff 75 08             	pushl  0x8(%ebp)
c002a596:	e8 a8 f9 ff ff       	call   c0029f43 <list_prev>
c002a59b:	83 c4 10             	add    $0x10,%esp
c002a59e:	83 ec 04             	sub    $0x4,%esp
c002a5a1:	ff 75 14             	pushl  0x14(%ebp)
c002a5a4:	50                   	push   %eax
c002a5a5:	ff 75 08             	pushl  0x8(%ebp)
c002a5a8:	8b 45 10             	mov    0x10(%ebp),%eax
c002a5ab:	ff d0                	call   *%eax
c002a5ad:	83 c4 10             	add    $0x10,%esp
c002a5b0:	83 f0 01             	xor    $0x1,%eax
c002a5b3:	84 c0                	test   %al,%al
c002a5b5:	75 c0                	jne    c002a577 <find_end_of_run+0xa4>
  return a;
c002a5b7:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a5ba:	c9                   	leave  
c002a5bb:	c3                   	ret    

c002a5bc <inplace_merge>:
   AUX.  The output range will be sorted the same way. */
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
c002a5bc:	55                   	push   %ebp
c002a5bd:	89 e5                	mov    %esp,%ebp
c002a5bf:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a0 != NULL);
c002a5c2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a5c6:	75 21                	jne    c002a5e9 <inplace_merge+0x2d>
c002a5c8:	83 ec 0c             	sub    $0xc,%esp
c002a5cb:	68 4f 29 03 c0       	push   $0xc003294f
c002a5d0:	68 25 28 03 c0       	push   $0xc0032825
c002a5d5:	68 a8 2a 03 c0       	push   $0xc0032aa8
c002a5da:	68 80 01 00 00       	push   $0x180
c002a5df:	68 3c 28 03 c0       	push   $0xc003283c
c002a5e4:	e8 b4 f5 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (a1b0 != NULL);
c002a5e9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a5ed:	75 21                	jne    c002a610 <inplace_merge+0x54>
c002a5ef:	83 ec 0c             	sub    $0xc,%esp
c002a5f2:	68 5a 29 03 c0       	push   $0xc003295a
c002a5f7:	68 25 28 03 c0       	push   $0xc0032825
c002a5fc:	68 a8 2a 03 c0       	push   $0xc0032aa8
c002a601:	68 81 01 00 00       	push   $0x181
c002a606:	68 3c 28 03 c0       	push   $0xc003283c
c002a60b:	e8 8d f5 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (b1 != NULL);
c002a610:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a614:	75 21                	jne    c002a637 <inplace_merge+0x7b>
c002a616:	83 ec 0c             	sub    $0xc,%esp
c002a619:	68 67 29 03 c0       	push   $0xc0032967
c002a61e:	68 25 28 03 c0       	push   $0xc0032825
c002a623:	68 a8 2a 03 c0       	push   $0xc0032aa8
c002a628:	68 82 01 00 00       	push   $0x182
c002a62d:	68 3c 28 03 c0       	push   $0xc003283c
c002a632:	e8 66 f5 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (less != NULL);
c002a637:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002a63b:	75 21                	jne    c002a65e <inplace_merge+0xa2>
c002a63d:	83 ec 0c             	sub    $0xc,%esp
c002a640:	68 3b 29 03 c0       	push   $0xc003293b
c002a645:	68 25 28 03 c0       	push   $0xc0032825
c002a64a:	68 a8 2a 03 c0       	push   $0xc0032aa8
c002a64f:	68 83 01 00 00       	push   $0x183
c002a654:	68 3c 28 03 c0       	push   $0xc003283c
c002a659:	e8 3f f5 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c002a65e:	ff 75 18             	pushl  0x18(%ebp)
c002a661:	ff 75 14             	pushl  0x14(%ebp)
c002a664:	ff 75 0c             	pushl  0xc(%ebp)
c002a667:	ff 75 08             	pushl  0x8(%ebp)
c002a66a:	e8 0f fe ff ff       	call   c002a47e <is_sorted>
c002a66f:	83 c4 10             	add    $0x10,%esp
c002a672:	84 c0                	test   %al,%al
c002a674:	75 21                	jne    c002a697 <inplace_merge+0xdb>
c002a676:	83 ec 0c             	sub    $0xc,%esp
c002a679:	68 74 29 03 c0       	push   $0xc0032974
c002a67e:	68 25 28 03 c0       	push   $0xc0032825
c002a683:	68 a8 2a 03 c0       	push   $0xc0032aa8
c002a688:	68 84 01 00 00       	push   $0x184
c002a68d:	68 3c 28 03 c0       	push   $0xc003283c
c002a692:	e8 06 f5 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c002a697:	ff 75 18             	pushl  0x18(%ebp)
c002a69a:	ff 75 14             	pushl  0x14(%ebp)
c002a69d:	ff 75 10             	pushl  0x10(%ebp)
c002a6a0:	ff 75 0c             	pushl  0xc(%ebp)
c002a6a3:	e8 d6 fd ff ff       	call   c002a47e <is_sorted>
c002a6a8:	83 c4 10             	add    $0x10,%esp
c002a6ab:	84 c0                	test   %al,%al
c002a6ad:	0f 85 80 00 00 00    	jne    c002a733 <inplace_merge+0x177>
c002a6b3:	83 ec 0c             	sub    $0xc,%esp
c002a6b6:	68 94 29 03 c0       	push   $0xc0032994
c002a6bb:	68 25 28 03 c0       	push   $0xc0032825
c002a6c0:	68 a8 2a 03 c0       	push   $0xc0032aa8
c002a6c5:	68 85 01 00 00       	push   $0x185
c002a6ca:	68 3c 28 03 c0       	push   $0xc003283c
c002a6cf:	e8 c9 f4 ff ff       	call   c0029b9d <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002a6d4:	83 ec 04             	sub    $0x4,%esp
c002a6d7:	ff 75 18             	pushl  0x18(%ebp)
c002a6da:	ff 75 08             	pushl  0x8(%ebp)
c002a6dd:	ff 75 0c             	pushl  0xc(%ebp)
c002a6e0:	8b 45 14             	mov    0x14(%ebp),%eax
c002a6e3:	ff d0                	call   *%eax
c002a6e5:	83 c4 10             	add    $0x10,%esp
c002a6e8:	83 f0 01             	xor    $0x1,%eax
c002a6eb:	84 c0                	test   %al,%al
c002a6ed:	74 13                	je     c002a702 <inplace_merge+0x146>
      a0 = list_next (a0);
c002a6ef:	83 ec 0c             	sub    $0xc,%esp
c002a6f2:	ff 75 08             	pushl  0x8(%ebp)
c002a6f5:	e8 9b f7 ff ff       	call   c0029e95 <list_next>
c002a6fa:	83 c4 10             	add    $0x10,%esp
c002a6fd:	89 45 08             	mov    %eax,0x8(%ebp)
c002a700:	eb 31                	jmp    c002a733 <inplace_merge+0x177>
    else 
      {
        a1b0 = list_next (a1b0);
c002a702:	83 ec 0c             	sub    $0xc,%esp
c002a705:	ff 75 0c             	pushl  0xc(%ebp)
c002a708:	e8 88 f7 ff ff       	call   c0029e95 <list_next>
c002a70d:	83 c4 10             	add    $0x10,%esp
c002a710:	89 45 0c             	mov    %eax,0xc(%ebp)
        list_splice (a0, list_prev (a1b0), a1b0);
c002a713:	83 ec 0c             	sub    $0xc,%esp
c002a716:	ff 75 0c             	pushl  0xc(%ebp)
c002a719:	e8 25 f8 ff ff       	call   c0029f43 <list_prev>
c002a71e:	83 c4 10             	add    $0x10,%esp
c002a721:	83 ec 04             	sub    $0x4,%esp
c002a724:	ff 75 0c             	pushl  0xc(%ebp)
c002a727:	50                   	push   %eax
c002a728:	ff 75 08             	pushl  0x8(%ebp)
c002a72b:	e8 8a f9 ff ff       	call   c002a0ba <list_splice>
c002a730:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c002a733:	8b 45 08             	mov    0x8(%ebp),%eax
c002a736:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a739:	74 08                	je     c002a743 <inplace_merge+0x187>
c002a73b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a73e:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a741:	75 91                	jne    c002a6d4 <inplace_merge+0x118>
      }
}
c002a743:	90                   	nop
c002a744:	c9                   	leave  
c002a745:	c3                   	ret    

c002a746 <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c002a746:	55                   	push   %ebp
c002a747:	89 e5                	mov    %esp,%ebp
c002a749:	53                   	push   %ebx
c002a74a:	83 ec 14             	sub    $0x14,%esp
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002a74d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a751:	75 21                	jne    c002a774 <list_sort+0x2e>
c002a753:	83 ec 0c             	sub    $0xc,%esp
c002a756:	68 18 28 03 c0       	push   $0xc0032818
c002a75b:	68 25 28 03 c0       	push   $0xc0032825
c002a760:	68 b8 2a 03 c0       	push   $0xc0032ab8
c002a765:	68 99 01 00 00       	push   $0x199
c002a76a:	68 3c 28 03 c0       	push   $0xc003283c
c002a76f:	e8 29 f4 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (less != NULL);
c002a774:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a778:	75 21                	jne    c002a79b <list_sort+0x55>
c002a77a:	83 ec 0c             	sub    $0xc,%esp
c002a77d:	68 3b 29 03 c0       	push   $0xc003293b
c002a782:	68 25 28 03 c0       	push   $0xc0032825
c002a787:	68 b8 2a 03 c0       	push   $0xc0032ab8
c002a78c:	68 9a 01 00 00       	push   $0x19a
c002a791:	68 3c 28 03 c0       	push   $0xc003283c
c002a796:	e8 02 f4 ff ff       	call   c0029b9d <debug_panic>
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c002a79b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a7a2:	83 ec 0c             	sub    $0xc,%esp
c002a7a5:	ff 75 08             	pushl  0x8(%ebp)
c002a7a8:	e8 b6 f6 ff ff       	call   c0029e63 <list_begin>
c002a7ad:	83 c4 10             	add    $0x10,%esp
c002a7b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a7b3:	eb 7c                	jmp    c002a831 <list_sort+0xeb>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c002a7b5:	ff 45 f4             	incl   -0xc(%ebp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002a7b8:	83 ec 0c             	sub    $0xc,%esp
c002a7bb:	ff 75 08             	pushl  0x8(%ebp)
c002a7be:	e8 1c f7 ff ff       	call   c0029edf <list_end>
c002a7c3:	83 c4 10             	add    $0x10,%esp
c002a7c6:	ff 75 10             	pushl  0x10(%ebp)
c002a7c9:	ff 75 0c             	pushl  0xc(%ebp)
c002a7cc:	50                   	push   %eax
c002a7cd:	ff 75 f0             	pushl  -0x10(%ebp)
c002a7d0:	e8 fe fc ff ff       	call   c002a4d3 <find_end_of_run>
c002a7d5:	83 c4 10             	add    $0x10,%esp
c002a7d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
          if (a1b0 == list_end (list))
c002a7db:	83 ec 0c             	sub    $0xc,%esp
c002a7de:	ff 75 08             	pushl  0x8(%ebp)
c002a7e1:	e8 f9 f6 ff ff       	call   c0029edf <list_end>
c002a7e6:	83 c4 10             	add    $0x10,%esp
c002a7e9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002a7ec:	74 5c                	je     c002a84a <list_sort+0x104>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c002a7ee:	83 ec 0c             	sub    $0xc,%esp
c002a7f1:	ff 75 08             	pushl  0x8(%ebp)
c002a7f4:	e8 e6 f6 ff ff       	call   c0029edf <list_end>
c002a7f9:	83 c4 10             	add    $0x10,%esp
c002a7fc:	ff 75 10             	pushl  0x10(%ebp)
c002a7ff:	ff 75 0c             	pushl  0xc(%ebp)
c002a802:	50                   	push   %eax
c002a803:	ff 75 ec             	pushl  -0x14(%ebp)
c002a806:	e8 c8 fc ff ff       	call   c002a4d3 <find_end_of_run>
c002a80b:	83 c4 10             	add    $0x10,%esp
c002a80e:	89 45 e8             	mov    %eax,-0x18(%ebp)

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
c002a811:	83 ec 0c             	sub    $0xc,%esp
c002a814:	ff 75 10             	pushl  0x10(%ebp)
c002a817:	ff 75 0c             	pushl  0xc(%ebp)
c002a81a:	ff 75 e8             	pushl  -0x18(%ebp)
c002a81d:	ff 75 ec             	pushl  -0x14(%ebp)
c002a820:	ff 75 f0             	pushl  -0x10(%ebp)
c002a823:	e8 94 fd ff ff       	call   c002a5bc <inplace_merge>
c002a828:	83 c4 20             	add    $0x20,%esp
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a82b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a82e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a831:	83 ec 0c             	sub    $0xc,%esp
c002a834:	ff 75 08             	pushl  0x8(%ebp)
c002a837:	e8 a3 f6 ff ff       	call   c0029edf <list_end>
c002a83c:	83 c4 10             	add    $0x10,%esp
c002a83f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a842:	0f 85 6d ff ff ff    	jne    c002a7b5 <list_sort+0x6f>
c002a848:	eb 01                	jmp    c002a84b <list_sort+0x105>
            break;
c002a84a:	90                   	nop
        }
    }
  while (output_run_cnt > 1);
c002a84b:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002a84f:	0f 87 46 ff ff ff    	ja     c002a79b <list_sort+0x55>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002a855:	83 ec 0c             	sub    $0xc,%esp
c002a858:	ff 75 08             	pushl  0x8(%ebp)
c002a85b:	e8 7f f6 ff ff       	call   c0029edf <list_end>
c002a860:	83 c4 10             	add    $0x10,%esp
c002a863:	89 c3                	mov    %eax,%ebx
c002a865:	83 ec 0c             	sub    $0xc,%esp
c002a868:	ff 75 08             	pushl  0x8(%ebp)
c002a86b:	e8 f3 f5 ff ff       	call   c0029e63 <list_begin>
c002a870:	83 c4 10             	add    $0x10,%esp
c002a873:	ff 75 10             	pushl  0x10(%ebp)
c002a876:	ff 75 0c             	pushl  0xc(%ebp)
c002a879:	53                   	push   %ebx
c002a87a:	50                   	push   %eax
c002a87b:	e8 fe fb ff ff       	call   c002a47e <is_sorted>
c002a880:	83 c4 10             	add    $0x10,%esp
c002a883:	84 c0                	test   %al,%al
c002a885:	75 21                	jne    c002a8a8 <list_sort+0x162>
c002a887:	83 ec 0c             	sub    $0xc,%esp
c002a88a:	68 b4 29 03 c0       	push   $0xc00329b4
c002a88f:	68 25 28 03 c0       	push   $0xc0032825
c002a894:	68 b8 2a 03 c0       	push   $0xc0032ab8
c002a899:	68 b7 01 00 00       	push   $0x1b7
c002a89e:	68 3c 28 03 c0       	push   $0xc003283c
c002a8a3:	e8 f5 f2 ff ff       	call   c0029b9d <debug_panic>
}
c002a8a8:	90                   	nop
c002a8a9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a8ac:	c9                   	leave  
c002a8ad:	c3                   	ret    

c002a8ae <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c002a8ae:	55                   	push   %ebp
c002a8af:	89 e5                	mov    %esp,%ebp
c002a8b1:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (list != NULL);
c002a8b4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a8b8:	75 21                	jne    c002a8db <list_insert_ordered+0x2d>
c002a8ba:	83 ec 0c             	sub    $0xc,%esp
c002a8bd:	68 18 28 03 c0       	push   $0xc0032818
c002a8c2:	68 25 28 03 c0       	push   $0xc0032825
c002a8c7:	68 c4 2a 03 c0       	push   $0xc0032ac4
c002a8cc:	68 c3 01 00 00       	push   $0x1c3
c002a8d1:	68 3c 28 03 c0       	push   $0xc003283c
c002a8d6:	e8 c2 f2 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (elem != NULL);
c002a8db:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a8df:	75 21                	jne    c002a902 <list_insert_ordered+0x54>
c002a8e1:	83 ec 0c             	sub    $0xc,%esp
c002a8e4:	68 cd 28 03 c0       	push   $0xc00328cd
c002a8e9:	68 25 28 03 c0       	push   $0xc0032825
c002a8ee:	68 c4 2a 03 c0       	push   $0xc0032ac4
c002a8f3:	68 c4 01 00 00       	push   $0x1c4
c002a8f8:	68 3c 28 03 c0       	push   $0xc003283c
c002a8fd:	e8 9b f2 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (less != NULL);
c002a902:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a906:	75 21                	jne    c002a929 <list_insert_ordered+0x7b>
c002a908:	83 ec 0c             	sub    $0xc,%esp
c002a90b:	68 3b 29 03 c0       	push   $0xc003293b
c002a910:	68 25 28 03 c0       	push   $0xc0032825
c002a915:	68 c4 2a 03 c0       	push   $0xc0032ac4
c002a91a:	68 c5 01 00 00       	push   $0x1c5
c002a91f:	68 3c 28 03 c0       	push   $0xc003283c
c002a924:	e8 74 f2 ff ff       	call   c0029b9d <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a929:	83 ec 0c             	sub    $0xc,%esp
c002a92c:	ff 75 08             	pushl  0x8(%ebp)
c002a92f:	e8 2f f5 ff ff       	call   c0029e63 <list_begin>
c002a934:	83 c4 10             	add    $0x10,%esp
c002a937:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a93a:	eb 29                	jmp    c002a965 <list_insert_ordered+0xb7>
    if (less (elem, e, aux))
c002a93c:	83 ec 04             	sub    $0x4,%esp
c002a93f:	ff 75 14             	pushl  0x14(%ebp)
c002a942:	ff 75 f4             	pushl  -0xc(%ebp)
c002a945:	ff 75 0c             	pushl  0xc(%ebp)
c002a948:	8b 45 10             	mov    0x10(%ebp),%eax
c002a94b:	ff d0                	call   *%eax
c002a94d:	83 c4 10             	add    $0x10,%esp
c002a950:	84 c0                	test   %al,%al
c002a952:	75 26                	jne    c002a97a <list_insert_ordered+0xcc>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a954:	83 ec 0c             	sub    $0xc,%esp
c002a957:	ff 75 f4             	pushl  -0xc(%ebp)
c002a95a:	e8 36 f5 ff ff       	call   c0029e95 <list_next>
c002a95f:	83 c4 10             	add    $0x10,%esp
c002a962:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a965:	83 ec 0c             	sub    $0xc,%esp
c002a968:	ff 75 08             	pushl  0x8(%ebp)
c002a96b:	e8 6f f5 ff ff       	call   c0029edf <list_end>
c002a970:	83 c4 10             	add    $0x10,%esp
c002a973:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a976:	75 c4                	jne    c002a93c <list_insert_ordered+0x8e>
c002a978:	eb 01                	jmp    c002a97b <list_insert_ordered+0xcd>
      break;
c002a97a:	90                   	nop
  return list_insert (e, elem);
c002a97b:	83 ec 08             	sub    $0x8,%esp
c002a97e:	ff 75 0c             	pushl  0xc(%ebp)
c002a981:	ff 75 f4             	pushl  -0xc(%ebp)
c002a984:	e8 9c f6 ff ff       	call   c002a025 <list_insert>
c002a989:	83 c4 10             	add    $0x10,%esp
}
c002a98c:	c9                   	leave  
c002a98d:	c3                   	ret    

c002a98e <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c002a98e:	55                   	push   %ebp
c002a98f:	89 e5                	mov    %esp,%ebp
c002a991:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c002a994:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a998:	75 21                	jne    c002a9bb <list_unique+0x2d>
c002a99a:	83 ec 0c             	sub    $0xc,%esp
c002a99d:	68 18 28 03 c0       	push   $0xc0032818
c002a9a2:	68 25 28 03 c0       	push   $0xc0032825
c002a9a7:	68 d8 2a 03 c0       	push   $0xc0032ad8
c002a9ac:	68 d7 01 00 00       	push   $0x1d7
c002a9b1:	68 3c 28 03 c0       	push   $0xc003283c
c002a9b6:	e8 e2 f1 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (less != NULL);
c002a9bb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a9bf:	75 21                	jne    c002a9e2 <list_unique+0x54>
c002a9c1:	83 ec 0c             	sub    $0xc,%esp
c002a9c4:	68 3b 29 03 c0       	push   $0xc003293b
c002a9c9:	68 25 28 03 c0       	push   $0xc0032825
c002a9ce:	68 d8 2a 03 c0       	push   $0xc0032ad8
c002a9d3:	68 d8 01 00 00       	push   $0x1d8
c002a9d8:	68 3c 28 03 c0       	push   $0xc003283c
c002a9dd:	e8 bb f1 ff ff       	call   c0029b9d <debug_panic>
  if (list_empty (list))
c002a9e2:	83 ec 0c             	sub    $0xc,%esp
c002a9e5:	ff 75 08             	pushl  0x8(%ebp)
c002a9e8:	e8 a8 f9 ff ff       	call   c002a395 <list_empty>
c002a9ed:	83 c4 10             	add    $0x10,%esp
c002a9f0:	84 c0                	test   %al,%al
c002a9f2:	0f 85 a0 00 00 00    	jne    c002aa98 <list_unique+0x10a>
    return;

  elem = list_begin (list);
c002a9f8:	83 ec 0c             	sub    $0xc,%esp
c002a9fb:	ff 75 08             	pushl  0x8(%ebp)
c002a9fe:	e8 60 f4 ff ff       	call   c0029e63 <list_begin>
c002aa03:	83 c4 10             	add    $0x10,%esp
c002aa06:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002aa09:	eb 63                	jmp    c002aa6e <list_unique+0xe0>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002aa0b:	83 ec 04             	sub    $0x4,%esp
c002aa0e:	ff 75 14             	pushl  0x14(%ebp)
c002aa11:	ff 75 f0             	pushl  -0x10(%ebp)
c002aa14:	ff 75 f4             	pushl  -0xc(%ebp)
c002aa17:	8b 45 10             	mov    0x10(%ebp),%eax
c002aa1a:	ff d0                	call   *%eax
c002aa1c:	83 c4 10             	add    $0x10,%esp
c002aa1f:	83 f0 01             	xor    $0x1,%eax
c002aa22:	84 c0                	test   %al,%al
c002aa24:	74 42                	je     c002aa68 <list_unique+0xda>
c002aa26:	83 ec 04             	sub    $0x4,%esp
c002aa29:	ff 75 14             	pushl  0x14(%ebp)
c002aa2c:	ff 75 f4             	pushl  -0xc(%ebp)
c002aa2f:	ff 75 f0             	pushl  -0x10(%ebp)
c002aa32:	8b 45 10             	mov    0x10(%ebp),%eax
c002aa35:	ff d0                	call   *%eax
c002aa37:	83 c4 10             	add    $0x10,%esp
c002aa3a:	83 f0 01             	xor    $0x1,%eax
c002aa3d:	84 c0                	test   %al,%al
c002aa3f:	74 27                	je     c002aa68 <list_unique+0xda>
      {
        list_remove (next);
c002aa41:	83 ec 0c             	sub    $0xc,%esp
c002aa44:	ff 75 f0             	pushl  -0x10(%ebp)
c002aa47:	e8 c8 f7 ff ff       	call   c002a214 <list_remove>
c002aa4c:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002aa4f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002aa53:	74 19                	je     c002aa6e <list_unique+0xe0>
          list_push_back (duplicates, next);
c002aa55:	83 ec 08             	sub    $0x8,%esp
c002aa58:	ff 75 f0             	pushl  -0x10(%ebp)
c002aa5b:	ff 75 0c             	pushl  0xc(%ebp)
c002aa5e:	e8 8b f7 ff ff       	call   c002a1ee <list_push_back>
c002aa63:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002aa66:	eb 06                	jmp    c002aa6e <list_unique+0xe0>
      }
    else
      elem = next;
c002aa68:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002aa6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002aa6e:	83 ec 0c             	sub    $0xc,%esp
c002aa71:	ff 75 f4             	pushl  -0xc(%ebp)
c002aa74:	e8 1c f4 ff ff       	call   c0029e95 <list_next>
c002aa79:	83 c4 10             	add    $0x10,%esp
c002aa7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002aa7f:	83 ec 0c             	sub    $0xc,%esp
c002aa82:	ff 75 08             	pushl  0x8(%ebp)
c002aa85:	e8 55 f4 ff ff       	call   c0029edf <list_end>
c002aa8a:	83 c4 10             	add    $0x10,%esp
c002aa8d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002aa90:	0f 85 75 ff ff ff    	jne    c002aa0b <list_unique+0x7d>
c002aa96:	eb 01                	jmp    c002aa99 <list_unique+0x10b>
    return;
c002aa98:	90                   	nop
}
c002aa99:	c9                   	leave  
c002aa9a:	c3                   	ret    

c002aa9b <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002aa9b:	55                   	push   %ebp
c002aa9c:	89 e5                	mov    %esp,%ebp
c002aa9e:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *max = list_begin (list);
c002aaa1:	83 ec 0c             	sub    $0xc,%esp
c002aaa4:	ff 75 08             	pushl  0x8(%ebp)
c002aaa7:	e8 b7 f3 ff ff       	call   c0029e63 <list_begin>
c002aaac:	83 c4 10             	add    $0x10,%esp
c002aaaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (max != list_end (list)) 
c002aab2:	83 ec 0c             	sub    $0xc,%esp
c002aab5:	ff 75 08             	pushl  0x8(%ebp)
c002aab8:	e8 22 f4 ff ff       	call   c0029edf <list_end>
c002aabd:	83 c4 10             	add    $0x10,%esp
c002aac0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002aac3:	74 55                	je     c002ab1a <list_max+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002aac5:	83 ec 0c             	sub    $0xc,%esp
c002aac8:	ff 75 f4             	pushl  -0xc(%ebp)
c002aacb:	e8 c5 f3 ff ff       	call   c0029e95 <list_next>
c002aad0:	83 c4 10             	add    $0x10,%esp
c002aad3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002aad6:	eb 2f                	jmp    c002ab07 <list_max+0x6c>
        if (less (max, e, aux))
c002aad8:	83 ec 04             	sub    $0x4,%esp
c002aadb:	ff 75 10             	pushl  0x10(%ebp)
c002aade:	ff 75 f0             	pushl  -0x10(%ebp)
c002aae1:	ff 75 f4             	pushl  -0xc(%ebp)
c002aae4:	8b 45 0c             	mov    0xc(%ebp),%eax
c002aae7:	ff d0                	call   *%eax
c002aae9:	83 c4 10             	add    $0x10,%esp
c002aaec:	84 c0                	test   %al,%al
c002aaee:	74 06                	je     c002aaf6 <list_max+0x5b>
          max = e; 
c002aaf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002aaf3:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002aaf6:	83 ec 0c             	sub    $0xc,%esp
c002aaf9:	ff 75 f0             	pushl  -0x10(%ebp)
c002aafc:	e8 94 f3 ff ff       	call   c0029e95 <list_next>
c002ab01:	83 c4 10             	add    $0x10,%esp
c002ab04:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ab07:	83 ec 0c             	sub    $0xc,%esp
c002ab0a:	ff 75 08             	pushl  0x8(%ebp)
c002ab0d:	e8 cd f3 ff ff       	call   c0029edf <list_end>
c002ab12:	83 c4 10             	add    $0x10,%esp
c002ab15:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002ab18:	75 be                	jne    c002aad8 <list_max+0x3d>
    }
  return max;
c002ab1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ab1d:	c9                   	leave  
c002ab1e:	c3                   	ret    

c002ab1f <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002ab1f:	55                   	push   %ebp
c002ab20:	89 e5                	mov    %esp,%ebp
c002ab22:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *min = list_begin (list);
c002ab25:	83 ec 0c             	sub    $0xc,%esp
c002ab28:	ff 75 08             	pushl  0x8(%ebp)
c002ab2b:	e8 33 f3 ff ff       	call   c0029e63 <list_begin>
c002ab30:	83 c4 10             	add    $0x10,%esp
c002ab33:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (min != list_end (list)) 
c002ab36:	83 ec 0c             	sub    $0xc,%esp
c002ab39:	ff 75 08             	pushl  0x8(%ebp)
c002ab3c:	e8 9e f3 ff ff       	call   c0029edf <list_end>
c002ab41:	83 c4 10             	add    $0x10,%esp
c002ab44:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002ab47:	74 55                	je     c002ab9e <list_min+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002ab49:	83 ec 0c             	sub    $0xc,%esp
c002ab4c:	ff 75 f4             	pushl  -0xc(%ebp)
c002ab4f:	e8 41 f3 ff ff       	call   c0029e95 <list_next>
c002ab54:	83 c4 10             	add    $0x10,%esp
c002ab57:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ab5a:	eb 2f                	jmp    c002ab8b <list_min+0x6c>
        if (less (e, min, aux))
c002ab5c:	83 ec 04             	sub    $0x4,%esp
c002ab5f:	ff 75 10             	pushl  0x10(%ebp)
c002ab62:	ff 75 f4             	pushl  -0xc(%ebp)
c002ab65:	ff 75 f0             	pushl  -0x10(%ebp)
c002ab68:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ab6b:	ff d0                	call   *%eax
c002ab6d:	83 c4 10             	add    $0x10,%esp
c002ab70:	84 c0                	test   %al,%al
c002ab72:	74 06                	je     c002ab7a <list_min+0x5b>
          min = e; 
c002ab74:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ab77:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002ab7a:	83 ec 0c             	sub    $0xc,%esp
c002ab7d:	ff 75 f0             	pushl  -0x10(%ebp)
c002ab80:	e8 10 f3 ff ff       	call   c0029e95 <list_next>
c002ab85:	83 c4 10             	add    $0x10,%esp
c002ab88:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ab8b:	83 ec 0c             	sub    $0xc,%esp
c002ab8e:	ff 75 08             	pushl  0x8(%ebp)
c002ab91:	e8 49 f3 ff ff       	call   c0029edf <list_end>
c002ab96:	83 c4 10             	add    $0x10,%esp
c002ab99:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002ab9c:	75 be                	jne    c002ab5c <list_min+0x3d>
    }
  return min;
c002ab9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002aba1:	c9                   	leave  
c002aba2:	c3                   	ret    

c002aba3 <elem_idx>:

/* Returns the index of the element that contains the bit
   numbered BIT_IDX. */
static inline size_t
elem_idx (size_t bit_idx) 
{
c002aba3:	55                   	push   %ebp
c002aba4:	89 e5                	mov    %esp,%ebp
  return bit_idx / ELEM_BITS;
c002aba6:	8b 45 08             	mov    0x8(%ebp),%eax
c002aba9:	c1 e8 05             	shr    $0x5,%eax
}
c002abac:	5d                   	pop    %ebp
c002abad:	c3                   	ret    

c002abae <bit_mask>:

/* Returns an elem_type where only the bit corresponding to
   BIT_IDX is turned on. */
static inline elem_type
bit_mask (size_t bit_idx) 
{
c002abae:	55                   	push   %ebp
c002abaf:	89 e5                	mov    %esp,%ebp
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002abb1:	8b 45 08             	mov    0x8(%ebp),%eax
c002abb4:	83 e0 1f             	and    $0x1f,%eax
c002abb7:	ba 01 00 00 00       	mov    $0x1,%edx
c002abbc:	88 c1                	mov    %al,%cl
c002abbe:	d3 e2                	shl    %cl,%edx
c002abc0:	89 d0                	mov    %edx,%eax
}
c002abc2:	5d                   	pop    %ebp
c002abc3:	c3                   	ret    

c002abc4 <elem_cnt>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
c002abc4:	55                   	push   %ebp
c002abc5:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002abc7:	8b 45 08             	mov    0x8(%ebp),%eax
c002abca:	83 c0 1f             	add    $0x1f,%eax
c002abcd:	c1 e8 05             	shr    $0x5,%eax
}
c002abd0:	5d                   	pop    %ebp
c002abd1:	c3                   	ret    

c002abd2 <byte_cnt>:

/* Returns the number of bytes required for BIT_CNT bits. */
static inline size_t
byte_cnt (size_t bit_cnt)
{
c002abd2:	55                   	push   %ebp
c002abd3:	89 e5                	mov    %esp,%ebp
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002abd5:	ff 75 08             	pushl  0x8(%ebp)
c002abd8:	e8 e7 ff ff ff       	call   c002abc4 <elem_cnt>
c002abdd:	83 c4 04             	add    $0x4,%esp
c002abe0:	c1 e0 02             	shl    $0x2,%eax
}
c002abe3:	c9                   	leave  
c002abe4:	c3                   	ret    

c002abe5 <last_mask>:

/* Returns a bit mask in which the bits actually used in the last
   element of B's bits are set to 1 and the rest are set to 0. */
static inline elem_type
last_mask (const struct bitmap *b) 
{
c002abe5:	55                   	push   %ebp
c002abe6:	89 e5                	mov    %esp,%ebp
c002abe8:	83 ec 10             	sub    $0x10,%esp
  int last_bits = b->bit_cnt % ELEM_BITS;
c002abeb:	8b 45 08             	mov    0x8(%ebp),%eax
c002abee:	8b 00                	mov    (%eax),%eax
c002abf0:	83 e0 1f             	and    $0x1f,%eax
c002abf3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return last_bits ? ((elem_type) 1 << last_bits) - 1 : (elem_type) -1;
c002abf6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c002abfa:	74 11                	je     c002ac0d <last_mask+0x28>
c002abfc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002abff:	ba 01 00 00 00       	mov    $0x1,%edx
c002ac04:	88 c1                	mov    %al,%cl
c002ac06:	d3 e2                	shl    %cl,%edx
c002ac08:	89 d0                	mov    %edx,%eax
c002ac0a:	48                   	dec    %eax
c002ac0b:	eb 05                	jmp    c002ac12 <last_mask+0x2d>
c002ac0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002ac12:	c9                   	leave  
c002ac13:	c3                   	ret    

c002ac14 <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c002ac14:	55                   	push   %ebp
c002ac15:	89 e5                	mov    %esp,%ebp
c002ac17:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = malloc (sizeof *b);
c002ac1a:	83 ec 0c             	sub    $0xc,%esp
c002ac1d:	6a 08                	push   $0x8
c002ac1f:	e8 96 8e ff ff       	call   c0023aba <malloc>
c002ac24:	83 c4 10             	add    $0x10,%esp
c002ac27:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (b != NULL)
c002ac2a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002ac2e:	74 5d                	je     c002ac8d <bitmap_create+0x79>
    {
      b->bit_cnt = bit_cnt;
c002ac30:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac33:	8b 55 08             	mov    0x8(%ebp),%edx
c002ac36:	89 10                	mov    %edx,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002ac38:	83 ec 0c             	sub    $0xc,%esp
c002ac3b:	ff 75 08             	pushl  0x8(%ebp)
c002ac3e:	e8 8f ff ff ff       	call   c002abd2 <byte_cnt>
c002ac43:	83 c4 10             	add    $0x10,%esp
c002ac46:	83 ec 0c             	sub    $0xc,%esp
c002ac49:	50                   	push   %eax
c002ac4a:	e8 6b 8e ff ff       	call   c0023aba <malloc>
c002ac4f:	83 c4 10             	add    $0x10,%esp
c002ac52:	89 c2                	mov    %eax,%edx
c002ac54:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac57:	89 50 04             	mov    %edx,0x4(%eax)
      if (b->bits != NULL || bit_cnt == 0)
c002ac5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac5d:	8b 40 04             	mov    0x4(%eax),%eax
c002ac60:	85 c0                	test   %eax,%eax
c002ac62:	75 06                	jne    c002ac6a <bitmap_create+0x56>
c002ac64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ac68:	75 15                	jne    c002ac7f <bitmap_create+0x6b>
        {
          bitmap_set_all (b, false);
c002ac6a:	83 ec 08             	sub    $0x8,%esp
c002ac6d:	6a 00                	push   $0x0
c002ac6f:	ff 75 f4             	pushl  -0xc(%ebp)
c002ac72:	e8 92 02 00 00       	call   c002af09 <bitmap_set_all>
c002ac77:	83 c4 10             	add    $0x10,%esp
          return b;
c002ac7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac7d:	eb 13                	jmp    c002ac92 <bitmap_create+0x7e>
        }
      free (b);
c002ac7f:	83 ec 0c             	sub    $0xc,%esp
c002ac82:	ff 75 f4             	pushl  -0xc(%ebp)
c002ac85:	e8 32 91 ff ff       	call   c0023dbc <free>
c002ac8a:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c002ac8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002ac92:	c9                   	leave  
c002ac93:	c3                   	ret    

c002ac94 <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c002ac94:	55                   	push   %ebp
c002ac95:	89 e5                	mov    %esp,%ebp
c002ac97:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = block;
c002ac9a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ac9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002aca0:	83 ec 0c             	sub    $0xc,%esp
c002aca3:	ff 75 08             	pushl  0x8(%ebp)
c002aca6:	e8 4f 00 00 00       	call   c002acfa <bitmap_buf_size>
c002acab:	83 c4 10             	add    $0x10,%esp
c002acae:	3b 45 10             	cmp    0x10(%ebp),%eax
c002acb1:	76 1e                	jbe    c002acd1 <bitmap_create_in_buf+0x3d>
c002acb3:	83 ec 0c             	sub    $0xc,%esp
c002acb6:	68 e4 2a 03 c0       	push   $0xc0032ae4
c002acbb:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002acc0:	68 88 2b 03 c0       	push   $0xc0032b88
c002acc5:	6a 68                	push   $0x68
c002acc7:	68 23 2b 03 c0       	push   $0xc0032b23
c002accc:	e8 cc ee ff ff       	call   c0029b9d <debug_panic>

  b->bit_cnt = bit_cnt;
c002acd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002acd4:	8b 55 08             	mov    0x8(%ebp),%edx
c002acd7:	89 10                	mov    %edx,(%eax)
  b->bits = (elem_type *) (b + 1);
c002acd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002acdc:	8d 50 08             	lea    0x8(%eax),%edx
c002acdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ace2:	89 50 04             	mov    %edx,0x4(%eax)
  bitmap_set_all (b, false);
c002ace5:	83 ec 08             	sub    $0x8,%esp
c002ace8:	6a 00                	push   $0x0
c002acea:	ff 75 f4             	pushl  -0xc(%ebp)
c002aced:	e8 17 02 00 00       	call   c002af09 <bitmap_set_all>
c002acf2:	83 c4 10             	add    $0x10,%esp
  return b;
c002acf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002acf8:	c9                   	leave  
c002acf9:	c3                   	ret    

c002acfa <bitmap_buf_size>:

/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
c002acfa:	55                   	push   %ebp
c002acfb:	89 e5                	mov    %esp,%ebp
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002acfd:	ff 75 08             	pushl  0x8(%ebp)
c002ad00:	e8 cd fe ff ff       	call   c002abd2 <byte_cnt>
c002ad05:	83 c4 04             	add    $0x4,%esp
c002ad08:	83 c0 08             	add    $0x8,%eax
}
c002ad0b:	c9                   	leave  
c002ad0c:	c3                   	ret    

c002ad0d <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002ad0d:	55                   	push   %ebp
c002ad0e:	89 e5                	mov    %esp,%ebp
c002ad10:	83 ec 08             	sub    $0x8,%esp
  if (b != NULL) 
c002ad13:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ad17:	74 20                	je     c002ad39 <bitmap_destroy+0x2c>
    {
      free (b->bits);
c002ad19:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad1c:	8b 40 04             	mov    0x4(%eax),%eax
c002ad1f:	83 ec 0c             	sub    $0xc,%esp
c002ad22:	50                   	push   %eax
c002ad23:	e8 94 90 ff ff       	call   c0023dbc <free>
c002ad28:	83 c4 10             	add    $0x10,%esp
      free (b);
c002ad2b:	83 ec 0c             	sub    $0xc,%esp
c002ad2e:	ff 75 08             	pushl  0x8(%ebp)
c002ad31:	e8 86 90 ff ff       	call   c0023dbc <free>
c002ad36:	83 c4 10             	add    $0x10,%esp
    }
}
c002ad39:	90                   	nop
c002ad3a:	c9                   	leave  
c002ad3b:	c3                   	ret    

c002ad3c <bitmap_size>:
/* Bitmap size. */

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
c002ad3c:	55                   	push   %ebp
c002ad3d:	89 e5                	mov    %esp,%ebp
  return b->bit_cnt;
c002ad3f:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad42:	8b 00                	mov    (%eax),%eax
}
c002ad44:	5d                   	pop    %ebp
c002ad45:	c3                   	ret    

c002ad46 <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002ad46:	55                   	push   %ebp
c002ad47:	89 e5                	mov    %esp,%ebp
c002ad49:	83 ec 18             	sub    $0x18,%esp
c002ad4c:	8b 45 10             	mov    0x10(%ebp),%eax
c002ad4f:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002ad52:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ad56:	75 21                	jne    c002ad79 <bitmap_set+0x33>
c002ad58:	83 ec 0c             	sub    $0xc,%esp
c002ad5b:	68 3d 2b 03 c0       	push   $0xc0032b3d
c002ad60:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002ad65:	68 a0 2b 03 c0       	push   $0xc0032ba0
c002ad6a:	68 93 00 00 00       	push   $0x93
c002ad6f:	68 23 2b 03 c0       	push   $0xc0032b23
c002ad74:	e8 24 ee ff ff       	call   c0029b9d <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002ad79:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad7c:	8b 00                	mov    (%eax),%eax
c002ad7e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ad81:	77 21                	ja     c002ada4 <bitmap_set+0x5e>
c002ad83:	83 ec 0c             	sub    $0xc,%esp
c002ad86:	68 47 2b 03 c0       	push   $0xc0032b47
c002ad8b:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002ad90:	68 a0 2b 03 c0       	push   $0xc0032ba0
c002ad95:	68 94 00 00 00       	push   $0x94
c002ad9a:	68 23 2b 03 c0       	push   $0xc0032b23
c002ad9f:	e8 f9 ed ff ff       	call   c0029b9d <debug_panic>
  if (value)
c002ada4:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002ada8:	74 13                	je     c002adbd <bitmap_set+0x77>
    bitmap_mark (b, idx);
c002adaa:	83 ec 08             	sub    $0x8,%esp
c002adad:	ff 75 0c             	pushl  0xc(%ebp)
c002adb0:	ff 75 08             	pushl  0x8(%ebp)
c002adb3:	e8 19 00 00 00       	call   c002add1 <bitmap_mark>
c002adb8:	83 c4 10             	add    $0x10,%esp
  else
    bitmap_reset (b, idx);
}
c002adbb:	eb 11                	jmp    c002adce <bitmap_set+0x88>
    bitmap_reset (b, idx);
c002adbd:	83 ec 08             	sub    $0x8,%esp
c002adc0:	ff 75 0c             	pushl  0xc(%ebp)
c002adc3:	ff 75 08             	pushl  0x8(%ebp)
c002adc6:	e8 3e 00 00 00       	call   c002ae09 <bitmap_reset>
c002adcb:	83 c4 10             	add    $0x10,%esp
}
c002adce:	90                   	nop
c002adcf:	c9                   	leave  
c002add0:	c3                   	ret    

c002add1 <bitmap_mark>:

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002add1:	55                   	push   %ebp
c002add2:	89 e5                	mov    %esp,%ebp
c002add4:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002add7:	ff 75 0c             	pushl  0xc(%ebp)
c002adda:	e8 c4 fd ff ff       	call   c002aba3 <elem_idx>
c002addf:	83 c4 04             	add    $0x4,%esp
c002ade2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002ade5:	ff 75 0c             	pushl  0xc(%ebp)
c002ade8:	e8 c1 fd ff ff       	call   c002abae <bit_mask>
c002aded:	83 c4 04             	add    $0x4,%esp
c002adf0:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002adf3:	8b 45 08             	mov    0x8(%ebp),%eax
c002adf6:	8b 40 04             	mov    0x4(%eax),%eax
c002adf9:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002adfc:	c1 e2 02             	shl    $0x2,%edx
c002adff:	01 c2                	add    %eax,%edx
c002ae01:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002ae04:	09 02                	or     %eax,(%edx)
}
c002ae06:	90                   	nop
c002ae07:	c9                   	leave  
c002ae08:	c3                   	ret    

c002ae09 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002ae09:	55                   	push   %ebp
c002ae0a:	89 e5                	mov    %esp,%ebp
c002ae0c:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002ae0f:	ff 75 0c             	pushl  0xc(%ebp)
c002ae12:	e8 8c fd ff ff       	call   c002aba3 <elem_idx>
c002ae17:	83 c4 04             	add    $0x4,%esp
c002ae1a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002ae1d:	ff 75 0c             	pushl  0xc(%ebp)
c002ae20:	e8 89 fd ff ff       	call   c002abae <bit_mask>
c002ae25:	83 c4 04             	add    $0x4,%esp
c002ae28:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002ae2b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae2e:	8b 40 04             	mov    0x4(%eax),%eax
c002ae31:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002ae34:	c1 e2 02             	shl    $0x2,%edx
c002ae37:	01 d0                	add    %edx,%eax
c002ae39:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002ae3c:	f7 d2                	not    %edx
c002ae3e:	21 10                	and    %edx,(%eax)
}
c002ae40:	90                   	nop
c002ae41:	c9                   	leave  
c002ae42:	c3                   	ret    

c002ae43 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002ae43:	55                   	push   %ebp
c002ae44:	89 e5                	mov    %esp,%ebp
c002ae46:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002ae49:	ff 75 0c             	pushl  0xc(%ebp)
c002ae4c:	e8 52 fd ff ff       	call   c002aba3 <elem_idx>
c002ae51:	83 c4 04             	add    $0x4,%esp
c002ae54:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002ae57:	ff 75 0c             	pushl  0xc(%ebp)
c002ae5a:	e8 4f fd ff ff       	call   c002abae <bit_mask>
c002ae5f:	83 c4 04             	add    $0x4,%esp
c002ae62:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002ae65:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae68:	8b 40 04             	mov    0x4(%eax),%eax
c002ae6b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002ae6e:	c1 e2 02             	shl    $0x2,%edx
c002ae71:	01 c2                	add    %eax,%edx
c002ae73:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002ae76:	31 02                	xor    %eax,(%edx)
}
c002ae78:	90                   	nop
c002ae79:	c9                   	leave  
c002ae7a:	c3                   	ret    

c002ae7b <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002ae7b:	55                   	push   %ebp
c002ae7c:	89 e5                	mov    %esp,%ebp
c002ae7e:	53                   	push   %ebx
c002ae7f:	83 ec 04             	sub    $0x4,%esp
  ASSERT (b != NULL);
c002ae82:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ae86:	75 21                	jne    c002aea9 <bitmap_test+0x2e>
c002ae88:	83 ec 0c             	sub    $0xc,%esp
c002ae8b:	68 3d 2b 03 c0       	push   $0xc0032b3d
c002ae90:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002ae95:	68 ac 2b 03 c0       	push   $0xc0032bac
c002ae9a:	68 c8 00 00 00       	push   $0xc8
c002ae9f:	68 23 2b 03 c0       	push   $0xc0032b23
c002aea4:	e8 f4 ec ff ff       	call   c0029b9d <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002aea9:	8b 45 08             	mov    0x8(%ebp),%eax
c002aeac:	8b 00                	mov    (%eax),%eax
c002aeae:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aeb1:	77 21                	ja     c002aed4 <bitmap_test+0x59>
c002aeb3:	83 ec 0c             	sub    $0xc,%esp
c002aeb6:	68 47 2b 03 c0       	push   $0xc0032b47
c002aebb:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002aec0:	68 ac 2b 03 c0       	push   $0xc0032bac
c002aec5:	68 c9 00 00 00       	push   $0xc9
c002aeca:	68 23 2b 03 c0       	push   $0xc0032b23
c002aecf:	e8 c9 ec ff ff       	call   c0029b9d <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002aed4:	8b 45 08             	mov    0x8(%ebp),%eax
c002aed7:	8b 58 04             	mov    0x4(%eax),%ebx
c002aeda:	83 ec 0c             	sub    $0xc,%esp
c002aedd:	ff 75 0c             	pushl  0xc(%ebp)
c002aee0:	e8 be fc ff ff       	call   c002aba3 <elem_idx>
c002aee5:	83 c4 10             	add    $0x10,%esp
c002aee8:	c1 e0 02             	shl    $0x2,%eax
c002aeeb:	01 d8                	add    %ebx,%eax
c002aeed:	8b 18                	mov    (%eax),%ebx
c002aeef:	83 ec 0c             	sub    $0xc,%esp
c002aef2:	ff 75 0c             	pushl  0xc(%ebp)
c002aef5:	e8 b4 fc ff ff       	call   c002abae <bit_mask>
c002aefa:	83 c4 10             	add    $0x10,%esp
c002aefd:	21 d8                	and    %ebx,%eax
c002aeff:	85 c0                	test   %eax,%eax
c002af01:	0f 95 c0             	setne  %al
}
c002af04:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002af07:	c9                   	leave  
c002af08:	c3                   	ret    

c002af09 <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c002af09:	55                   	push   %ebp
c002af0a:	89 e5                	mov    %esp,%ebp
c002af0c:	53                   	push   %ebx
c002af0d:	83 ec 14             	sub    $0x14,%esp
c002af10:	8b 45 0c             	mov    0xc(%ebp),%eax
c002af13:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002af16:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002af1a:	75 21                	jne    c002af3d <bitmap_set_all+0x34>
c002af1c:	83 ec 0c             	sub    $0xc,%esp
c002af1f:	68 3d 2b 03 c0       	push   $0xc0032b3d
c002af24:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002af29:	68 b8 2b 03 c0       	push   $0xc0032bb8
c002af2e:	68 d3 00 00 00       	push   $0xd3
c002af33:	68 23 2b 03 c0       	push   $0xc0032b23
c002af38:	e8 60 ec ff ff       	call   c0029b9d <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002af3d:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002af41:	83 ec 0c             	sub    $0xc,%esp
c002af44:	ff 75 08             	pushl  0x8(%ebp)
c002af47:	e8 f0 fd ff ff       	call   c002ad3c <bitmap_size>
c002af4c:	83 c4 10             	add    $0x10,%esp
c002af4f:	53                   	push   %ebx
c002af50:	50                   	push   %eax
c002af51:	6a 00                	push   $0x0
c002af53:	ff 75 08             	pushl  0x8(%ebp)
c002af56:	e8 09 00 00 00       	call   c002af64 <bitmap_set_multiple>
c002af5b:	83 c4 10             	add    $0x10,%esp
}
c002af5e:	90                   	nop
c002af5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002af62:	c9                   	leave  
c002af63:	c3                   	ret    

c002af64 <bitmap_set_multiple>:

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002af64:	55                   	push   %ebp
c002af65:	89 e5                	mov    %esp,%ebp
c002af67:	83 ec 28             	sub    $0x28,%esp
c002af6a:	8b 45 14             	mov    0x14(%ebp),%eax
c002af6d:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002af70:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002af74:	75 21                	jne    c002af97 <bitmap_set_multiple+0x33>
c002af76:	83 ec 0c             	sub    $0xc,%esp
c002af79:	68 3d 2b 03 c0       	push   $0xc0032b3d
c002af7e:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002af83:	68 c8 2b 03 c0       	push   $0xc0032bc8
c002af88:	68 de 00 00 00       	push   $0xde
c002af8d:	68 23 2b 03 c0       	push   $0xc0032b23
c002af92:	e8 06 ec ff ff       	call   c0029b9d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002af97:	8b 45 08             	mov    0x8(%ebp),%eax
c002af9a:	8b 00                	mov    (%eax),%eax
c002af9c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002af9f:	73 21                	jae    c002afc2 <bitmap_set_multiple+0x5e>
c002afa1:	83 ec 0c             	sub    $0xc,%esp
c002afa4:	68 58 2b 03 c0       	push   $0xc0032b58
c002afa9:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002afae:	68 c8 2b 03 c0       	push   $0xc0032bc8
c002afb3:	68 df 00 00 00       	push   $0xdf
c002afb8:	68 23 2b 03 c0       	push   $0xc0032b23
c002afbd:	e8 db eb ff ff       	call   c0029b9d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002afc2:	8b 55 0c             	mov    0xc(%ebp),%edx
c002afc5:	8b 45 10             	mov    0x10(%ebp),%eax
c002afc8:	01 c2                	add    %eax,%edx
c002afca:	8b 45 08             	mov    0x8(%ebp),%eax
c002afcd:	8b 00                	mov    (%eax),%eax
c002afcf:	39 c2                	cmp    %eax,%edx
c002afd1:	76 21                	jbe    c002aff4 <bitmap_set_multiple+0x90>
c002afd3:	83 ec 0c             	sub    $0xc,%esp
c002afd6:	68 6c 2b 03 c0       	push   $0xc0032b6c
c002afdb:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002afe0:	68 c8 2b 03 c0       	push   $0xc0032bc8
c002afe5:	68 e0 00 00 00       	push   $0xe0
c002afea:	68 23 2b 03 c0       	push   $0xc0032b23
c002afef:	e8 a9 eb ff ff       	call   c0029b9d <debug_panic>

  for (i = 0; i < cnt; i++)
c002aff4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002affb:	eb 1f                	jmp    c002b01c <bitmap_set_multiple+0xb8>
    bitmap_set (b, start + i, value);
c002affd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b001:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002b004:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b007:	01 ca                	add    %ecx,%edx
c002b009:	83 ec 04             	sub    $0x4,%esp
c002b00c:	50                   	push   %eax
c002b00d:	52                   	push   %edx
c002b00e:	ff 75 08             	pushl  0x8(%ebp)
c002b011:	e8 30 fd ff ff       	call   c002ad46 <bitmap_set>
c002b016:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < cnt; i++)
c002b019:	ff 45 f4             	incl   -0xc(%ebp)
c002b01c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b01f:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b022:	72 d9                	jb     c002affd <bitmap_set_multiple+0x99>
}
c002b024:	90                   	nop
c002b025:	c9                   	leave  
c002b026:	c3                   	ret    

c002b027 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b027:	55                   	push   %ebp
c002b028:	89 e5                	mov    %esp,%ebp
c002b02a:	83 ec 28             	sub    $0x28,%esp
c002b02d:	8b 45 14             	mov    0x14(%ebp),%eax
c002b030:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002b033:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b037:	75 21                	jne    c002b05a <bitmap_count+0x33>
c002b039:	83 ec 0c             	sub    $0xc,%esp
c002b03c:	68 3d 2b 03 c0       	push   $0xc0032b3d
c002b041:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002b046:	68 dc 2b 03 c0       	push   $0xc0032bdc
c002b04b:	68 ed 00 00 00       	push   $0xed
c002b050:	68 23 2b 03 c0       	push   $0xc0032b23
c002b055:	e8 43 eb ff ff       	call   c0029b9d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b05a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b05d:	8b 00                	mov    (%eax),%eax
c002b05f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b062:	73 21                	jae    c002b085 <bitmap_count+0x5e>
c002b064:	83 ec 0c             	sub    $0xc,%esp
c002b067:	68 58 2b 03 c0       	push   $0xc0032b58
c002b06c:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002b071:	68 dc 2b 03 c0       	push   $0xc0032bdc
c002b076:	68 ee 00 00 00       	push   $0xee
c002b07b:	68 23 2b 03 c0       	push   $0xc0032b23
c002b080:	e8 18 eb ff ff       	call   c0029b9d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002b085:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b088:	8b 45 10             	mov    0x10(%ebp),%eax
c002b08b:	01 c2                	add    %eax,%edx
c002b08d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b090:	8b 00                	mov    (%eax),%eax
c002b092:	39 c2                	cmp    %eax,%edx
c002b094:	76 21                	jbe    c002b0b7 <bitmap_count+0x90>
c002b096:	83 ec 0c             	sub    $0xc,%esp
c002b099:	68 6c 2b 03 c0       	push   $0xc0032b6c
c002b09e:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002b0a3:	68 dc 2b 03 c0       	push   $0xc0032bdc
c002b0a8:	68 ef 00 00 00       	push   $0xef
c002b0ad:	68 23 2b 03 c0       	push   $0xc0032b23
c002b0b2:	e8 e6 ea ff ff       	call   c0029b9d <debug_panic>

  value_cnt = 0;
c002b0b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002b0be:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b0c5:	eb 22                	jmp    c002b0e9 <bitmap_count+0xc2>
    if (bitmap_test (b, start + i) == value)
c002b0c7:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b0ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b0cd:	01 d0                	add    %edx,%eax
c002b0cf:	83 ec 08             	sub    $0x8,%esp
c002b0d2:	50                   	push   %eax
c002b0d3:	ff 75 08             	pushl  0x8(%ebp)
c002b0d6:	e8 a0 fd ff ff       	call   c002ae7b <bitmap_test>
c002b0db:	83 c4 10             	add    $0x10,%esp
c002b0de:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002b0e1:	75 03                	jne    c002b0e6 <bitmap_count+0xbf>
      value_cnt++;
c002b0e3:	ff 45 f0             	incl   -0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002b0e6:	ff 45 f4             	incl   -0xc(%ebp)
c002b0e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b0ec:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b0ef:	72 d6                	jb     c002b0c7 <bitmap_count+0xa0>
  return value_cnt;
c002b0f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b0f4:	c9                   	leave  
c002b0f5:	c3                   	ret    

c002b0f6 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b0f6:	55                   	push   %ebp
c002b0f7:	89 e5                	mov    %esp,%ebp
c002b0f9:	83 ec 28             	sub    $0x28,%esp
c002b0fc:	8b 45 14             	mov    0x14(%ebp),%eax
c002b0ff:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002b102:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b106:	75 21                	jne    c002b129 <bitmap_contains+0x33>
c002b108:	83 ec 0c             	sub    $0xc,%esp
c002b10b:	68 3d 2b 03 c0       	push   $0xc0032b3d
c002b110:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002b115:	68 ec 2b 03 c0       	push   $0xc0032bec
c002b11a:	68 ff 00 00 00       	push   $0xff
c002b11f:	68 23 2b 03 c0       	push   $0xc0032b23
c002b124:	e8 74 ea ff ff       	call   c0029b9d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b129:	8b 45 08             	mov    0x8(%ebp),%eax
c002b12c:	8b 00                	mov    (%eax),%eax
c002b12e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b131:	73 21                	jae    c002b154 <bitmap_contains+0x5e>
c002b133:	83 ec 0c             	sub    $0xc,%esp
c002b136:	68 58 2b 03 c0       	push   $0xc0032b58
c002b13b:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002b140:	68 ec 2b 03 c0       	push   $0xc0032bec
c002b145:	68 00 01 00 00       	push   $0x100
c002b14a:	68 23 2b 03 c0       	push   $0xc0032b23
c002b14f:	e8 49 ea ff ff       	call   c0029b9d <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002b154:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b157:	8b 45 10             	mov    0x10(%ebp),%eax
c002b15a:	01 c2                	add    %eax,%edx
c002b15c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b15f:	8b 00                	mov    (%eax),%eax
c002b161:	39 c2                	cmp    %eax,%edx
c002b163:	76 21                	jbe    c002b186 <bitmap_contains+0x90>
c002b165:	83 ec 0c             	sub    $0xc,%esp
c002b168:	68 6c 2b 03 c0       	push   $0xc0032b6c
c002b16d:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002b172:	68 ec 2b 03 c0       	push   $0xc0032bec
c002b177:	68 01 01 00 00       	push   $0x101
c002b17c:	68 23 2b 03 c0       	push   $0xc0032b23
c002b181:	e8 17 ea ff ff       	call   c0029b9d <debug_panic>

  for (i = 0; i < cnt; i++)
c002b186:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b18d:	eb 23                	jmp    c002b1b2 <bitmap_contains+0xbc>
    if (bitmap_test (b, start + i) == value)
c002b18f:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b192:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b195:	01 d0                	add    %edx,%eax
c002b197:	83 ec 08             	sub    $0x8,%esp
c002b19a:	50                   	push   %eax
c002b19b:	ff 75 08             	pushl  0x8(%ebp)
c002b19e:	e8 d8 fc ff ff       	call   c002ae7b <bitmap_test>
c002b1a3:	83 c4 10             	add    $0x10,%esp
c002b1a6:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002b1a9:	75 04                	jne    c002b1af <bitmap_contains+0xb9>
      return true;
c002b1ab:	b0 01                	mov    $0x1,%al
c002b1ad:	eb 0d                	jmp    c002b1bc <bitmap_contains+0xc6>
  for (i = 0; i < cnt; i++)
c002b1af:	ff 45 f4             	incl   -0xc(%ebp)
c002b1b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b1b5:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b1b8:	72 d5                	jb     c002b18f <bitmap_contains+0x99>
  return false;
c002b1ba:	b0 00                	mov    $0x0,%al
}
c002b1bc:	c9                   	leave  
c002b1bd:	c3                   	ret    

c002b1be <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002b1be:	55                   	push   %ebp
c002b1bf:	89 e5                	mov    %esp,%ebp
c002b1c1:	83 ec 08             	sub    $0x8,%esp
  return bitmap_contains (b, start, cnt, true);
c002b1c4:	6a 01                	push   $0x1
c002b1c6:	ff 75 10             	pushl  0x10(%ebp)
c002b1c9:	ff 75 0c             	pushl  0xc(%ebp)
c002b1cc:	ff 75 08             	pushl  0x8(%ebp)
c002b1cf:	e8 22 ff ff ff       	call   c002b0f6 <bitmap_contains>
c002b1d4:	83 c4 10             	add    $0x10,%esp
}
c002b1d7:	c9                   	leave  
c002b1d8:	c3                   	ret    

c002b1d9 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002b1d9:	55                   	push   %ebp
c002b1da:	89 e5                	mov    %esp,%ebp
c002b1dc:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, true);
c002b1df:	6a 01                	push   $0x1
c002b1e1:	ff 75 10             	pushl  0x10(%ebp)
c002b1e4:	ff 75 0c             	pushl  0xc(%ebp)
c002b1e7:	ff 75 08             	pushl  0x8(%ebp)
c002b1ea:	e8 07 ff ff ff       	call   c002b0f6 <bitmap_contains>
c002b1ef:	83 c4 10             	add    $0x10,%esp
c002b1f2:	0f b6 c0             	movzbl %al,%eax
c002b1f5:	85 c0                	test   %eax,%eax
c002b1f7:	0f 95 c0             	setne  %al
c002b1fa:	83 f0 01             	xor    $0x1,%eax
c002b1fd:	0f b6 c0             	movzbl %al,%eax
c002b200:	83 e0 01             	and    $0x1,%eax
}
c002b203:	c9                   	leave  
c002b204:	c3                   	ret    

c002b205 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002b205:	55                   	push   %ebp
c002b206:	89 e5                	mov    %esp,%ebp
c002b208:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, false);
c002b20b:	6a 00                	push   $0x0
c002b20d:	ff 75 10             	pushl  0x10(%ebp)
c002b210:	ff 75 0c             	pushl  0xc(%ebp)
c002b213:	ff 75 08             	pushl  0x8(%ebp)
c002b216:	e8 db fe ff ff       	call   c002b0f6 <bitmap_contains>
c002b21b:	83 c4 10             	add    $0x10,%esp
c002b21e:	0f b6 c0             	movzbl %al,%eax
c002b221:	85 c0                	test   %eax,%eax
c002b223:	0f 95 c0             	setne  %al
c002b226:	83 f0 01             	xor    $0x1,%eax
c002b229:	0f b6 c0             	movzbl %al,%eax
c002b22c:	83 e0 01             	and    $0x1,%eax
}
c002b22f:	c9                   	leave  
c002b230:	c3                   	ret    

c002b231 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b231:	55                   	push   %ebp
c002b232:	89 e5                	mov    %esp,%ebp
c002b234:	83 ec 28             	sub    $0x28,%esp
c002b237:	8b 45 14             	mov    0x14(%ebp),%eax
c002b23a:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT (b != NULL);
c002b23d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b241:	75 21                	jne    c002b264 <bitmap_scan+0x33>
c002b243:	83 ec 0c             	sub    $0xc,%esp
c002b246:	68 3d 2b 03 c0       	push   $0xc0032b3d
c002b24b:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002b250:	68 fc 2b 03 c0       	push   $0xc0032bfc
c002b255:	68 2a 01 00 00       	push   $0x12a
c002b25a:	68 23 2b 03 c0       	push   $0xc0032b23
c002b25f:	e8 39 e9 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b264:	8b 45 08             	mov    0x8(%ebp),%eax
c002b267:	8b 00                	mov    (%eax),%eax
c002b269:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b26c:	73 21                	jae    c002b28f <bitmap_scan+0x5e>
c002b26e:	83 ec 0c             	sub    $0xc,%esp
c002b271:	68 58 2b 03 c0       	push   $0xc0032b58
c002b276:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002b27b:	68 fc 2b 03 c0       	push   $0xc0032bfc
c002b280:	68 2b 01 00 00       	push   $0x12b
c002b285:	68 23 2b 03 c0       	push   $0xc0032b23
c002b28a:	e8 0e e9 ff ff       	call   c0029b9d <debug_panic>

  if (cnt <= b->bit_cnt) 
c002b28f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b292:	8b 00                	mov    (%eax),%eax
c002b294:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b297:	72 51                	jb     c002b2ea <bitmap_scan+0xb9>
    {
      size_t last = b->bit_cnt - cnt;
c002b299:	8b 45 08             	mov    0x8(%ebp),%eax
c002b29c:	8b 00                	mov    (%eax),%eax
c002b29e:	2b 45 10             	sub    0x10(%ebp),%eax
c002b2a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t i;
      for (i = start; i <= last; i++)
c002b2a4:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b2a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b2aa:	eb 36                	jmp    c002b2e2 <bitmap_scan+0xb1>
        if (!bitmap_contains (b, i, cnt, !value))
c002b2ac:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b2b0:	85 c0                	test   %eax,%eax
c002b2b2:	0f 95 c0             	setne  %al
c002b2b5:	83 f0 01             	xor    $0x1,%eax
c002b2b8:	0f b6 c0             	movzbl %al,%eax
c002b2bb:	83 e0 01             	and    $0x1,%eax
c002b2be:	0f b6 c0             	movzbl %al,%eax
c002b2c1:	50                   	push   %eax
c002b2c2:	ff 75 10             	pushl  0x10(%ebp)
c002b2c5:	ff 75 f4             	pushl  -0xc(%ebp)
c002b2c8:	ff 75 08             	pushl  0x8(%ebp)
c002b2cb:	e8 26 fe ff ff       	call   c002b0f6 <bitmap_contains>
c002b2d0:	83 c4 10             	add    $0x10,%esp
c002b2d3:	83 f0 01             	xor    $0x1,%eax
c002b2d6:	84 c0                	test   %al,%al
c002b2d8:	74 05                	je     c002b2df <bitmap_scan+0xae>
          return i; 
c002b2da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b2dd:	eb 10                	jmp    c002b2ef <bitmap_scan+0xbe>
      for (i = start; i <= last; i++)
c002b2df:	ff 45 f4             	incl   -0xc(%ebp)
c002b2e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b2e5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b2e8:	76 c2                	jbe    c002b2ac <bitmap_scan+0x7b>
    }
  return BITMAP_ERROR;
c002b2ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002b2ef:	c9                   	leave  
c002b2f0:	c3                   	ret    

c002b2f1 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002b2f1:	55                   	push   %ebp
c002b2f2:	89 e5                	mov    %esp,%ebp
c002b2f4:	83 ec 28             	sub    $0x28,%esp
c002b2f7:	8b 45 14             	mov    0x14(%ebp),%eax
c002b2fa:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t idx = bitmap_scan (b, start, cnt, value);
c002b2fd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b301:	50                   	push   %eax
c002b302:	ff 75 10             	pushl  0x10(%ebp)
c002b305:	ff 75 0c             	pushl  0xc(%ebp)
c002b308:	ff 75 08             	pushl  0x8(%ebp)
c002b30b:	e8 21 ff ff ff       	call   c002b231 <bitmap_scan>
c002b310:	83 c4 10             	add    $0x10,%esp
c002b313:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (idx != BITMAP_ERROR) 
c002b316:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002b31a:	74 27                	je     c002b343 <bitmap_scan_and_flip+0x52>
    bitmap_set_multiple (b, idx, cnt, !value);
c002b31c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b320:	85 c0                	test   %eax,%eax
c002b322:	0f 95 c0             	setne  %al
c002b325:	83 f0 01             	xor    $0x1,%eax
c002b328:	0f b6 c0             	movzbl %al,%eax
c002b32b:	83 e0 01             	and    $0x1,%eax
c002b32e:	0f b6 c0             	movzbl %al,%eax
c002b331:	50                   	push   %eax
c002b332:	ff 75 10             	pushl  0x10(%ebp)
c002b335:	ff 75 f4             	pushl  -0xc(%ebp)
c002b338:	ff 75 08             	pushl  0x8(%ebp)
c002b33b:	e8 24 fc ff ff       	call   c002af64 <bitmap_set_multiple>
c002b340:	83 c4 10             	add    $0x10,%esp
  return idx;
c002b343:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b346:	c9                   	leave  
c002b347:	c3                   	ret    

c002b348 <bitmap_file_size>:

#ifdef FILESYS
/* Returns the number of bytes needed to store B in a file. */
size_t
bitmap_file_size (const struct bitmap *b) 
{
c002b348:	55                   	push   %ebp
c002b349:	89 e5                	mov    %esp,%ebp
  return byte_cnt (b->bit_cnt);
c002b34b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b34e:	8b 00                	mov    (%eax),%eax
c002b350:	50                   	push   %eax
c002b351:	e8 7c f8 ff ff       	call   c002abd2 <byte_cnt>
c002b356:	83 c4 04             	add    $0x4,%esp
}
c002b359:	c9                   	leave  
c002b35a:	c3                   	ret    

c002b35b <bitmap_read>:

/* Reads B from FILE.  Returns true if successful, false
   otherwise. */
bool
bitmap_read (struct bitmap *b, struct file *file) 
{
c002b35b:	55                   	push   %ebp
c002b35c:	89 e5                	mov    %esp,%ebp
c002b35e:	56                   	push   %esi
c002b35f:	53                   	push   %ebx
c002b360:	83 ec 10             	sub    $0x10,%esp
  bool success = true;
c002b363:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
  if (b->bit_cnt > 0) 
c002b367:	8b 45 08             	mov    0x8(%ebp),%eax
c002b36a:	8b 00                	mov    (%eax),%eax
c002b36c:	85 c0                	test   %eax,%eax
c002b36e:	74 7a                	je     c002b3ea <bitmap_read+0x8f>
    {
      off_t size = byte_cnt (b->bit_cnt);
c002b370:	8b 45 08             	mov    0x8(%ebp),%eax
c002b373:	8b 00                	mov    (%eax),%eax
c002b375:	50                   	push   %eax
c002b376:	e8 57 f8 ff ff       	call   c002abd2 <byte_cnt>
c002b37b:	83 c4 04             	add    $0x4,%esp
c002b37e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      success = file_read_at (file, b->bits, size, 0) == size;
c002b381:	8b 45 08             	mov    0x8(%ebp),%eax
c002b384:	8b 40 04             	mov    0x4(%eax),%eax
c002b387:	6a 00                	push   $0x0
c002b389:	ff 75 f0             	pushl  -0x10(%ebp)
c002b38c:	50                   	push   %eax
c002b38d:	ff 75 0c             	pushl  0xc(%ebp)
c002b390:	e8 64 35 00 00       	call   c002e8f9 <file_read_at>
c002b395:	83 c4 10             	add    $0x10,%esp
c002b398:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b39b:	0f 94 c0             	sete   %al
c002b39e:	88 45 f7             	mov    %al,-0x9(%ebp)
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
c002b3a1:	83 ec 0c             	sub    $0xc,%esp
c002b3a4:	ff 75 08             	pushl  0x8(%ebp)
c002b3a7:	e8 39 f8 ff ff       	call   c002abe5 <last_mask>
c002b3ac:	83 c4 10             	add    $0x10,%esp
c002b3af:	89 c3                	mov    %eax,%ebx
c002b3b1:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3b4:	8b 70 04             	mov    0x4(%eax),%esi
c002b3b7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3ba:	8b 00                	mov    (%eax),%eax
c002b3bc:	83 ec 0c             	sub    $0xc,%esp
c002b3bf:	50                   	push   %eax
c002b3c0:	e8 ff f7 ff ff       	call   c002abc4 <elem_cnt>
c002b3c5:	83 c4 10             	add    $0x10,%esp
c002b3c8:	8d 90 ff ff ff 3f    	lea    0x3fffffff(%eax),%edx
c002b3ce:	c1 e2 02             	shl    $0x2,%edx
c002b3d1:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
c002b3d4:	8b 55 08             	mov    0x8(%ebp),%edx
c002b3d7:	8b 52 04             	mov    0x4(%edx),%edx
c002b3da:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
c002b3df:	c1 e0 02             	shl    $0x2,%eax
c002b3e2:	01 d0                	add    %edx,%eax
c002b3e4:	8b 00                	mov    (%eax),%eax
c002b3e6:	21 d8                	and    %ebx,%eax
c002b3e8:	89 01                	mov    %eax,(%ecx)
    }
  return success;
c002b3ea:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c002b3ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002b3f0:	5b                   	pop    %ebx
c002b3f1:	5e                   	pop    %esi
c002b3f2:	5d                   	pop    %ebp
c002b3f3:	c3                   	ret    

c002b3f4 <bitmap_write>:

/* Writes B to FILE.  Return true if successful, false
   otherwise. */
bool
bitmap_write (const struct bitmap *b, struct file *file)
{
c002b3f4:	55                   	push   %ebp
c002b3f5:	89 e5                	mov    %esp,%ebp
c002b3f7:	83 ec 18             	sub    $0x18,%esp
  off_t size = byte_cnt (b->bit_cnt);
c002b3fa:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3fd:	8b 00                	mov    (%eax),%eax
c002b3ff:	50                   	push   %eax
c002b400:	e8 cd f7 ff ff       	call   c002abd2 <byte_cnt>
c002b405:	83 c4 04             	add    $0x4,%esp
c002b408:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return file_write_at (file, b->bits, size, 0) == size;
c002b40b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b40e:	8b 40 04             	mov    0x4(%eax),%eax
c002b411:	6a 00                	push   $0x0
c002b413:	ff 75 f4             	pushl  -0xc(%ebp)
c002b416:	50                   	push   %eax
c002b417:	ff 75 0c             	pushl  0xc(%ebp)
c002b41a:	e8 33 35 00 00       	call   c002e952 <file_write_at>
c002b41f:	83 c4 10             	add    $0x10,%esp
c002b422:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b425:	0f 94 c0             	sete   %al
}
c002b428:	c9                   	leave  
c002b429:	c3                   	ret    

c002b42a <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002b42a:	55                   	push   %ebp
c002b42b:	89 e5                	mov    %esp,%ebp
c002b42d:	83 ec 08             	sub    $0x8,%esp
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002b430:	8b 45 08             	mov    0x8(%ebp),%eax
c002b433:	8b 00                	mov    (%eax),%eax
c002b435:	50                   	push   %eax
c002b436:	e8 97 f7 ff ff       	call   c002abd2 <byte_cnt>
c002b43b:	83 c4 04             	add    $0x4,%esp
c002b43e:	89 c2                	mov    %eax,%edx
c002b440:	8b 45 08             	mov    0x8(%ebp),%eax
c002b443:	8b 40 04             	mov    0x4(%eax),%eax
c002b446:	6a 00                	push   $0x0
c002b448:	52                   	push   %edx
c002b449:	50                   	push   %eax
c002b44a:	6a 00                	push   $0x0
c002b44c:	e8 c4 ce ff ff       	call   c0028315 <hex_dump>
c002b451:	83 c4 10             	add    $0x10,%esp
}
c002b454:	90                   	nop
c002b455:	c9                   	leave  
c002b456:	c3                   	ret    

c002b457 <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002b457:	55                   	push   %ebp
c002b458:	89 e5                	mov    %esp,%ebp
c002b45a:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt = 0;
c002b45d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b460:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  h->bucket_cnt = 4;
c002b466:	8b 45 08             	mov    0x8(%ebp),%eax
c002b469:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002b470:	8b 45 08             	mov    0x8(%ebp),%eax
c002b473:	8b 40 04             	mov    0x4(%eax),%eax
c002b476:	c1 e0 04             	shl    $0x4,%eax
c002b479:	83 ec 0c             	sub    $0xc,%esp
c002b47c:	50                   	push   %eax
c002b47d:	e8 38 86 ff ff       	call   c0023aba <malloc>
c002b482:	83 c4 10             	add    $0x10,%esp
c002b485:	89 c2                	mov    %eax,%edx
c002b487:	8b 45 08             	mov    0x8(%ebp),%eax
c002b48a:	89 50 08             	mov    %edx,0x8(%eax)
  h->hash = hash;
c002b48d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b490:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b493:	89 50 0c             	mov    %edx,0xc(%eax)
  h->less = less;
c002b496:	8b 45 08             	mov    0x8(%ebp),%eax
c002b499:	8b 55 10             	mov    0x10(%ebp),%edx
c002b49c:	89 50 10             	mov    %edx,0x10(%eax)
  h->aux = aux;
c002b49f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4a2:	8b 55 14             	mov    0x14(%ebp),%edx
c002b4a5:	89 50 14             	mov    %edx,0x14(%eax)

  if (h->buckets != NULL) 
c002b4a8:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4ab:	8b 40 08             	mov    0x8(%eax),%eax
c002b4ae:	85 c0                	test   %eax,%eax
c002b4b0:	74 14                	je     c002b4c6 <hash_init+0x6f>
    {
      hash_clear (h, NULL);
c002b4b2:	83 ec 08             	sub    $0x8,%esp
c002b4b5:	6a 00                	push   $0x0
c002b4b7:	ff 75 08             	pushl  0x8(%ebp)
c002b4ba:	e8 0b 00 00 00       	call   c002b4ca <hash_clear>
c002b4bf:	83 c4 10             	add    $0x10,%esp
      return true;
c002b4c2:	b0 01                	mov    $0x1,%al
c002b4c4:	eb 02                	jmp    c002b4c8 <hash_init+0x71>
    }
  else
    return false;
c002b4c6:	b0 00                	mov    $0x0,%al
}
c002b4c8:	c9                   	leave  
c002b4c9:	c3                   	ret    

c002b4ca <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002b4ca:	55                   	push   %ebp
c002b4cb:	89 e5                	mov    %esp,%ebp
c002b4cd:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002b4d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b4d7:	eb 71                	jmp    c002b54a <hash_clear+0x80>
    {
      struct list *bucket = &h->buckets[i];
c002b4d9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4dc:	8b 40 08             	mov    0x8(%eax),%eax
c002b4df:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b4e2:	c1 e2 04             	shl    $0x4,%edx
c002b4e5:	01 d0                	add    %edx,%eax
c002b4e7:	89 45 f0             	mov    %eax,-0x10(%ebp)

      if (destructor != NULL) 
c002b4ea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b4ee:	74 49                	je     c002b539 <hash_clear+0x6f>
        while (!list_empty (bucket)) 
c002b4f0:	eb 32                	jmp    c002b524 <hash_clear+0x5a>
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c002b4f2:	83 ec 0c             	sub    $0xc,%esp
c002b4f5:	ff 75 f0             	pushl  -0x10(%ebp)
c002b4f8:	e8 70 ed ff ff       	call   c002a26d <list_pop_front>
c002b4fd:	83 c4 10             	add    $0x10,%esp
c002b500:	89 45 ec             	mov    %eax,-0x14(%ebp)
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
c002b503:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b506:	83 c0 04             	add    $0x4,%eax
c002b509:	83 e8 04             	sub    $0x4,%eax
c002b50c:	89 45 e8             	mov    %eax,-0x18(%ebp)
            destructor (hash_elem, h->aux);
c002b50f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b512:	8b 40 14             	mov    0x14(%eax),%eax
c002b515:	83 ec 08             	sub    $0x8,%esp
c002b518:	50                   	push   %eax
c002b519:	ff 75 e8             	pushl  -0x18(%ebp)
c002b51c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b51f:	ff d0                	call   *%eax
c002b521:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c002b524:	83 ec 0c             	sub    $0xc,%esp
c002b527:	ff 75 f0             	pushl  -0x10(%ebp)
c002b52a:	e8 66 ee ff ff       	call   c002a395 <list_empty>
c002b52f:	83 c4 10             	add    $0x10,%esp
c002b532:	83 f0 01             	xor    $0x1,%eax
c002b535:	84 c0                	test   %al,%al
c002b537:	75 b9                	jne    c002b4f2 <hash_clear+0x28>
          }

      list_init (bucket); 
c002b539:	83 ec 0c             	sub    $0xc,%esp
c002b53c:	ff 75 f0             	pushl  -0x10(%ebp)
c002b53f:	e8 ca e8 ff ff       	call   c0029e0e <list_init>
c002b544:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
c002b547:	ff 45 f4             	incl   -0xc(%ebp)
c002b54a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b54d:	8b 40 04             	mov    0x4(%eax),%eax
c002b550:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b553:	77 84                	ja     c002b4d9 <hash_clear+0xf>
    }    

  h->elem_cnt = 0;
c002b555:	8b 45 08             	mov    0x8(%ebp),%eax
c002b558:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c002b55e:	90                   	nop
c002b55f:	c9                   	leave  
c002b560:	c3                   	ret    

c002b561 <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c002b561:	55                   	push   %ebp
c002b562:	89 e5                	mov    %esp,%ebp
c002b564:	83 ec 08             	sub    $0x8,%esp
  if (destructor != NULL)
c002b567:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b56b:	74 11                	je     c002b57e <hash_destroy+0x1d>
    hash_clear (h, destructor);
c002b56d:	83 ec 08             	sub    $0x8,%esp
c002b570:	ff 75 0c             	pushl  0xc(%ebp)
c002b573:	ff 75 08             	pushl  0x8(%ebp)
c002b576:	e8 4f ff ff ff       	call   c002b4ca <hash_clear>
c002b57b:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002b57e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b581:	8b 40 08             	mov    0x8(%eax),%eax
c002b584:	83 ec 0c             	sub    $0xc,%esp
c002b587:	50                   	push   %eax
c002b588:	e8 2f 88 ff ff       	call   c0023dbc <free>
c002b58d:	83 c4 10             	add    $0x10,%esp
}
c002b590:	90                   	nop
c002b591:	c9                   	leave  
c002b592:	c3                   	ret    

c002b593 <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c002b593:	55                   	push   %ebp
c002b594:	89 e5                	mov    %esp,%ebp
c002b596:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b599:	83 ec 08             	sub    $0x8,%esp
c002b59c:	ff 75 0c             	pushl  0xc(%ebp)
c002b59f:	ff 75 08             	pushl  0x8(%ebp)
c002b5a2:	e8 7e 04 00 00       	call   c002ba25 <find_bucket>
c002b5a7:	83 c4 10             	add    $0x10,%esp
c002b5aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b5ad:	83 ec 04             	sub    $0x4,%esp
c002b5b0:	ff 75 0c             	pushl  0xc(%ebp)
c002b5b3:	ff 75 f4             	pushl  -0xc(%ebp)
c002b5b6:	ff 75 08             	pushl  0x8(%ebp)
c002b5b9:	e8 a3 04 00 00       	call   c002ba61 <find_elem>
c002b5be:	83 c4 10             	add    $0x10,%esp
c002b5c1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old == NULL) 
c002b5c4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b5c8:	75 14                	jne    c002b5de <hash_insert+0x4b>
    insert_elem (h, bucket, new);
c002b5ca:	83 ec 04             	sub    $0x4,%esp
c002b5cd:	ff 75 0c             	pushl  0xc(%ebp)
c002b5d0:	ff 75 f4             	pushl  -0xc(%ebp)
c002b5d3:	ff 75 08             	pushl  0x8(%ebp)
c002b5d6:	e8 ee 06 00 00       	call   c002bcc9 <insert_elem>
c002b5db:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b5de:	83 ec 0c             	sub    $0xc,%esp
c002b5e1:	ff 75 08             	pushl  0x8(%ebp)
c002b5e4:	e8 43 05 00 00       	call   c002bb2c <rehash>
c002b5e9:	83 c4 10             	add    $0x10,%esp

  return old; 
c002b5ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b5ef:	c9                   	leave  
c002b5f0:	c3                   	ret    

c002b5f1 <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002b5f1:	55                   	push   %ebp
c002b5f2:	89 e5                	mov    %esp,%ebp
c002b5f4:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b5f7:	83 ec 08             	sub    $0x8,%esp
c002b5fa:	ff 75 0c             	pushl  0xc(%ebp)
c002b5fd:	ff 75 08             	pushl  0x8(%ebp)
c002b600:	e8 20 04 00 00       	call   c002ba25 <find_bucket>
c002b605:	83 c4 10             	add    $0x10,%esp
c002b608:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b60b:	83 ec 04             	sub    $0x4,%esp
c002b60e:	ff 75 0c             	pushl  0xc(%ebp)
c002b611:	ff 75 f4             	pushl  -0xc(%ebp)
c002b614:	ff 75 08             	pushl  0x8(%ebp)
c002b617:	e8 45 04 00 00       	call   c002ba61 <find_elem>
c002b61c:	83 c4 10             	add    $0x10,%esp
c002b61f:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old != NULL)
c002b622:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b626:	74 11                	je     c002b639 <hash_replace+0x48>
    remove_elem (h, old);
c002b628:	83 ec 08             	sub    $0x8,%esp
c002b62b:	ff 75 f0             	pushl  -0x10(%ebp)
c002b62e:	ff 75 08             	pushl  0x8(%ebp)
c002b631:	e8 bb 06 00 00       	call   c002bcf1 <remove_elem>
c002b636:	83 c4 10             	add    $0x10,%esp
  insert_elem (h, bucket, new);
c002b639:	83 ec 04             	sub    $0x4,%esp
c002b63c:	ff 75 0c             	pushl  0xc(%ebp)
c002b63f:	ff 75 f4             	pushl  -0xc(%ebp)
c002b642:	ff 75 08             	pushl  0x8(%ebp)
c002b645:	e8 7f 06 00 00       	call   c002bcc9 <insert_elem>
c002b64a:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b64d:	83 ec 0c             	sub    $0xc,%esp
c002b650:	ff 75 08             	pushl  0x8(%ebp)
c002b653:	e8 d4 04 00 00       	call   c002bb2c <rehash>
c002b658:	83 c4 10             	add    $0x10,%esp

  return old;
c002b65b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b65e:	c9                   	leave  
c002b65f:	c3                   	ret    

c002b660 <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c002b660:	55                   	push   %ebp
c002b661:	89 e5                	mov    %esp,%ebp
c002b663:	83 ec 08             	sub    $0x8,%esp
  return find_elem (h, find_bucket (h, e), e);
c002b666:	83 ec 08             	sub    $0x8,%esp
c002b669:	ff 75 0c             	pushl  0xc(%ebp)
c002b66c:	ff 75 08             	pushl  0x8(%ebp)
c002b66f:	e8 b1 03 00 00       	call   c002ba25 <find_bucket>
c002b674:	83 c4 10             	add    $0x10,%esp
c002b677:	83 ec 04             	sub    $0x4,%esp
c002b67a:	ff 75 0c             	pushl  0xc(%ebp)
c002b67d:	50                   	push   %eax
c002b67e:	ff 75 08             	pushl  0x8(%ebp)
c002b681:	e8 db 03 00 00       	call   c002ba61 <find_elem>
c002b686:	83 c4 10             	add    $0x10,%esp
}
c002b689:	c9                   	leave  
c002b68a:	c3                   	ret    

c002b68b <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c002b68b:	55                   	push   %ebp
c002b68c:	89 e5                	mov    %esp,%ebp
c002b68e:	83 ec 18             	sub    $0x18,%esp
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002b691:	83 ec 08             	sub    $0x8,%esp
c002b694:	ff 75 0c             	pushl  0xc(%ebp)
c002b697:	ff 75 08             	pushl  0x8(%ebp)
c002b69a:	e8 86 03 00 00       	call   c002ba25 <find_bucket>
c002b69f:	83 c4 10             	add    $0x10,%esp
c002b6a2:	83 ec 04             	sub    $0x4,%esp
c002b6a5:	ff 75 0c             	pushl  0xc(%ebp)
c002b6a8:	50                   	push   %eax
c002b6a9:	ff 75 08             	pushl  0x8(%ebp)
c002b6ac:	e8 b0 03 00 00       	call   c002ba61 <find_elem>
c002b6b1:	83 c4 10             	add    $0x10,%esp
c002b6b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (found != NULL) 
c002b6b7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b6bb:	74 1f                	je     c002b6dc <hash_delete+0x51>
    {
      remove_elem (h, found);
c002b6bd:	83 ec 08             	sub    $0x8,%esp
c002b6c0:	ff 75 f4             	pushl  -0xc(%ebp)
c002b6c3:	ff 75 08             	pushl  0x8(%ebp)
c002b6c6:	e8 26 06 00 00       	call   c002bcf1 <remove_elem>
c002b6cb:	83 c4 10             	add    $0x10,%esp
      rehash (h); 
c002b6ce:	83 ec 0c             	sub    $0xc,%esp
c002b6d1:	ff 75 08             	pushl  0x8(%ebp)
c002b6d4:	e8 53 04 00 00       	call   c002bb2c <rehash>
c002b6d9:	83 c4 10             	add    $0x10,%esp
    }
  return found;
c002b6dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b6df:	c9                   	leave  
c002b6e0:	c3                   	ret    

c002b6e1 <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c002b6e1:	55                   	push   %ebp
c002b6e2:	89 e5                	mov    %esp,%ebp
c002b6e4:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  
  ASSERT (action != NULL);
c002b6e7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b6eb:	75 21                	jne    c002b70e <hash_apply+0x2d>
c002b6ed:	83 ec 0c             	sub    $0xc,%esp
c002b6f0:	68 08 2c 03 c0       	push   $0xc0032c08
c002b6f5:	68 17 2c 03 c0       	push   $0xc0032c17
c002b6fa:	68 70 2c 03 c0       	push   $0xc0032c70
c002b6ff:	68 a7 00 00 00       	push   $0xa7
c002b704:	68 2e 2c 03 c0       	push   $0xc0032c2e
c002b709:	e8 8f e4 ff ff       	call   c0029b9d <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
c002b70e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b715:	eb 6d                	jmp    c002b784 <hash_apply+0xa3>
    {
      struct list *bucket = &h->buckets[i];
c002b717:	8b 45 08             	mov    0x8(%ebp),%eax
c002b71a:	8b 40 08             	mov    0x8(%eax),%eax
c002b71d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b720:	c1 e2 04             	shl    $0x4,%edx
c002b723:	01 d0                	add    %edx,%eax
c002b725:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b728:	83 ec 0c             	sub    $0xc,%esp
c002b72b:	ff 75 ec             	pushl  -0x14(%ebp)
c002b72e:	e8 30 e7 ff ff       	call   c0029e63 <list_begin>
c002b733:	83 c4 10             	add    $0x10,%esp
c002b736:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b739:	eb 33                	jmp    c002b76e <hash_apply+0x8d>
        {
          next = list_next (elem);
c002b73b:	83 ec 0c             	sub    $0xc,%esp
c002b73e:	ff 75 f0             	pushl  -0x10(%ebp)
c002b741:	e8 4f e7 ff ff       	call   c0029e95 <list_next>
c002b746:	83 c4 10             	add    $0x10,%esp
c002b749:	89 45 e8             	mov    %eax,-0x18(%ebp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002b74c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b74f:	8b 40 14             	mov    0x14(%eax),%eax
c002b752:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b755:	83 c2 04             	add    $0x4,%edx
c002b758:	83 ea 04             	sub    $0x4,%edx
c002b75b:	83 ec 08             	sub    $0x8,%esp
c002b75e:	50                   	push   %eax
c002b75f:	52                   	push   %edx
c002b760:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b763:	ff d0                	call   *%eax
c002b765:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b768:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b76b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b76e:	83 ec 0c             	sub    $0xc,%esp
c002b771:	ff 75 ec             	pushl  -0x14(%ebp)
c002b774:	e8 66 e7 ff ff       	call   c0029edf <list_end>
c002b779:	83 c4 10             	add    $0x10,%esp
c002b77c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b77f:	75 ba                	jne    c002b73b <hash_apply+0x5a>
  for (i = 0; i < h->bucket_cnt; i++) 
c002b781:	ff 45 f4             	incl   -0xc(%ebp)
c002b784:	8b 45 08             	mov    0x8(%ebp),%eax
c002b787:	8b 40 04             	mov    0x4(%eax),%eax
c002b78a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b78d:	77 88                	ja     c002b717 <hash_apply+0x36>
        }
    }
}
c002b78f:	90                   	nop
c002b790:	c9                   	leave  
c002b791:	c3                   	ret    

c002b792 <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c002b792:	55                   	push   %ebp
c002b793:	89 e5                	mov    %esp,%ebp
c002b795:	83 ec 08             	sub    $0x8,%esp
  ASSERT (i != NULL);
c002b798:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b79c:	75 21                	jne    c002b7bf <hash_first+0x2d>
c002b79e:	83 ec 0c             	sub    $0xc,%esp
c002b7a1:	68 46 2c 03 c0       	push   $0xc0032c46
c002b7a6:	68 17 2c 03 c0       	push   $0xc0032c17
c002b7ab:	68 7c 2c 03 c0       	push   $0xc0032c7c
c002b7b0:	68 ca 00 00 00       	push   $0xca
c002b7b5:	68 2e 2c 03 c0       	push   $0xc0032c2e
c002b7ba:	e8 de e3 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (h != NULL);
c002b7bf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b7c3:	75 21                	jne    c002b7e6 <hash_first+0x54>
c002b7c5:	83 ec 0c             	sub    $0xc,%esp
c002b7c8:	68 50 2c 03 c0       	push   $0xc0032c50
c002b7cd:	68 17 2c 03 c0       	push   $0xc0032c17
c002b7d2:	68 7c 2c 03 c0       	push   $0xc0032c7c
c002b7d7:	68 cb 00 00 00       	push   $0xcb
c002b7dc:	68 2e 2c 03 c0       	push   $0xc0032c2e
c002b7e1:	e8 b7 e3 ff ff       	call   c0029b9d <debug_panic>

  i->hash = h;
c002b7e6:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7e9:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b7ec:	89 10                	mov    %edx,(%eax)
  i->bucket = i->hash->buckets;
c002b7ee:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7f1:	8b 00                	mov    (%eax),%eax
c002b7f3:	8b 50 08             	mov    0x8(%eax),%edx
c002b7f6:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7f9:	89 50 04             	mov    %edx,0x4(%eax)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002b7fc:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7ff:	8b 40 04             	mov    0x4(%eax),%eax
c002b802:	83 ec 0c             	sub    $0xc,%esp
c002b805:	50                   	push   %eax
c002b806:	e8 b3 e7 ff ff       	call   c0029fbe <list_head>
c002b80b:	83 c4 10             	add    $0x10,%esp
c002b80e:	83 c0 04             	add    $0x4,%eax
c002b811:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b814:	8b 45 08             	mov    0x8(%ebp),%eax
c002b817:	89 50 08             	mov    %edx,0x8(%eax)
}
c002b81a:	90                   	nop
c002b81b:	c9                   	leave  
c002b81c:	c3                   	ret    

c002b81d <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002b81d:	55                   	push   %ebp
c002b81e:	89 e5                	mov    %esp,%ebp
c002b820:	53                   	push   %ebx
c002b821:	83 ec 04             	sub    $0x4,%esp
  ASSERT (i != NULL);
c002b824:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b828:	75 21                	jne    c002b84b <hash_next+0x2e>
c002b82a:	83 ec 0c             	sub    $0xc,%esp
c002b82d:	68 46 2c 03 c0       	push   $0xc0032c46
c002b832:	68 17 2c 03 c0       	push   $0xc0032c17
c002b837:	68 88 2c 03 c0       	push   $0xc0032c88
c002b83c:	68 dd 00 00 00       	push   $0xdd
c002b841:	68 2e 2c 03 c0       	push   $0xc0032c2e
c002b846:	e8 52 e3 ff ff       	call   c0029b9d <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002b84b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b84e:	8b 40 08             	mov    0x8(%eax),%eax
c002b851:	83 ec 0c             	sub    $0xc,%esp
c002b854:	50                   	push   %eax
c002b855:	e8 3b e6 ff ff       	call   c0029e95 <list_next>
c002b85a:	83 c4 10             	add    $0x10,%esp
c002b85d:	83 c0 04             	add    $0x4,%eax
c002b860:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b863:	8b 45 08             	mov    0x8(%ebp),%eax
c002b866:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b869:	eb 58                	jmp    c002b8c3 <hash_next+0xa6>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002b86b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b86e:	8b 40 04             	mov    0x4(%eax),%eax
c002b871:	8d 50 10             	lea    0x10(%eax),%edx
c002b874:	8b 45 08             	mov    0x8(%ebp),%eax
c002b877:	89 50 04             	mov    %edx,0x4(%eax)
c002b87a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b87d:	8b 50 04             	mov    0x4(%eax),%edx
c002b880:	8b 45 08             	mov    0x8(%ebp),%eax
c002b883:	8b 00                	mov    (%eax),%eax
c002b885:	8b 48 08             	mov    0x8(%eax),%ecx
c002b888:	8b 45 08             	mov    0x8(%ebp),%eax
c002b88b:	8b 00                	mov    (%eax),%eax
c002b88d:	8b 40 04             	mov    0x4(%eax),%eax
c002b890:	c1 e0 04             	shl    $0x4,%eax
c002b893:	01 c8                	add    %ecx,%eax
c002b895:	39 c2                	cmp    %eax,%edx
c002b897:	72 0c                	jb     c002b8a5 <hash_next+0x88>
        {
          i->elem = NULL;
c002b899:	8b 45 08             	mov    0x8(%ebp),%eax
c002b89c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          break;
c002b8a3:	eb 40                	jmp    c002b8e5 <hash_next+0xc8>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002b8a5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8a8:	8b 40 04             	mov    0x4(%eax),%eax
c002b8ab:	83 ec 0c             	sub    $0xc,%esp
c002b8ae:	50                   	push   %eax
c002b8af:	e8 af e5 ff ff       	call   c0029e63 <list_begin>
c002b8b4:	83 c4 10             	add    $0x10,%esp
c002b8b7:	83 c0 04             	add    $0x4,%eax
c002b8ba:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b8bd:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8c0:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b8c3:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8c6:	8b 58 08             	mov    0x8(%eax),%ebx
c002b8c9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8cc:	8b 40 04             	mov    0x4(%eax),%eax
c002b8cf:	83 ec 0c             	sub    $0xc,%esp
c002b8d2:	50                   	push   %eax
c002b8d3:	e8 07 e6 ff ff       	call   c0029edf <list_end>
c002b8d8:	83 c4 10             	add    $0x10,%esp
c002b8db:	83 c0 04             	add    $0x4,%eax
c002b8de:	83 e8 04             	sub    $0x4,%eax
c002b8e1:	39 c3                	cmp    %eax,%ebx
c002b8e3:	74 86                	je     c002b86b <hash_next+0x4e>
    }
  
  return i->elem;
c002b8e5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8e8:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b8eb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b8ee:	c9                   	leave  
c002b8ef:	c3                   	ret    

c002b8f0 <hash_cur>:
/* Returns the current element in the hash table iteration, or a
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
c002b8f0:	55                   	push   %ebp
c002b8f1:	89 e5                	mov    %esp,%ebp
  return i->elem;
c002b8f3:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8f6:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b8f9:	5d                   	pop    %ebp
c002b8fa:	c3                   	ret    

c002b8fb <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
c002b8fb:	55                   	push   %ebp
c002b8fc:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt;
c002b8fe:	8b 45 08             	mov    0x8(%ebp),%eax
c002b901:	8b 00                	mov    (%eax),%eax
}
c002b903:	5d                   	pop    %ebp
c002b904:	c3                   	ret    

c002b905 <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
c002b905:	55                   	push   %ebp
c002b906:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt == 0;
c002b908:	8b 45 08             	mov    0x8(%ebp),%eax
c002b90b:	8b 00                	mov    (%eax),%eax
c002b90d:	85 c0                	test   %eax,%eax
c002b90f:	0f 94 c0             	sete   %al
}
c002b912:	5d                   	pop    %ebp
c002b913:	c3                   	ret    

c002b914 <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c002b914:	55                   	push   %ebp
c002b915:	89 e5                	mov    %esp,%ebp
c002b917:	83 ec 18             	sub    $0x18,%esp
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
c002b91a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b91d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);
c002b920:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b924:	75 21                	jne    c002b947 <hash_bytes+0x33>
c002b926:	83 ec 0c             	sub    $0xc,%esp
c002b929:	68 5a 2c 03 c0       	push   $0xc0032c5a
c002b92e:	68 17 2c 03 c0       	push   $0xc0032c17
c002b933:	68 94 2c 03 c0       	push   $0xc0032c94
c002b938:	68 10 01 00 00       	push   $0x110
c002b93d:	68 2e 2c 03 c0       	push   $0xc0032c2e
c002b942:	e8 56 e2 ff ff       	call   c0029b9d <debug_panic>

  hash = FNV_32_BASIS;
c002b947:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (size-- > 0)
c002b94e:	eb 30                	jmp    c002b980 <hash_bytes+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002b950:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b953:	89 d0                	mov    %edx,%eax
c002b955:	c1 e0 10             	shl    $0x10,%eax
c002b958:	01 d0                	add    %edx,%eax
c002b95a:	01 c0                	add    %eax,%eax
c002b95c:	01 d0                	add    %edx,%eax
c002b95e:	c1 e0 03             	shl    $0x3,%eax
c002b961:	01 d0                	add    %edx,%eax
c002b963:	c1 e0 03             	shl    $0x3,%eax
c002b966:	01 d0                	add    %edx,%eax
c002b968:	01 c0                	add    %eax,%eax
c002b96a:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002b96d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b970:	8d 50 01             	lea    0x1(%eax),%edx
c002b973:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b976:	8a 00                	mov    (%eax),%al
c002b978:	0f b6 c0             	movzbl %al,%eax
c002b97b:	31 c8                	xor    %ecx,%eax
c002b97d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (size-- > 0)
c002b980:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b983:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b986:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b989:	85 c0                	test   %eax,%eax
c002b98b:	75 c3                	jne    c002b950 <hash_bytes+0x3c>

  return hash;
c002b98d:	8b 45 f0             	mov    -0x10(%ebp),%eax
} 
c002b990:	c9                   	leave  
c002b991:	c3                   	ret    

c002b992 <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002b992:	55                   	push   %ebp
c002b993:	89 e5                	mov    %esp,%ebp
c002b995:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *s = (const unsigned char *) s_;
c002b998:	8b 45 08             	mov    0x8(%ebp),%eax
c002b99b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (s != NULL);
c002b99e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b9a2:	75 21                	jne    c002b9c5 <hash_string+0x33>
c002b9a4:	83 ec 0c             	sub    $0xc,%esp
c002b9a7:	68 66 2c 03 c0       	push   $0xc0032c66
c002b9ac:	68 17 2c 03 c0       	push   $0xc0032c17
c002b9b1:	68 a0 2c 03 c0       	push   $0xc0032ca0
c002b9b6:	68 20 01 00 00       	push   $0x120
c002b9bb:	68 2e 2c 03 c0       	push   $0xc0032c2e
c002b9c0:	e8 d8 e1 ff ff       	call   c0029b9d <debug_panic>

  hash = FNV_32_BASIS;
c002b9c5:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (*s != '\0')
c002b9cc:	eb 30                	jmp    c002b9fe <hash_string+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002b9ce:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b9d1:	89 d0                	mov    %edx,%eax
c002b9d3:	c1 e0 10             	shl    $0x10,%eax
c002b9d6:	01 d0                	add    %edx,%eax
c002b9d8:	01 c0                	add    %eax,%eax
c002b9da:	01 d0                	add    %edx,%eax
c002b9dc:	c1 e0 03             	shl    $0x3,%eax
c002b9df:	01 d0                	add    %edx,%eax
c002b9e1:	c1 e0 03             	shl    $0x3,%eax
c002b9e4:	01 d0                	add    %edx,%eax
c002b9e6:	01 c0                	add    %eax,%eax
c002b9e8:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002b9eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b9ee:	8d 50 01             	lea    0x1(%eax),%edx
c002b9f1:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b9f4:	8a 00                	mov    (%eax),%al
c002b9f6:	0f b6 c0             	movzbl %al,%eax
c002b9f9:	31 c8                	xor    %ecx,%eax
c002b9fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (*s != '\0')
c002b9fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ba01:	8a 00                	mov    (%eax),%al
c002ba03:	84 c0                	test   %al,%al
c002ba05:	75 c7                	jne    c002b9ce <hash_string+0x3c>

  return hash;
c002ba07:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002ba0a:	c9                   	leave  
c002ba0b:	c3                   	ret    

c002ba0c <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c002ba0c:	55                   	push   %ebp
c002ba0d:	89 e5                	mov    %esp,%ebp
c002ba0f:	83 ec 08             	sub    $0x8,%esp
  return hash_bytes (&i, sizeof i);
c002ba12:	83 ec 08             	sub    $0x8,%esp
c002ba15:	6a 04                	push   $0x4
c002ba17:	8d 45 08             	lea    0x8(%ebp),%eax
c002ba1a:	50                   	push   %eax
c002ba1b:	e8 f4 fe ff ff       	call   c002b914 <hash_bytes>
c002ba20:	83 c4 10             	add    $0x10,%esp
}
c002ba23:	c9                   	leave  
c002ba24:	c3                   	ret    

c002ba25 <find_bucket>:

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002ba25:	55                   	push   %ebp
c002ba26:	89 e5                	mov    %esp,%ebp
c002ba28:	83 ec 18             	sub    $0x18,%esp
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002ba2b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba2e:	8b 40 0c             	mov    0xc(%eax),%eax
c002ba31:	8b 55 08             	mov    0x8(%ebp),%edx
c002ba34:	8b 52 14             	mov    0x14(%edx),%edx
c002ba37:	83 ec 08             	sub    $0x8,%esp
c002ba3a:	52                   	push   %edx
c002ba3b:	ff 75 0c             	pushl  0xc(%ebp)
c002ba3e:	ff d0                	call   *%eax
c002ba40:	83 c4 10             	add    $0x10,%esp
c002ba43:	89 c2                	mov    %eax,%edx
c002ba45:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba48:	8b 40 04             	mov    0x4(%eax),%eax
c002ba4b:	48                   	dec    %eax
c002ba4c:	21 d0                	and    %edx,%eax
c002ba4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return &h->buckets[bucket_idx];
c002ba51:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba54:	8b 40 08             	mov    0x8(%eax),%eax
c002ba57:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002ba5a:	c1 e2 04             	shl    $0x4,%edx
c002ba5d:	01 d0                	add    %edx,%eax
}
c002ba5f:	c9                   	leave  
c002ba60:	c3                   	ret    

c002ba61 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002ba61:	55                   	push   %ebp
c002ba62:	89 e5                	mov    %esp,%ebp
c002ba64:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002ba67:	83 ec 0c             	sub    $0xc,%esp
c002ba6a:	ff 75 0c             	pushl  0xc(%ebp)
c002ba6d:	e8 f1 e3 ff ff       	call   c0029e63 <list_begin>
c002ba72:	83 c4 10             	add    $0x10,%esp
c002ba75:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002ba78:	eb 66                	jmp    c002bae0 <find_elem+0x7f>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
c002ba7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ba7d:	83 c0 04             	add    $0x4,%eax
c002ba80:	83 e8 04             	sub    $0x4,%eax
c002ba83:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002ba86:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba89:	8b 40 10             	mov    0x10(%eax),%eax
c002ba8c:	8b 55 08             	mov    0x8(%ebp),%edx
c002ba8f:	8b 52 14             	mov    0x14(%edx),%edx
c002ba92:	83 ec 04             	sub    $0x4,%esp
c002ba95:	52                   	push   %edx
c002ba96:	ff 75 10             	pushl  0x10(%ebp)
c002ba99:	ff 75 f0             	pushl  -0x10(%ebp)
c002ba9c:	ff d0                	call   *%eax
c002ba9e:	83 c4 10             	add    $0x10,%esp
c002baa1:	83 f0 01             	xor    $0x1,%eax
c002baa4:	84 c0                	test   %al,%al
c002baa6:	74 27                	je     c002bacf <find_elem+0x6e>
c002baa8:	8b 45 08             	mov    0x8(%ebp),%eax
c002baab:	8b 40 10             	mov    0x10(%eax),%eax
c002baae:	8b 55 08             	mov    0x8(%ebp),%edx
c002bab1:	8b 52 14             	mov    0x14(%edx),%edx
c002bab4:	83 ec 04             	sub    $0x4,%esp
c002bab7:	52                   	push   %edx
c002bab8:	ff 75 f0             	pushl  -0x10(%ebp)
c002babb:	ff 75 10             	pushl  0x10(%ebp)
c002babe:	ff d0                	call   *%eax
c002bac0:	83 c4 10             	add    $0x10,%esp
c002bac3:	83 f0 01             	xor    $0x1,%eax
c002bac6:	84 c0                	test   %al,%al
c002bac8:	74 05                	je     c002bacf <find_elem+0x6e>
        return hi; 
c002baca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bacd:	eb 29                	jmp    c002baf8 <find_elem+0x97>
  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002bacf:	83 ec 0c             	sub    $0xc,%esp
c002bad2:	ff 75 f4             	pushl  -0xc(%ebp)
c002bad5:	e8 bb e3 ff ff       	call   c0029e95 <list_next>
c002bada:	83 c4 10             	add    $0x10,%esp
c002badd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002bae0:	83 ec 0c             	sub    $0xc,%esp
c002bae3:	ff 75 0c             	pushl  0xc(%ebp)
c002bae6:	e8 f4 e3 ff ff       	call   c0029edf <list_end>
c002baeb:	83 c4 10             	add    $0x10,%esp
c002baee:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002baf1:	75 87                	jne    c002ba7a <find_elem+0x19>
    }
  return NULL;
c002baf3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002baf8:	c9                   	leave  
c002baf9:	c3                   	ret    

c002bafa <turn_off_least_1bit>:

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
c002bafa:	55                   	push   %ebp
c002bafb:	89 e5                	mov    %esp,%ebp
  return x & (x - 1);
c002bafd:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb00:	48                   	dec    %eax
c002bb01:	23 45 08             	and    0x8(%ebp),%eax
}
c002bb04:	5d                   	pop    %ebp
c002bb05:	c3                   	ret    

c002bb06 <is_power_of_2>:

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
c002bb06:	55                   	push   %ebp
c002bb07:	89 e5                	mov    %esp,%ebp
  return x != 0 && turn_off_least_1bit (x) == 0;
c002bb09:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bb0d:	74 16                	je     c002bb25 <is_power_of_2+0x1f>
c002bb0f:	ff 75 08             	pushl  0x8(%ebp)
c002bb12:	e8 e3 ff ff ff       	call   c002bafa <turn_off_least_1bit>
c002bb17:	83 c4 04             	add    $0x4,%esp
c002bb1a:	85 c0                	test   %eax,%eax
c002bb1c:	75 07                	jne    c002bb25 <is_power_of_2+0x1f>
c002bb1e:	b8 01 00 00 00       	mov    $0x1,%eax
c002bb23:	eb 05                	jmp    c002bb2a <is_power_of_2+0x24>
c002bb25:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002bb2a:	c9                   	leave  
c002bb2b:	c3                   	ret    

c002bb2c <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002bb2c:	55                   	push   %ebp
c002bb2d:	89 e5                	mov    %esp,%ebp
c002bb2f:	83 ec 38             	sub    $0x38,%esp
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002bb32:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002bb36:	75 21                	jne    c002bb59 <rehash+0x2d>
c002bb38:	83 ec 0c             	sub    $0xc,%esp
c002bb3b:	68 50 2c 03 c0       	push   $0xc0032c50
c002bb40:	68 17 2c 03 c0       	push   $0xc0032c17
c002bb45:	68 ac 2c 03 c0       	push   $0xc0032cac
c002bb4a:	68 66 01 00 00       	push   $0x166
c002bb4f:	68 2e 2c 03 c0       	push   $0xc0032c2e
c002bb54:	e8 44 e0 ff ff       	call   c0029b9d <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c002bb59:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb5c:	8b 40 08             	mov    0x8(%eax),%eax
c002bb5f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  old_bucket_cnt = h->bucket_cnt;
c002bb62:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb65:	8b 40 04             	mov    0x4(%eax),%eax
c002bb68:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002bb6b:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb6e:	8b 00                	mov    (%eax),%eax
c002bb70:	d1 e8                	shr    %eax
c002bb72:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (new_bucket_cnt < 4)
c002bb75:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002bb79:	77 1a                	ja     c002bb95 <rehash+0x69>
    new_bucket_cnt = 4;
c002bb7b:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002bb82:	eb 11                	jmp    c002bb95 <rehash+0x69>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);
c002bb84:	83 ec 0c             	sub    $0xc,%esp
c002bb87:	ff 75 f4             	pushl  -0xc(%ebp)
c002bb8a:	e8 6b ff ff ff       	call   c002bafa <turn_off_least_1bit>
c002bb8f:	83 c4 10             	add    $0x10,%esp
c002bb92:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002bb95:	83 ec 0c             	sub    $0xc,%esp
c002bb98:	ff 75 f4             	pushl  -0xc(%ebp)
c002bb9b:	e8 66 ff ff ff       	call   c002bb06 <is_power_of_2>
c002bba0:	83 c4 10             	add    $0x10,%esp
c002bba3:	85 c0                	test   %eax,%eax
c002bba5:	74 dd                	je     c002bb84 <rehash+0x58>

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002bba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bbaa:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002bbad:	0f 84 10 01 00 00    	je     c002bcc3 <rehash+0x197>
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002bbb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bbb6:	c1 e0 04             	shl    $0x4,%eax
c002bbb9:	83 ec 0c             	sub    $0xc,%esp
c002bbbc:	50                   	push   %eax
c002bbbd:	e8 f8 7e ff ff       	call   c0023aba <malloc>
c002bbc2:	83 c4 10             	add    $0x10,%esp
c002bbc5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (new_buckets == NULL) 
c002bbc8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002bbcc:	0f 84 f4 00 00 00    	je     c002bcc6 <rehash+0x19a>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002bbd2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002bbd9:	eb 1c                	jmp    c002bbf7 <rehash+0xcb>
    list_init (&new_buckets[i]);
c002bbdb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bbde:	c1 e0 04             	shl    $0x4,%eax
c002bbe1:	89 c2                	mov    %eax,%edx
c002bbe3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bbe6:	01 d0                	add    %edx,%eax
c002bbe8:	83 ec 0c             	sub    $0xc,%esp
c002bbeb:	50                   	push   %eax
c002bbec:	e8 1d e2 ff ff       	call   c0029e0e <list_init>
c002bbf1:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < new_bucket_cnt; i++) 
c002bbf4:	ff 45 f0             	incl   -0x10(%ebp)
c002bbf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bbfa:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002bbfd:	72 dc                	jb     c002bbdb <rehash+0xaf>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002bbff:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc02:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002bc05:	89 50 08             	mov    %edx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002bc08:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002bc0e:	89 50 04             	mov    %edx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002bc11:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002bc18:	e9 8a 00 00 00       	jmp    c002bca7 <rehash+0x17b>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002bc1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bc20:	c1 e0 04             	shl    $0x4,%eax
c002bc23:	89 c2                	mov    %eax,%edx
c002bc25:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bc28:	01 d0                	add    %edx,%eax
c002bc2a:	89 45 dc             	mov    %eax,-0x24(%ebp)
      for (elem = list_begin (old_bucket);
c002bc2d:	83 ec 0c             	sub    $0xc,%esp
c002bc30:	ff 75 dc             	pushl  -0x24(%ebp)
c002bc33:	e8 2b e2 ff ff       	call   c0029e63 <list_begin>
c002bc38:	83 c4 10             	add    $0x10,%esp
c002bc3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002bc3e:	eb 51                	jmp    c002bc91 <rehash+0x165>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002bc40:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bc43:	83 c0 04             	add    $0x4,%eax
c002bc46:	83 e8 04             	sub    $0x4,%eax
          struct list *new_bucket
c002bc49:	83 ec 08             	sub    $0x8,%esp
c002bc4c:	50                   	push   %eax
c002bc4d:	ff 75 08             	pushl  0x8(%ebp)
c002bc50:	e8 d0 fd ff ff       	call   c002ba25 <find_bucket>
c002bc55:	83 c4 10             	add    $0x10,%esp
c002bc58:	89 45 d8             	mov    %eax,-0x28(%ebp)
          next = list_next (elem);
c002bc5b:	83 ec 0c             	sub    $0xc,%esp
c002bc5e:	ff 75 ec             	pushl  -0x14(%ebp)
c002bc61:	e8 2f e2 ff ff       	call   c0029e95 <list_next>
c002bc66:	83 c4 10             	add    $0x10,%esp
c002bc69:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          list_remove (elem);
c002bc6c:	83 ec 0c             	sub    $0xc,%esp
c002bc6f:	ff 75 ec             	pushl  -0x14(%ebp)
c002bc72:	e8 9d e5 ff ff       	call   c002a214 <list_remove>
c002bc77:	83 c4 10             	add    $0x10,%esp
          list_push_front (new_bucket, elem);
c002bc7a:	83 ec 08             	sub    $0x8,%esp
c002bc7d:	ff 75 ec             	pushl  -0x14(%ebp)
c002bc80:	ff 75 d8             	pushl  -0x28(%ebp)
c002bc83:	e8 40 e5 ff ff       	call   c002a1c8 <list_push_front>
c002bc88:	83 c4 10             	add    $0x10,%esp
           elem != list_end (old_bucket); elem = next) 
c002bc8b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002bc8e:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002bc91:	83 ec 0c             	sub    $0xc,%esp
c002bc94:	ff 75 dc             	pushl  -0x24(%ebp)
c002bc97:	e8 43 e2 ff ff       	call   c0029edf <list_end>
c002bc9c:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (old_bucket);
c002bc9f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002bca2:	75 9c                	jne    c002bc40 <rehash+0x114>
  for (i = 0; i < old_bucket_cnt; i++) 
c002bca4:	ff 45 f0             	incl   -0x10(%ebp)
c002bca7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bcaa:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002bcad:	0f 82 6a ff ff ff    	jb     c002bc1d <rehash+0xf1>
        }
    }

  free (old_buckets);
c002bcb3:	83 ec 0c             	sub    $0xc,%esp
c002bcb6:	ff 75 e8             	pushl  -0x18(%ebp)
c002bcb9:	e8 fe 80 ff ff       	call   c0023dbc <free>
c002bcbe:	83 c4 10             	add    $0x10,%esp
c002bcc1:	eb 04                	jmp    c002bcc7 <rehash+0x19b>
    return;
c002bcc3:	90                   	nop
c002bcc4:	eb 01                	jmp    c002bcc7 <rehash+0x19b>
      return;
c002bcc6:	90                   	nop
}
c002bcc7:	c9                   	leave  
c002bcc8:	c3                   	ret    

c002bcc9 <insert_elem>:

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002bcc9:	55                   	push   %ebp
c002bcca:	89 e5                	mov    %esp,%ebp
c002bccc:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt++;
c002bccf:	8b 45 08             	mov    0x8(%ebp),%eax
c002bcd2:	8b 00                	mov    (%eax),%eax
c002bcd4:	8d 50 01             	lea    0x1(%eax),%edx
c002bcd7:	8b 45 08             	mov    0x8(%ebp),%eax
c002bcda:	89 10                	mov    %edx,(%eax)
  list_push_front (bucket, &e->list_elem);
c002bcdc:	8b 45 10             	mov    0x10(%ebp),%eax
c002bcdf:	83 ec 08             	sub    $0x8,%esp
c002bce2:	50                   	push   %eax
c002bce3:	ff 75 0c             	pushl  0xc(%ebp)
c002bce6:	e8 dd e4 ff ff       	call   c002a1c8 <list_push_front>
c002bceb:	83 c4 10             	add    $0x10,%esp
}
c002bcee:	90                   	nop
c002bcef:	c9                   	leave  
c002bcf0:	c3                   	ret    

c002bcf1 <remove_elem>:

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
c002bcf1:	55                   	push   %ebp
c002bcf2:	89 e5                	mov    %esp,%ebp
c002bcf4:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt--;
c002bcf7:	8b 45 08             	mov    0x8(%ebp),%eax
c002bcfa:	8b 00                	mov    (%eax),%eax
c002bcfc:	8d 50 ff             	lea    -0x1(%eax),%edx
c002bcff:	8b 45 08             	mov    0x8(%ebp),%eax
c002bd02:	89 10                	mov    %edx,(%eax)
  list_remove (&e->list_elem);
c002bd04:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bd07:	83 ec 0c             	sub    $0xc,%esp
c002bd0a:	50                   	push   %eax
c002bd0b:	e8 04 e5 ff ff       	call   c002a214 <list_remove>
c002bd10:	83 c4 10             	add    $0x10,%esp
}
c002bd13:	90                   	nop
c002bd14:	c9                   	leave  
c002bd15:	c3                   	ret    

c002bd16 <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c002bd16:	55                   	push   %ebp
c002bd17:	89 e5                	mov    %esp,%ebp
c002bd19:	83 ec 08             	sub    $0x8,%esp
  lock_init (&console_lock);
c002bd1c:	83 ec 0c             	sub    $0xc,%esp
c002bd1f:	68 20 a6 03 c0       	push   $0xc003a620
c002bd24:	e8 25 73 ff ff       	call   c002304e <lock_init>
c002bd29:	83 c4 10             	add    $0x10,%esp
  use_console_lock = true;
c002bd2c:	c6 05 40 a6 03 c0 01 	movb   $0x1,0xc003a640
}
c002bd33:	90                   	nop
c002bd34:	c9                   	leave  
c002bd35:	c3                   	ret    

c002bd36 <console_panic>:
/* Notifies the console that a kernel panic is underway,
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
c002bd36:	55                   	push   %ebp
c002bd37:	89 e5                	mov    %esp,%ebp
  use_console_lock = false;
c002bd39:	c6 05 40 a6 03 c0 00 	movb   $0x0,0xc003a640
}
c002bd40:	90                   	nop
c002bd41:	5d                   	pop    %ebp
c002bd42:	c3                   	ret    

c002bd43 <console_print_stats>:

/* Prints console statistics. */
void
console_print_stats (void) 
{
c002bd43:	55                   	push   %ebp
c002bd44:	89 e5                	mov    %esp,%ebp
c002bd46:	83 ec 08             	sub    $0x8,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002bd49:	a1 48 a6 03 c0       	mov    0xc003a648,%eax
c002bd4e:	8b 15 4c a6 03 c0    	mov    0xc003a64c,%edx
c002bd54:	83 ec 04             	sub    $0x4,%esp
c002bd57:	52                   	push   %edx
c002bd58:	50                   	push   %eax
c002bd59:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002bd5e:	e8 7b ba ff ff       	call   c00277de <printf>
c002bd63:	83 c4 10             	add    $0x10,%esp
}
c002bd66:	90                   	nop
c002bd67:	c9                   	leave  
c002bd68:	c3                   	ret    

c002bd69 <acquire_console>:

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c002bd69:	55                   	push   %ebp
c002bd6a:	89 e5                	mov    %esp,%ebp
c002bd6c:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002bd6f:	e8 f0 5e ff ff       	call   c0021c64 <intr_context>
c002bd74:	83 f0 01             	xor    $0x1,%eax
c002bd77:	84 c0                	test   %al,%al
c002bd79:	74 3a                	je     c002bdb5 <acquire_console+0x4c>
c002bd7b:	a0 40 a6 03 c0       	mov    0xc003a640,%al
c002bd80:	84 c0                	test   %al,%al
c002bd82:	74 31                	je     c002bdb5 <acquire_console+0x4c>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c002bd84:	83 ec 0c             	sub    $0xc,%esp
c002bd87:	68 20 a6 03 c0       	push   $0xc003a620
c002bd8c:	e8 18 75 ff ff       	call   c00232a9 <lock_held_by_current_thread>
c002bd91:	83 c4 10             	add    $0x10,%esp
c002bd94:	84 c0                	test   %al,%al
c002bd96:	74 0d                	je     c002bda5 <acquire_console+0x3c>
        console_lock_depth++; 
c002bd98:	a1 44 a6 03 c0       	mov    0xc003a644,%eax
c002bd9d:	40                   	inc    %eax
c002bd9e:	a3 44 a6 03 c0       	mov    %eax,0xc003a644
      else
        lock_acquire (&console_lock); 
    }
}
c002bda3:	eb 10                	jmp    c002bdb5 <acquire_console+0x4c>
        lock_acquire (&console_lock); 
c002bda5:	83 ec 0c             	sub    $0xc,%esp
c002bda8:	68 20 a6 03 c0       	push   $0xc003a620
c002bdad:	e8 e9 72 ff ff       	call   c002309b <lock_acquire>
c002bdb2:	83 c4 10             	add    $0x10,%esp
}
c002bdb5:	90                   	nop
c002bdb6:	c9                   	leave  
c002bdb7:	c3                   	ret    

c002bdb8 <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c002bdb8:	55                   	push   %ebp
c002bdb9:	89 e5                	mov    %esp,%ebp
c002bdbb:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002bdbe:	e8 a1 5e ff ff       	call   c0021c64 <intr_context>
c002bdc3:	83 f0 01             	xor    $0x1,%eax
c002bdc6:	84 c0                	test   %al,%al
c002bdc8:	74 2f                	je     c002bdf9 <release_console+0x41>
c002bdca:	a0 40 a6 03 c0       	mov    0xc003a640,%al
c002bdcf:	84 c0                	test   %al,%al
c002bdd1:	74 26                	je     c002bdf9 <release_console+0x41>
    {
      if (console_lock_depth > 0)
c002bdd3:	a1 44 a6 03 c0       	mov    0xc003a644,%eax
c002bdd8:	85 c0                	test   %eax,%eax
c002bdda:	7e 0d                	jle    c002bde9 <release_console+0x31>
        console_lock_depth--;
c002bddc:	a1 44 a6 03 c0       	mov    0xc003a644,%eax
c002bde1:	48                   	dec    %eax
c002bde2:	a3 44 a6 03 c0       	mov    %eax,0xc003a644
      else
        lock_release (&console_lock); 
    }
}
c002bde7:	eb 10                	jmp    c002bdf9 <release_console+0x41>
        lock_release (&console_lock); 
c002bde9:	83 ec 0c             	sub    $0xc,%esp
c002bdec:	68 20 a6 03 c0       	push   $0xc003a620
c002bdf1:	e8 23 74 ff ff       	call   c0023219 <lock_release>
c002bdf6:	83 c4 10             	add    $0x10,%esp
}
c002bdf9:	90                   	nop
c002bdfa:	c9                   	leave  
c002bdfb:	c3                   	ret    

c002bdfc <console_locked_by_current_thread>:

/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
c002bdfc:	55                   	push   %ebp
c002bdfd:	89 e5                	mov    %esp,%ebp
c002bdff:	83 ec 08             	sub    $0x8,%esp
  return (intr_context ()
c002be02:	e8 5d 5e ff ff       	call   c0021c64 <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c002be07:	84 c0                	test   %al,%al
c002be09:	75 20                	jne    c002be2b <console_locked_by_current_thread+0x2f>
          || !use_console_lock
c002be0b:	a0 40 a6 03 c0       	mov    0xc003a640,%al
c002be10:	83 f0 01             	xor    $0x1,%eax
c002be13:	84 c0                	test   %al,%al
c002be15:	75 14                	jne    c002be2b <console_locked_by_current_thread+0x2f>
          || lock_held_by_current_thread (&console_lock));
c002be17:	83 ec 0c             	sub    $0xc,%esp
c002be1a:	68 20 a6 03 c0       	push   $0xc003a620
c002be1f:	e8 85 74 ff ff       	call   c00232a9 <lock_held_by_current_thread>
c002be24:	83 c4 10             	add    $0x10,%esp
c002be27:	84 c0                	test   %al,%al
c002be29:	74 07                	je     c002be32 <console_locked_by_current_thread+0x36>
c002be2b:	b8 01 00 00 00       	mov    $0x1,%eax
c002be30:	eb 05                	jmp    c002be37 <console_locked_by_current_thread+0x3b>
c002be32:	b8 00 00 00 00       	mov    $0x0,%eax
c002be37:	83 e0 01             	and    $0x1,%eax
}
c002be3a:	c9                   	leave  
c002be3b:	c3                   	ret    

c002be3c <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c002be3c:	55                   	push   %ebp
c002be3d:	89 e5                	mov    %esp,%ebp
c002be3f:	83 ec 18             	sub    $0x18,%esp
  int char_cnt = 0;
c002be42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  acquire_console ();
c002be49:	e8 1b ff ff ff       	call   c002bd69 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002be4e:	8d 45 f4             	lea    -0xc(%ebp),%eax
c002be51:	50                   	push   %eax
c002be52:	68 1b bf 02 c0       	push   $0xc002bf1b
c002be57:	ff 75 0c             	pushl  0xc(%ebp)
c002be5a:	ff 75 08             	pushl  0x8(%ebp)
c002be5d:	e8 a2 b9 ff ff       	call   c0027804 <__vprintf>
c002be62:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002be65:	e8 4e ff ff ff       	call   c002bdb8 <release_console>

  return char_cnt;
c002be6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002be6d:	c9                   	leave  
c002be6e:	c3                   	ret    

c002be6f <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c002be6f:	55                   	push   %ebp
c002be70:	89 e5                	mov    %esp,%ebp
c002be72:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002be75:	e8 ef fe ff ff       	call   c002bd69 <acquire_console>
  while (*s != '\0')
c002be7a:	eb 1a                	jmp    c002be96 <puts+0x27>
    putchar_have_lock (*s++);
c002be7c:	8b 45 08             	mov    0x8(%ebp),%eax
c002be7f:	8d 50 01             	lea    0x1(%eax),%edx
c002be82:	89 55 08             	mov    %edx,0x8(%ebp)
c002be85:	8a 00                	mov    (%eax),%al
c002be87:	0f b6 c0             	movzbl %al,%eax
c002be8a:	83 ec 0c             	sub    $0xc,%esp
c002be8d:	50                   	push   %eax
c002be8e:	e8 bc 00 00 00       	call   c002bf4f <putchar_have_lock>
c002be93:	83 c4 10             	add    $0x10,%esp
  while (*s != '\0')
c002be96:	8b 45 08             	mov    0x8(%ebp),%eax
c002be99:	8a 00                	mov    (%eax),%al
c002be9b:	84 c0                	test   %al,%al
c002be9d:	75 dd                	jne    c002be7c <puts+0xd>
  putchar_have_lock ('\n');
c002be9f:	83 ec 0c             	sub    $0xc,%esp
c002bea2:	6a 0a                	push   $0xa
c002bea4:	e8 a6 00 00 00       	call   c002bf4f <putchar_have_lock>
c002bea9:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002beac:	e8 07 ff ff ff       	call   c002bdb8 <release_console>

  return 0;
c002beb1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002beb6:	c9                   	leave  
c002beb7:	c3                   	ret    

c002beb8 <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c002beb8:	55                   	push   %ebp
c002beb9:	89 e5                	mov    %esp,%ebp
c002bebb:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002bebe:	e8 a6 fe ff ff       	call   c002bd69 <acquire_console>
  while (n-- > 0)
c002bec3:	eb 1a                	jmp    c002bedf <putbuf+0x27>
    putchar_have_lock (*buffer++);
c002bec5:	8b 45 08             	mov    0x8(%ebp),%eax
c002bec8:	8d 50 01             	lea    0x1(%eax),%edx
c002becb:	89 55 08             	mov    %edx,0x8(%ebp)
c002bece:	8a 00                	mov    (%eax),%al
c002bed0:	0f b6 c0             	movzbl %al,%eax
c002bed3:	83 ec 0c             	sub    $0xc,%esp
c002bed6:	50                   	push   %eax
c002bed7:	e8 73 00 00 00       	call   c002bf4f <putchar_have_lock>
c002bedc:	83 c4 10             	add    $0x10,%esp
  while (n-- > 0)
c002bedf:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bee2:	8d 50 ff             	lea    -0x1(%eax),%edx
c002bee5:	89 55 0c             	mov    %edx,0xc(%ebp)
c002bee8:	85 c0                	test   %eax,%eax
c002beea:	75 d9                	jne    c002bec5 <putbuf+0xd>
  release_console ();
c002beec:	e8 c7 fe ff ff       	call   c002bdb8 <release_console>
}
c002bef1:	90                   	nop
c002bef2:	c9                   	leave  
c002bef3:	c3                   	ret    

c002bef4 <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c002bef4:	55                   	push   %ebp
c002bef5:	89 e5                	mov    %esp,%ebp
c002bef7:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002befa:	e8 6a fe ff ff       	call   c002bd69 <acquire_console>
  putchar_have_lock (c);
c002beff:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf02:	0f b6 c0             	movzbl %al,%eax
c002bf05:	83 ec 0c             	sub    $0xc,%esp
c002bf08:	50                   	push   %eax
c002bf09:	e8 41 00 00 00       	call   c002bf4f <putchar_have_lock>
c002bf0e:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002bf11:	e8 a2 fe ff ff       	call   c002bdb8 <release_console>
  
  return c;
c002bf16:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002bf19:	c9                   	leave  
c002bf1a:	c3                   	ret    

c002bf1b <vprintf_helper>:

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c002bf1b:	55                   	push   %ebp
c002bf1c:	89 e5                	mov    %esp,%ebp
c002bf1e:	83 ec 28             	sub    $0x28,%esp
c002bf21:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf24:	88 45 e4             	mov    %al,-0x1c(%ebp)
  int *char_cnt = char_cnt_;
c002bf27:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bf2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  (*char_cnt)++;
c002bf2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf30:	8b 00                	mov    (%eax),%eax
c002bf32:	8d 50 01             	lea    0x1(%eax),%edx
c002bf35:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf38:	89 10                	mov    %edx,(%eax)
  putchar_have_lock (c);
c002bf3a:	8a 45 e4             	mov    -0x1c(%ebp),%al
c002bf3d:	0f b6 c0             	movzbl %al,%eax
c002bf40:	83 ec 0c             	sub    $0xc,%esp
c002bf43:	50                   	push   %eax
c002bf44:	e8 06 00 00 00       	call   c002bf4f <putchar_have_lock>
c002bf49:	83 c4 10             	add    $0x10,%esp
}
c002bf4c:	90                   	nop
c002bf4d:	c9                   	leave  
c002bf4e:	c3                   	ret    

c002bf4f <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002bf4f:	55                   	push   %ebp
c002bf50:	89 e5                	mov    %esp,%ebp
c002bf52:	83 ec 18             	sub    $0x18,%esp
c002bf55:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf58:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (console_locked_by_current_thread ());
c002bf5b:	e8 9c fe ff ff       	call   c002bdfc <console_locked_by_current_thread>
c002bf60:	84 c0                	test   %al,%al
c002bf62:	75 21                	jne    c002bf85 <putchar_have_lock+0x36>
c002bf64:	83 ec 0c             	sub    $0xc,%esp
c002bf67:	68 d8 2c 03 c0       	push   $0xc0032cd8
c002bf6c:	68 fc 2c 03 c0       	push   $0xc0032cfc
c002bf71:	68 30 2d 03 c0       	push   $0xc0032d30
c002bf76:	68 bb 00 00 00       	push   $0xbb
c002bf7b:	68 13 2d 03 c0       	push   $0xc0032d13
c002bf80:	e8 18 dc ff ff       	call   c0029b9d <debug_panic>
  write_cnt++;
c002bf85:	a1 48 a6 03 c0       	mov    0xc003a648,%eax
c002bf8a:	8b 15 4c a6 03 c0    	mov    0xc003a64c,%edx
c002bf90:	83 c0 01             	add    $0x1,%eax
c002bf93:	83 d2 00             	adc    $0x0,%edx
c002bf96:	a3 48 a6 03 c0       	mov    %eax,0xc003a648
c002bf9b:	89 15 4c a6 03 c0    	mov    %edx,0xc003a64c
  serial_putc (c);
c002bfa1:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002bfa5:	83 ec 0c             	sub    $0xc,%esp
c002bfa8:	50                   	push   %eax
c002bfa9:	e8 4b 90 ff ff       	call   c0024ff9 <serial_putc>
c002bfae:	83 c4 10             	add    $0x10,%esp
  vga_putc (c);
c002bfb1:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002bfb5:	83 ec 0c             	sub    $0xc,%esp
c002bfb8:	50                   	push   %eax
c002bfb9:	e8 d3 8b ff ff       	call   c0024b91 <vga_putc>
c002bfbe:	83 c4 10             	add    $0x10,%esp
}
c002bfc1:	90                   	nop
c002bfc2:	c9                   	leave  
c002bfc3:	c3                   	ret    

c002bfc4 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c002bfc4:	55                   	push   %ebp
c002bfc5:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c002bfc7:	8b 45 08             	mov    0x8(%ebp),%eax
c002bfca:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002bfcf:	5d                   	pop    %ebp
c002bfd0:	c3                   	ret    

c002bfd1 <is_user_vaddr>:
{
c002bfd1:	55                   	push   %ebp
c002bfd2:	89 e5                	mov    %esp,%ebp
  return vaddr < PHYS_BASE;
c002bfd4:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c002bfdb:	0f 96 c0             	setbe  %al
}
c002bfde:	5d                   	pop    %ebp
c002bfdf:	c3                   	ret    

c002bfe0 <process_execute>:
/* Starts a new thread running a user program loaded from
   FILENAME.  The new thread may be scheduled (and may even exit)
   before process_execute() returns.  Returns the new process's
   thread id, or TID_ERROR if the thread cannot be created. */
tid_t process_execute(const char *file_name)
{
c002bfe0:	55                   	push   %ebp
c002bfe1:	89 e5                	mov    %esp,%ebp
c002bfe3:	83 ec 18             	sub    $0x18,%esp
  char *file_name_copy;
  tid_t tid;

  /* Make a copy of FILE_NAME.
     Otherwise there's a race between the caller and load(). */
  file_name_copy = palloc_get_page(0);
c002bfe6:	83 ec 0c             	sub    $0xc,%esp
c002bfe9:	6a 00                	push   $0x0
c002bfeb:	e8 7f 77 ff ff       	call   c002376f <palloc_get_page>
c002bff0:	83 c4 10             	add    $0x10,%esp
c002bff3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file_name_copy == NULL)
c002bff6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002bffa:	75 07                	jne    c002c003 <process_execute+0x23>
    return TID_ERROR;
c002bffc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002c001:	eb 5f                	jmp    c002c062 <process_execute+0x82>
  strlcpy(file_name_copy, file_name, PGSIZE);
c002c003:	83 ec 04             	sub    $0x4,%esp
c002c006:	68 00 10 00 00       	push   $0x1000
c002c00b:	ff 75 08             	pushl  0x8(%ebp)
c002c00e:	ff 75 f4             	pushl  -0xc(%ebp)
c002c011:	e8 74 d0 ff ff       	call   c002908a <strlcpy>
c002c016:	83 c4 10             	add    $0x10,%esp

  // create pointers and separate arguments
  char *token_pointer, *save_pointer;
  token_pointer = strtok_r(file_name, " ", &save_pointer);
c002c019:	83 ec 04             	sub    $0x4,%esp
c002c01c:	8d 45 e8             	lea    -0x18(%ebp),%eax
c002c01f:	50                   	push   %eax
c002c020:	68 44 2d 03 c0       	push   $0xc0032d44
c002c025:	ff 75 08             	pushl  0x8(%ebp)
c002c028:	e8 7c ce ff ff       	call   c0028ea9 <strtok_r>
c002c02d:	83 c4 10             	add    $0x10,%esp
c002c030:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Create a new thread to execute FILE_NAME. */
  tid = thread_create(token_pointer, PRI_DEFAULT, start_process, file_name_copy);
c002c033:	ff 75 f4             	pushl  -0xc(%ebp)
c002c036:	68 64 c0 02 c0       	push   $0xc002c064
c002c03b:	6a 1f                	push   $0x1f
c002c03d:	ff 75 f0             	pushl  -0x10(%ebp)
c002c040:	e8 18 4e ff ff       	call   c0020e5d <thread_create>
c002c045:	83 c4 10             	add    $0x10,%esp
c002c048:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (tid == TID_ERROR)
c002c04b:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c002c04f:	75 0e                	jne    c002c05f <process_execute+0x7f>
    palloc_free_page(file_name_copy);
c002c051:	83 ec 0c             	sub    $0xc,%esp
c002c054:	ff 75 f4             	pushl  -0xc(%ebp)
c002c057:	e8 6b 78 ff ff       	call   c00238c7 <palloc_free_page>
c002c05c:	83 c4 10             	add    $0x10,%esp
  return tid;
c002c05f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c002c062:	c9                   	leave  
c002c063:	c3                   	ret    

c002c064 <start_process>:

/* A thread function that loads a user process and starts it
   running. */
static void
start_process(void *file_name_)
{
c002c064:	55                   	push   %ebp
c002c065:	89 e5                	mov    %esp,%ebp
c002c067:	83 ec 68             	sub    $0x68,%esp
  char *file_name = file_name_;
c002c06a:	8b 45 08             	mov    0x8(%ebp),%eax
c002c06d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct intr_frame if_;
  bool success;

  /* Initialize interrupt frame and load executable. */
  memset(&if_, 0, sizeof if_);
c002c070:	83 ec 04             	sub    $0x4,%esp
c002c073:	6a 50                	push   $0x50
c002c075:	6a 00                	push   $0x0
c002c077:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002c07a:	50                   	push   %eax
c002c07b:	e8 37 cf ff ff       	call   c0028fb7 <memset>
c002c080:	83 c4 10             	add    $0x10,%esp
  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
c002c083:	66 c7 45 ec 23 00    	movw   $0x23,-0x14(%ebp)
c002c089:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c08c:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
c002c090:	8b 45 cc             	mov    -0x34(%ebp),%eax
c002c093:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
c002c097:	8b 45 c8             	mov    -0x38(%ebp),%eax
c002c09a:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
c002c09e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c002c0a1:	66 89 45 c0          	mov    %ax,-0x40(%ebp)
  if_.cs = SEL_UCSEG;
c002c0a5:	66 c7 45 e0 1b 00    	movw   $0x1b,-0x20(%ebp)
  if_.eflags = FLAG_IF | FLAG_MBS;
c002c0ab:	c7 45 e4 02 02 00 00 	movl   $0x202,-0x1c(%ebp)

  success = load(file_name, &if_.eip, &if_.esp);
c002c0b2:	83 ec 04             	sub    $0x4,%esp
c002c0b5:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002c0b8:	83 c0 48             	add    $0x48,%eax
c002c0bb:	50                   	push   %eax
c002c0bc:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002c0bf:	83 c0 3c             	add    $0x3c,%eax
c002c0c2:	50                   	push   %eax
c002c0c3:	ff 75 f4             	pushl  -0xc(%ebp)
c002c0c6:	e8 ec 01 00 00       	call   c002c2b7 <load>
c002c0cb:	83 c4 10             	add    $0x10,%esp
c002c0ce:	88 45 f3             	mov    %al,-0xd(%ebp)

  /* Update the load status of the child process based on the success of the load operation
If the load operation was successful, set the load status to LOADED
If the load operation was not successful, set the load status to LOAD_FAILED
Signal the completion of the load process by calling semaphore_up on the load_sema semaphore */
  if (success)
c002c0d1:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c002c0d5:	74 11                	je     c002c0e8 <start_process+0x84>
    thread_current()->child_process->load_status = LOADED;
c002c0d7:	e8 da 4f ff ff       	call   c00210b6 <thread_current>
c002c0dc:	8b 40 70             	mov    0x70(%eax),%eax
c002c0df:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
c002c0e6:	eb 0f                	jmp    c002c0f7 <start_process+0x93>
  else
    thread_current()->child_process->load_status = LOAD_FAILED;
c002c0e8:	e8 c9 4f ff ff       	call   c00210b6 <thread_current>
c002c0ed:	8b 40 70             	mov    0x70(%eax),%eax
c002c0f0:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)

  semaphore_up(&thread_current()->child_process->load_semaphore);
c002c0f7:	e8 ba 4f ff ff       	call   c00210b6 <thread_current>
c002c0fc:	8b 40 70             	mov    0x70(%eax),%eax
c002c0ff:	83 c0 14             	add    $0x14,%eax
c002c102:	83 ec 0c             	sub    $0xc,%esp
c002c105:	50                   	push   %eax
c002c106:	e8 dc 6d ff ff       	call   c0022ee7 <semaphore_up>
c002c10b:	83 c4 10             	add    $0x10,%esp

  /* If load failed, quit. */
  palloc_free_page(file_name);
c002c10e:	83 ec 0c             	sub    $0xc,%esp
c002c111:	ff 75 f4             	pushl  -0xc(%ebp)
c002c114:	e8 ae 77 ff ff       	call   c00238c7 <palloc_free_page>
c002c119:	83 c4 10             	add    $0x10,%esp
  if (!success)
c002c11c:	8a 45 f3             	mov    -0xd(%ebp),%al
c002c11f:	83 f0 01             	xor    $0x1,%eax
c002c122:	84 c0                	test   %al,%al
c002c124:	74 05                	je     c002c12b <start_process+0xc7>
    thread_exit();
c002c126:	e8 0b 50 ff ff       	call   c0021136 <thread_exit>
     interrupt, implemented by intr_exit (in
     threads/intr-stubs.S).  Because intr_exit takes all of its
     arguments on the stack in the form of a `struct intr_frame',
     we just point the stack pointer (%esp) to our stack frame
     and jump to it. */
  asm volatile("movl %0, %%esp; jmp intr_exit"
c002c12b:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002c12e:	89 c4                	mov    %eax,%esp
c002c130:	e9 cb 60 ff ff       	jmp    c0022200 <intr_exit>
               :
               : "g"(&if_)
               : "memory");
  NOT_REACHED();
c002c135:	68 48 2d 03 c0       	push   $0xc0032d48
c002c13a:	68 2c 2e 03 c0       	push   $0xc0032e2c
c002c13f:	6a 61                	push   $0x61
c002c141:	68 6a 2d 03 c0       	push   $0xc0032d6a
c002c146:	e8 52 da ff ff       	call   c0029b9d <debug_panic>

c002c14b <process_wait>:
child of the calling process, or if process_wait() has already
been successfully called for the given TID, returns -1
immediately, without waiting.
*/
int process_wait(tid_t child_tid UNUSED)
{
c002c14b:	55                   	push   %ebp
c002c14c:	89 e5                	mov    %esp,%ebp
c002c14e:	83 ec 18             	sub    $0x18,%esp

  /* Find the child process structure for the child with the specified child_tid */
  struct child_process *child_process_pointer = find_child(child_tid);
c002c151:	83 ec 0c             	sub    $0xc,%esp
c002c154:	ff 75 08             	pushl  0x8(%ebp)
c002c157:	e8 b0 1c 00 00       	call   c002de0c <find_child>
c002c15c:	83 c4 10             	add    $0x10,%esp
c002c15f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* If the child process structure is not found, return SYS_ERROR */
  if (!child_process_pointer)
c002c162:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002c166:	75 07                	jne    c002c16f <process_wait+0x24>
    return SYS_ERROR;
c002c168:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002c16d:	eb 53                	jmp    c002c1c2 <process_wait+0x77>

  /* Set the wait flag for the child process */
  if (child_process_pointer->wait)
c002c16f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c172:	8b 40 08             	mov    0x8(%eax),%eax
c002c175:	85 c0                	test   %eax,%eax
c002c177:	74 07                	je     c002c180 <process_wait+0x35>
    return SYS_ERROR;
c002c179:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002c17e:	eb 42                	jmp    c002c1c2 <process_wait+0x77>

  /* Set the wait flag for the child process */
  child_process_pointer->wait = 1;
c002c180:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c183:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

  /* Wait for the exit of the child process */
  while (!child_process_pointer->exit)
c002c18a:	eb 00                	jmp    c002c18c <process_wait+0x41>
c002c18c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c18f:	8b 40 0c             	mov    0xc(%eax),%eax
c002c192:	85 c0                	test   %eax,%eax
c002c194:	74 f6                	je     c002c18c <process_wait+0x41>
   * compile-time memory barrier
   * that won't allow reordering any memory access instructions:
   */

  /* Retrieve the exit status of the child process */
  int status = child_process_pointer->status;
c002c196:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c199:	8b 40 10             	mov    0x10(%eax),%eax
c002c19c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  list_remove(&child_process_pointer->elem);
c002c19f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c1a2:	83 c0 3c             	add    $0x3c,%eax
c002c1a5:	83 ec 0c             	sub    $0xc,%esp
c002c1a8:	50                   	push   %eax
c002c1a9:	e8 66 e0 ff ff       	call   c002a214 <list_remove>
c002c1ae:	83 c4 10             	add    $0x10,%esp
  free(child_process_pointer);
c002c1b1:	83 ec 0c             	sub    $0xc,%esp
c002c1b4:	ff 75 f4             	pushl  -0xc(%ebp)
c002c1b7:	e8 00 7c ff ff       	call   c0023dbc <free>
c002c1bc:	83 c4 10             	add    $0x10,%esp

  // child_remove(child_process_pointer);

  return status;
c002c1bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002c1c2:	c9                   	leave  
c002c1c3:	c3                   	ret    

c002c1c4 <process_exit>:

void process_exit(void)
{
c002c1c4:	55                   	push   %ebp
c002c1c5:	89 e5                	mov    %esp,%ebp
c002c1c7:	83 ec 18             	sub    $0x18,%esp

  struct thread *current_thread = thread_current();
c002c1ca:	e8 e7 4e ff ff       	call   c00210b6 <thread_current>
c002c1cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint32_t *pd;

  lock_acquire(&fs_lock);
c002c1d2:	83 ec 0c             	sub    $0xc,%esp
c002c1d5:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002c1da:	e8 bc 6e ff ff       	call   c002309b <lock_acquire>
c002c1df:	83 c4 10             	add    $0x10,%esp
  close_file(ALL_FDESC_CLOSE);
c002c1e2:	83 ec 0c             	sub    $0xc,%esp
c002c1e5:	6a ff                	push   $0xffffffff
c002c1e7:	e8 17 1d 00 00       	call   c002df03 <close_file>
c002c1ec:	83 c4 10             	add    $0x10,%esp

  if (current_thread->executable)
c002c1ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c1f2:	8b 40 74             	mov    0x74(%eax),%eax
c002c1f5:	85 c0                	test   %eax,%eax
c002c1f7:	74 12                	je     c002c20b <process_exit+0x47>
    file_close(current_thread->executable);
c002c1f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c1fc:	8b 40 74             	mov    0x74(%eax),%eax
c002c1ff:	83 ec 0c             	sub    $0xc,%esp
c002c202:	50                   	push   %eax
c002c203:	e8 71 26 00 00       	call   c002e879 <file_close>
c002c208:	83 c4 10             	add    $0x10,%esp

  lock_release(&fs_lock);
c002c20b:	83 ec 0c             	sub    $0xc,%esp
c002c20e:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002c213:	e8 01 70 ff ff       	call   c0023219 <lock_release>
c002c218:	83 c4 10             	add    $0x10,%esp
  children_remove();
c002c21b:	e8 61 1c 00 00       	call   c002de81 <children_remove>

  if (check_thread_active(current_thread->parent))
c002c220:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c223:	8b 40 6c             	mov    0x6c(%eax),%eax
c002c226:	83 ec 0c             	sub    $0xc,%esp
c002c229:	50                   	push   %eax
c002c22a:	e8 47 56 ff ff       	call   c0021876 <check_thread_active>
c002c22f:	83 c4 10             	add    $0x10,%esp
c002c232:	85 c0                	test   %eax,%eax
c002c234:	74 22                	je     c002c258 <process_exit+0x94>
  {
    current_thread->child_process->exit = 1;
c002c236:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c239:	8b 40 70             	mov    0x70(%eax),%eax
c002c23c:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    semaphore_up(&current_thread->child_process->exit_sema);
c002c243:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c246:	8b 40 70             	mov    0x70(%eax),%eax
c002c249:	83 c0 28             	add    $0x28,%eax
c002c24c:	83 ec 0c             	sub    $0xc,%esp
c002c24f:	50                   	push   %eax
c002c250:	e8 92 6c ff ff       	call   c0022ee7 <semaphore_up>
c002c255:	83 c4 10             	add    $0x10,%esp
  }

  /* Destroy the current process's page directory and switch back
     to the kernel-only page directory. */
  pd = current_thread->pagedir;
c002c258:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c25b:	8b 40 30             	mov    0x30(%eax),%eax
c002c25e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pd != NULL)
c002c261:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c265:	74 25                	je     c002c28c <process_exit+0xc8>
       so that a timer interrupt can't switch back to the
       process page directory.  We must activate the base page
       directory before destroying the process's page
       directory, or our active page directory will be one
       that's been freed (and cleared). */
    current_thread->pagedir = NULL;
c002c267:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c26a:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
    pagedir_activate(NULL);
c002c271:	83 ec 0c             	sub    $0xc,%esp
c002c274:	6a 00                	push   $0x0
c002c276:	e8 43 10 00 00       	call   c002d2be <pagedir_activate>
c002c27b:	83 c4 10             	add    $0x10,%esp
    pagedir_destroy(pd);
c002c27e:	83 ec 0c             	sub    $0xc,%esp
c002c281:	ff 75 f0             	pushl  -0x10(%ebp)
c002c284:	e8 6a 0a 00 00       	call   c002ccf3 <pagedir_destroy>
c002c289:	83 c4 10             	add    $0x10,%esp
  }
}
c002c28c:	90                   	nop
c002c28d:	c9                   	leave  
c002c28e:	c3                   	ret    

c002c28f <process_activate>:

/* Sets up the CPU for running user code in the current
   thread.
   This function is called on every context switch. */
void process_activate(void)
{
c002c28f:	55                   	push   %ebp
c002c290:	89 e5                	mov    %esp,%ebp
c002c292:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current();
c002c295:	e8 1c 4e ff ff       	call   c00210b6 <thread_current>
c002c29a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Activate thread's page tables. */
  pagedir_activate(t->pagedir);
c002c29d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c2a0:	8b 40 30             	mov    0x30(%eax),%eax
c002c2a3:	83 ec 0c             	sub    $0xc,%esp
c002c2a6:	50                   	push   %eax
c002c2a7:	e8 12 10 00 00       	call   c002d2be <pagedir_activate>
c002c2ac:	83 c4 10             	add    $0x10,%esp

  /* Set thread's kernel stack for use in processing
     interrupts. */
  tss_update();
c002c2af:	e8 3c 20 00 00       	call   c002e2f0 <tss_update>
}
c002c2b4:	90                   	nop
c002c2b5:	c9                   	leave  
c002c2b6:	c3                   	ret    

c002c2b7 <load>:
/* Loads an ELF executable from FILE_NAME into the current thread.
   Stores the executable's entry point into *EIP
   and its initial stack pointer into *ESP.
   Returns true if successful, false otherwise. */
bool load(const char *file_name, void (**eip)(void), void **esp)
{
c002c2b7:	55                   	push   %ebp
c002c2b8:	89 e5                	mov    %esp,%ebp
c002c2ba:	81 ec f8 00 00 00    	sub    $0xf8,%esp
  struct thread *t = thread_current();
c002c2c0:	e8 f1 4d ff ff       	call   c00210b6 <thread_current>
c002c2c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  struct Elf32_Ehdr ehdr;
  struct file *file = NULL;
c002c2c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  off_t file_ofs;
  bool success = false;
c002c2cf:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  int i;

  /* Allocate and activate page directory. */
  t->pagedir = pagedir_create();
c002c2d3:	e8 e1 09 00 00       	call   c002ccb9 <pagedir_create>
c002c2d8:	89 c2                	mov    %eax,%edx
c002c2da:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c2dd:	89 50 30             	mov    %edx,0x30(%eax)
  if (t->pagedir == NULL)
c002c2e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c2e3:	8b 40 30             	mov    0x30(%eax),%eax
c002c2e6:	85 c0                	test   %eax,%eax
c002c2e8:	0f 84 8a 02 00 00    	je     c002c578 <load+0x2c1>
    goto done;
  process_activate();
c002c2ee:	e8 9c ff ff ff       	call   c002c28f <process_activate>

  char *save_pointer;
  char file_name_copy[100]; // better if change to len

  strlcpy(file_name_copy, file_name, 100);
c002c2f3:	83 ec 04             	sub    $0x4,%esp
c002c2f6:	6a 64                	push   $0x64
c002c2f8:	ff 75 08             	pushl  0x8(%ebp)
c002c2fb:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
c002c301:	50                   	push   %eax
c002c302:	e8 83 cd ff ff       	call   c002908a <strlcpy>
c002c307:	83 c4 10             	add    $0x10,%esp

  file_name = strtok_r(file_name, " ", &save_pointer);
c002c30a:	83 ec 04             	sub    $0x4,%esp
c002c30d:	8d 45 94             	lea    -0x6c(%ebp),%eax
c002c310:	50                   	push   %eax
c002c311:	68 44 2d 03 c0       	push   $0xc0032d44
c002c316:	ff 75 08             	pushl  0x8(%ebp)
c002c319:	e8 8b cb ff ff       	call   c0028ea9 <strtok_r>
c002c31e:	83 c4 10             	add    $0x10,%esp
c002c321:	89 45 08             	mov    %eax,0x8(%ebp)

  /* Open executable file. */
  file = filesys_open(file_name);
c002c324:	83 ec 0c             	sub    $0xc,%esp
c002c327:	ff 75 08             	pushl  0x8(%ebp)
c002c32a:	e8 17 21 00 00       	call   c002e446 <filesys_open>
c002c32f:	83 c4 10             	add    $0x10,%esp
c002c332:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file == NULL)
c002c335:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002c339:	75 18                	jne    c002c353 <load+0x9c>
  {
    printf("load: %s: open failed\n", file_name);
c002c33b:	83 ec 08             	sub    $0x8,%esp
c002c33e:	ff 75 08             	pushl  0x8(%ebp)
c002c341:	68 83 2d 03 c0       	push   $0xc0032d83
c002c346:	e8 93 b4 ff ff       	call   c00277de <printf>
c002c34b:	83 c4 10             	add    $0x10,%esp
    goto done;
c002c34e:	e9 35 02 00 00       	jmp    c002c588 <load+0x2d1>
  }

  /* Read and verify executable header. */
  if (file_read(file, &ehdr, sizeof ehdr) != sizeof ehdr || memcmp(ehdr.e_ident, "\177ELF\1\1\1", 7) || ehdr.e_type != 2 || ehdr.e_machine != 3 || ehdr.e_version != 1 || ehdr.e_phentsize != sizeof(struct Elf32_Phdr) || ehdr.e_phnum > 1024)
c002c353:	83 ec 04             	sub    $0x4,%esp
c002c356:	6a 34                	push   $0x34
c002c358:	8d 45 98             	lea    -0x68(%ebp),%eax
c002c35b:	50                   	push   %eax
c002c35c:	ff 75 f4             	pushl  -0xc(%ebp)
c002c35f:	e8 5b 25 00 00       	call   c002e8bf <file_read>
c002c364:	83 c4 10             	add    $0x10,%esp
c002c367:	83 f8 34             	cmp    $0x34,%eax
c002c36a:	75 48                	jne    c002c3b4 <load+0xfd>
c002c36c:	83 ec 04             	sub    $0x4,%esp
c002c36f:	6a 07                	push   $0x7
c002c371:	68 9a 2d 03 c0       	push   $0xc0032d9a
c002c376:	8d 45 98             	lea    -0x68(%ebp),%eax
c002c379:	50                   	push   %eax
c002c37a:	e8 b1 c7 ff ff       	call   c0028b30 <memcmp>
c002c37f:	83 c4 10             	add    $0x10,%esp
c002c382:	85 c0                	test   %eax,%eax
c002c384:	75 2e                	jne    c002c3b4 <load+0xfd>
c002c386:	8b 45 a8             	mov    -0x58(%ebp),%eax
c002c389:	66 83 f8 02          	cmp    $0x2,%ax
c002c38d:	75 25                	jne    c002c3b4 <load+0xfd>
c002c38f:	66 8b 45 aa          	mov    -0x56(%ebp),%ax
c002c393:	66 83 f8 03          	cmp    $0x3,%ax
c002c397:	75 1b                	jne    c002c3b4 <load+0xfd>
c002c399:	8b 45 ac             	mov    -0x54(%ebp),%eax
c002c39c:	83 f8 01             	cmp    $0x1,%eax
c002c39f:	75 13                	jne    c002c3b4 <load+0xfd>
c002c3a1:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
c002c3a5:	66 83 f8 20          	cmp    $0x20,%ax
c002c3a9:	75 09                	jne    c002c3b4 <load+0xfd>
c002c3ab:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c002c3ae:	66 3d 00 04          	cmp    $0x400,%ax
c002c3b2:	76 18                	jbe    c002c3cc <load+0x115>
  {
    printf("load: %s: error loading executable\n", file_name);
c002c3b4:	83 ec 08             	sub    $0x8,%esp
c002c3b7:	ff 75 08             	pushl  0x8(%ebp)
c002c3ba:	68 a4 2d 03 c0       	push   $0xc0032da4
c002c3bf:	e8 1a b4 ff ff       	call   c00277de <printf>
c002c3c4:	83 c4 10             	add    $0x10,%esp
    goto done;
c002c3c7:	e9 bc 01 00 00       	jmp    c002c588 <load+0x2d1>
  }

  /* Read program headers. */
  file_ofs = ehdr.e_phoff;
c002c3cc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c002c3cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 0; i < ehdr.e_phnum; i++)
c002c3d2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c002c3d9:	e9 5f 01 00 00       	jmp    c002c53d <load+0x286>
  {
    struct Elf32_Phdr phdr;

    if (file_ofs < 0 || file_ofs > file_length(file))
c002c3de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c3e2:	0f 88 a0 01 00 00    	js     c002c588 <load+0x2d1>
c002c3e8:	83 ec 0c             	sub    $0xc,%esp
c002c3eb:	ff 75 f4             	pushl  -0xc(%ebp)
c002c3ee:	e8 22 26 00 00       	call   c002ea15 <file_length>
c002c3f3:	83 c4 10             	add    $0x10,%esp
c002c3f6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002c3f9:	0f 8c 89 01 00 00    	jl     c002c588 <load+0x2d1>
      goto done;
    file_seek(file, file_ofs);
c002c3ff:	83 ec 08             	sub    $0x8,%esp
c002c402:	ff 75 f0             	pushl  -0x10(%ebp)
c002c405:	ff 75 f4             	pushl  -0xc(%ebp)
c002c408:	e8 48 26 00 00       	call   c002ea55 <file_seek>
c002c40d:	83 c4 10             	add    $0x10,%esp

    if (file_read(file, &phdr, sizeof phdr) != sizeof phdr)
c002c410:	83 ec 04             	sub    $0x4,%esp
c002c413:	6a 20                	push   $0x20
c002c415:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
c002c41b:	50                   	push   %eax
c002c41c:	ff 75 f4             	pushl  -0xc(%ebp)
c002c41f:	e8 9b 24 00 00       	call   c002e8bf <file_read>
c002c424:	83 c4 10             	add    $0x10,%esp
c002c427:	83 f8 20             	cmp    $0x20,%eax
c002c42a:	0f 85 4b 01 00 00    	jne    c002c57b <load+0x2c4>
      goto done;
    file_ofs += sizeof phdr;
c002c430:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c433:	83 c0 20             	add    $0x20,%eax
c002c436:	89 45 f0             	mov    %eax,-0x10(%ebp)
    switch (phdr.p_type)
c002c439:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
c002c43f:	83 f8 03             	cmp    $0x3,%eax
c002c442:	77 13                	ja     c002c457 <load+0x1a0>
c002c444:	83 f8 02             	cmp    $0x2,%eax
c002c447:	0f 83 31 01 00 00    	jae    c002c57e <load+0x2c7>
c002c44d:	83 f8 01             	cmp    $0x1,%eax
c002c450:	74 13                	je     c002c465 <load+0x1ae>
    case PT_NOTE:
    case PT_PHDR:
    case PT_STACK:
    default:
      /* Ignore this segment. */
      break;
c002c452:	e9 e3 00 00 00       	jmp    c002c53a <load+0x283>
    switch (phdr.p_type)
c002c457:	83 f8 05             	cmp    $0x5,%eax
c002c45a:	0f 84 1e 01 00 00    	je     c002c57e <load+0x2c7>
      break;
c002c460:	e9 d5 00 00 00       	jmp    c002c53a <load+0x283>
    case PT_DYNAMIC:
    case PT_INTERP:
    case PT_SHLIB:
      goto done;
    case PT_LOAD:
      if (validate_segment(&phdr, file))
c002c465:	83 ec 08             	sub    $0x8,%esp
c002c468:	ff 75 f4             	pushl  -0xc(%ebp)
c002c46b:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
c002c471:	50                   	push   %eax
c002c472:	e8 24 01 00 00       	call   c002c59b <validate_segment>
c002c477:	83 c4 10             	add    $0x10,%esp
c002c47a:	84 c0                	test   %al,%al
c002c47c:	0f 84 ff 00 00 00    	je     c002c581 <load+0x2ca>
      {
        bool writable = (phdr.p_flags & PF_W) != 0;
c002c482:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
c002c488:	83 e0 02             	and    $0x2,%eax
c002c48b:	85 c0                	test   %eax,%eax
c002c48d:	0f 95 c0             	setne  %al
c002c490:	88 45 db             	mov    %al,-0x25(%ebp)
        uint32_t file_page = phdr.p_offset & ~PGMASK;
c002c493:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
c002c499:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002c49e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        uint32_t mem_page = phdr.p_vaddr & ~PGMASK;
c002c4a1:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
c002c4a7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002c4ac:	89 45 d0             	mov    %eax,-0x30(%ebp)
        uint32_t page_offset = phdr.p_vaddr & PGMASK;
c002c4af:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
c002c4b5:	25 ff 0f 00 00       	and    $0xfff,%eax
c002c4ba:	89 45 cc             	mov    %eax,-0x34(%ebp)
        uint32_t read_bytes, zero_bytes;
        if (phdr.p_filesz > 0)
c002c4bd:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
c002c4c3:	85 c0                	test   %eax,%eax
c002c4c5:	74 2b                	je     c002c4f2 <load+0x23b>
        {
          /* Normal segment.
             Read initial part from disk and zero the rest. */
          read_bytes = page_offset + phdr.p_filesz;
c002c4c7:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
c002c4cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
c002c4d0:	01 d0                	add    %edx,%eax
c002c4d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          zero_bytes = (ROUND_UP(page_offset + phdr.p_memsz, PGSIZE) - read_bytes);
c002c4d5:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
c002c4db:	8b 45 cc             	mov    -0x34(%ebp),%eax
c002c4de:	01 d0                	add    %edx,%eax
c002c4e0:	05 ff 0f 00 00       	add    $0xfff,%eax
c002c4e5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002c4ea:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002c4ed:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002c4f0:	eb 1f                	jmp    c002c511 <load+0x25a>
        }
        else
        {
          /* Entirely zero.
             Don't read anything from disk. */
          read_bytes = 0;
c002c4f2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
          zero_bytes = ROUND_UP(page_offset + phdr.p_memsz, PGSIZE);
c002c4f9:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
c002c4ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
c002c502:	01 d0                	add    %edx,%eax
c002c504:	05 ff 0f 00 00       	add    $0xfff,%eax
c002c509:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002c50e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        }
        if (!load_segment(file, file_page, (void *)mem_page,
c002c511:	0f b6 4d db          	movzbl -0x25(%ebp),%ecx
c002c515:	8b 55 d0             	mov    -0x30(%ebp),%edx
c002c518:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002c51b:	83 ec 08             	sub    $0x8,%esp
c002c51e:	51                   	push   %ecx
c002c51f:	ff 75 e0             	pushl  -0x20(%ebp)
c002c522:	ff 75 e4             	pushl  -0x1c(%ebp)
c002c525:	52                   	push   %edx
c002c526:	50                   	push   %eax
c002c527:	ff 75 f4             	pushl  -0xc(%ebp)
c002c52a:	e8 48 01 00 00       	call   c002c677 <load_segment>
c002c52f:	83 c4 20             	add    $0x20,%esp
c002c532:	83 f0 01             	xor    $0x1,%eax
c002c535:	84 c0                	test   %al,%al
c002c537:	75 4b                	jne    c002c584 <load+0x2cd>
                          read_bytes, zero_bytes, writable))
          goto done;
      }
      else
        goto done;
      break;
c002c539:	90                   	nop
  for (i = 0; i < ehdr.e_phnum; i++)
c002c53a:	ff 45 e8             	incl   -0x18(%ebp)
c002c53d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c002c540:	0f b7 c0             	movzwl %ax,%eax
c002c543:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002c546:	0f 8f 92 fe ff ff    	jg     c002c3de <load+0x127>
    }
  }

  /* Set up stack. */

  if (!setup_stack(esp, file_name_copy))
c002c54c:	83 ec 08             	sub    $0x8,%esp
c002c54f:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
c002c555:	50                   	push   %eax
c002c556:	ff 75 10             	pushl  0x10(%ebp)
c002c559:	e8 aa 02 00 00       	call   c002c808 <setup_stack>
c002c55e:	83 c4 10             	add    $0x10,%esp
c002c561:	83 f0 01             	xor    $0x1,%eax
c002c564:	84 c0                	test   %al,%al
c002c566:	75 1f                	jne    c002c587 <load+0x2d0>
  {
    goto done;
  }

  /* Start address. */
  *eip = (void (*)(void))ehdr.e_entry;
c002c568:	8b 45 b0             	mov    -0x50(%ebp),%eax
c002c56b:	89 c2                	mov    %eax,%edx
c002c56d:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c570:	89 10                	mov    %edx,(%eax)

  success = true;
c002c572:	c6 45 ef 01          	movb   $0x1,-0x11(%ebp)
c002c576:	eb 10                	jmp    c002c588 <load+0x2d1>
    goto done;
c002c578:	90                   	nop
c002c579:	eb 0d                	jmp    c002c588 <load+0x2d1>
      goto done;
c002c57b:	90                   	nop
c002c57c:	eb 0a                	jmp    c002c588 <load+0x2d1>
      goto done;
c002c57e:	90                   	nop
c002c57f:	eb 07                	jmp    c002c588 <load+0x2d1>
        goto done;
c002c581:	90                   	nop
c002c582:	eb 04                	jmp    c002c588 <load+0x2d1>
          goto done;
c002c584:	90                   	nop
c002c585:	eb 01                	jmp    c002c588 <load+0x2d1>
    goto done;
c002c587:	90                   	nop

done:
  /* We arrive here whether the load is successful or not. */
  file_close(file);
c002c588:	83 ec 0c             	sub    $0xc,%esp
c002c58b:	ff 75 f4             	pushl  -0xc(%ebp)
c002c58e:	e8 e6 22 00 00       	call   c002e879 <file_close>
c002c593:	83 c4 10             	add    $0x10,%esp
  return success;
c002c596:	8a 45 ef             	mov    -0x11(%ebp),%al
}
c002c599:	c9                   	leave  
c002c59a:	c3                   	ret    

c002c59b <validate_segment>:

/* Checks whether PHDR describes a valid, loadable segment in
   FILE and returns true if so, false otherwise. */
static bool
validate_segment(const struct Elf32_Phdr *phdr, struct file *file)
{
c002c59b:	55                   	push   %ebp
c002c59c:	89 e5                	mov    %esp,%ebp
c002c59e:	53                   	push   %ebx
c002c59f:	83 ec 04             	sub    $0x4,%esp
  /* p_offset and p_vaddr must have the same page offset. */
  if ((phdr->p_offset & PGMASK) != (phdr->p_vaddr & PGMASK))
c002c5a2:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5a5:	8b 50 04             	mov    0x4(%eax),%edx
c002c5a8:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5ab:	8b 40 08             	mov    0x8(%eax),%eax
c002c5ae:	31 d0                	xor    %edx,%eax
c002c5b0:	25 ff 0f 00 00       	and    $0xfff,%eax
c002c5b5:	85 c0                	test   %eax,%eax
c002c5b7:	74 07                	je     c002c5c0 <validate_segment+0x25>
    return false;
c002c5b9:	b0 00                	mov    $0x0,%al
c002c5bb:	e9 b2 00 00 00       	jmp    c002c672 <validate_segment+0xd7>

  /* p_offset must point within FILE. */
  if (phdr->p_offset > (Elf32_Off)file_length(file))
c002c5c0:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5c3:	8b 58 04             	mov    0x4(%eax),%ebx
c002c5c6:	83 ec 0c             	sub    $0xc,%esp
c002c5c9:	ff 75 0c             	pushl  0xc(%ebp)
c002c5cc:	e8 44 24 00 00       	call   c002ea15 <file_length>
c002c5d1:	83 c4 10             	add    $0x10,%esp
c002c5d4:	39 c3                	cmp    %eax,%ebx
c002c5d6:	76 07                	jbe    c002c5df <validate_segment+0x44>
    return false;
c002c5d8:	b0 00                	mov    $0x0,%al
c002c5da:	e9 93 00 00 00       	jmp    c002c672 <validate_segment+0xd7>

  /* p_memsz must be at least as big as p_filesz. */
  if (phdr->p_memsz < phdr->p_filesz)
c002c5df:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5e2:	8b 50 14             	mov    0x14(%eax),%edx
c002c5e5:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5e8:	8b 40 10             	mov    0x10(%eax),%eax
c002c5eb:	39 c2                	cmp    %eax,%edx
c002c5ed:	73 04                	jae    c002c5f3 <validate_segment+0x58>
    return false;
c002c5ef:	b0 00                	mov    $0x0,%al
c002c5f1:	eb 7f                	jmp    c002c672 <validate_segment+0xd7>

  /* The segment must not be empty. */
  if (phdr->p_memsz == 0)
c002c5f3:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5f6:	8b 40 14             	mov    0x14(%eax),%eax
c002c5f9:	85 c0                	test   %eax,%eax
c002c5fb:	75 04                	jne    c002c601 <validate_segment+0x66>
    return false;
c002c5fd:	b0 00                	mov    $0x0,%al
c002c5ff:	eb 71                	jmp    c002c672 <validate_segment+0xd7>

  /* The virtual memory region must both start and end within the
     user address space range. */
  if (!is_user_vaddr((void *)phdr->p_vaddr))
c002c601:	8b 45 08             	mov    0x8(%ebp),%eax
c002c604:	8b 40 08             	mov    0x8(%eax),%eax
c002c607:	83 ec 0c             	sub    $0xc,%esp
c002c60a:	50                   	push   %eax
c002c60b:	e8 c1 f9 ff ff       	call   c002bfd1 <is_user_vaddr>
c002c610:	83 c4 10             	add    $0x10,%esp
c002c613:	83 f0 01             	xor    $0x1,%eax
c002c616:	84 c0                	test   %al,%al
c002c618:	74 04                	je     c002c61e <validate_segment+0x83>
    return false;
c002c61a:	b0 00                	mov    $0x0,%al
c002c61c:	eb 54                	jmp    c002c672 <validate_segment+0xd7>
  if (!is_user_vaddr((void *)(phdr->p_vaddr + phdr->p_memsz)))
c002c61e:	8b 45 08             	mov    0x8(%ebp),%eax
c002c621:	8b 50 08             	mov    0x8(%eax),%edx
c002c624:	8b 45 08             	mov    0x8(%ebp),%eax
c002c627:	8b 40 14             	mov    0x14(%eax),%eax
c002c62a:	01 d0                	add    %edx,%eax
c002c62c:	83 ec 0c             	sub    $0xc,%esp
c002c62f:	50                   	push   %eax
c002c630:	e8 9c f9 ff ff       	call   c002bfd1 <is_user_vaddr>
c002c635:	83 c4 10             	add    $0x10,%esp
c002c638:	83 f0 01             	xor    $0x1,%eax
c002c63b:	84 c0                	test   %al,%al
c002c63d:	74 04                	je     c002c643 <validate_segment+0xa8>
    return false;
c002c63f:	b0 00                	mov    $0x0,%al
c002c641:	eb 2f                	jmp    c002c672 <validate_segment+0xd7>

  /* The region cannot "wrap around" across the kernel virtual
     address space. */
  if (phdr->p_vaddr + phdr->p_memsz < phdr->p_vaddr)
c002c643:	8b 45 08             	mov    0x8(%ebp),%eax
c002c646:	8b 50 08             	mov    0x8(%eax),%edx
c002c649:	8b 45 08             	mov    0x8(%ebp),%eax
c002c64c:	8b 40 14             	mov    0x14(%eax),%eax
c002c64f:	01 c2                	add    %eax,%edx
c002c651:	8b 45 08             	mov    0x8(%ebp),%eax
c002c654:	8b 40 08             	mov    0x8(%eax),%eax
c002c657:	39 c2                	cmp    %eax,%edx
c002c659:	73 04                	jae    c002c65f <validate_segment+0xc4>
    return false;
c002c65b:	b0 00                	mov    $0x0,%al
c002c65d:	eb 13                	jmp    c002c672 <validate_segment+0xd7>
  /* Disallow mapping page 0.
     Not only is it a bad idea to map page 0, but if we allowed
     it then user code that passed a null pointer to system calls
     could quite likely panic the kernel by way of null pointer
     assertions in memcpy(), etc. */
  if (phdr->p_vaddr < PGSIZE)
c002c65f:	8b 45 08             	mov    0x8(%ebp),%eax
c002c662:	8b 40 08             	mov    0x8(%eax),%eax
c002c665:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002c66a:	77 04                	ja     c002c670 <validate_segment+0xd5>
    return false;
c002c66c:	b0 00                	mov    $0x0,%al
c002c66e:	eb 02                	jmp    c002c672 <validate_segment+0xd7>

  /* It's okay. */
  return true;
c002c670:	b0 01                	mov    $0x1,%al
}
c002c672:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c675:	c9                   	leave  
c002c676:	c3                   	ret    

c002c677 <load_segment>:
   Return true if successful, false if a memory allocation error
   or disk read error occurs. */
static bool
load_segment(struct file *file, off_t ofs, uint8_t *upage,
             uint32_t read_bytes, uint32_t zero_bytes, bool writable)
{
c002c677:	55                   	push   %ebp
c002c678:	89 e5                	mov    %esp,%ebp
c002c67a:	83 ec 28             	sub    $0x28,%esp
c002c67d:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002c680:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT((read_bytes + zero_bytes) % PGSIZE == 0);
c002c683:	8b 55 14             	mov    0x14(%ebp),%edx
c002c686:	8b 45 18             	mov    0x18(%ebp),%eax
c002c689:	01 d0                	add    %edx,%eax
c002c68b:	25 ff 0f 00 00       	and    $0xfff,%eax
c002c690:	85 c0                	test   %eax,%eax
c002c692:	74 21                	je     c002c6b5 <load_segment+0x3e>
c002c694:	83 ec 0c             	sub    $0xc,%esp
c002c697:	68 c8 2d 03 c0       	push   $0xc0032dc8
c002c69c:	68 f0 2d 03 c0       	push   $0xc0032df0
c002c6a1:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002c6a6:	68 c4 01 00 00       	push   $0x1c4
c002c6ab:	68 6a 2d 03 c0       	push   $0xc0032d6a
c002c6b0:	e8 e8 d4 ff ff       	call   c0029b9d <debug_panic>
  ASSERT(pg_ofs(upage) == 0);
c002c6b5:	83 ec 0c             	sub    $0xc,%esp
c002c6b8:	ff 75 10             	pushl  0x10(%ebp)
c002c6bb:	e8 04 f9 ff ff       	call   c002bfc4 <pg_ofs>
c002c6c0:	83 c4 10             	add    $0x10,%esp
c002c6c3:	85 c0                	test   %eax,%eax
c002c6c5:	74 21                	je     c002c6e8 <load_segment+0x71>
c002c6c7:	83 ec 0c             	sub    $0xc,%esp
c002c6ca:	68 07 2e 03 c0       	push   $0xc0032e07
c002c6cf:	68 f0 2d 03 c0       	push   $0xc0032df0
c002c6d4:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002c6d9:	68 c5 01 00 00       	push   $0x1c5
c002c6de:	68 6a 2d 03 c0       	push   $0xc0032d6a
c002c6e3:	e8 b5 d4 ff ff       	call   c0029b9d <debug_panic>
  ASSERT(ofs % PGSIZE == 0);
c002c6e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c6eb:	25 ff 0f 00 00       	and    $0xfff,%eax
c002c6f0:	85 c0                	test   %eax,%eax
c002c6f2:	74 21                	je     c002c715 <load_segment+0x9e>
c002c6f4:	83 ec 0c             	sub    $0xc,%esp
c002c6f7:	68 1a 2e 03 c0       	push   $0xc0032e1a
c002c6fc:	68 f0 2d 03 c0       	push   $0xc0032df0
c002c701:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002c706:	68 c6 01 00 00       	push   $0x1c6
c002c70b:	68 6a 2d 03 c0       	push   $0xc0032d6a
c002c710:	e8 88 d4 ff ff       	call   c0029b9d <debug_panic>

  file_seek(file, ofs);
c002c715:	83 ec 08             	sub    $0x8,%esp
c002c718:	ff 75 0c             	pushl  0xc(%ebp)
c002c71b:	ff 75 08             	pushl  0x8(%ebp)
c002c71e:	e8 32 23 00 00       	call   c002ea55 <file_seek>
c002c723:	83 c4 10             	add    $0x10,%esp
  while (read_bytes > 0 || zero_bytes > 0)
c002c726:	e9 c5 00 00 00       	jmp    c002c7f0 <load_segment+0x179>
  {
    /* Calculate how to fill this page.
       We will read PAGE_READ_BYTES bytes from FILE
       and zero the final PAGE_ZERO_BYTES bytes. */
    size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
c002c72b:	8b 45 14             	mov    0x14(%ebp),%eax
c002c72e:	3d 00 10 00 00       	cmp    $0x1000,%eax
c002c733:	76 05                	jbe    c002c73a <load_segment+0xc3>
c002c735:	b8 00 10 00 00       	mov    $0x1000,%eax
c002c73a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t page_zero_bytes = PGSIZE - page_read_bytes;
c002c73d:	b8 00 10 00 00       	mov    $0x1000,%eax
c002c742:	2b 45 f4             	sub    -0xc(%ebp),%eax
c002c745:	89 45 f0             	mov    %eax,-0x10(%ebp)

    /* Get a page of memory. */
    uint8_t *kpage = palloc_get_page(PAL_USER);
c002c748:	83 ec 0c             	sub    $0xc,%esp
c002c74b:	6a 04                	push   $0x4
c002c74d:	e8 1d 70 ff ff       	call   c002376f <palloc_get_page>
c002c752:	83 c4 10             	add    $0x10,%esp
c002c755:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (kpage == NULL)
c002c758:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002c75c:	75 07                	jne    c002c765 <load_segment+0xee>
      return false;
c002c75e:	b0 00                	mov    $0x0,%al
c002c760:	e9 a1 00 00 00       	jmp    c002c806 <load_segment+0x18f>

    /* Load this page. */
    if (file_read(file, kpage, page_read_bytes) != (int)page_read_bytes)
c002c765:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c768:	83 ec 04             	sub    $0x4,%esp
c002c76b:	50                   	push   %eax
c002c76c:	ff 75 ec             	pushl  -0x14(%ebp)
c002c76f:	ff 75 08             	pushl  0x8(%ebp)
c002c772:	e8 48 21 00 00       	call   c002e8bf <file_read>
c002c777:	83 c4 10             	add    $0x10,%esp
c002c77a:	89 c2                	mov    %eax,%edx
c002c77c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c77f:	39 c2                	cmp    %eax,%edx
c002c781:	74 12                	je     c002c795 <load_segment+0x11e>
    {
      palloc_free_page(kpage);
c002c783:	83 ec 0c             	sub    $0xc,%esp
c002c786:	ff 75 ec             	pushl  -0x14(%ebp)
c002c789:	e8 39 71 ff ff       	call   c00238c7 <palloc_free_page>
c002c78e:	83 c4 10             	add    $0x10,%esp
      return false;
c002c791:	b0 00                	mov    $0x0,%al
c002c793:	eb 71                	jmp    c002c806 <load_segment+0x18f>
    }
    memset(kpage + page_read_bytes, 0, page_zero_bytes);
c002c795:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002c798:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c79b:	01 d0                	add    %edx,%eax
c002c79d:	83 ec 04             	sub    $0x4,%esp
c002c7a0:	ff 75 f0             	pushl  -0x10(%ebp)
c002c7a3:	6a 00                	push   $0x0
c002c7a5:	50                   	push   %eax
c002c7a6:	e8 0c c8 ff ff       	call   c0028fb7 <memset>
c002c7ab:	83 c4 10             	add    $0x10,%esp

    /* Add the page to the process's address space. */
    if (!install_page(upage, kpage, writable))
c002c7ae:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002c7b2:	83 ec 04             	sub    $0x4,%esp
c002c7b5:	50                   	push   %eax
c002c7b6:	ff 75 ec             	pushl  -0x14(%ebp)
c002c7b9:	ff 75 10             	pushl  0x10(%ebp)
c002c7bc:	e8 b5 02 00 00       	call   c002ca76 <install_page>
c002c7c1:	83 c4 10             	add    $0x10,%esp
c002c7c4:	83 f0 01             	xor    $0x1,%eax
c002c7c7:	84 c0                	test   %al,%al
c002c7c9:	74 12                	je     c002c7dd <load_segment+0x166>
    {
      palloc_free_page(kpage);
c002c7cb:	83 ec 0c             	sub    $0xc,%esp
c002c7ce:	ff 75 ec             	pushl  -0x14(%ebp)
c002c7d1:	e8 f1 70 ff ff       	call   c00238c7 <palloc_free_page>
c002c7d6:	83 c4 10             	add    $0x10,%esp
      return false;
c002c7d9:	b0 00                	mov    $0x0,%al
c002c7db:	eb 29                	jmp    c002c806 <load_segment+0x18f>
    }

    /* Advance. */
    read_bytes -= page_read_bytes;
c002c7dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c7e0:	29 45 14             	sub    %eax,0x14(%ebp)
    zero_bytes -= page_zero_bytes;
c002c7e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c7e6:	29 45 18             	sub    %eax,0x18(%ebp)
    upage += PGSIZE;
c002c7e9:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
  while (read_bytes > 0 || zero_bytes > 0)
c002c7f0:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002c7f4:	0f 85 31 ff ff ff    	jne    c002c72b <load_segment+0xb4>
c002c7fa:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c002c7fe:	0f 85 27 ff ff ff    	jne    c002c72b <load_segment+0xb4>
  }
  return true;
c002c804:	b0 01                	mov    $0x1,%al
}
c002c806:	c9                   	leave  
c002c807:	c3                   	ret    

c002c808 <setup_stack>:

/* Create a minimal stack by mapping a zeroed page at the top of
   user virtual memory. */
static bool
setup_stack(void **esp, char *file_name)
{
c002c808:	55                   	push   %ebp
c002c809:	89 e5                	mov    %esp,%ebp
c002c80b:	53                   	push   %ebx
c002c80c:	83 ec 34             	sub    $0x34,%esp
  uint8_t *kpage;
  bool success = false;
c002c80f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  int argc = 0;
c002c813:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  char *token_pointer, *save_pointer;
  int arg_length = 200;
c002c81a:	c7 45 e8 c8 00 00 00 	movl   $0xc8,-0x18(%ebp)
  char **arr = (char **)(malloc(sizeof(char *) * arg_length));
c002c821:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c824:	c1 e0 02             	shl    $0x2,%eax
c002c827:	83 ec 0c             	sub    $0xc,%esp
c002c82a:	50                   	push   %eax
c002c82b:	e8 8a 72 ff ff       	call   c0023aba <malloc>
c002c830:	83 c4 10             	add    $0x10,%esp
c002c833:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  // Separating Arguments
  token_pointer = strtok_r(file_name, " ", &save_pointer);
c002c836:	83 ec 04             	sub    $0x4,%esp
c002c839:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002c83c:	50                   	push   %eax
c002c83d:	68 44 2d 03 c0       	push   $0xc0032d44
c002c842:	ff 75 0c             	pushl  0xc(%ebp)
c002c845:	e8 5f c6 ff ff       	call   c0028ea9 <strtok_r>
c002c84a:	83 c4 10             	add    $0x10,%esp
c002c84d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  while (token_pointer != NULL)
c002c850:	eb 58                	jmp    c002c8aa <setup_stack+0xa2>
  {
    if (argc > arg_length)
c002c852:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c855:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002c858:	7e 20                	jle    c002c87a <setup_stack+0x72>
    {
      arr = realloc(arr, 2 * sizeof(char *) * arg_length);
c002c85a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c85d:	c1 e0 03             	shl    $0x3,%eax
c002c860:	83 ec 08             	sub    $0x8,%esp
c002c863:	50                   	push   %eax
c002c864:	ff 75 e4             	pushl  -0x1c(%ebp)
c002c867:	e8 cb 74 ff ff       	call   c0023d37 <realloc>
c002c86c:	83 c4 10             	add    $0x10,%esp
c002c86f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      arg_length *= 2;
c002c872:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c875:	01 c0                	add    %eax,%eax
c002c877:	89 45 e8             	mov    %eax,-0x18(%ebp)
    }

    arr[argc] = token_pointer;
c002c87a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c87d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c884:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002c887:	01 c2                	add    %eax,%edx
c002c889:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c88c:	89 02                	mov    %eax,(%edx)
    argc++;
c002c88e:	ff 45 f0             	incl   -0x10(%ebp)
    token_pointer = strtok_r(NULL, " ", &save_pointer);
c002c891:	83 ec 04             	sub    $0x4,%esp
c002c894:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002c897:	50                   	push   %eax
c002c898:	68 44 2d 03 c0       	push   $0xc0032d44
c002c89d:	6a 00                	push   $0x0
c002c89f:	e8 05 c6 ff ff       	call   c0028ea9 <strtok_r>
c002c8a4:	83 c4 10             	add    $0x10,%esp
c002c8a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  while (token_pointer != NULL)
c002c8aa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002c8ae:	75 a2                	jne    c002c852 <setup_stack+0x4a>
  }

  kpage = palloc_get_page(PAL_USER | PAL_ZERO);
c002c8b0:	83 ec 0c             	sub    $0xc,%esp
c002c8b3:	6a 06                	push   $0x6
c002c8b5:	e8 b5 6e ff ff       	call   c002376f <palloc_get_page>
c002c8ba:	83 c4 10             	add    $0x10,%esp
c002c8bd:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (kpage != NULL)
c002c8c0:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c002c8c4:	74 37                	je     c002c8fd <setup_stack+0xf5>
  {
    success = install_page(((uint8_t *)PHYS_BASE) - PGSIZE, kpage, true);
c002c8c6:	83 ec 04             	sub    $0x4,%esp
c002c8c9:	6a 01                	push   $0x1
c002c8cb:	ff 75 d8             	pushl  -0x28(%ebp)
c002c8ce:	68 00 f0 ff bf       	push   $0xbffff000
c002c8d3:	e8 9e 01 00 00       	call   c002ca76 <install_page>
c002c8d8:	83 c4 10             	add    $0x10,%esp
c002c8db:	88 45 f7             	mov    %al,-0x9(%ebp)

    if (success)
c002c8de:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c002c8e2:	74 0b                	je     c002c8ef <setup_stack+0xe7>
    {
      *esp = PHYS_BASE;
c002c8e4:	8b 45 08             	mov    0x8(%ebp),%eax
c002c8e7:	c7 00 00 00 00 c0    	movl   $0xc0000000,(%eax)
c002c8ed:	eb 0e                	jmp    c002c8fd <setup_stack+0xf5>
    }
    else
      palloc_free_page(kpage);
c002c8ef:	83 ec 0c             	sub    $0xc,%esp
c002c8f2:	ff 75 d8             	pushl  -0x28(%ebp)
c002c8f5:	e8 cd 6f ff ff       	call   c00238c7 <palloc_free_page>
c002c8fa:	83 c4 10             	add    $0x10,%esp
  }

   // aligning
  int zeros = (uint32_t)*esp % 4;
c002c8fd:	8b 45 08             	mov    0x8(%ebp),%eax
c002c900:	8b 00                	mov    (%eax),%eax
c002c902:	83 e0 03             	and    $0x3,%eax
c002c905:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  *esp -= zeros;
c002c908:	8b 45 08             	mov    0x8(%ebp),%eax
c002c90b:	8b 00                	mov    (%eax),%eax
c002c90d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002c910:	f7 da                	neg    %edx
c002c912:	01 c2                	add    %eax,%edx
c002c914:	8b 45 08             	mov    0x8(%ebp),%eax
c002c917:	89 10                	mov    %edx,(%eax)

  if (zeros != 0)
c002c919:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002c91d:	74 17                	je     c002c936 <setup_stack+0x12e>
  {
    memset(*esp, 0, zeros);
c002c91f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002c922:	8b 45 08             	mov    0x8(%ebp),%eax
c002c925:	8b 00                	mov    (%eax),%eax
c002c927:	83 ec 04             	sub    $0x4,%esp
c002c92a:	52                   	push   %edx
c002c92b:	6a 00                	push   $0x0
c002c92d:	50                   	push   %eax
c002c92e:	e8 84 c6 ff ff       	call   c0028fb7 <memset>
c002c933:	83 c4 10             	add    $0x10,%esp
  }


  // stacking arguments from last to first
  for (int i = argc - 1; i >= 0; i--)
c002c936:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c939:	48                   	dec    %eax
c002c93a:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002c93d:	e9 89 00 00 00       	jmp    c002c9cb <setup_stack+0x1c3>
  {
    *esp -= (strlen(arr[i]) + 1);
c002c942:	8b 45 08             	mov    0x8(%ebp),%eax
c002c945:	8b 18                	mov    (%eax),%ebx
c002c947:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c94a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c951:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002c954:	01 d0                	add    %edx,%eax
c002c956:	8b 00                	mov    (%eax),%eax
c002c958:	83 ec 0c             	sub    $0xc,%esp
c002c95b:	50                   	push   %eax
c002c95c:	e8 af c6 ff ff       	call   c0029010 <strlen>
c002c961:	83 c4 10             	add    $0x10,%esp
c002c964:	f7 d0                	not    %eax
c002c966:	8d 14 03             	lea    (%ebx,%eax,1),%edx
c002c969:	8b 45 08             	mov    0x8(%ebp),%eax
c002c96c:	89 10                	mov    %edx,(%eax)
    memcpy(*esp, arr[i], strlen(arr[i]) + 1);
c002c96e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c971:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c978:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002c97b:	01 d0                	add    %edx,%eax
c002c97d:	8b 00                	mov    (%eax),%eax
c002c97f:	83 ec 0c             	sub    $0xc,%esp
c002c982:	50                   	push   %eax
c002c983:	e8 88 c6 ff ff       	call   c0029010 <strlen>
c002c988:	83 c4 10             	add    $0x10,%esp
c002c98b:	8d 48 01             	lea    0x1(%eax),%ecx
c002c98e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c991:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c998:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002c99b:	01 d0                	add    %edx,%eax
c002c99d:	8b 10                	mov    (%eax),%edx
c002c99f:	8b 45 08             	mov    0x8(%ebp),%eax
c002c9a2:	8b 00                	mov    (%eax),%eax
c002c9a4:	83 ec 04             	sub    $0x4,%esp
c002c9a7:	51                   	push   %ecx
c002c9a8:	52                   	push   %edx
c002c9a9:	50                   	push   %eax
c002c9aa:	e8 2e c0 ff ff       	call   c00289dd <memcpy>
c002c9af:	83 c4 10             	add    $0x10,%esp
    arr[i] = *esp;
c002c9b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c9b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c9bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002c9bf:	01 c2                	add    %eax,%edx
c002c9c1:	8b 45 08             	mov    0x8(%ebp),%eax
c002c9c4:	8b 00                	mov    (%eax),%eax
c002c9c6:	89 02                	mov    %eax,(%edx)
  for (int i = argc - 1; i >= 0; i--)
c002c9c8:	ff 4d e0             	decl   -0x20(%ebp)
c002c9cb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002c9cf:	0f 89 6d ff ff ff    	jns    c002c942 <setup_stack+0x13a>
  }

 
  // set null pointer
  *esp -= 4;
c002c9d5:	8b 45 08             	mov    0x8(%ebp),%eax
c002c9d8:	8b 00                	mov    (%eax),%eax
c002c9da:	8d 50 fc             	lea    -0x4(%eax),%edx
c002c9dd:	8b 45 08             	mov    0x8(%ebp),%eax
c002c9e0:	89 10                	mov    %edx,(%eax)
  (*(int *)(*esp)) = 0;
c002c9e2:	8b 45 08             	mov    0x8(%ebp),%eax
c002c9e5:	8b 00                	mov    (%eax),%eax
c002c9e7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

  // stacking addresses of arguments from last to first
  int j = argc;
c002c9ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c9f0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  while (--j >= 0)
c002c9f3:	eb 25                	jmp    c002ca1a <setup_stack+0x212>
  {
    *esp = *esp - sizeof(char *);
c002c9f5:	8b 45 08             	mov    0x8(%ebp),%eax
c002c9f8:	8b 00                	mov    (%eax),%eax
c002c9fa:	8d 50 fc             	lea    -0x4(%eax),%edx
c002c9fd:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca00:	89 10                	mov    %edx,(%eax)
    *(int *)*esp = arr[j];
c002ca02:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca05:	8b 00                	mov    (%eax),%eax
c002ca07:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002ca0a:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
c002ca11:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002ca14:	01 ca                	add    %ecx,%edx
c002ca16:	8b 12                	mov    (%edx),%edx
c002ca18:	89 10                	mov    %edx,(%eax)
  while (--j >= 0)
c002ca1a:	ff 4d dc             	decl   -0x24(%ebp)
c002ca1d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c002ca21:	79 d2                	jns    c002c9f5 <setup_stack+0x1ed>
  }

 
  *esp -= 4;
c002ca23:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca26:	8b 00                	mov    (%eax),%eax
c002ca28:	8d 50 fc             	lea    -0x4(%eax),%edx
c002ca2b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca2e:	89 10                	mov    %edx,(%eax)
  (*(int *)(*esp)) = (int)(*esp + 4);
c002ca30:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca33:	8b 00                	mov    (%eax),%eax
c002ca35:	8b 55 08             	mov    0x8(%ebp),%edx
c002ca38:	8b 12                	mov    (%edx),%edx
c002ca3a:	83 c2 04             	add    $0x4,%edx
c002ca3d:	89 10                	mov    %edx,(%eax)

  *esp -= 4;
c002ca3f:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca42:	8b 00                	mov    (%eax),%eax
c002ca44:	8d 50 fc             	lea    -0x4(%eax),%edx
c002ca47:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca4a:	89 10                	mov    %edx,(%eax)
  *(int *)(*esp) = argc;
c002ca4c:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca4f:	8b 00                	mov    (%eax),%eax
c002ca51:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002ca54:	89 10                	mov    %edx,(%eax)

  *esp -= 4;
c002ca56:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca59:	8b 00                	mov    (%eax),%eax
c002ca5b:	8d 50 fc             	lea    -0x4(%eax),%edx
c002ca5e:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca61:	89 10                	mov    %edx,(%eax)
  (*(int *)(*esp)) = 0;
c002ca63:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca66:	8b 00                	mov    (%eax),%eax
c002ca68:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

  return success;
c002ca6e:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c002ca71:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ca74:	c9                   	leave  
c002ca75:	c3                   	ret    

c002ca76 <install_page>:
   with palloc_get_page().
   Returns true on success, false if UPAGE is already mapped or
   if memory allocation fails. */
static bool
install_page(void *upage, void *kpage, bool writable)
{
c002ca76:	55                   	push   %ebp
c002ca77:	89 e5                	mov    %esp,%ebp
c002ca79:	83 ec 28             	sub    $0x28,%esp
c002ca7c:	8b 45 10             	mov    0x10(%ebp),%eax
c002ca7f:	88 45 e4             	mov    %al,-0x1c(%ebp)
  struct thread *t = thread_current();
c002ca82:	e8 2f 46 ff ff       	call   c00210b6 <thread_current>
c002ca87:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Verify that there's not already a page at that virtual
     address, then map our page there. */
  return (pagedir_get_page(t->pagedir, upage) == NULL && pagedir_set_page(t->pagedir, upage, kpage, writable));
c002ca8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ca8d:	8b 40 30             	mov    0x30(%eax),%eax
c002ca90:	83 ec 08             	sub    $0x8,%esp
c002ca93:	ff 75 08             	pushl  0x8(%ebp)
c002ca96:	50                   	push   %eax
c002ca97:	e8 a7 05 00 00       	call   c002d043 <pagedir_get_page>
c002ca9c:	83 c4 10             	add    $0x10,%esp
c002ca9f:	85 c0                	test   %eax,%eax
c002caa1:	75 25                	jne    c002cac8 <install_page+0x52>
c002caa3:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c002caa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002caaa:	8b 40 30             	mov    0x30(%eax),%eax
c002caad:	52                   	push   %edx
c002caae:	ff 75 0c             	pushl  0xc(%ebp)
c002cab1:	ff 75 08             	pushl  0x8(%ebp)
c002cab4:	50                   	push   %eax
c002cab5:	e8 26 04 00 00       	call   c002cee0 <pagedir_set_page>
c002caba:	83 c4 10             	add    $0x10,%esp
c002cabd:	84 c0                	test   %al,%al
c002cabf:	74 07                	je     c002cac8 <install_page+0x52>
c002cac1:	b8 01 00 00 00       	mov    $0x1,%eax
c002cac6:	eb 05                	jmp    c002cacd <install_page+0x57>
c002cac8:	b8 00 00 00 00       	mov    $0x0,%eax
c002cacd:	83 e0 01             	and    $0x1,%eax
}
c002cad0:	c9                   	leave  
c002cad1:	c3                   	ret    

c002cad2 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c002cad2:	55                   	push   %ebp
c002cad3:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c002cad5:	8b 45 08             	mov    0x8(%ebp),%eax
c002cad8:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002cadd:	5d                   	pop    %ebp
c002cade:	c3                   	ret    

c002cadf <is_user_vaddr>:
{
c002cadf:	55                   	push   %ebp
c002cae0:	89 e5                	mov    %esp,%ebp
  return vaddr < PHYS_BASE;
c002cae2:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c002cae9:	0f 96 c0             	setbe  %al
}
c002caec:	5d                   	pop    %ebp
c002caed:	c3                   	ret    

c002caee <is_kernel_vaddr>:
{
c002caee:	55                   	push   %ebp
c002caef:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c002caf1:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c002caf8:	0f 97 c0             	seta   %al
}
c002cafb:	5d                   	pop    %ebp
c002cafc:	c3                   	ret    

c002cafd <ptov>:
{
c002cafd:	55                   	push   %ebp
c002cafe:	89 e5                	mov    %esp,%ebp
c002cb00:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c002cb03:	8b 45 08             	mov    0x8(%ebp),%eax
c002cb06:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002cb0b:	76 1e                	jbe    c002cb2b <ptov+0x2e>
c002cb0d:	83 ec 0c             	sub    $0xc,%esp
c002cb10:	68 4c 2e 03 c0       	push   $0xc0032e4c
c002cb15:	68 67 2e 03 c0       	push   $0xc0032e67
c002cb1a:	68 f8 2f 03 c0       	push   $0xc0032ff8
c002cb1f:	6a 4a                	push   $0x4a
c002cb21:	68 7e 2e 03 c0       	push   $0xc0032e7e
c002cb26:	e8 72 d0 ff ff       	call   c0029b9d <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c002cb2b:	8b 45 08             	mov    0x8(%ebp),%eax
c002cb2e:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c002cb33:	c9                   	leave  
c002cb34:	c3                   	ret    

c002cb35 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c002cb35:	55                   	push   %ebp
c002cb36:	89 e5                	mov    %esp,%ebp
c002cb38:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c002cb3b:	ff 75 08             	pushl  0x8(%ebp)
c002cb3e:	e8 ab ff ff ff       	call   c002caee <is_kernel_vaddr>
c002cb43:	83 c4 04             	add    $0x4,%esp
c002cb46:	84 c0                	test   %al,%al
c002cb48:	75 1e                	jne    c002cb68 <vtop+0x33>
c002cb4a:	83 ec 0c             	sub    $0xc,%esp
c002cb4d:	68 94 2e 03 c0       	push   $0xc0032e94
c002cb52:	68 67 2e 03 c0       	push   $0xc0032e67
c002cb57:	68 18 30 03 c0       	push   $0xc0033018
c002cb5c:	6a 54                	push   $0x54
c002cb5e:	68 7e 2e 03 c0       	push   $0xc0032e7e
c002cb63:	e8 35 d0 ff ff       	call   c0029b9d <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002cb68:	8b 45 08             	mov    0x8(%ebp),%eax
c002cb6b:	05 00 00 00 40       	add    $0x40000000,%eax
}
c002cb70:	c9                   	leave  
c002cb71:	c3                   	ret    

c002cb72 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c002cb72:	55                   	push   %ebp
c002cb73:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002cb75:	8b 45 08             	mov    0x8(%ebp),%eax
c002cb78:	c1 e8 0c             	shr    $0xc,%eax
c002cb7b:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c002cb80:	5d                   	pop    %ebp
c002cb81:	c3                   	ret    

c002cb82 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c002cb82:	55                   	push   %ebp
c002cb83:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c002cb85:	8b 45 08             	mov    0x8(%ebp),%eax
c002cb88:	c1 e8 16             	shr    $0x16,%eax
}
c002cb8b:	5d                   	pop    %ebp
c002cb8c:	c3                   	ret    

c002cb8d <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c002cb8d:	55                   	push   %ebp
c002cb8e:	89 e5                	mov    %esp,%ebp
c002cb90:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c002cb93:	ff 75 08             	pushl  0x8(%ebp)
c002cb96:	e8 37 ff ff ff       	call   c002cad2 <pg_ofs>
c002cb9b:	83 c4 04             	add    $0x4,%esp
c002cb9e:	85 c0                	test   %eax,%eax
c002cba0:	74 1e                	je     c002cbc0 <pde_create+0x33>
c002cba2:	83 ec 0c             	sub    $0xc,%esp
c002cba5:	68 ac 2e 03 c0       	push   $0xc0032eac
c002cbaa:	68 67 2e 03 c0       	push   $0xc0032e67
c002cbaf:	68 0c 30 03 c0       	push   $0xc003300c
c002cbb4:	6a 48                	push   $0x48
c002cbb6:	68 bd 2e 03 c0       	push   $0xc0032ebd
c002cbbb:	e8 dd cf ff ff       	call   c0029b9d <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c002cbc0:	83 ec 0c             	sub    $0xc,%esp
c002cbc3:	ff 75 08             	pushl  0x8(%ebp)
c002cbc6:	e8 6a ff ff ff       	call   c002cb35 <vtop>
c002cbcb:	83 c4 10             	add    $0x10,%esp
c002cbce:	83 c8 07             	or     $0x7,%eax
}
c002cbd1:	c9                   	leave  
c002cbd2:	c3                   	ret    

c002cbd3 <pde_get_pt>:

/* Returns a pointer to the page table that page directory entry
   PDE, which must "present", points to. */
static inline uint32_t *pde_get_pt (uint32_t pde) {
c002cbd3:	55                   	push   %ebp
c002cbd4:	89 e5                	mov    %esp,%ebp
c002cbd6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pde & PTE_P);
c002cbd9:	8b 45 08             	mov    0x8(%ebp),%eax
c002cbdc:	83 e0 01             	and    $0x1,%eax
c002cbdf:	85 c0                	test   %eax,%eax
c002cbe1:	75 1e                	jne    c002cc01 <pde_get_pt+0x2e>
c002cbe3:	83 ec 0c             	sub    $0xc,%esp
c002cbe6:	68 d1 2e 03 c0       	push   $0xc0032ed1
c002cbeb:	68 67 2e 03 c0       	push   $0xc0032e67
c002cbf0:	68 ec 2f 03 c0       	push   $0xc0032fec
c002cbf5:	6a 4f                	push   $0x4f
c002cbf7:	68 bd 2e 03 c0       	push   $0xc0032ebd
c002cbfc:	e8 9c cf ff ff       	call   c0029b9d <debug_panic>
  return ptov (pde & PTE_ADDR);
c002cc01:	8b 45 08             	mov    0x8(%ebp),%eax
c002cc04:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002cc09:	83 ec 0c             	sub    $0xc,%esp
c002cc0c:	50                   	push   %eax
c002cc0d:	e8 eb fe ff ff       	call   c002cafd <ptov>
c002cc12:	83 c4 10             	add    $0x10,%esp
}
c002cc15:	c9                   	leave  
c002cc16:	c3                   	ret    

c002cc17 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c002cc17:	55                   	push   %ebp
c002cc18:	89 e5                	mov    %esp,%ebp
c002cc1a:	83 ec 18             	sub    $0x18,%esp
c002cc1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c002cc20:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c002cc23:	ff 75 08             	pushl  0x8(%ebp)
c002cc26:	e8 a7 fe ff ff       	call   c002cad2 <pg_ofs>
c002cc2b:	83 c4 04             	add    $0x4,%esp
c002cc2e:	85 c0                	test   %eax,%eax
c002cc30:	74 1e                	je     c002cc50 <pte_create_kernel+0x39>
c002cc32:	83 ec 0c             	sub    $0xc,%esp
c002cc35:	68 dd 2e 03 c0       	push   $0xc0032edd
c002cc3a:	68 67 2e 03 c0       	push   $0xc0032e67
c002cc3f:	68 34 30 03 c0       	push   $0xc0033034
c002cc44:	6a 58                	push   $0x58
c002cc46:	68 bd 2e 03 c0       	push   $0xc0032ebd
c002cc4b:	e8 4d cf ff ff       	call   c0029b9d <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002cc50:	83 ec 0c             	sub    $0xc,%esp
c002cc53:	ff 75 08             	pushl  0x8(%ebp)
c002cc56:	e8 da fe ff ff       	call   c002cb35 <vtop>
c002cc5b:	83 c4 10             	add    $0x10,%esp
c002cc5e:	89 c2                	mov    %eax,%edx
c002cc60:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002cc64:	74 07                	je     c002cc6d <pte_create_kernel+0x56>
c002cc66:	b8 02 00 00 00       	mov    $0x2,%eax
c002cc6b:	eb 05                	jmp    c002cc72 <pte_create_kernel+0x5b>
c002cc6d:	b8 00 00 00 00       	mov    $0x0,%eax
c002cc72:	09 d0                	or     %edx,%eax
c002cc74:	83 c8 01             	or     $0x1,%eax
}
c002cc77:	c9                   	leave  
c002cc78:	c3                   	ret    

c002cc79 <pte_create_user>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable by both user and kernel code. */
static inline uint32_t pte_create_user (void *page, bool writable) {
c002cc79:	55                   	push   %ebp
c002cc7a:	89 e5                	mov    %esp,%ebp
c002cc7c:	83 ec 18             	sub    $0x18,%esp
c002cc7f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002cc82:	88 45 f4             	mov    %al,-0xc(%ebp)
  return pte_create_kernel (page, writable) | PTE_U;
c002cc85:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002cc89:	83 ec 08             	sub    $0x8,%esp
c002cc8c:	50                   	push   %eax
c002cc8d:	ff 75 08             	pushl  0x8(%ebp)
c002cc90:	e8 82 ff ff ff       	call   c002cc17 <pte_create_kernel>
c002cc95:	83 c4 10             	add    $0x10,%esp
c002cc98:	83 c8 04             	or     $0x4,%eax
}
c002cc9b:	c9                   	leave  
c002cc9c:	c3                   	ret    

c002cc9d <pte_get_page>:

/* Returns a pointer to the page that page table entry PTE points
   to. */
static inline void *pte_get_page (uint32_t pte) {
c002cc9d:	55                   	push   %ebp
c002cc9e:	89 e5                	mov    %esp,%ebp
c002cca0:	83 ec 08             	sub    $0x8,%esp
  return ptov (pte & PTE_ADDR);
c002cca3:	8b 45 08             	mov    0x8(%ebp),%eax
c002cca6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002ccab:	83 ec 0c             	sub    $0xc,%esp
c002ccae:	50                   	push   %eax
c002ccaf:	e8 49 fe ff ff       	call   c002cafd <ptov>
c002ccb4:	83 c4 10             	add    $0x10,%esp
}
c002ccb7:	c9                   	leave  
c002ccb8:	c3                   	ret    

c002ccb9 <pagedir_create>:
   virtual addresses, but none for user virtual addresses.
   Returns the new page directory, or a null pointer if memory
   allocation fails. */
uint32_t *
pagedir_create (void) 
{
c002ccb9:	55                   	push   %ebp
c002ccba:	89 e5                	mov    %esp,%ebp
c002ccbc:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pd = palloc_get_page (0);
c002ccbf:	83 ec 0c             	sub    $0xc,%esp
c002ccc2:	6a 00                	push   $0x0
c002ccc4:	e8 a6 6a ff ff       	call   c002376f <palloc_get_page>
c002ccc9:	83 c4 10             	add    $0x10,%esp
c002cccc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pd != NULL)
c002cccf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002ccd3:	74 19                	je     c002ccee <pagedir_create+0x35>
    memcpy (pd, init_page_dir, PGSIZE);
c002ccd5:	a1 00 a9 03 c0       	mov    0xc003a900,%eax
c002ccda:	83 ec 04             	sub    $0x4,%esp
c002ccdd:	68 00 10 00 00       	push   $0x1000
c002cce2:	50                   	push   %eax
c002cce3:	ff 75 f4             	pushl  -0xc(%ebp)
c002cce6:	e8 f2 bc ff ff       	call   c00289dd <memcpy>
c002cceb:	83 c4 10             	add    $0x10,%esp
  return pd;
c002ccee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ccf1:	c9                   	leave  
c002ccf2:	c3                   	ret    

c002ccf3 <pagedir_destroy>:

/* Destroys page directory PD, freeing all the pages it
   references. */
void
pagedir_destroy (uint32_t *pd) 
{
c002ccf3:	55                   	push   %ebp
c002ccf4:	89 e5                	mov    %esp,%ebp
c002ccf6:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pde;

  if (pd == NULL)
c002ccf9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ccfd:	0f 84 d9 00 00 00    	je     c002cddc <pagedir_destroy+0xe9>
    return;

  ASSERT (pd != init_page_dir);
c002cd03:	a1 00 a9 03 c0       	mov    0xc003a900,%eax
c002cd08:	39 45 08             	cmp    %eax,0x8(%ebp)
c002cd0b:	75 1e                	jne    c002cd2b <pagedir_destroy+0x38>
c002cd0d:	83 ec 0c             	sub    $0xc,%esp
c002cd10:	68 f0 2e 03 c0       	push   $0xc0032ef0
c002cd15:	68 67 2e 03 c0       	push   $0xc0032e67
c002cd1a:	68 dc 2f 03 c0       	push   $0xc0032fdc
c002cd1f:	6a 23                	push   $0x23
c002cd21:	68 04 2f 03 c0       	push   $0xc0032f04
c002cd26:	e8 72 ce ff ff       	call   c0029b9d <debug_panic>
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002cd2b:	8b 45 08             	mov    0x8(%ebp),%eax
c002cd2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002cd31:	eb 74                	jmp    c002cda7 <pagedir_destroy+0xb4>
    if (*pde & PTE_P) 
c002cd33:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cd36:	8b 00                	mov    (%eax),%eax
c002cd38:	83 e0 01             	and    $0x1,%eax
c002cd3b:	85 c0                	test   %eax,%eax
c002cd3d:	74 64                	je     c002cda3 <pagedir_destroy+0xb0>
      {
        uint32_t *pt = pde_get_pt (*pde);
c002cd3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cd42:	8b 00                	mov    (%eax),%eax
c002cd44:	83 ec 0c             	sub    $0xc,%esp
c002cd47:	50                   	push   %eax
c002cd48:	e8 86 fe ff ff       	call   c002cbd3 <pde_get_pt>
c002cd4d:	83 c4 10             	add    $0x10,%esp
c002cd50:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t *pte;
        
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002cd53:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002cd56:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002cd59:	eb 2d                	jmp    c002cd88 <pagedir_destroy+0x95>
          if (*pte & PTE_P) 
c002cd5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002cd5e:	8b 00                	mov    (%eax),%eax
c002cd60:	83 e0 01             	and    $0x1,%eax
c002cd63:	85 c0                	test   %eax,%eax
c002cd65:	74 1d                	je     c002cd84 <pagedir_destroy+0x91>
            palloc_free_page (pte_get_page (*pte));
c002cd67:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002cd6a:	8b 00                	mov    (%eax),%eax
c002cd6c:	83 ec 0c             	sub    $0xc,%esp
c002cd6f:	50                   	push   %eax
c002cd70:	e8 28 ff ff ff       	call   c002cc9d <pte_get_page>
c002cd75:	83 c4 10             	add    $0x10,%esp
c002cd78:	83 ec 0c             	sub    $0xc,%esp
c002cd7b:	50                   	push   %eax
c002cd7c:	e8 46 6b ff ff       	call   c00238c7 <palloc_free_page>
c002cd81:	83 c4 10             	add    $0x10,%esp
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002cd84:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
c002cd88:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002cd8b:	05 00 10 00 00       	add    $0x1000,%eax
c002cd90:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002cd93:	77 c6                	ja     c002cd5b <pagedir_destroy+0x68>
        palloc_free_page (pt);
c002cd95:	83 ec 0c             	sub    $0xc,%esp
c002cd98:	ff 75 ec             	pushl  -0x14(%ebp)
c002cd9b:	e8 27 6b ff ff       	call   c00238c7 <palloc_free_page>
c002cda0:	83 c4 10             	add    $0x10,%esp
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002cda3:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002cda7:	83 ec 0c             	sub    $0xc,%esp
c002cdaa:	68 00 00 00 c0       	push   $0xc0000000
c002cdaf:	e8 ce fd ff ff       	call   c002cb82 <pd_no>
c002cdb4:	83 c4 10             	add    $0x10,%esp
c002cdb7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002cdbe:	8b 45 08             	mov    0x8(%ebp),%eax
c002cdc1:	01 d0                	add    %edx,%eax
c002cdc3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002cdc6:	0f 87 67 ff ff ff    	ja     c002cd33 <pagedir_destroy+0x40>
      }
  palloc_free_page (pd);
c002cdcc:	83 ec 0c             	sub    $0xc,%esp
c002cdcf:	ff 75 08             	pushl  0x8(%ebp)
c002cdd2:	e8 f0 6a ff ff       	call   c00238c7 <palloc_free_page>
c002cdd7:	83 c4 10             	add    $0x10,%esp
c002cdda:	eb 01                	jmp    c002cddd <pagedir_destroy+0xea>
    return;
c002cddc:	90                   	nop
}
c002cddd:	c9                   	leave  
c002cdde:	c3                   	ret    

c002cddf <lookup_page>:
   on CREATE.  If CREATE is true, then a new page table is
   created and a pointer into it is returned.  Otherwise, a null
   pointer is returned. */
static uint32_t *
lookup_page (uint32_t *pd, const void *vaddr, bool create)
{
c002cddf:	55                   	push   %ebp
c002cde0:	89 e5                	mov    %esp,%ebp
c002cde2:	83 ec 28             	sub    $0x28,%esp
c002cde5:	8b 45 10             	mov    0x10(%ebp),%eax
c002cde8:	88 45 e4             	mov    %al,-0x1c(%ebp)
  uint32_t *pt, *pde;

  ASSERT (pd != NULL);
c002cdeb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002cdef:	75 1e                	jne    c002ce0f <lookup_page+0x30>
c002cdf1:	83 ec 0c             	sub    $0xc,%esp
c002cdf4:	68 1d 2f 03 c0       	push   $0xc0032f1d
c002cdf9:	68 67 2e 03 c0       	push   $0xc0032e67
c002cdfe:	68 00 30 03 c0       	push   $0xc0033000
c002ce03:	6a 3d                	push   $0x3d
c002ce05:	68 04 2f 03 c0       	push   $0xc0032f04
c002ce0a:	e8 8e cd ff ff       	call   c0029b9d <debug_panic>

  /* Shouldn't create new kernel virtual mappings. */
  ASSERT (!create || is_user_vaddr (vaddr));
c002ce0f:	8a 45 e4             	mov    -0x1c(%ebp),%al
c002ce12:	83 f0 01             	xor    $0x1,%eax
c002ce15:	84 c0                	test   %al,%al
c002ce17:	75 30                	jne    c002ce49 <lookup_page+0x6a>
c002ce19:	83 ec 0c             	sub    $0xc,%esp
c002ce1c:	ff 75 0c             	pushl  0xc(%ebp)
c002ce1f:	e8 bb fc ff ff       	call   c002cadf <is_user_vaddr>
c002ce24:	83 c4 10             	add    $0x10,%esp
c002ce27:	84 c0                	test   %al,%al
c002ce29:	75 1e                	jne    c002ce49 <lookup_page+0x6a>
c002ce2b:	83 ec 0c             	sub    $0xc,%esp
c002ce2e:	68 28 2f 03 c0       	push   $0xc0032f28
c002ce33:	68 67 2e 03 c0       	push   $0xc0032e67
c002ce38:	68 00 30 03 c0       	push   $0xc0033000
c002ce3d:	6a 40                	push   $0x40
c002ce3f:	68 04 2f 03 c0       	push   $0xc0032f04
c002ce44:	e8 54 cd ff ff       	call   c0029b9d <debug_panic>

  /* Check for a page table for VADDR.
     If one is missing, create one if requested. */
  pde = pd + pd_no (vaddr);
c002ce49:	83 ec 0c             	sub    $0xc,%esp
c002ce4c:	ff 75 0c             	pushl  0xc(%ebp)
c002ce4f:	e8 2e fd ff ff       	call   c002cb82 <pd_no>
c002ce54:	83 c4 10             	add    $0x10,%esp
c002ce57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002ce5e:	8b 45 08             	mov    0x8(%ebp),%eax
c002ce61:	01 d0                	add    %edx,%eax
c002ce63:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (*pde == 0) 
c002ce66:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ce69:	8b 00                	mov    (%eax),%eax
c002ce6b:	85 c0                	test   %eax,%eax
c002ce6d:	75 41                	jne    c002ceb0 <lookup_page+0xd1>
    {
      if (create)
c002ce6f:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c002ce73:	74 34                	je     c002cea9 <lookup_page+0xca>
        {
          pt = palloc_get_page (PAL_ZERO);
c002ce75:	83 ec 0c             	sub    $0xc,%esp
c002ce78:	6a 02                	push   $0x2
c002ce7a:	e8 f0 68 ff ff       	call   c002376f <palloc_get_page>
c002ce7f:	83 c4 10             	add    $0x10,%esp
c002ce82:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if (pt == NULL) 
c002ce85:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002ce89:	75 07                	jne    c002ce92 <lookup_page+0xb3>
            return NULL; 
c002ce8b:	b8 00 00 00 00       	mov    $0x0,%eax
c002ce90:	eb 4c                	jmp    c002cede <lookup_page+0xff>
      
          *pde = pde_create (pt);
c002ce92:	83 ec 0c             	sub    $0xc,%esp
c002ce95:	ff 75 f0             	pushl  -0x10(%ebp)
c002ce98:	e8 f0 fc ff ff       	call   c002cb8d <pde_create>
c002ce9d:	83 c4 10             	add    $0x10,%esp
c002cea0:	89 c2                	mov    %eax,%edx
c002cea2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cea5:	89 10                	mov    %edx,(%eax)
c002cea7:	eb 07                	jmp    c002ceb0 <lookup_page+0xd1>
        }
      else
        return NULL;
c002cea9:	b8 00 00 00 00       	mov    $0x0,%eax
c002ceae:	eb 2e                	jmp    c002cede <lookup_page+0xff>
    }

  /* Return the page table entry. */
  pt = pde_get_pt (*pde);
c002ceb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ceb3:	8b 00                	mov    (%eax),%eax
c002ceb5:	83 ec 0c             	sub    $0xc,%esp
c002ceb8:	50                   	push   %eax
c002ceb9:	e8 15 fd ff ff       	call   c002cbd3 <pde_get_pt>
c002cebe:	83 c4 10             	add    $0x10,%esp
c002cec1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  return &pt[pt_no (vaddr)];
c002cec4:	83 ec 0c             	sub    $0xc,%esp
c002cec7:	ff 75 0c             	pushl  0xc(%ebp)
c002ceca:	e8 a3 fc ff ff       	call   c002cb72 <pt_no>
c002cecf:	83 c4 10             	add    $0x10,%esp
c002ced2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002ced9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002cedc:	01 d0                	add    %edx,%eax
}
c002cede:	c9                   	leave  
c002cedf:	c3                   	ret    

c002cee0 <pagedir_set_page>:
   otherwise it is read-only.
   Returns true if successful, false if memory allocation
   failed. */
bool
pagedir_set_page (uint32_t *pd, void *upage, void *kpage, bool writable)
{
c002cee0:	55                   	push   %ebp
c002cee1:	89 e5                	mov    %esp,%ebp
c002cee3:	83 ec 28             	sub    $0x28,%esp
c002cee6:	8b 45 14             	mov    0x14(%ebp),%eax
c002cee9:	88 45 e4             	mov    %al,-0x1c(%ebp)
  uint32_t *pte;

  ASSERT (pg_ofs (upage) == 0);
c002ceec:	ff 75 0c             	pushl  0xc(%ebp)
c002ceef:	e8 de fb ff ff       	call   c002cad2 <pg_ofs>
c002cef4:	83 c4 04             	add    $0x4,%esp
c002cef7:	85 c0                	test   %eax,%eax
c002cef9:	74 1e                	je     c002cf19 <pagedir_set_page+0x39>
c002cefb:	83 ec 0c             	sub    $0xc,%esp
c002cefe:	68 49 2f 03 c0       	push   $0xc0032f49
c002cf03:	68 67 2e 03 c0       	push   $0xc0032e67
c002cf08:	68 20 30 03 c0       	push   $0xc0033020
c002cf0d:	6a 67                	push   $0x67
c002cf0f:	68 04 2f 03 c0       	push   $0xc0032f04
c002cf14:	e8 84 cc ff ff       	call   c0029b9d <debug_panic>
  ASSERT (pg_ofs (kpage) == 0);
c002cf19:	83 ec 0c             	sub    $0xc,%esp
c002cf1c:	ff 75 10             	pushl  0x10(%ebp)
c002cf1f:	e8 ae fb ff ff       	call   c002cad2 <pg_ofs>
c002cf24:	83 c4 10             	add    $0x10,%esp
c002cf27:	85 c0                	test   %eax,%eax
c002cf29:	74 1e                	je     c002cf49 <pagedir_set_page+0x69>
c002cf2b:	83 ec 0c             	sub    $0xc,%esp
c002cf2e:	68 5d 2f 03 c0       	push   $0xc0032f5d
c002cf33:	68 67 2e 03 c0       	push   $0xc0032e67
c002cf38:	68 20 30 03 c0       	push   $0xc0033020
c002cf3d:	6a 68                	push   $0x68
c002cf3f:	68 04 2f 03 c0       	push   $0xc0032f04
c002cf44:	e8 54 cc ff ff       	call   c0029b9d <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002cf49:	83 ec 0c             	sub    $0xc,%esp
c002cf4c:	ff 75 0c             	pushl  0xc(%ebp)
c002cf4f:	e8 8b fb ff ff       	call   c002cadf <is_user_vaddr>
c002cf54:	83 c4 10             	add    $0x10,%esp
c002cf57:	84 c0                	test   %al,%al
c002cf59:	75 1e                	jne    c002cf79 <pagedir_set_page+0x99>
c002cf5b:	83 ec 0c             	sub    $0xc,%esp
c002cf5e:	68 71 2f 03 c0       	push   $0xc0032f71
c002cf63:	68 67 2e 03 c0       	push   $0xc0032e67
c002cf68:	68 20 30 03 c0       	push   $0xc0033020
c002cf6d:	6a 69                	push   $0x69
c002cf6f:	68 04 2f 03 c0       	push   $0xc0032f04
c002cf74:	e8 24 cc ff ff       	call   c0029b9d <debug_panic>
  ASSERT (vtop (kpage) >> PTSHIFT < init_ram_pages);
c002cf79:	83 ec 0c             	sub    $0xc,%esp
c002cf7c:	ff 75 10             	pushl  0x10(%ebp)
c002cf7f:	e8 b1 fb ff ff       	call   c002cb35 <vtop>
c002cf84:	83 c4 10             	add    $0x10,%esp
c002cf87:	c1 e8 0c             	shr    $0xc,%eax
c002cf8a:	89 c2                	mov    %eax,%edx
c002cf8c:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c002cf91:	39 c2                	cmp    %eax,%edx
c002cf93:	72 1e                	jb     c002cfb3 <pagedir_set_page+0xd3>
c002cf95:	83 ec 0c             	sub    $0xc,%esp
c002cf98:	68 88 2f 03 c0       	push   $0xc0032f88
c002cf9d:	68 67 2e 03 c0       	push   $0xc0032e67
c002cfa2:	68 20 30 03 c0       	push   $0xc0033020
c002cfa7:	6a 6a                	push   $0x6a
c002cfa9:	68 04 2f 03 c0       	push   $0xc0032f04
c002cfae:	e8 ea cb ff ff       	call   c0029b9d <debug_panic>
  ASSERT (pd != init_page_dir);
c002cfb3:	a1 00 a9 03 c0       	mov    0xc003a900,%eax
c002cfb8:	39 45 08             	cmp    %eax,0x8(%ebp)
c002cfbb:	75 1e                	jne    c002cfdb <pagedir_set_page+0xfb>
c002cfbd:	83 ec 0c             	sub    $0xc,%esp
c002cfc0:	68 f0 2e 03 c0       	push   $0xc0032ef0
c002cfc5:	68 67 2e 03 c0       	push   $0xc0032e67
c002cfca:	68 20 30 03 c0       	push   $0xc0033020
c002cfcf:	6a 6b                	push   $0x6b
c002cfd1:	68 04 2f 03 c0       	push   $0xc0032f04
c002cfd6:	e8 c2 cb ff ff       	call   c0029b9d <debug_panic>

  pte = lookup_page (pd, upage, true);
c002cfdb:	83 ec 04             	sub    $0x4,%esp
c002cfde:	6a 01                	push   $0x1
c002cfe0:	ff 75 0c             	pushl  0xc(%ebp)
c002cfe3:	ff 75 08             	pushl  0x8(%ebp)
c002cfe6:	e8 f4 fd ff ff       	call   c002cddf <lookup_page>
c002cfeb:	83 c4 10             	add    $0x10,%esp
c002cfee:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (pte != NULL) 
c002cff1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002cff5:	74 48                	je     c002d03f <pagedir_set_page+0x15f>
    {
      ASSERT ((*pte & PTE_P) == 0);
c002cff7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cffa:	8b 00                	mov    (%eax),%eax
c002cffc:	83 e0 01             	and    $0x1,%eax
c002cfff:	85 c0                	test   %eax,%eax
c002d001:	74 1e                	je     c002d021 <pagedir_set_page+0x141>
c002d003:	83 ec 0c             	sub    $0xc,%esp
c002d006:	68 b1 2f 03 c0       	push   $0xc0032fb1
c002d00b:	68 67 2e 03 c0       	push   $0xc0032e67
c002d010:	68 20 30 03 c0       	push   $0xc0033020
c002d015:	6a 71                	push   $0x71
c002d017:	68 04 2f 03 c0       	push   $0xc0032f04
c002d01c:	e8 7c cb ff ff       	call   c0029b9d <debug_panic>
      *pte = pte_create_user (kpage, writable);
c002d021:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002d025:	83 ec 08             	sub    $0x8,%esp
c002d028:	50                   	push   %eax
c002d029:	ff 75 10             	pushl  0x10(%ebp)
c002d02c:	e8 48 fc ff ff       	call   c002cc79 <pte_create_user>
c002d031:	83 c4 10             	add    $0x10,%esp
c002d034:	89 c2                	mov    %eax,%edx
c002d036:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d039:	89 10                	mov    %edx,(%eax)
      return true;
c002d03b:	b0 01                	mov    $0x1,%al
c002d03d:	eb 02                	jmp    c002d041 <pagedir_set_page+0x161>
    }
  else
    return false;
c002d03f:	b0 00                	mov    $0x0,%al
}
c002d041:	c9                   	leave  
c002d042:	c3                   	ret    

c002d043 <pagedir_get_page>:
   address UADDR in PD.  Returns the kernel virtual address
   corresponding to that physical address, or a null pointer if
   UADDR is unmapped. */
void *
pagedir_get_page (uint32_t *pd, const void *uaddr) 
{
c002d043:	55                   	push   %ebp
c002d044:	89 e5                	mov    %esp,%ebp
c002d046:	53                   	push   %ebx
c002d047:	83 ec 14             	sub    $0x14,%esp
  uint32_t *pte;

  ASSERT (is_user_vaddr (uaddr));
c002d04a:	ff 75 0c             	pushl  0xc(%ebp)
c002d04d:	e8 8d fa ff ff       	call   c002cadf <is_user_vaddr>
c002d052:	83 c4 04             	add    $0x4,%esp
c002d055:	84 c0                	test   %al,%al
c002d057:	75 21                	jne    c002d07a <pagedir_get_page+0x37>
c002d059:	83 ec 0c             	sub    $0xc,%esp
c002d05c:	68 c5 2f 03 c0       	push   $0xc0032fc5
c002d061:	68 67 2e 03 c0       	push   $0xc0032e67
c002d066:	68 48 30 03 c0       	push   $0xc0033048
c002d06b:	68 82 00 00 00       	push   $0x82
c002d070:	68 04 2f 03 c0       	push   $0xc0032f04
c002d075:	e8 23 cb ff ff       	call   c0029b9d <debug_panic>
  
  pte = lookup_page (pd, uaddr, false);
c002d07a:	83 ec 04             	sub    $0x4,%esp
c002d07d:	6a 00                	push   $0x0
c002d07f:	ff 75 0c             	pushl  0xc(%ebp)
c002d082:	ff 75 08             	pushl  0x8(%ebp)
c002d085:	e8 55 fd ff ff       	call   c002cddf <lookup_page>
c002d08a:	83 c4 10             	add    $0x10,%esp
c002d08d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pte != NULL && (*pte & PTE_P) != 0)
c002d090:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d094:	74 31                	je     c002d0c7 <pagedir_get_page+0x84>
c002d096:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d099:	8b 00                	mov    (%eax),%eax
c002d09b:	83 e0 01             	and    $0x1,%eax
c002d09e:	85 c0                	test   %eax,%eax
c002d0a0:	74 25                	je     c002d0c7 <pagedir_get_page+0x84>
    return pte_get_page (*pte) + pg_ofs (uaddr);
c002d0a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d0a5:	8b 00                	mov    (%eax),%eax
c002d0a7:	83 ec 0c             	sub    $0xc,%esp
c002d0aa:	50                   	push   %eax
c002d0ab:	e8 ed fb ff ff       	call   c002cc9d <pte_get_page>
c002d0b0:	83 c4 10             	add    $0x10,%esp
c002d0b3:	89 c3                	mov    %eax,%ebx
c002d0b5:	83 ec 0c             	sub    $0xc,%esp
c002d0b8:	ff 75 0c             	pushl  0xc(%ebp)
c002d0bb:	e8 12 fa ff ff       	call   c002cad2 <pg_ofs>
c002d0c0:	83 c4 10             	add    $0x10,%esp
c002d0c3:	01 d8                	add    %ebx,%eax
c002d0c5:	eb 05                	jmp    c002d0cc <pagedir_get_page+0x89>
  else
    return NULL;
c002d0c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002d0cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d0cf:	c9                   	leave  
c002d0d0:	c3                   	ret    

c002d0d1 <pagedir_clear_page>:
   directory PD.  Later accesses to the page will fault.  Other
   bits in the page table entry are preserved.
   UPAGE need not be mapped. */
void
pagedir_clear_page (uint32_t *pd, void *upage) 
{
c002d0d1:	55                   	push   %ebp
c002d0d2:	89 e5                	mov    %esp,%ebp
c002d0d4:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pte;

  ASSERT (pg_ofs (upage) == 0);
c002d0d7:	ff 75 0c             	pushl  0xc(%ebp)
c002d0da:	e8 f3 f9 ff ff       	call   c002cad2 <pg_ofs>
c002d0df:	83 c4 04             	add    $0x4,%esp
c002d0e2:	85 c0                	test   %eax,%eax
c002d0e4:	74 21                	je     c002d107 <pagedir_clear_page+0x36>
c002d0e6:	83 ec 0c             	sub    $0xc,%esp
c002d0e9:	68 49 2f 03 c0       	push   $0xc0032f49
c002d0ee:	68 67 2e 03 c0       	push   $0xc0032e67
c002d0f3:	68 5c 30 03 c0       	push   $0xc003305c
c002d0f8:	68 94 00 00 00       	push   $0x94
c002d0fd:	68 04 2f 03 c0       	push   $0xc0032f04
c002d102:	e8 96 ca ff ff       	call   c0029b9d <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002d107:	83 ec 0c             	sub    $0xc,%esp
c002d10a:	ff 75 0c             	pushl  0xc(%ebp)
c002d10d:	e8 cd f9 ff ff       	call   c002cadf <is_user_vaddr>
c002d112:	83 c4 10             	add    $0x10,%esp
c002d115:	84 c0                	test   %al,%al
c002d117:	75 21                	jne    c002d13a <pagedir_clear_page+0x69>
c002d119:	83 ec 0c             	sub    $0xc,%esp
c002d11c:	68 71 2f 03 c0       	push   $0xc0032f71
c002d121:	68 67 2e 03 c0       	push   $0xc0032e67
c002d126:	68 5c 30 03 c0       	push   $0xc003305c
c002d12b:	68 95 00 00 00       	push   $0x95
c002d130:	68 04 2f 03 c0       	push   $0xc0032f04
c002d135:	e8 63 ca ff ff       	call   c0029b9d <debug_panic>

  pte = lookup_page (pd, upage, false);
c002d13a:	83 ec 04             	sub    $0x4,%esp
c002d13d:	6a 00                	push   $0x0
c002d13f:	ff 75 0c             	pushl  0xc(%ebp)
c002d142:	ff 75 08             	pushl  0x8(%ebp)
c002d145:	e8 95 fc ff ff       	call   c002cddf <lookup_page>
c002d14a:	83 c4 10             	add    $0x10,%esp
c002d14d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pte != NULL && (*pte & PTE_P) != 0)
c002d150:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d154:	74 29                	je     c002d17f <pagedir_clear_page+0xae>
c002d156:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d159:	8b 00                	mov    (%eax),%eax
c002d15b:	83 e0 01             	and    $0x1,%eax
c002d15e:	85 c0                	test   %eax,%eax
c002d160:	74 1d                	je     c002d17f <pagedir_clear_page+0xae>
    {
      *pte &= ~PTE_P;
c002d162:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d165:	8b 00                	mov    (%eax),%eax
c002d167:	83 e0 fe             	and    $0xfffffffe,%eax
c002d16a:	89 c2                	mov    %eax,%edx
c002d16c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d16f:	89 10                	mov    %edx,(%eax)
      invalidate_pagedir (pd);
c002d171:	83 ec 0c             	sub    $0xc,%esp
c002d174:	ff 75 08             	pushl  0x8(%ebp)
c002d177:	e8 86 01 00 00       	call   c002d302 <invalidate_pagedir>
c002d17c:	83 c4 10             	add    $0x10,%esp
    }
}
c002d17f:	90                   	nop
c002d180:	c9                   	leave  
c002d181:	c3                   	ret    

c002d182 <pagedir_is_dirty>:
   that is, if the page has been modified since the PTE was
   installed.
   Returns false if PD contains no PTE for VPAGE. */
bool
pagedir_is_dirty (uint32_t *pd, const void *vpage) 
{
c002d182:	55                   	push   %ebp
c002d183:	89 e5                	mov    %esp,%ebp
c002d185:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002d188:	83 ec 04             	sub    $0x4,%esp
c002d18b:	6a 00                	push   $0x0
c002d18d:	ff 75 0c             	pushl  0xc(%ebp)
c002d190:	ff 75 08             	pushl  0x8(%ebp)
c002d193:	e8 47 fc ff ff       	call   c002cddf <lookup_page>
c002d198:	83 c4 10             	add    $0x10,%esp
c002d19b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return pte != NULL && (*pte & PTE_D) != 0;
c002d19e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d1a2:	74 13                	je     c002d1b7 <pagedir_is_dirty+0x35>
c002d1a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d1a7:	8b 00                	mov    (%eax),%eax
c002d1a9:	83 e0 40             	and    $0x40,%eax
c002d1ac:	85 c0                	test   %eax,%eax
c002d1ae:	74 07                	je     c002d1b7 <pagedir_is_dirty+0x35>
c002d1b0:	b8 01 00 00 00       	mov    $0x1,%eax
c002d1b5:	eb 05                	jmp    c002d1bc <pagedir_is_dirty+0x3a>
c002d1b7:	b8 00 00 00 00       	mov    $0x0,%eax
c002d1bc:	83 e0 01             	and    $0x1,%eax
}
c002d1bf:	c9                   	leave  
c002d1c0:	c3                   	ret    

c002d1c1 <pagedir_set_dirty>:

/* Set the dirty bit to DIRTY in the PTE for virtual page VPAGE
   in PD. */
void
pagedir_set_dirty (uint32_t *pd, const void *vpage, bool dirty) 
{
c002d1c1:	55                   	push   %ebp
c002d1c2:	89 e5                	mov    %esp,%ebp
c002d1c4:	83 ec 28             	sub    $0x28,%esp
c002d1c7:	8b 45 10             	mov    0x10(%ebp),%eax
c002d1ca:	88 45 e4             	mov    %al,-0x1c(%ebp)
  uint32_t *pte = lookup_page (pd, vpage, false);
c002d1cd:	83 ec 04             	sub    $0x4,%esp
c002d1d0:	6a 00                	push   $0x0
c002d1d2:	ff 75 0c             	pushl  0xc(%ebp)
c002d1d5:	ff 75 08             	pushl  0x8(%ebp)
c002d1d8:	e8 02 fc ff ff       	call   c002cddf <lookup_page>
c002d1dd:	83 c4 10             	add    $0x10,%esp
c002d1e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pte != NULL) 
c002d1e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d1e7:	74 34                	je     c002d21d <pagedir_set_dirty+0x5c>
    {
      if (dirty)
c002d1e9:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c002d1ed:	74 11                	je     c002d200 <pagedir_set_dirty+0x3f>
        *pte |= PTE_D;
c002d1ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d1f2:	8b 00                	mov    (%eax),%eax
c002d1f4:	83 c8 40             	or     $0x40,%eax
c002d1f7:	89 c2                	mov    %eax,%edx
c002d1f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d1fc:	89 10                	mov    %edx,(%eax)
        {
          *pte &= ~(uint32_t) PTE_D;
          invalidate_pagedir (pd);
        }
    }
}
c002d1fe:	eb 1d                	jmp    c002d21d <pagedir_set_dirty+0x5c>
          *pte &= ~(uint32_t) PTE_D;
c002d200:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d203:	8b 00                	mov    (%eax),%eax
c002d205:	83 e0 bf             	and    $0xffffffbf,%eax
c002d208:	89 c2                	mov    %eax,%edx
c002d20a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d20d:	89 10                	mov    %edx,(%eax)
          invalidate_pagedir (pd);
c002d20f:	83 ec 0c             	sub    $0xc,%esp
c002d212:	ff 75 08             	pushl  0x8(%ebp)
c002d215:	e8 e8 00 00 00       	call   c002d302 <invalidate_pagedir>
c002d21a:	83 c4 10             	add    $0x10,%esp
}
c002d21d:	90                   	nop
c002d21e:	c9                   	leave  
c002d21f:	c3                   	ret    

c002d220 <pagedir_is_accessed>:
   accessed recently, that is, between the time the PTE was
   installed and the last time it was cleared.  Returns false if
   PD contains no PTE for VPAGE. */
bool
pagedir_is_accessed (uint32_t *pd, const void *vpage) 
{
c002d220:	55                   	push   %ebp
c002d221:	89 e5                	mov    %esp,%ebp
c002d223:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002d226:	83 ec 04             	sub    $0x4,%esp
c002d229:	6a 00                	push   $0x0
c002d22b:	ff 75 0c             	pushl  0xc(%ebp)
c002d22e:	ff 75 08             	pushl  0x8(%ebp)
c002d231:	e8 a9 fb ff ff       	call   c002cddf <lookup_page>
c002d236:	83 c4 10             	add    $0x10,%esp
c002d239:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return pte != NULL && (*pte & PTE_A) != 0;
c002d23c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d240:	74 13                	je     c002d255 <pagedir_is_accessed+0x35>
c002d242:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d245:	8b 00                	mov    (%eax),%eax
c002d247:	83 e0 20             	and    $0x20,%eax
c002d24a:	85 c0                	test   %eax,%eax
c002d24c:	74 07                	je     c002d255 <pagedir_is_accessed+0x35>
c002d24e:	b8 01 00 00 00       	mov    $0x1,%eax
c002d253:	eb 05                	jmp    c002d25a <pagedir_is_accessed+0x3a>
c002d255:	b8 00 00 00 00       	mov    $0x0,%eax
c002d25a:	83 e0 01             	and    $0x1,%eax
}
c002d25d:	c9                   	leave  
c002d25e:	c3                   	ret    

c002d25f <pagedir_set_accessed>:

/* Sets the accessed bit to ACCESSED in the PTE for virtual page
   VPAGE in PD. */
void
pagedir_set_accessed (uint32_t *pd, const void *vpage, bool accessed) 
{
c002d25f:	55                   	push   %ebp
c002d260:	89 e5                	mov    %esp,%ebp
c002d262:	83 ec 28             	sub    $0x28,%esp
c002d265:	8b 45 10             	mov    0x10(%ebp),%eax
c002d268:	88 45 e4             	mov    %al,-0x1c(%ebp)
  uint32_t *pte = lookup_page (pd, vpage, false);
c002d26b:	83 ec 04             	sub    $0x4,%esp
c002d26e:	6a 00                	push   $0x0
c002d270:	ff 75 0c             	pushl  0xc(%ebp)
c002d273:	ff 75 08             	pushl  0x8(%ebp)
c002d276:	e8 64 fb ff ff       	call   c002cddf <lookup_page>
c002d27b:	83 c4 10             	add    $0x10,%esp
c002d27e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pte != NULL) 
c002d281:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d285:	74 34                	je     c002d2bb <pagedir_set_accessed+0x5c>
    {
      if (accessed)
c002d287:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c002d28b:	74 11                	je     c002d29e <pagedir_set_accessed+0x3f>
        *pte |= PTE_A;
c002d28d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d290:	8b 00                	mov    (%eax),%eax
c002d292:	83 c8 20             	or     $0x20,%eax
c002d295:	89 c2                	mov    %eax,%edx
c002d297:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d29a:	89 10                	mov    %edx,(%eax)
        {
          *pte &= ~(uint32_t) PTE_A; 
          invalidate_pagedir (pd);
        }
    }
}
c002d29c:	eb 1d                	jmp    c002d2bb <pagedir_set_accessed+0x5c>
          *pte &= ~(uint32_t) PTE_A; 
c002d29e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d2a1:	8b 00                	mov    (%eax),%eax
c002d2a3:	83 e0 df             	and    $0xffffffdf,%eax
c002d2a6:	89 c2                	mov    %eax,%edx
c002d2a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d2ab:	89 10                	mov    %edx,(%eax)
          invalidate_pagedir (pd);
c002d2ad:	83 ec 0c             	sub    $0xc,%esp
c002d2b0:	ff 75 08             	pushl  0x8(%ebp)
c002d2b3:	e8 4a 00 00 00       	call   c002d302 <invalidate_pagedir>
c002d2b8:	83 c4 10             	add    $0x10,%esp
}
c002d2bb:	90                   	nop
c002d2bc:	c9                   	leave  
c002d2bd:	c3                   	ret    

c002d2be <pagedir_activate>:

/* Loads page directory PD into the CPU's page directory base
   register. */
void
pagedir_activate (uint32_t *pd) 
{
c002d2be:	55                   	push   %ebp
c002d2bf:	89 e5                	mov    %esp,%ebp
c002d2c1:	83 ec 08             	sub    $0x8,%esp
  if (pd == NULL)
c002d2c4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002d2c8:	75 08                	jne    c002d2d2 <pagedir_activate+0x14>
    pd = init_page_dir;
c002d2ca:	a1 00 a9 03 c0       	mov    0xc003a900,%eax
c002d2cf:	89 45 08             	mov    %eax,0x8(%ebp)
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base
     Address of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (pd)) : "memory");
c002d2d2:	83 ec 0c             	sub    $0xc,%esp
c002d2d5:	ff 75 08             	pushl  0x8(%ebp)
c002d2d8:	e8 58 f8 ff ff       	call   c002cb35 <vtop>
c002d2dd:	83 c4 10             	add    $0x10,%esp
c002d2e0:	0f 22 d8             	mov    %eax,%cr3
}
c002d2e3:	90                   	nop
c002d2e4:	c9                   	leave  
c002d2e5:	c3                   	ret    

c002d2e6 <active_pd>:

/* Returns the currently active page directory. */
static uint32_t *
active_pd (void) 
{
c002d2e6:	55                   	push   %ebp
c002d2e7:	89 e5                	mov    %esp,%ebp
c002d2e9:	83 ec 18             	sub    $0x18,%esp
  /* Copy CR3, the page directory base register (PDBR), into
     `pd'.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 3.7.5 "Base Address of the Page Directory". */
  uintptr_t pd;
  asm volatile ("movl %%cr3, %0" : "=r" (pd));
c002d2ec:	0f 20 d8             	mov    %cr3,%eax
c002d2ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return ptov (pd);
c002d2f2:	83 ec 0c             	sub    $0xc,%esp
c002d2f5:	ff 75 f4             	pushl  -0xc(%ebp)
c002d2f8:	e8 00 f8 ff ff       	call   c002cafd <ptov>
c002d2fd:	83 c4 10             	add    $0x10,%esp
}
c002d300:	c9                   	leave  
c002d301:	c3                   	ret    

c002d302 <invalidate_pagedir>:
   This function invalidates the TLB if PD is the active page
   directory.  (If PD is not active then its entries are not in
   the TLB, so there is no need to invalidate anything.) */
static void
invalidate_pagedir (uint32_t *pd) 
{
c002d302:	55                   	push   %ebp
c002d303:	89 e5                	mov    %esp,%ebp
c002d305:	83 ec 08             	sub    $0x8,%esp
  if (active_pd () == pd) 
c002d308:	e8 d9 ff ff ff       	call   c002d2e6 <active_pd>
c002d30d:	3b 45 08             	cmp    0x8(%ebp),%eax
c002d310:	75 0e                	jne    c002d320 <invalidate_pagedir+0x1e>
    {
      /* Re-activating PD clears the TLB.  See [IA32-v3a] 3.12
         "Translation Lookaside Buffers (TLBs)". */
      pagedir_activate (pd);
c002d312:	83 ec 0c             	sub    $0xc,%esp
c002d315:	ff 75 08             	pushl  0x8(%ebp)
c002d318:	e8 a1 ff ff ff       	call   c002d2be <pagedir_activate>
c002d31d:	83 c4 10             	add    $0x10,%esp
    } 
}
c002d320:	90                   	nop
c002d321:	c9                   	leave  
c002d322:	c3                   	ret    

c002d323 <exception_init>:

   Refer to [IA32-v3a] section 5.15 "Exception and Interrupt
   Reference" for a description of each of these exceptions. */
void
exception_init (void) 
{
c002d323:	55                   	push   %ebp
c002d324:	89 e5                	mov    %esp,%ebp
c002d326:	83 ec 08             	sub    $0x8,%esp
  /* These exceptions can be raised explicitly by a user program,
     e.g. via the INT, INT3, INTO, and BOUND instructions.  Thus,
     we set DPL==3, meaning that user programs are allowed to
     invoke them via these instructions. */
  intr_register_int (3, 3, INTR_ON, kill, "#BP Breakpoint Exception");
c002d329:	83 ec 0c             	sub    $0xc,%esp
c002d32c:	68 70 30 03 c0       	push   $0xc0033070
c002d331:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d336:	6a 01                	push   $0x1
c002d338:	6a 03                	push   $0x3
c002d33a:	6a 03                	push   $0x3
c002d33c:	e8 cb 48 ff ff       	call   c0021c0c <intr_register_int>
c002d341:	83 c4 20             	add    $0x20,%esp
  intr_register_int (4, 3, INTR_ON, kill, "#OF Overflow Exception");
c002d344:	83 ec 0c             	sub    $0xc,%esp
c002d347:	68 89 30 03 c0       	push   $0xc0033089
c002d34c:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d351:	6a 01                	push   $0x1
c002d353:	6a 03                	push   $0x3
c002d355:	6a 04                	push   $0x4
c002d357:	e8 b0 48 ff ff       	call   c0021c0c <intr_register_int>
c002d35c:	83 c4 20             	add    $0x20,%esp
  intr_register_int (5, 3, INTR_ON, kill,
c002d35f:	83 ec 0c             	sub    $0xc,%esp
c002d362:	68 a0 30 03 c0       	push   $0xc00330a0
c002d367:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d36c:	6a 01                	push   $0x1
c002d36e:	6a 03                	push   $0x3
c002d370:	6a 05                	push   $0x5
c002d372:	e8 95 48 ff ff       	call   c0021c0c <intr_register_int>
c002d377:	83 c4 20             	add    $0x20,%esp

  /* These exceptions have DPL==0, preventing user processes from
     invoking them via the INT instruction.  They can still be
     caused indirectly, e.g. #DE can be caused by dividing by
     0.  */
  intr_register_int (0, 0, INTR_ON, kill, "#DE Divide Error");
c002d37a:	83 ec 0c             	sub    $0xc,%esp
c002d37d:	68 c3 30 03 c0       	push   $0xc00330c3
c002d382:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d387:	6a 01                	push   $0x1
c002d389:	6a 00                	push   $0x0
c002d38b:	6a 00                	push   $0x0
c002d38d:	e8 7a 48 ff ff       	call   c0021c0c <intr_register_int>
c002d392:	83 c4 20             	add    $0x20,%esp
  intr_register_int (1, 0, INTR_ON, kill, "#DB Debug Exception");
c002d395:	83 ec 0c             	sub    $0xc,%esp
c002d398:	68 d4 30 03 c0       	push   $0xc00330d4
c002d39d:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d3a2:	6a 01                	push   $0x1
c002d3a4:	6a 00                	push   $0x0
c002d3a6:	6a 01                	push   $0x1
c002d3a8:	e8 5f 48 ff ff       	call   c0021c0c <intr_register_int>
c002d3ad:	83 c4 20             	add    $0x20,%esp
  intr_register_int (6, 0, INTR_ON, kill, "#UD Invalid Opcode Exception");
c002d3b0:	83 ec 0c             	sub    $0xc,%esp
c002d3b3:	68 e8 30 03 c0       	push   $0xc00330e8
c002d3b8:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d3bd:	6a 01                	push   $0x1
c002d3bf:	6a 00                	push   $0x0
c002d3c1:	6a 06                	push   $0x6
c002d3c3:	e8 44 48 ff ff       	call   c0021c0c <intr_register_int>
c002d3c8:	83 c4 20             	add    $0x20,%esp
  intr_register_int (7, 0, INTR_ON, kill,
c002d3cb:	83 ec 0c             	sub    $0xc,%esp
c002d3ce:	68 08 31 03 c0       	push   $0xc0033108
c002d3d3:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d3d8:	6a 01                	push   $0x1
c002d3da:	6a 00                	push   $0x0
c002d3dc:	6a 07                	push   $0x7
c002d3de:	e8 29 48 ff ff       	call   c0021c0c <intr_register_int>
c002d3e3:	83 c4 20             	add    $0x20,%esp
                     "#NM Device Not Available Exception");
  intr_register_int (11, 0, INTR_ON, kill, "#NP Segment Not Present");
c002d3e6:	83 ec 0c             	sub    $0xc,%esp
c002d3e9:	68 2b 31 03 c0       	push   $0xc003312b
c002d3ee:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d3f3:	6a 01                	push   $0x1
c002d3f5:	6a 00                	push   $0x0
c002d3f7:	6a 0b                	push   $0xb
c002d3f9:	e8 0e 48 ff ff       	call   c0021c0c <intr_register_int>
c002d3fe:	83 c4 20             	add    $0x20,%esp
  intr_register_int (12, 0, INTR_ON, kill, "#SS Stack Fault Exception");
c002d401:	83 ec 0c             	sub    $0xc,%esp
c002d404:	68 43 31 03 c0       	push   $0xc0033143
c002d409:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d40e:	6a 01                	push   $0x1
c002d410:	6a 00                	push   $0x0
c002d412:	6a 0c                	push   $0xc
c002d414:	e8 f3 47 ff ff       	call   c0021c0c <intr_register_int>
c002d419:	83 c4 20             	add    $0x20,%esp
  intr_register_int (13, 0, INTR_ON, kill, "#GP General Protection Exception");
c002d41c:	83 ec 0c             	sub    $0xc,%esp
c002d41f:	68 60 31 03 c0       	push   $0xc0033160
c002d424:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d429:	6a 01                	push   $0x1
c002d42b:	6a 00                	push   $0x0
c002d42d:	6a 0d                	push   $0xd
c002d42f:	e8 d8 47 ff ff       	call   c0021c0c <intr_register_int>
c002d434:	83 c4 20             	add    $0x20,%esp
  intr_register_int (16, 0, INTR_ON, kill, "#MF x87 FPU Floating-Point Error");
c002d437:	83 ec 0c             	sub    $0xc,%esp
c002d43a:	68 84 31 03 c0       	push   $0xc0033184
c002d43f:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d444:	6a 01                	push   $0x1
c002d446:	6a 00                	push   $0x0
c002d448:	6a 10                	push   $0x10
c002d44a:	e8 bd 47 ff ff       	call   c0021c0c <intr_register_int>
c002d44f:	83 c4 20             	add    $0x20,%esp
  intr_register_int (19, 0, INTR_ON, kill,
c002d452:	83 ec 0c             	sub    $0xc,%esp
c002d455:	68 a8 31 03 c0       	push   $0xc00331a8
c002d45a:	68 b1 d4 02 c0       	push   $0xc002d4b1
c002d45f:	6a 01                	push   $0x1
c002d461:	6a 00                	push   $0x0
c002d463:	6a 13                	push   $0x13
c002d465:	e8 a2 47 ff ff       	call   c0021c0c <intr_register_int>
c002d46a:	83 c4 20             	add    $0x20,%esp
                     "#XF SIMD Floating-Point Exception");

  /* Most exceptions can be handled with interrupts turned on.
     We need to disable interrupts for page faults because the
     fault address is stored in CR2 and needs to be preserved. */
  intr_register_int (14, 0, INTR_OFF, page_fault, "#PF Page-Fault Exception");
c002d46d:	83 ec 0c             	sub    $0xc,%esp
c002d470:	68 ca 31 03 c0       	push   $0xc00331ca
c002d475:	68 72 d5 02 c0       	push   $0xc002d572
c002d47a:	6a 00                	push   $0x0
c002d47c:	6a 00                	push   $0x0
c002d47e:	6a 0e                	push   $0xe
c002d480:	e8 87 47 ff ff       	call   c0021c0c <intr_register_int>
c002d485:	83 c4 20             	add    $0x20,%esp
}
c002d488:	90                   	nop
c002d489:	c9                   	leave  
c002d48a:	c3                   	ret    

c002d48b <exception_print_stats>:

/* Prints exception statistics. */
void
exception_print_stats (void) 
{
c002d48b:	55                   	push   %ebp
c002d48c:	89 e5                	mov    %esp,%ebp
c002d48e:	83 ec 08             	sub    $0x8,%esp
  printf ("Exception: %lld page faults\n", page_fault_cnt);
c002d491:	a1 50 a6 03 c0       	mov    0xc003a650,%eax
c002d496:	8b 15 54 a6 03 c0    	mov    0xc003a654,%edx
c002d49c:	83 ec 04             	sub    $0x4,%esp
c002d49f:	52                   	push   %edx
c002d4a0:	50                   	push   %eax
c002d4a1:	68 e3 31 03 c0       	push   $0xc00331e3
c002d4a6:	e8 33 a3 ff ff       	call   c00277de <printf>
c002d4ab:	83 c4 10             	add    $0x10,%esp
}
c002d4ae:	90                   	nop
c002d4af:	c9                   	leave  
c002d4b0:	c3                   	ret    

c002d4b1 <kill>:

/* Handler for an exception (probably) caused by a user process. */
static void
kill (struct intr_frame *f) 
{
c002d4b1:	55                   	push   %ebp
c002d4b2:	89 e5                	mov    %esp,%ebp
c002d4b4:	56                   	push   %esi
c002d4b5:	53                   	push   %ebx
     exceptions back to the process via signals, but we don't
     implement them. */
     
  /* The interrupt frame's code segment value tells us where the
     exception originated. */
  switch (f->cs)
c002d4b6:	8b 45 08             	mov    0x8(%ebp),%eax
c002d4b9:	8b 40 40             	mov    0x40(%eax),%eax
c002d4bc:	0f b7 c0             	movzwl %ax,%eax
c002d4bf:	83 f8 08             	cmp    $0x8,%eax
c002d4c2:	74 4f                	je     c002d513 <kill+0x62>
c002d4c4:	83 f8 1b             	cmp    $0x1b,%eax
c002d4c7:	75 6e                	jne    c002d537 <kill+0x86>
    {
    case SEL_UCSEG:
      /* User's code segment, so it's a user exception, as we
         expected.  Kill the user process.  */
      printf ("%s: dying due to interrupt %#04x (%s).\n",
              thread_name (), f->vec_no, intr_name (f->vec_no));
c002d4c9:	8b 45 08             	mov    0x8(%ebp),%eax
c002d4cc:	8b 40 30             	mov    0x30(%eax),%eax
      printf ("%s: dying due to interrupt %#04x (%s).\n",
c002d4cf:	0f b6 c0             	movzbl %al,%eax
c002d4d2:	83 ec 0c             	sub    $0xc,%esp
c002d4d5:	50                   	push   %eax
c002d4d6:	e8 ee 4c ff ff       	call   c00221c9 <intr_name>
c002d4db:	83 c4 10             	add    $0x10,%esp
c002d4de:	89 c6                	mov    %eax,%esi
c002d4e0:	8b 45 08             	mov    0x8(%ebp),%eax
c002d4e3:	8b 58 30             	mov    0x30(%eax),%ebx
c002d4e6:	e8 bb 3b ff ff       	call   c00210a6 <thread_name>
c002d4eb:	56                   	push   %esi
c002d4ec:	53                   	push   %ebx
c002d4ed:	50                   	push   %eax
c002d4ee:	68 00 32 03 c0       	push   $0xc0033200
c002d4f3:	e8 e6 a2 ff ff       	call   c00277de <printf>
c002d4f8:	83 c4 10             	add    $0x10,%esp
      intr_dump_frame (f);
c002d4fb:	83 ec 0c             	sub    $0xc,%esp
c002d4fe:	ff 75 08             	pushl  0x8(%ebp)
c002d501:	e8 dc 4b ff ff       	call   c00220e2 <intr_dump_frame>
c002d506:	83 c4 10             	add    $0x10,%esp
      //thread_exit (); 
      exit(-1);
c002d509:	83 ec 0c             	sub    $0xc,%esp
c002d50c:	6a ff                	push   $0xffffffff
c002d50e:	e8 56 04 00 00       	call   c002d969 <exit>
    case SEL_KCSEG:
      /* Kernel's code segment, which indicates a kernel bug.
         Kernel code shouldn't throw exceptions.  (Page faults
         may cause kernel exceptions--but they shouldn't arrive
         here.)  Panic the kernel to make the point.  */
      intr_dump_frame (f);
c002d513:	83 ec 0c             	sub    $0xc,%esp
c002d516:	ff 75 08             	pushl  0x8(%ebp)
c002d519:	e8 c4 4b ff ff       	call   c00220e2 <intr_dump_frame>
c002d51e:	83 c4 10             	add    $0x10,%esp
      PANIC ("Kernel bug - unexpected interrupt in kernel"); 
c002d521:	68 28 32 03 c0       	push   $0xc0033228
c002d526:	68 0c 33 03 c0       	push   $0xc003330c
c002d52b:	6a 65                	push   $0x65
c002d52d:	68 54 32 03 c0       	push   $0xc0033254
c002d532:	e8 66 c6 ff ff       	call   c0029b9d <debug_panic>

    default:
      /* Some other code segment?  Shouldn't happen.  Panic the
         kernel. */
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
             f->vec_no, intr_name (f->vec_no), f->cs);
c002d537:	8b 45 08             	mov    0x8(%ebp),%eax
c002d53a:	8b 40 40             	mov    0x40(%eax),%eax
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002d53d:	0f b7 d8             	movzwl %ax,%ebx
             f->vec_no, intr_name (f->vec_no), f->cs);
c002d540:	8b 45 08             	mov    0x8(%ebp),%eax
c002d543:	8b 40 30             	mov    0x30(%eax),%eax
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002d546:	0f b6 c0             	movzbl %al,%eax
c002d549:	83 ec 0c             	sub    $0xc,%esp
c002d54c:	50                   	push   %eax
c002d54d:	e8 77 4c ff ff       	call   c00221c9 <intr_name>
c002d552:	83 c4 10             	add    $0x10,%esp
c002d555:	89 c2                	mov    %eax,%edx
c002d557:	8b 45 08             	mov    0x8(%ebp),%eax
c002d55a:	8b 40 30             	mov    0x30(%eax),%eax
c002d55d:	53                   	push   %ebx
c002d55e:	52                   	push   %edx
c002d55f:	50                   	push   %eax
c002d560:	68 70 32 03 c0       	push   $0xc0033270
c002d565:	e8 74 a2 ff ff       	call   c00277de <printf>
c002d56a:	83 c4 10             	add    $0x10,%esp
      thread_exit ();
c002d56d:	e8 c4 3b ff ff       	call   c0021136 <thread_exit>

c002d572 <page_fault>:
   can find more information about both of these in the
   description of "Interrupt 14--Page Fault Exception (#PF)" in
   [IA32-v3a] section 5.15 "Exception and Interrupt Reference". */
static void
page_fault (struct intr_frame *f) 
{
c002d572:	55                   	push   %ebp
c002d573:	89 e5                	mov    %esp,%ebp
c002d575:	83 ec 18             	sub    $0x18,%esp
     data.  It is not necessarily the address of the instruction
     that caused the fault (that's f->eip).
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (fault_addr));
c002d578:	0f 20 d0             	mov    %cr2,%eax
c002d57b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Turn interrupts back on (they were only off so that we could
     be assured of reading CR2 before it changed). */
  intr_enable ();
c002d57e:	e8 d6 43 ff ff       	call   c0021959 <intr_enable>

  /* Count page faults. */
  page_fault_cnt++;
c002d583:	a1 50 a6 03 c0       	mov    0xc003a650,%eax
c002d588:	8b 15 54 a6 03 c0    	mov    0xc003a654,%edx
c002d58e:	83 c0 01             	add    $0x1,%eax
c002d591:	83 d2 00             	adc    $0x0,%edx
c002d594:	a3 50 a6 03 c0       	mov    %eax,0xc003a650
c002d599:	89 15 54 a6 03 c0    	mov    %edx,0xc003a654

  /* Determine cause. */
  not_present = (f->error_code & PF_P) == 0;
c002d59f:	8b 45 08             	mov    0x8(%ebp),%eax
c002d5a2:	8b 40 34             	mov    0x34(%eax),%eax
c002d5a5:	83 e0 01             	and    $0x1,%eax
c002d5a8:	85 c0                	test   %eax,%eax
c002d5aa:	0f 94 c0             	sete   %al
c002d5ad:	88 45 f3             	mov    %al,-0xd(%ebp)
  write = (f->error_code & PF_W) != 0;
c002d5b0:	8b 45 08             	mov    0x8(%ebp),%eax
c002d5b3:	8b 40 34             	mov    0x34(%eax),%eax
c002d5b6:	83 e0 02             	and    $0x2,%eax
c002d5b9:	85 c0                	test   %eax,%eax
c002d5bb:	0f 95 c0             	setne  %al
c002d5be:	88 45 f2             	mov    %al,-0xe(%ebp)
  user = (f->error_code & PF_U) != 0;
c002d5c1:	8b 45 08             	mov    0x8(%ebp),%eax
c002d5c4:	8b 40 34             	mov    0x34(%eax),%eax
c002d5c7:	83 e0 04             	and    $0x4,%eax
c002d5ca:	85 c0                	test   %eax,%eax
c002d5cc:	0f 95 c0             	setne  %al
c002d5cf:	88 45 f1             	mov    %al,-0xf(%ebp)

  /* To implement virtual memory, delete the rest of the function
     body, and replace it with code that brings in the page to
     which fault_addr refers. */
  printf ("Page fault at %p: %s error %s page in %s context.\n",
c002d5d2:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c002d5d6:	74 07                	je     c002d5df <page_fault+0x6d>
c002d5d8:	b9 9e 32 03 c0       	mov    $0xc003329e,%ecx
c002d5dd:	eb 05                	jmp    c002d5e4 <page_fault+0x72>
c002d5df:	b9 a3 32 03 c0       	mov    $0xc00332a3,%ecx
c002d5e4:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c002d5e8:	74 07                	je     c002d5f1 <page_fault+0x7f>
c002d5ea:	ba aa 32 03 c0       	mov    $0xc00332aa,%edx
c002d5ef:	eb 05                	jmp    c002d5f6 <page_fault+0x84>
c002d5f1:	ba b2 32 03 c0       	mov    $0xc00332b2,%edx
c002d5f6:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c002d5fa:	74 07                	je     c002d603 <page_fault+0x91>
c002d5fc:	b8 ba 32 03 c0       	mov    $0xc00332ba,%eax
c002d601:	eb 05                	jmp    c002d608 <page_fault+0x96>
c002d603:	b8 c6 32 03 c0       	mov    $0xc00332c6,%eax
c002d608:	83 ec 0c             	sub    $0xc,%esp
c002d60b:	51                   	push   %ecx
c002d60c:	52                   	push   %edx
c002d60d:	50                   	push   %eax
c002d60e:	ff 75 f4             	pushl  -0xc(%ebp)
c002d611:	68 d8 32 03 c0       	push   $0xc00332d8
c002d616:	e8 c3 a1 ff ff       	call   c00277de <printf>
c002d61b:	83 c4 20             	add    $0x20,%esp
          fault_addr,
          not_present ? "not present" : "rights violation",
          write ? "writing" : "reading",
          user ? "user" : "kernel");
  kill (f);
c002d61e:	83 ec 0c             	sub    $0xc,%esp
c002d621:	ff 75 08             	pushl  0x8(%ebp)
c002d624:	e8 88 fe ff ff       	call   c002d4b1 <kill>
c002d629:	83 c4 10             	add    $0x10,%esp
}
c002d62c:	90                   	nop
c002d62d:	c9                   	leave  
c002d62e:	c3                   	ret    

c002d62f <is_user_vaddr>:
{
c002d62f:	55                   	push   %ebp
c002d630:	89 e5                	mov    %esp,%ebp
  return vaddr < PHYS_BASE;
c002d632:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c002d639:	0f 96 c0             	setbe  %al
}
c002d63c:	5d                   	pop    %ebp
c002d63d:	c3                   	ret    

c002d63e <syscall_init>:

/*
 * System call initializer
 * It handles the set up for system call operations.
 */
void syscall_init(void){
c002d63e:	55                   	push   %ebp
c002d63f:	89 e5                	mov    %esp,%ebp
c002d641:	83 ec 08             	sub    $0x8,%esp
    intr_register_int(0x30, 3, INTR_ON, syscall_handler, "syscall");
c002d644:	83 ec 0c             	sub    $0xc,%esp
c002d647:	68 14 33 03 c0       	push   $0xc0033314
c002d64c:	68 62 d6 02 c0       	push   $0xc002d662
c002d651:	6a 01                	push   $0x1
c002d653:	6a 03                	push   $0x3
c002d655:	6a 30                	push   $0x30
c002d657:	e8 b0 45 ff ff       	call   c0021c0c <intr_register_int>
c002d65c:	83 c4 20             	add    $0x20,%esp
}
c002d65f:	90                   	nop
c002d660:	c9                   	leave  
c002d661:	c3                   	ret    

c002d662 <syscall_handler>:

static void syscall_handler(struct intr_frame *f UNUSED)
{
c002d662:	55                   	push   %ebp
c002d663:	89 e5                	mov    %esp,%ebp
c002d665:	83 ec 28             	sub    $0x28,%esp
  // Check if file lock has been initialized
  if (!IS_FILE_LOCKED)
c002d668:	a0 58 a6 03 c0       	mov    0xc003a658,%al
c002d66d:	83 f0 01             	xor    $0x1,%eax
c002d670:	84 c0                	test   %al,%al
c002d672:	74 17                	je     c002d68b <syscall_handler+0x29>
  {
    lock_init(&fs_lock);
c002d674:	83 ec 0c             	sub    $0xc,%esp
c002d677:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002d67c:	e8 cd 59 ff ff       	call   c002304e <lock_init>
c002d681:	83 c4 10             	add    $0x10,%esp
    IS_FILE_LOCKED = true;
c002d684:	c6 05 58 a6 03 c0 01 	movb   $0x1,0xc003a658
  }

  int arg[MAXIMUM_ARGS_COUNT];
  int esp = get_page((const void *)f->esp);
c002d68b:	8b 45 08             	mov    0x8(%ebp),%eax
c002d68e:	8b 40 48             	mov    0x48(%eax),%eax
c002d691:	83 ec 0c             	sub    $0xc,%esp
c002d694:	50                   	push   %eax
c002d695:	e8 3d 07 00 00       	call   c002ddd7 <get_page>
c002d69a:	83 c4 10             	add    $0x10,%esp
c002d69d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  // Get system call number
  int syscall_num = *(int *)esp;
c002d6a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d6a3:	8b 00                	mov    (%eax),%eax
c002d6a5:	89 45 f0             	mov    %eax,-0x10(%ebp)

  switch (syscall_num)
c002d6a8:	83 7d f0 0c          	cmpl   $0xc,-0x10(%ebp)
c002d6ac:	0f 87 60 02 00 00    	ja     c002d912 <syscall_handler+0x2b0>
c002d6b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d6b5:	c1 e0 02             	shl    $0x2,%eax
c002d6b8:	05 1c 33 03 c0       	add    $0xc003331c,%eax
c002d6bd:	8b 00                	mov    (%eax),%eax
c002d6bf:	ff e0                	jmp    *%eax
  {

  /* Read from a file. */
  case SYS_READ:
    stack_access(f, &arg[0], 3);
c002d6c1:	83 ec 04             	sub    $0x4,%esp
c002d6c4:	6a 03                	push   $0x3
c002d6c6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002d6c9:	50                   	push   %eax
c002d6ca:	ff 75 08             	pushl  0x8(%ebp)
c002d6cd:	e8 44 02 00 00       	call   c002d916 <stack_access>
c002d6d2:	83 c4 10             	add    $0x10,%esp
    buffer_validator((const void *)arg[1], (unsigned)arg[2]);
c002d6d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d6d8:	89 c2                	mov    %eax,%edx
c002d6da:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d6dd:	83 ec 08             	sub    $0x8,%esp
c002d6e0:	52                   	push   %edx
c002d6e1:	50                   	push   %eax
c002d6e2:	e8 bc 06 00 00       	call   c002dda3 <buffer_validator>
c002d6e7:	83 c4 10             	add    $0x10,%esp
    arg[1] = get_page((const void *)arg[1]);
c002d6ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d6ed:	83 ec 0c             	sub    $0xc,%esp
c002d6f0:	50                   	push   %eax
c002d6f1:	e8 e1 06 00 00       	call   c002ddd7 <get_page>
c002d6f6:	83 c4 10             	add    $0x10,%esp
c002d6f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    f->eax = read(arg[0], (void *)arg[1], (unsigned)arg[2]);
c002d6fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d6ff:	89 c1                	mov    %eax,%ecx
c002d701:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d704:	89 c2                	mov    %eax,%edx
c002d706:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d709:	83 ec 04             	sub    $0x4,%esp
c002d70c:	51                   	push   %ecx
c002d70d:	52                   	push   %edx
c002d70e:	50                   	push   %eax
c002d70f:	e8 0d 04 00 00       	call   c002db21 <read>
c002d714:	83 c4 10             	add    $0x10,%esp
c002d717:	89 c2                	mov    %eax,%edx
c002d719:	8b 45 08             	mov    0x8(%ebp),%eax
c002d71c:	89 50 1c             	mov    %edx,0x1c(%eax)
    break;
c002d71f:	e9 ef 01 00 00       	jmp    c002d913 <syscall_handler+0x2b1>

  /* Write to a file. */
  case SYS_WRITE:
    stack_access(f, &arg[0], 3);
c002d724:	83 ec 04             	sub    $0x4,%esp
c002d727:	6a 03                	push   $0x3
c002d729:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002d72c:	50                   	push   %eax
c002d72d:	ff 75 08             	pushl  0x8(%ebp)
c002d730:	e8 e1 01 00 00       	call   c002d916 <stack_access>
c002d735:	83 c4 10             	add    $0x10,%esp
    buffer_validator((const void *)arg[1], (unsigned)arg[2]);
c002d738:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d73b:	89 c2                	mov    %eax,%edx
c002d73d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d740:	83 ec 08             	sub    $0x8,%esp
c002d743:	52                   	push   %edx
c002d744:	50                   	push   %eax
c002d745:	e8 59 06 00 00       	call   c002dda3 <buffer_validator>
c002d74a:	83 c4 10             	add    $0x10,%esp
    arg[1] = get_page((const void *)arg[1]);
c002d74d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d750:	83 ec 0c             	sub    $0xc,%esp
c002d753:	50                   	push   %eax
c002d754:	e8 7e 06 00 00       	call   c002ddd7 <get_page>
c002d759:	83 c4 10             	add    $0x10,%esp
c002d75c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    f->eax = write(arg[0], (const void *)arg[1], (unsigned)arg[2]);
c002d75f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d762:	89 c1                	mov    %eax,%ecx
c002d764:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d767:	89 c2                	mov    %eax,%edx
c002d769:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d76c:	83 ec 04             	sub    $0x4,%esp
c002d76f:	51                   	push   %ecx
c002d770:	52                   	push   %edx
c002d771:	50                   	push   %eax
c002d772:	e8 64 04 00 00       	call   c002dbdb <write>
c002d777:	83 c4 10             	add    $0x10,%esp
c002d77a:	89 c2                	mov    %eax,%edx
c002d77c:	8b 45 08             	mov    0x8(%ebp),%eax
c002d77f:	89 50 1c             	mov    %edx,0x1c(%eax)
    break;
c002d782:	e9 8c 01 00 00       	jmp    c002d913 <syscall_handler+0x2b1>
//    break;

  /* Create a file. */
  case SYS_CREATE:
    // Retrieve file name and size from stack
    stack_access(f, &arg[0], 2);
c002d787:	83 ec 04             	sub    $0x4,%esp
c002d78a:	6a 02                	push   $0x2
c002d78c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002d78f:	50                   	push   %eax
c002d790:	ff 75 08             	pushl  0x8(%ebp)
c002d793:	e8 7e 01 00 00       	call   c002d916 <stack_access>
c002d798:	83 c4 10             	add    $0x10,%esp
    // Validate file name
    string_validator((const void *)arg[0]);
c002d79b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d79e:	83 ec 0c             	sub    $0xc,%esp
c002d7a1:	50                   	push   %eax
c002d7a2:	e8 da 05 00 00       	call   c002dd81 <string_validator>
c002d7a7:	83 c4 10             	add    $0x10,%esp
    // Get page pointer
    arg[0] = get_page((const void *)arg[0]);
c002d7aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d7ad:	83 ec 0c             	sub    $0xc,%esp
c002d7b0:	50                   	push   %eax
c002d7b1:	e8 21 06 00 00       	call   c002ddd7 <get_page>
c002d7b6:	83 c4 10             	add    $0x10,%esp
c002d7b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    // Create file
    f->eax = create((const char *)arg[0], (unsigned)arg[1]);
c002d7bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d7bf:	89 c2                	mov    %eax,%edx
c002d7c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d7c4:	83 ec 08             	sub    $0x8,%esp
c002d7c7:	52                   	push   %edx
c002d7c8:	50                   	push   %eax
c002d7c9:	e8 01 02 00 00       	call   c002d9cf <create>
c002d7ce:	83 c4 10             	add    $0x10,%esp
c002d7d1:	0f b6 d0             	movzbl %al,%edx
c002d7d4:	8b 45 08             	mov    0x8(%ebp),%eax
c002d7d7:	89 50 1c             	mov    %edx,0x1c(%eax)
    break;
c002d7da:	e9 34 01 00 00       	jmp    c002d913 <syscall_handler+0x2b1>

  /* Delete a file. */
  case SYS_REMOVE:
    // Retrieve file name from stack
    stack_access(f, &arg[0], 1);
c002d7df:	83 ec 04             	sub    $0x4,%esp
c002d7e2:	6a 01                	push   $0x1
c002d7e4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002d7e7:	50                   	push   %eax
c002d7e8:	ff 75 08             	pushl  0x8(%ebp)
c002d7eb:	e8 26 01 00 00       	call   c002d916 <stack_access>
c002d7f0:	83 c4 10             	add    $0x10,%esp
    // Validate file name
    string_validator((const void *)arg[0]);
c002d7f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d7f6:	83 ec 0c             	sub    $0xc,%esp
c002d7f9:	50                   	push   %eax
c002d7fa:	e8 82 05 00 00       	call   c002dd81 <string_validator>
c002d7ff:	83 c4 10             	add    $0x10,%esp
    // Get page pointer
    arg[0] = get_page((const void *)arg[0]);
c002d802:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d805:	83 ec 0c             	sub    $0xc,%esp
c002d808:	50                   	push   %eax
c002d809:	e8 c9 05 00 00       	call   c002ddd7 <get_page>
c002d80e:	83 c4 10             	add    $0x10,%esp
c002d811:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    // Remove file
    f->eax = remove((const char *)arg[0]);
c002d814:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d817:	83 ec 0c             	sub    $0xc,%esp
c002d81a:	50                   	push   %eax
c002d81b:	e8 ef 01 00 00       	call   c002da0f <remove>
c002d820:	83 c4 10             	add    $0x10,%esp
c002d823:	0f b6 d0             	movzbl %al,%edx
c002d826:	8b 45 08             	mov    0x8(%ebp),%eax
c002d829:	89 50 1c             	mov    %edx,0x1c(%eax)
    break;
c002d82c:	e9 e2 00 00 00       	jmp    c002d913 <syscall_handler+0x2b1>

  /* Change position in a file. */
  case SYS_SEEK:
    stack_access(f, &arg[0], 2);
c002d831:	83 ec 04             	sub    $0x4,%esp
c002d834:	6a 02                	push   $0x2
c002d836:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002d839:	50                   	push   %eax
c002d83a:	ff 75 08             	pushl  0x8(%ebp)
c002d83d:	e8 d4 00 00 00       	call   c002d916 <stack_access>
c002d842:	83 c4 10             	add    $0x10,%esp
    seek(arg[0], (unsigned)arg[1]);
c002d845:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d848:	89 c2                	mov    %eax,%edx
c002d84a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d84d:	83 ec 08             	sub    $0x8,%esp
c002d850:	52                   	push   %edx
c002d851:	50                   	push   %eax
c002d852:	e8 99 04 00 00       	call   c002dcf0 <seek>
c002d857:	83 c4 10             	add    $0x10,%esp
    break;
c002d85a:	e9 b4 00 00 00       	jmp    c002d913 <syscall_handler+0x2b1>


  /* Open a file. */
  case SYS_OPEN:
    // Retrieve file name from stack
    stack_access(f, &arg[0], 1);
c002d85f:	83 ec 04             	sub    $0x4,%esp
c002d862:	6a 01                	push   $0x1
c002d864:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002d867:	50                   	push   %eax
c002d868:	ff 75 08             	pushl  0x8(%ebp)
c002d86b:	e8 a6 00 00 00       	call   c002d916 <stack_access>
c002d870:	83 c4 10             	add    $0x10,%esp
    // Validate file name
    string_validator((const void *)arg[0]);
c002d873:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d876:	83 ec 0c             	sub    $0xc,%esp
c002d879:	50                   	push   %eax
c002d87a:	e8 02 05 00 00       	call   c002dd81 <string_validator>
c002d87f:	83 c4 10             	add    $0x10,%esp
    // Get page pointer
    arg[0] = get_page((const void *)arg[0]);
c002d882:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d885:	83 ec 0c             	sub    $0xc,%esp
c002d888:	50                   	push   %eax
c002d889:	e8 49 05 00 00       	call   c002ddd7 <get_page>
c002d88e:	83 c4 10             	add    $0x10,%esp
c002d891:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    // Open file
    f->eax = open((const char *)arg[0]);
c002d894:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d897:	83 ec 0c             	sub    $0xc,%esp
c002d89a:	50                   	push   %eax
c002d89b:	e8 ab 01 00 00       	call   c002da4b <open>
c002d8a0:	83 c4 10             	add    $0x10,%esp
c002d8a3:	89 c2                	mov    %eax,%edx
c002d8a5:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8a8:	89 50 1c             	mov    %edx,0x1c(%eax)
    break;
c002d8ab:	eb 66                	jmp    c002d913 <syscall_handler+0x2b1>

  /* Close a file. */
  case SYS_CLOSE:
    stack_access(f, &arg[0], 1);
c002d8ad:	83 ec 04             	sub    $0x4,%esp
c002d8b0:	6a 01                	push   $0x1
c002d8b2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002d8b5:	50                   	push   %eax
c002d8b6:	ff 75 08             	pushl  0x8(%ebp)
c002d8b9:	e8 58 00 00 00       	call   c002d916 <stack_access>
c002d8be:	83 c4 10             	add    $0x10,%esp
    lock_acquire(&fs_lock);
c002d8c1:	83 ec 0c             	sub    $0xc,%esp
c002d8c4:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002d8c9:	e8 cd 57 ff ff       	call   c002309b <lock_acquire>
c002d8ce:	83 c4 10             	add    $0x10,%esp
    close_file(arg[0]);
c002d8d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d8d4:	83 ec 0c             	sub    $0xc,%esp
c002d8d7:	50                   	push   %eax
c002d8d8:	e8 26 06 00 00       	call   c002df03 <close_file>
c002d8dd:	83 c4 10             	add    $0x10,%esp
    lock_release(&fs_lock);
c002d8e0:	83 ec 0c             	sub    $0xc,%esp
c002d8e3:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002d8e8:	e8 2c 59 ff ff       	call   c0023219 <lock_release>
c002d8ed:	83 c4 10             	add    $0x10,%esp
    break;
c002d8f0:	eb 21                	jmp    c002d913 <syscall_handler+0x2b1>

  /* Terminate this process. */
  case SYS_EXIT:
    // Retrieve exit status from stack
    stack_access(f, &arg[0], 1);
c002d8f2:	83 ec 04             	sub    $0x4,%esp
c002d8f5:	6a 01                	push   $0x1
c002d8f7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002d8fa:	50                   	push   %eax
c002d8fb:	ff 75 08             	pushl  0x8(%ebp)
c002d8fe:	e8 13 00 00 00       	call   c002d916 <stack_access>
c002d903:	83 c4 10             	add    $0x10,%esp
    // Exit process with given status
    exit(arg[0]);
c002d906:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d909:	83 ec 0c             	sub    $0xc,%esp
c002d90c:	50                   	push   %eax
c002d90d:	e8 57 00 00 00       	call   c002d969 <exit>
    break;

  default:
    break;
c002d912:	90                   	nop
  }
}
c002d913:	90                   	nop
c002d914:	c9                   	leave  
c002d915:	c3                   	ret    

c002d916 <stack_access>:

void stack_access(struct intr_frame *f, int *args, int num_of_args)
{
c002d916:	55                   	push   %ebp
c002d917:	89 e5                	mov    %esp,%ebp
c002d919:	83 ec 18             	sub    $0x18,%esp
  // Pointer to traverse the stack
  int *ptr;

  // Loop through the number of arguments
  for (int i = 0; i < num_of_args; i++)
c002d91c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d923:	eb 39                	jmp    c002d95e <stack_access+0x48>
  {
    // Set the pointer to the current argument location on the stack
    ptr = (int *)f->esp + i + 1;
c002d925:	8b 45 08             	mov    0x8(%ebp),%eax
c002d928:	8b 40 48             	mov    0x48(%eax),%eax
c002d92b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d92e:	42                   	inc    %edx
c002d92f:	c1 e2 02             	shl    $0x2,%edx
c002d932:	01 d0                	add    %edx,%eax
c002d934:	89 45 f0             	mov    %eax,-0x10(%ebp)
    // Validate the pointer to ensure it's within the user space
    pointer_validator((const void *)ptr);
c002d937:	83 ec 0c             	sub    $0xc,%esp
c002d93a:	ff 75 f0             	pushl  -0x10(%ebp)
c002d93d:	e8 11 04 00 00       	call   c002dd53 <pointer_validator>
c002d942:	83 c4 10             	add    $0x10,%esp
    // Retrieve the argument value
    args[i] = *ptr;
c002d945:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d948:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002d94f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d952:	01 c2                	add    %eax,%edx
c002d954:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d957:	8b 00                	mov    (%eax),%eax
c002d959:	89 02                	mov    %eax,(%edx)
  for (int i = 0; i < num_of_args; i++)
c002d95b:	ff 45 f4             	incl   -0xc(%ebp)
c002d95e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d961:	3b 45 10             	cmp    0x10(%ebp),%eax
c002d964:	7c bf                	jl     c002d925 <stack_access+0xf>
  }
}
c002d966:	90                   	nop
c002d967:	c9                   	leave  
c002d968:	c3                   	ret    

c002d969 <exit>:

/* Exits the current thread with the given status */
void exit(int status)
{
c002d969:	55                   	push   %ebp
c002d96a:	89 e5                	mov    %esp,%ebp
c002d96c:	83 ec 18             	sub    $0x18,%esp
  // Get the current thread
  struct thread *curr_thread = thread_current();
c002d96f:	e8 42 37 ff ff       	call   c00210b6 <thread_current>
c002d974:	89 45 f4             	mov    %eax,-0xc(%ebp)

  // If the current thread has a parent and it's a child process
  if (check_thread_active(curr_thread->parent) && curr_thread->child_process)
c002d977:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d97a:	8b 40 6c             	mov    0x6c(%eax),%eax
c002d97d:	83 ec 0c             	sub    $0xc,%esp
c002d980:	50                   	push   %eax
c002d981:	e8 f0 3e ff ff       	call   c0021876 <check_thread_active>
c002d986:	83 c4 10             	add    $0x10,%esp
c002d989:	85 c0                	test   %eax,%eax
c002d98b:	74 23                	je     c002d9b0 <exit+0x47>
c002d98d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d990:	8b 40 70             	mov    0x70(%eax),%eax
c002d993:	85 c0                	test   %eax,%eax
c002d995:	74 19                	je     c002d9b0 <exit+0x47>
  {
    // If the status is negative, set it to -1
    if (status < 0)
c002d997:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002d99b:	79 07                	jns    c002d9a4 <exit+0x3b>
      status = -1;
c002d99d:	c7 45 08 ff ff ff ff 	movl   $0xffffffff,0x8(%ebp)

    // Set the status of the child process
    curr_thread->child_process->status = status;
c002d9a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d9a7:	8b 40 70             	mov    0x70(%eax),%eax
c002d9aa:	8b 55 08             	mov    0x8(%ebp),%edx
c002d9ad:	89 50 10             	mov    %edx,0x10(%eax)
  }

  // Print the exit message
  printf("%s: exit(%d)\n", curr_thread->name, status);
c002d9b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d9b3:	83 c0 08             	add    $0x8,%eax
c002d9b6:	83 ec 04             	sub    $0x4,%esp
c002d9b9:	ff 75 08             	pushl  0x8(%ebp)
c002d9bc:	50                   	push   %eax
c002d9bd:	68 50 33 03 c0       	push   $0xc0033350
c002d9c2:	e8 17 9e ff ff       	call   c00277de <printf>
c002d9c7:	83 c4 10             	add    $0x10,%esp

  // Exit the thread
  thread_exit();
c002d9ca:	e8 67 37 ff ff       	call   c0021136 <thread_exit>

c002d9cf <create>:
}

/* Creates a file with the given name and initial size */
bool create(const char *file_name, unsigned initial_size)
{
c002d9cf:	55                   	push   %ebp
c002d9d0:	89 e5                	mov    %esp,%ebp
c002d9d2:	83 ec 18             	sub    $0x18,%esp
  // Acquire the file system lock
  lock_acquire(&fs_lock);
c002d9d5:	83 ec 0c             	sub    $0xc,%esp
c002d9d8:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002d9dd:	e8 b9 56 ff ff       	call   c002309b <lock_acquire>
c002d9e2:	83 c4 10             	add    $0x10,%esp

  // Create the file
  bool success = filesys_create(file_name, initial_size);
c002d9e5:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d9e8:	83 ec 08             	sub    $0x8,%esp
c002d9eb:	50                   	push   %eax
c002d9ec:	ff 75 08             	pushl  0x8(%ebp)
c002d9ef:	e8 ab 09 00 00       	call   c002e39f <filesys_create>
c002d9f4:	83 c4 10             	add    $0x10,%esp
c002d9f7:	88 45 f7             	mov    %al,-0x9(%ebp)

  // Release the file system lock
  lock_release(&fs_lock);
c002d9fa:	83 ec 0c             	sub    $0xc,%esp
c002d9fd:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002da02:	e8 12 58 ff ff       	call   c0023219 <lock_release>
c002da07:	83 c4 10             	add    $0x10,%esp

  // Return the result
  return success;
c002da0a:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c002da0d:	c9                   	leave  
c002da0e:	c3                   	ret    

c002da0f <remove>:

/* Removes a file with the given file name
   Returns true if successful, false otherwise */
bool remove(const char *file_name)
{
c002da0f:	55                   	push   %ebp
c002da10:	89 e5                	mov    %esp,%ebp
c002da12:	83 ec 18             	sub    $0x18,%esp
  // Acquire the file system lock before accessing it
  lock_acquire(&fs_lock);
c002da15:	83 ec 0c             	sub    $0xc,%esp
c002da18:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002da1d:	e8 79 56 ff ff       	call   c002309b <lock_acquire>
c002da22:	83 c4 10             	add    $0x10,%esp

  // Call filesys_remove to remove the file
  bool success = filesys_remove(file_name);
c002da25:	83 ec 0c             	sub    $0xc,%esp
c002da28:	ff 75 08             	pushl  0x8(%ebp)
c002da2b:	e8 65 0a 00 00       	call   c002e495 <filesys_remove>
c002da30:	83 c4 10             	add    $0x10,%esp
c002da33:	88 45 f7             	mov    %al,-0x9(%ebp)

  // Release the file system lock
  lock_release(&fs_lock);
c002da36:	83 ec 0c             	sub    $0xc,%esp
c002da39:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002da3e:	e8 d6 57 ff ff       	call   c0023219 <lock_release>
c002da43:	83 c4 10             	add    $0x10,%esp

  // Return the success status of removing the file
  return success;
c002da46:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c002da49:	c9                   	leave  
c002da4a:	c3                   	ret    

c002da4b <open>:

/* Opens a file with the given file name
   Returns the file descriptor if successful, SYS_ERROR otherwise */
int open(const char *file_name)
{
c002da4b:	55                   	push   %ebp
c002da4c:	89 e5                	mov    %esp,%ebp
c002da4e:	83 ec 18             	sub    $0x18,%esp
  // Acquire the file system lock before accessing it
  lock_acquire(&fs_lock);
c002da51:	83 ec 0c             	sub    $0xc,%esp
c002da54:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002da59:	e8 3d 56 ff ff       	call   c002309b <lock_acquire>
c002da5e:	83 c4 10             	add    $0x10,%esp

  // Call filesys_open to open the file
  struct file *file_ptr = filesys_open(file_name);
c002da61:	83 ec 0c             	sub    $0xc,%esp
c002da64:	ff 75 08             	pushl  0x8(%ebp)
c002da67:	e8 da 09 00 00       	call   c002e446 <filesys_open>
c002da6c:	83 c4 10             	add    $0x10,%esp
c002da6f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  // If the file pointer is null, release the lock and return SYS_ERROR
  if (!file_ptr)
c002da72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002da76:	75 17                	jne    c002da8f <open+0x44>
  {
    lock_release(&fs_lock);
c002da78:	83 ec 0c             	sub    $0xc,%esp
c002da7b:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002da80:	e8 94 57 ff ff       	call   c0023219 <lock_release>
c002da85:	83 c4 10             	add    $0x10,%esp
    return SYS_ERROR;
c002da88:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002da8d:	eb 24                	jmp    c002dab3 <open+0x68>
  }

  // Call add_file to add the file to the current thread's file list
  int file_des = add_file(file_ptr);
c002da8f:	83 ec 0c             	sub    $0xc,%esp
c002da92:	ff 75 f4             	pushl  -0xc(%ebp)
c002da95:	e8 1b 00 00 00       	call   c002dab5 <add_file>
c002da9a:	83 c4 10             	add    $0x10,%esp
c002da9d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  // Release the file system lock
  lock_release(&fs_lock);
c002daa0:	83 ec 0c             	sub    $0xc,%esp
c002daa3:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002daa8:	e8 6c 57 ff ff       	call   c0023219 <lock_release>
c002daad:	83 c4 10             	add    $0x10,%esp

  // Return the file descriptor
  return file_des;
c002dab0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002dab3:	c9                   	leave  
c002dab4:	c3                   	ret    

c002dab5 <add_file>:

/* Adds a file to the current thread's file list
   Returns the file descriptor if successful, SYS_ERROR otherwise */
int add_file(struct file *file_ptr)
{
c002dab5:	55                   	push   %ebp
c002dab6:	89 e5                	mov    %esp,%ebp
c002dab8:	53                   	push   %ebx
c002dab9:	83 ec 14             	sub    $0x14,%esp
  // Allocate memory for the process_file structure
  struct process_file *file_struct = malloc(sizeof(struct process_file));
c002dabc:	83 ec 0c             	sub    $0xc,%esp
c002dabf:	6a 10                	push   $0x10
c002dac1:	e8 f4 5f ff ff       	call   c0023aba <malloc>
c002dac6:	83 c4 10             	add    $0x10,%esp
c002dac9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  // If memory allocation fails, return SYS_ERROR
  if (!file_struct)
c002dacc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002dad0:	75 07                	jne    c002dad9 <add_file+0x24>
    return SYS_ERROR;
c002dad2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002dad7:	eb 43                	jmp    c002db1c <add_file+0x67>

  // Fill in the fields of the process_file structure
  file_struct->file = file_ptr;
c002dad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dadc:	8b 55 08             	mov    0x8(%ebp),%edx
c002dadf:	89 10                	mov    %edx,(%eax)
  file_struct->fd = thread_current()->fd;
c002dae1:	e8 d0 35 ff ff       	call   c00210b6 <thread_current>
c002dae6:	8b 50 48             	mov    0x48(%eax),%edx
c002dae9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002daec:	89 50 04             	mov    %edx,0x4(%eax)
  thread_current()->fd++;
c002daef:	e8 c2 35 ff ff       	call   c00210b6 <thread_current>
c002daf4:	8b 50 48             	mov    0x48(%eax),%edx
c002daf7:	42                   	inc    %edx
c002daf8:	89 50 48             	mov    %edx,0x48(%eax)
  list_push_back(&thread_current()->file_name_list, &file_struct->elem);
c002dafb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dafe:	8d 58 08             	lea    0x8(%eax),%ebx
c002db01:	e8 b0 35 ff ff       	call   c00210b6 <thread_current>
c002db06:	83 c0 38             	add    $0x38,%eax
c002db09:	83 ec 08             	sub    $0x8,%esp
c002db0c:	53                   	push   %ebx
c002db0d:	50                   	push   %eax
c002db0e:	e8 db c6 ff ff       	call   c002a1ee <list_push_back>
c002db13:	83 c4 10             	add    $0x10,%esp

  // Return the file descriptor
  return file_struct->fd;
c002db16:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002db19:	8b 40 04             	mov    0x4(%eax),%eax
}
c002db1c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002db1f:	c9                   	leave  
c002db20:	c3                   	ret    

c002db21 <read>:

// read function implementation
int read(int filedes, void *buffer, unsigned length)
{
c002db21:	55                   	push   %ebp
c002db22:	89 e5                	mov    %esp,%ebp
c002db24:	53                   	push   %ebx
c002db25:	83 ec 14             	sub    $0x14,%esp
  // Return 0 if length is 0 or negative
  if (length <= 0)
c002db28:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002db2c:	75 0a                	jne    c002db38 <read+0x17>
    return 0;
c002db2e:	b8 00 00 00 00       	mov    $0x0,%eax
c002db33:	e9 9e 00 00 00       	jmp    c002dbd6 <read+0xb5>

  // Read from standard input if filedes is STD_INPUT
  if (filedes == STD_INPUT)
c002db38:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002db3c:	75 2f                	jne    c002db6d <read+0x4c>
  {
    uint8_t *buf = (uint8_t *)buffer;
c002db3e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002db41:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (unsigned i = 0; i < length; i++)
c002db44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002db4b:	eb 13                	jmp    c002db60 <read+0x3f>
      buf[i] = input_getc();
c002db4d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002db50:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002db53:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c002db56:	e8 76 8f ff ff       	call   c0026ad1 <input_getc>
c002db5b:	88 03                	mov    %al,(%ebx)
    for (unsigned i = 0; i < length; i++)
c002db5d:	ff 45 f4             	incl   -0xc(%ebp)
c002db60:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002db63:	3b 45 10             	cmp    0x10(%ebp),%eax
c002db66:	72 e5                	jb     c002db4d <read+0x2c>

    return length;
c002db68:	8b 45 10             	mov    0x10(%ebp),%eax
c002db6b:	eb 69                	jmp    c002dbd6 <read+0xb5>
  }

  // Acquire lock to access file system
  lock_acquire(&fs_lock);
c002db6d:	83 ec 0c             	sub    $0xc,%esp
c002db70:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002db75:	e8 21 55 ff ff       	call   c002309b <lock_acquire>
c002db7a:	83 c4 10             	add    $0x10,%esp

  // Get file pointer using filedes
  struct file *file_ptr = get_file(filedes);
c002db7d:	83 ec 0c             	sub    $0xc,%esp
c002db80:	ff 75 08             	pushl  0x8(%ebp)
c002db83:	e8 f0 00 00 00       	call   c002dc78 <get_file>
c002db88:	83 c4 10             	add    $0x10,%esp
c002db8b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (!file_ptr)
c002db8e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002db92:	75 17                	jne    c002dbab <read+0x8a>
  {
    lock_release(&fs_lock);
c002db94:	83 ec 0c             	sub    $0xc,%esp
c002db97:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002db9c:	e8 78 56 ff ff       	call   c0023219 <lock_release>
c002dba1:	83 c4 10             	add    $0x10,%esp
    return SYS_ERROR;
c002dba4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002dba9:	eb 2b                	jmp    c002dbd6 <read+0xb5>
  }

  // Read data from the file
  int size = file_read(file_ptr, buffer, length);
c002dbab:	8b 45 10             	mov    0x10(%ebp),%eax
c002dbae:	83 ec 04             	sub    $0x4,%esp
c002dbb1:	50                   	push   %eax
c002dbb2:	ff 75 0c             	pushl  0xc(%ebp)
c002dbb5:	ff 75 ec             	pushl  -0x14(%ebp)
c002dbb8:	e8 02 0d 00 00       	call   c002e8bf <file_read>
c002dbbd:	83 c4 10             	add    $0x10,%esp
c002dbc0:	89 45 e8             	mov    %eax,-0x18(%ebp)

  // Release lock and return the number of bytes read
  lock_release(&fs_lock);
c002dbc3:	83 ec 0c             	sub    $0xc,%esp
c002dbc6:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002dbcb:	e8 49 56 ff ff       	call   c0023219 <lock_release>
c002dbd0:	83 c4 10             	add    $0x10,%esp
  return size;
c002dbd3:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
c002dbd6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dbd9:	c9                   	leave  
c002dbda:	c3                   	ret    

c002dbdb <write>:

// write function implementation
int write(int filedes, const void *buffer, unsigned byte_size)
{
c002dbdb:	55                   	push   %ebp
c002dbdc:	89 e5                	mov    %esp,%ebp
c002dbde:	83 ec 18             	sub    $0x18,%esp
  // Return 0 if byte_size is 0 or negative
  if (byte_size <= 0)
c002dbe1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002dbe5:	75 0a                	jne    c002dbf1 <write+0x16>
    return 0;
c002dbe7:	b8 00 00 00 00       	mov    $0x0,%eax
c002dbec:	e9 85 00 00 00       	jmp    c002dc76 <write+0x9b>

  // Write to standard output if filedes is STD_OUTPUT
  if (filedes == STD_OUTPUT)
c002dbf1:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c002dbf5:	75 16                	jne    c002dc0d <write+0x32>
  {
    putbuf(buffer, byte_size);
c002dbf7:	83 ec 08             	sub    $0x8,%esp
c002dbfa:	ff 75 10             	pushl  0x10(%ebp)
c002dbfd:	ff 75 0c             	pushl  0xc(%ebp)
c002dc00:	e8 b3 e2 ff ff       	call   c002beb8 <putbuf>
c002dc05:	83 c4 10             	add    $0x10,%esp
    return byte_size;
c002dc08:	8b 45 10             	mov    0x10(%ebp),%eax
c002dc0b:	eb 69                	jmp    c002dc76 <write+0x9b>
  }

  // Acquire lock to access file system
  lock_acquire(&fs_lock);
c002dc0d:	83 ec 0c             	sub    $0xc,%esp
c002dc10:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002dc15:	e8 81 54 ff ff       	call   c002309b <lock_acquire>
c002dc1a:	83 c4 10             	add    $0x10,%esp

  // Get file pointer using filedes
  struct file *file_ptr = get_file(filedes);
c002dc1d:	83 ec 0c             	sub    $0xc,%esp
c002dc20:	ff 75 08             	pushl  0x8(%ebp)
c002dc23:	e8 50 00 00 00       	call   c002dc78 <get_file>
c002dc28:	83 c4 10             	add    $0x10,%esp
c002dc2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!file_ptr)
c002dc2e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002dc32:	75 17                	jne    c002dc4b <write+0x70>
  {
    lock_release(&fs_lock);
c002dc34:	83 ec 0c             	sub    $0xc,%esp
c002dc37:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002dc3c:	e8 d8 55 ff ff       	call   c0023219 <lock_release>
c002dc41:	83 c4 10             	add    $0x10,%esp
    return SYS_ERROR;
c002dc44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002dc49:	eb 2b                	jmp    c002dc76 <write+0x9b>
  }

  // Write data to the file
  int size = file_write(file_ptr, buffer, byte_size);
c002dc4b:	8b 45 10             	mov    0x10(%ebp),%eax
c002dc4e:	83 ec 04             	sub    $0x4,%esp
c002dc51:	50                   	push   %eax
c002dc52:	ff 75 0c             	pushl  0xc(%ebp)
c002dc55:	ff 75 f4             	pushl  -0xc(%ebp)
c002dc58:	e8 bb 0c 00 00       	call   c002e918 <file_write>
c002dc5d:	83 c4 10             	add    $0x10,%esp
c002dc60:	89 45 f0             	mov    %eax,-0x10(%ebp)

  // Release lock and return the number of bytes written
  lock_release(&fs_lock);
c002dc63:	83 ec 0c             	sub    $0xc,%esp
c002dc66:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002dc6b:	e8 a9 55 ff ff       	call   c0023219 <lock_release>
c002dc70:	83 c4 10             	add    $0x10,%esp
  return size;
c002dc73:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002dc76:	c9                   	leave  
c002dc77:	c3                   	ret    

c002dc78 <get_file>:

/* Returns the file associated with the given file descriptor */
struct file *
get_file(int filedes)
{
c002dc78:	55                   	push   %ebp
c002dc79:	89 e5                	mov    %esp,%ebp
c002dc7b:	83 ec 18             	sub    $0x18,%esp
  // Get the current thread
  struct thread *t = thread_current();
c002dc7e:	e8 33 34 ff ff       	call   c00210b6 <thread_current>
c002dc83:	89 45 f0             	mov    %eax,-0x10(%ebp)
  // Initialize variables to traverse the list of process files
  struct list_elem *next;
  struct list_elem *e = list_begin(&t->file_name_list);
c002dc86:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dc89:	83 c0 38             	add    $0x38,%eax
c002dc8c:	83 ec 0c             	sub    $0xc,%esp
c002dc8f:	50                   	push   %eax
c002dc90:	e8 ce c1 ff ff       	call   c0029e63 <list_begin>
c002dc95:	83 c4 10             	add    $0x10,%esp
c002dc98:	89 45 f4             	mov    %eax,-0xc(%ebp)

  // Iterate over the list of process files
  for (; e != list_end(&t->file_name_list); e = next)
c002dc9b:	eb 35                	jmp    c002dcd2 <get_file+0x5a>
  {
    next = list_next(e);
c002dc9d:	83 ec 0c             	sub    $0xc,%esp
c002dca0:	ff 75 f4             	pushl  -0xc(%ebp)
c002dca3:	e8 ed c1 ff ff       	call   c0029e95 <list_next>
c002dca8:	83 c4 10             	add    $0x10,%esp
c002dcab:	89 45 ec             	mov    %eax,-0x14(%ebp)
    // Get the current process file
    struct process_file *ptr_processing_file = list_entry(e, struct process_file, elem);
c002dcae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dcb1:	83 c0 04             	add    $0x4,%eax
c002dcb4:	83 e8 0c             	sub    $0xc,%eax
c002dcb7:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // Check if the file descriptor matches the given one
    if (filedes == ptr_processing_file->fd)
c002dcba:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002dcbd:	8b 40 04             	mov    0x4(%eax),%eax
c002dcc0:	3b 45 08             	cmp    0x8(%ebp),%eax
c002dcc3:	75 07                	jne    c002dccc <get_file+0x54>
      return ptr_processing_file->file;
c002dcc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002dcc8:	8b 00                	mov    (%eax),%eax
c002dcca:	eb 22                	jmp    c002dcee <get_file+0x76>
  for (; e != list_end(&t->file_name_list); e = next)
c002dccc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002dccf:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002dcd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dcd5:	83 c0 38             	add    $0x38,%eax
c002dcd8:	83 ec 0c             	sub    $0xc,%esp
c002dcdb:	50                   	push   %eax
c002dcdc:	e8 fe c1 ff ff       	call   c0029edf <list_end>
c002dce1:	83 c4 10             	add    $0x10,%esp
c002dce4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002dce7:	75 b4                	jne    c002dc9d <get_file+0x25>
  }

  // Return NULL if file not found
  return NULL;
c002dce9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002dcee:	c9                   	leave  
c002dcef:	c3                   	ret    

c002dcf0 <seek>:

/* function to change the position of the file pointer */
void seek(int filedes, unsigned new_position)
{
c002dcf0:	55                   	push   %ebp
c002dcf1:	89 e5                	mov    %esp,%ebp
c002dcf3:	83 ec 18             	sub    $0x18,%esp
  // Acquire lock to access file system
  lock_acquire(&fs_lock);
c002dcf6:	83 ec 0c             	sub    $0xc,%esp
c002dcf9:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002dcfe:	e8 98 53 ff ff       	call   c002309b <lock_acquire>
c002dd03:	83 c4 10             	add    $0x10,%esp

  // Get the file associated with the file descriptor
  struct file *file_ptr = get_file(filedes);
c002dd06:	83 ec 0c             	sub    $0xc,%esp
c002dd09:	ff 75 08             	pushl  0x8(%ebp)
c002dd0c:	e8 67 ff ff ff       	call   c002dc78 <get_file>
c002dd11:	83 c4 10             	add    $0x10,%esp
c002dd14:	89 45 f4             	mov    %eax,-0xc(%ebp)

  // If the file does not exist, release lock and return error
  if (!file_ptr)
c002dd17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002dd1b:	75 12                	jne    c002dd2f <seek+0x3f>
  {
    lock_release(&fs_lock);
c002dd1d:	83 ec 0c             	sub    $0xc,%esp
c002dd20:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002dd25:	e8 ef 54 ff ff       	call   c0023219 <lock_release>
c002dd2a:	83 c4 10             	add    $0x10,%esp
    return;
c002dd2d:	eb 22                	jmp    c002dd51 <seek+0x61>
  }

  // Change the position of the file pointer
  file_seek(file_ptr, new_position);
c002dd2f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002dd32:	83 ec 08             	sub    $0x8,%esp
c002dd35:	50                   	push   %eax
c002dd36:	ff 75 f4             	pushl  -0xc(%ebp)
c002dd39:	e8 17 0d 00 00       	call   c002ea55 <file_seek>
c002dd3e:	83 c4 10             	add    $0x10,%esp

  // Release lock after accessing the file
  lock_release(&fs_lock);
c002dd41:	83 ec 0c             	sub    $0xc,%esp
c002dd44:	68 e0 a8 03 c0       	push   $0xc003a8e0
c002dd49:	e8 cb 54 ff ff       	call   c0023219 <lock_release>
c002dd4e:	83 c4 10             	add    $0x10,%esp
}
c002dd51:	c9                   	leave  
c002dd52:	c3                   	ret    

c002dd53 <pointer_validator>:

is not within the user virtual address space or is not a user virtual address,
the function exits with a system error status.
*/
void pointer_validator(const void *vaddr)
{
c002dd53:	55                   	push   %ebp
c002dd54:	89 e5                	mov    %esp,%ebp
c002dd56:	83 ec 08             	sub    $0x8,%esp
  if (vaddr < USER_VADDR_BOTTOM || !is_user_vaddr(vaddr))
c002dd59:	81 7d 08 ff 7f 04 08 	cmpl   $0x8047fff,0x8(%ebp)
c002dd60:	76 12                	jbe    c002dd74 <pointer_validator+0x21>
c002dd62:	ff 75 08             	pushl  0x8(%ebp)
c002dd65:	e8 c5 f8 ff ff       	call   c002d62f <is_user_vaddr>
c002dd6a:	83 c4 04             	add    $0x4,%esp
c002dd6d:	83 f0 01             	xor    $0x1,%eax
c002dd70:	84 c0                	test   %al,%al
c002dd72:	74 0a                	je     c002dd7e <pointer_validator+0x2b>
  {
    exit(SYS_ERROR);
c002dd74:	83 ec 0c             	sub    $0xc,%esp
c002dd77:	6a ff                	push   $0xffffffff
c002dd79:	e8 eb fb ff ff       	call   c002d969 <exit>
  }
}
c002dd7e:	90                   	nop
c002dd7f:	c9                   	leave  
c002dd80:	c3                   	ret    

c002dd81 <string_validator>:
The function uses the get_page function to ensure that the pages containing each character of
the string are accessible. If any page is not accessible, the function exits with a system
error status.
*/
void string_validator(const void *str)
{
c002dd81:	55                   	push   %ebp
c002dd82:	89 e5                	mov    %esp,%ebp
c002dd84:	83 ec 08             	sub    $0x8,%esp
  for (; *(char *)get_page(str) != 0; str = (char *)str + 1)
c002dd87:	eb 03                	jmp    c002dd8c <string_validator+0xb>
c002dd89:	ff 45 08             	incl   0x8(%ebp)
c002dd8c:	83 ec 0c             	sub    $0xc,%esp
c002dd8f:	ff 75 08             	pushl  0x8(%ebp)
c002dd92:	e8 40 00 00 00       	call   c002ddd7 <get_page>
c002dd97:	83 c4 10             	add    $0x10,%esp
c002dd9a:	8a 00                	mov    (%eax),%al
c002dd9c:	84 c0                	test   %al,%al
c002dd9e:	75 e9                	jne    c002dd89 <string_validator+0x8>
  {
    /*Empty body */
  }
}
c002dda0:	90                   	nop
c002dda1:	c9                   	leave  
c002dda2:	c3                   	ret    

c002dda3 <buffer_validator>:

The function uses the pointer_validator function to ensure that each byte in the buffer
is accessible.
*/
void buffer_validator(const void *buf, unsigned byte_size)
{
c002dda3:	55                   	push   %ebp
c002dda4:	89 e5                	mov    %esp,%ebp
c002dda6:	83 ec 18             	sub    $0x18,%esp
  unsigned i = 0;
c002dda9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *local_buffer = (char *)buf;
c002ddb0:	8b 45 08             	mov    0x8(%ebp),%eax
c002ddb3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (; i < byte_size; i++)
c002ddb6:	eb 14                	jmp    c002ddcc <buffer_validator+0x29>
  {
    pointer_validator((const void *)local_buffer);
c002ddb8:	83 ec 0c             	sub    $0xc,%esp
c002ddbb:	ff 75 f0             	pushl  -0x10(%ebp)
c002ddbe:	e8 90 ff ff ff       	call   c002dd53 <pointer_validator>
c002ddc3:	83 c4 10             	add    $0x10,%esp
    local_buffer++;
c002ddc6:	ff 45 f0             	incl   -0x10(%ebp)
  for (; i < byte_size; i++)
c002ddc9:	ff 45 f4             	incl   -0xc(%ebp)
c002ddcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ddcf:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ddd2:	72 e4                	jb     c002ddb8 <buffer_validator+0x15>
  }
}
c002ddd4:	90                   	nop
c002ddd5:	c9                   	leave  
c002ddd6:	c3                   	ret    

c002ddd7 <get_page>:

using the pagedir_get_page function. If the page is not accessible, the function exits
with a system error status.
*/
int get_page(const void *vaddr)
{
c002ddd7:	55                   	push   %ebp
c002ddd8:	89 e5                	mov    %esp,%ebp
c002ddda:	83 ec 18             	sub    $0x18,%esp
  void *ptr = pagedir_get_page(thread_current()->pagedir, vaddr);
c002dddd:	e8 d4 32 ff ff       	call   c00210b6 <thread_current>
c002dde2:	8b 40 30             	mov    0x30(%eax),%eax
c002dde5:	83 ec 08             	sub    $0x8,%esp
c002dde8:	ff 75 08             	pushl  0x8(%ebp)
c002ddeb:	50                   	push   %eax
c002ddec:	e8 52 f2 ff ff       	call   c002d043 <pagedir_get_page>
c002ddf1:	83 c4 10             	add    $0x10,%esp
c002ddf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!ptr)
c002ddf7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002ddfb:	75 0a                	jne    c002de07 <get_page+0x30>
  {
    exit(SYS_ERROR);
c002ddfd:	83 ec 0c             	sub    $0xc,%esp
c002de00:	6a ff                	push   $0xffffffff
c002de02:	e8 62 fb ff ff       	call   c002d969 <exit>
  }
  return (int)ptr;
c002de07:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002de0a:	c9                   	leave  
c002de0b:	c3                   	ret    

c002de0c <find_child>:

/* Find a child process with given PID */
struct child_process *find_child(int pid)
{
c002de0c:	55                   	push   %ebp
c002de0d:	89 e5                	mov    %esp,%ebp
c002de0f:	83 ec 18             	sub    $0x18,%esp
  /* Get the current thread */
  struct thread *t = thread_current();
c002de12:	e8 9f 32 ff ff       	call   c00210b6 <thread_current>
c002de17:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* List element pointers */
  struct list_elem *e, *next;

  /* Iterate through the child process list */
  for (e = list_begin(&t->child_process_list); e != list_end(&t->child_process_list); e = next)
c002de1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002de1d:	83 c0 5c             	add    $0x5c,%eax
c002de20:	83 ec 0c             	sub    $0xc,%esp
c002de23:	50                   	push   %eax
c002de24:	e8 3a c0 ff ff       	call   c0029e63 <list_begin>
c002de29:	83 c4 10             	add    $0x10,%esp
c002de2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002de2f:	eb 32                	jmp    c002de63 <find_child+0x57>
  {
    next = list_next(e);
c002de31:	83 ec 0c             	sub    $0xc,%esp
c002de34:	ff 75 f4             	pushl  -0xc(%ebp)
c002de37:	e8 59 c0 ff ff       	call   c0029e95 <list_next>
c002de3c:	83 c4 10             	add    $0x10,%esp
c002de3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /* Get the child process data */
    struct child_process *child_process = list_entry(e, struct child_process, elem);
c002de42:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002de45:	83 c0 04             	add    $0x4,%eax
c002de48:	83 e8 40             	sub    $0x40,%eax
c002de4b:	89 45 e8             	mov    %eax,-0x18(%ebp)

    /* Check if the PID matches */
    if (pid == child_process->pid)
c002de4e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002de51:	8b 00                	mov    (%eax),%eax
c002de53:	3b 45 08             	cmp    0x8(%ebp),%eax
c002de56:	75 05                	jne    c002de5d <find_child+0x51>
    {
      return child_process;
c002de58:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002de5b:	eb 22                	jmp    c002de7f <find_child+0x73>
  for (e = list_begin(&t->child_process_list); e != list_end(&t->child_process_list); e = next)
c002de5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002de60:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002de63:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002de66:	83 c0 5c             	add    $0x5c,%eax
c002de69:	83 ec 0c             	sub    $0xc,%esp
c002de6c:	50                   	push   %eax
c002de6d:	e8 6d c0 ff ff       	call   c0029edf <list_end>
c002de72:	83 c4 10             	add    $0x10,%esp
c002de75:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002de78:	75 b7                	jne    c002de31 <find_child+0x25>
    }
  }

  /* If not found, return NULL */
  return NULL;
c002de7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002de7f:	c9                   	leave  
c002de80:	c3                   	ret    

c002de81 <children_remove>:

/* Remove all child processes */
void children_remove(void)
{
c002de81:	55                   	push   %ebp
c002de82:	89 e5                	mov    %esp,%ebp
c002de84:	83 ec 18             	sub    $0x18,%esp
  /* Get the current thread */
  struct thread *t = thread_current();
c002de87:	e8 2a 32 ff ff       	call   c00210b6 <thread_current>
c002de8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* List element pointers */
  struct list_elem *e, *next;

  /* Iterate through the child process list */
  for (e = list_begin(&t->child_process_list); e != list_end(&t->child_process_list); e = next)
c002de8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002de92:	83 c0 5c             	add    $0x5c,%eax
c002de95:	83 ec 0c             	sub    $0xc,%esp
c002de98:	50                   	push   %eax
c002de99:	e8 c5 bf ff ff       	call   c0029e63 <list_begin>
c002de9e:	83 c4 10             	add    $0x10,%esp
c002dea1:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002dea4:	eb 43                	jmp    c002dee9 <children_remove+0x68>
  {
    next = list_next(e);
c002dea6:	83 ec 0c             	sub    $0xc,%esp
c002dea9:	ff 75 f4             	pushl  -0xc(%ebp)
c002deac:	e8 e4 bf ff ff       	call   c0029e95 <list_next>
c002deb1:	83 c4 10             	add    $0x10,%esp
c002deb4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /* Get the child process data */
    struct child_process *child_process = list_entry(e, struct child_process, elem);
c002deb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002deba:	83 c0 04             	add    $0x4,%eax
c002debd:	83 e8 40             	sub    $0x40,%eax
c002dec0:	89 45 e8             	mov    %eax,-0x18(%ebp)

    /* Remove the child process from the list */
    list_remove(&child_process->elem);
c002dec3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002dec6:	83 c0 3c             	add    $0x3c,%eax
c002dec9:	83 ec 0c             	sub    $0xc,%esp
c002decc:	50                   	push   %eax
c002decd:	e8 42 c3 ff ff       	call   c002a214 <list_remove>
c002ded2:	83 c4 10             	add    $0x10,%esp
    /* Free the child process data */
    free(child_process);
c002ded5:	83 ec 0c             	sub    $0xc,%esp
c002ded8:	ff 75 e8             	pushl  -0x18(%ebp)
c002dedb:	e8 dc 5e ff ff       	call   c0023dbc <free>
c002dee0:	83 c4 10             	add    $0x10,%esp
  for (e = list_begin(&t->child_process_list); e != list_end(&t->child_process_list); e = next)
c002dee3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002dee6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002dee9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002deec:	83 c0 5c             	add    $0x5c,%eax
c002deef:	83 ec 0c             	sub    $0xc,%esp
c002def2:	50                   	push   %eax
c002def3:	e8 e7 bf ff ff       	call   c0029edf <list_end>
c002def8:	83 c4 10             	add    $0x10,%esp
c002defb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002defe:	75 a6                	jne    c002dea6 <children_remove+0x25>
  }
}
c002df00:	90                   	nop
c002df01:	c9                   	leave  
c002df02:	c3                   	ret    

c002df03 <close_file>:

// Function to close a file given a file descriptor
void close_file(int file_descriptor)
{
c002df03:	55                   	push   %ebp
c002df04:	89 e5                	mov    %esp,%ebp
c002df06:	83 ec 18             	sub    $0x18,%esp
  // Get the current thread
  struct thread *t = thread_current();
c002df09:	e8 a8 31 ff ff       	call   c00210b6 <thread_current>
c002df0e:	89 45 f0             	mov    %eax,-0x10(%ebp)

  // Traverse the list of open files for the current thread
  struct list_elem *next;
  struct list_elem *e = list_begin(&t->file_name_list);
c002df11:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002df14:	83 c0 38             	add    $0x38,%eax
c002df17:	83 ec 0c             	sub    $0xc,%esp
c002df1a:	50                   	push   %eax
c002df1b:	e8 43 bf ff ff       	call   c0029e63 <list_begin>
c002df20:	83 c4 10             	add    $0x10,%esp
c002df23:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for (; e != list_end(&t->file_name_list); e = next)
c002df26:	eb 6b                	jmp    c002df93 <close_file+0x90>
  {
    // Store the next element in the list
    next = list_next(e);
c002df28:	83 ec 0c             	sub    $0xc,%esp
c002df2b:	ff 75 f4             	pushl  -0xc(%ebp)
c002df2e:	e8 62 bf ff ff       	call   c0029e95 <list_next>
c002df33:	83 c4 10             	add    $0x10,%esp
c002df36:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // Get the current process file
    struct process_file *ptr_processing_file = list_entry(e, struct process_file, elem);
c002df39:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002df3c:	83 c0 04             	add    $0x4,%eax
c002df3f:	83 e8 0c             	sub    $0xc,%eax
c002df42:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // If the file descriptor matches the one being closed
    if (file_descriptor == ptr_processing_file->fd || file_descriptor == ALL_FDESC_CLOSE)
c002df45:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002df48:	8b 40 04             	mov    0x4(%eax),%eax
c002df4b:	3b 45 08             	cmp    0x8(%ebp),%eax
c002df4e:	74 06                	je     c002df56 <close_file+0x53>
c002df50:	83 7d 08 ff          	cmpl   $0xffffffff,0x8(%ebp)
c002df54:	75 37                	jne    c002df8d <close_file+0x8a>
    {
      // Close the file
      file_close(ptr_processing_file->file);
c002df56:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002df59:	8b 00                	mov    (%eax),%eax
c002df5b:	83 ec 0c             	sub    $0xc,%esp
c002df5e:	50                   	push   %eax
c002df5f:	e8 15 09 00 00       	call   c002e879 <file_close>
c002df64:	83 c4 10             	add    $0x10,%esp

      // Remove the process file from the list
      list_remove(&ptr_processing_file->elem);
c002df67:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002df6a:	83 c0 08             	add    $0x8,%eax
c002df6d:	83 ec 0c             	sub    $0xc,%esp
c002df70:	50                   	push   %eax
c002df71:	e8 9e c2 ff ff       	call   c002a214 <list_remove>
c002df76:	83 c4 10             	add    $0x10,%esp

      // Free the memory for the process file
      free(ptr_processing_file);
c002df79:	83 ec 0c             	sub    $0xc,%esp
c002df7c:	ff 75 e8             	pushl  -0x18(%ebp)
c002df7f:	e8 38 5e ff ff       	call   c0023dbc <free>
c002df84:	83 c4 10             	add    $0x10,%esp

      // If not closing all file descriptors, return
      if (file_descriptor != ALL_FDESC_CLOSE)
c002df87:	83 7d 08 ff          	cmpl   $0xffffffff,0x8(%ebp)
c002df8b:	75 23                	jne    c002dfb0 <close_file+0xad>
  for (; e != list_end(&t->file_name_list); e = next)
c002df8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002df90:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002df93:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002df96:	83 c0 38             	add    $0x38,%eax
c002df99:	83 ec 0c             	sub    $0xc,%esp
c002df9c:	50                   	push   %eax
c002df9d:	e8 3d bf ff ff       	call   c0029edf <list_end>
c002dfa2:	83 c4 10             	add    $0x10,%esp
c002dfa5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002dfa8:	0f 85 7a ff ff ff    	jne    c002df28 <close_file+0x25>
c002dfae:	eb 01                	jmp    c002dfb1 <close_file+0xae>
        return;
c002dfb0:	90                   	nop
    }

  }
}
c002dfb1:	c9                   	leave  
c002dfb2:	c3                   	ret    

c002dfb3 <gdt_init>:

/* Sets up a proper GDT.  The bootstrap loader's GDT didn't
   include user-mode selectors or a TSS, but we need both now. */
void
gdt_init (void)
{
c002dfb3:	55                   	push   %ebp
c002dfb4:	89 e5                	mov    %esp,%ebp
c002dfb6:	83 ec 18             	sub    $0x18,%esp
  uint64_t gdtr_operand;

  /* Initialize GDT. */
  gdt[SEL_NULL / sizeof *gdt] = 0;
c002dfb9:	c7 05 60 a6 03 c0 00 	movl   $0x0,0xc003a660
c002dfc0:	00 00 00 
c002dfc3:	c7 05 64 a6 03 c0 00 	movl   $0x0,0xc003a664
c002dfca:	00 00 00 
  gdt[SEL_KCSEG / sizeof *gdt] = make_code_desc (0);
c002dfcd:	83 ec 0c             	sub    $0xc,%esp
c002dfd0:	6a 00                	push   $0x0
c002dfd2:	e8 fe 01 00 00       	call   c002e1d5 <make_code_desc>
c002dfd7:	83 c4 10             	add    $0x10,%esp
c002dfda:	a3 68 a6 03 c0       	mov    %eax,0xc003a668
c002dfdf:	89 15 6c a6 03 c0    	mov    %edx,0xc003a66c
  gdt[SEL_KDSEG / sizeof *gdt] = make_data_desc (0);
c002dfe5:	83 ec 0c             	sub    $0xc,%esp
c002dfe8:	6a 00                	push   $0x0
c002dfea:	e8 09 02 00 00       	call   c002e1f8 <make_data_desc>
c002dfef:	83 c4 10             	add    $0x10,%esp
c002dff2:	a3 70 a6 03 c0       	mov    %eax,0xc003a670
c002dff7:	89 15 74 a6 03 c0    	mov    %edx,0xc003a674
  gdt[SEL_UCSEG / sizeof *gdt] = make_code_desc (3);
c002dffd:	83 ec 0c             	sub    $0xc,%esp
c002e000:	6a 03                	push   $0x3
c002e002:	e8 ce 01 00 00       	call   c002e1d5 <make_code_desc>
c002e007:	83 c4 10             	add    $0x10,%esp
c002e00a:	a3 78 a6 03 c0       	mov    %eax,0xc003a678
c002e00f:	89 15 7c a6 03 c0    	mov    %edx,0xc003a67c
  gdt[SEL_UDSEG / sizeof *gdt] = make_data_desc (3);
c002e015:	83 ec 0c             	sub    $0xc,%esp
c002e018:	6a 03                	push   $0x3
c002e01a:	e8 d9 01 00 00       	call   c002e1f8 <make_data_desc>
c002e01f:	83 c4 10             	add    $0x10,%esp
c002e022:	a3 80 a6 03 c0       	mov    %eax,0xc003a680
c002e027:	89 15 84 a6 03 c0    	mov    %edx,0xc003a684
  gdt[SEL_TSS / sizeof *gdt] = make_tss_desc (tss_get ());
c002e02d:	e8 8a 02 00 00       	call   c002e2bc <tss_get>
c002e032:	83 ec 0c             	sub    $0xc,%esp
c002e035:	50                   	push   %eax
c002e036:	e8 e0 01 00 00       	call   c002e21b <make_tss_desc>
c002e03b:	83 c4 10             	add    $0x10,%esp
c002e03e:	a3 88 a6 03 c0       	mov    %eax,0xc003a688
c002e043:	89 15 8c a6 03 c0    	mov    %edx,0xc003a68c

  /* Load GDTR, TR.  See [IA32-v3a] 2.4.1 "Global Descriptor
     Table Register (GDTR)", 2.4.4 "Task Register (TR)", and
     6.2.4 "Task Register".  */
  gdtr_operand = make_gdtr_operand (sizeof gdt - 1, gdt);
c002e049:	83 ec 08             	sub    $0x8,%esp
c002e04c:	68 60 a6 03 c0       	push   $0xc003a660
c002e051:	6a 2f                	push   $0x2f
c002e053:	e8 e4 01 00 00       	call   c002e23c <make_gdtr_operand>
c002e058:	83 c4 10             	add    $0x10,%esp
c002e05b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e05e:	89 55 f4             	mov    %edx,-0xc(%ebp)
  asm volatile ("lgdt %0" : : "m" (gdtr_operand));
c002e061:	0f 01 55 f0          	lgdtl  -0x10(%ebp)
  asm volatile ("ltr %w0" : : "q" (SEL_TSS));
c002e065:	b8 28 00 00 00       	mov    $0x28,%eax
c002e06a:	0f 00 d8             	ltr    %ax
}
c002e06d:	90                   	nop
c002e06e:	c9                   	leave  
c002e06f:	c3                   	ret    

c002e070 <make_seg_desc>:
               uint32_t limit,
               enum seg_class class,
               int type,
               int dpl,
               enum seg_granularity granularity)
{
c002e070:	55                   	push   %ebp
c002e071:	89 e5                	mov    %esp,%ebp
c002e073:	57                   	push   %edi
c002e074:	56                   	push   %esi
c002e075:	53                   	push   %ebx
c002e076:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (limit <= 0xfffff);
c002e079:	81 7d 0c ff ff 0f 00 	cmpl   $0xfffff,0xc(%ebp)
c002e080:	76 1e                	jbe    c002e0a0 <make_seg_desc+0x30>
c002e082:	83 ec 0c             	sub    $0xc,%esp
c002e085:	68 60 33 03 c0       	push   $0xc0033360
c002e08a:	68 71 33 03 c0       	push   $0xc0033371
c002e08f:	68 34 34 03 c0       	push   $0xc0033434
c002e094:	6a 5b                	push   $0x5b
c002e096:	68 88 33 03 c0       	push   $0xc0033388
c002e09b:	e8 fd ba ff ff       	call   c0029b9d <debug_panic>
  ASSERT (class == CLS_SYSTEM || class == CLS_CODE_DATA);
c002e0a0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e0a4:	74 24                	je     c002e0ca <make_seg_desc+0x5a>
c002e0a6:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c002e0aa:	74 1e                	je     c002e0ca <make_seg_desc+0x5a>
c002e0ac:	83 ec 0c             	sub    $0xc,%esp
c002e0af:	68 a0 33 03 c0       	push   $0xc00333a0
c002e0b4:	68 71 33 03 c0       	push   $0xc0033371
c002e0b9:	68 34 34 03 c0       	push   $0xc0033434
c002e0be:	6a 5c                	push   $0x5c
c002e0c0:	68 88 33 03 c0       	push   $0xc0033388
c002e0c5:	e8 d3 ba ff ff       	call   c0029b9d <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c002e0ca:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002e0ce:	78 06                	js     c002e0d6 <make_seg_desc+0x66>
c002e0d0:	83 7d 14 0f          	cmpl   $0xf,0x14(%ebp)
c002e0d4:	7e 1e                	jle    c002e0f4 <make_seg_desc+0x84>
c002e0d6:	83 ec 0c             	sub    $0xc,%esp
c002e0d9:	68 ce 33 03 c0       	push   $0xc00333ce
c002e0de:	68 71 33 03 c0       	push   $0xc0033371
c002e0e3:	68 34 34 03 c0       	push   $0xc0033434
c002e0e8:	6a 5d                	push   $0x5d
c002e0ea:	68 88 33 03 c0       	push   $0xc0033388
c002e0ef:	e8 a9 ba ff ff       	call   c0029b9d <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c002e0f4:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c002e0f8:	78 06                	js     c002e100 <make_seg_desc+0x90>
c002e0fa:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
c002e0fe:	7e 1e                	jle    c002e11e <make_seg_desc+0xae>
c002e100:	83 ec 0c             	sub    $0xc,%esp
c002e103:	68 e6 33 03 c0       	push   $0xc00333e6
c002e108:	68 71 33 03 c0       	push   $0xc0033371
c002e10d:	68 34 34 03 c0       	push   $0xc0033434
c002e112:	6a 5e                	push   $0x5e
c002e114:	68 88 33 03 c0       	push   $0xc0033388
c002e119:	e8 7f ba ff ff       	call   c0029b9d <debug_panic>
  ASSERT (granularity == GRAN_BYTE || granularity == GRAN_PAGE);
c002e11e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
c002e122:	74 24                	je     c002e148 <make_seg_desc+0xd8>
c002e124:	83 7d 1c 01          	cmpl   $0x1,0x1c(%ebp)
c002e128:	74 1e                	je     c002e148 <make_seg_desc+0xd8>
c002e12a:	83 ec 0c             	sub    $0xc,%esp
c002e12d:	68 fc 33 03 c0       	push   $0xc00333fc
c002e132:	68 71 33 03 c0       	push   $0xc0033371
c002e137:	68 34 34 03 c0       	push   $0xc0033434
c002e13c:	6a 5f                	push   $0x5f
c002e13e:	68 88 33 03 c0       	push   $0xc0033388
c002e143:	e8 55 ba ff ff       	call   c0029b9d <debug_panic>

  e0 = ((limit & 0xffff)             /* Limit 15:0. */
c002e148:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e14b:	0f b7 c0             	movzwl %ax,%eax
        | (base << 16));             /* Base 15:0. */
c002e14e:	8b 55 08             	mov    0x8(%ebp),%edx
c002e151:	c1 e2 10             	shl    $0x10,%edx
  e0 = ((limit & 0xffff)             /* Limit 15:0. */
c002e154:	09 d0                	or     %edx,%eax
c002e156:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002e159:	8b 45 08             	mov    0x8(%ebp),%eax
c002e15c:	c1 e8 10             	shr    $0x10,%eax
c002e15f:	0f b6 c0             	movzbl %al,%eax
        | (type << 8)                /* Segment type. */
c002e162:	8b 55 14             	mov    0x14(%ebp),%edx
c002e165:	c1 e2 08             	shl    $0x8,%edx
c002e168:	09 c2                	or     %eax,%edx
        | (class << 12)              /* 0=system, 1=code/data. */
c002e16a:	8b 45 10             	mov    0x10(%ebp),%eax
c002e16d:	c1 e0 0c             	shl    $0xc,%eax
c002e170:	09 c2                	or     %eax,%edx
        | (dpl << 13)                /* Descriptor privilege. */
c002e172:	8b 45 18             	mov    0x18(%ebp),%eax
c002e175:	c1 e0 0d             	shl    $0xd,%eax
c002e178:	09 c2                	or     %eax,%edx
        | (1 << 15)                  /* Present. */
        | (limit & 0xf0000)          /* Limit 16:19. */
c002e17a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e17d:	25 00 00 0f 00       	and    $0xf0000,%eax
c002e182:	09 c2                	or     %eax,%edx
        | (1 << 22)                  /* 32-bit segment. */
        | (granularity << 23)        /* Byte/page granularity. */
c002e184:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002e187:	c1 e0 17             	shl    $0x17,%eax
c002e18a:	09 c2                	or     %eax,%edx
        | (base & 0xff000000));      /* Base 31:24. */
c002e18c:	8b 45 08             	mov    0x8(%ebp),%eax
c002e18f:	25 00 00 00 ff       	and    $0xff000000,%eax
c002e194:	09 d0                	or     %edx,%eax
  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002e196:	0d 00 80 40 00       	or     $0x408000,%eax
c002e19b:	89 45 e0             	mov    %eax,-0x20(%ebp)

  return e0 | ((uint64_t) e1 << 32);
c002e19e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c002e1a1:	bf 00 00 00 00       	mov    $0x0,%edi
c002e1a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e1a9:	ba 00 00 00 00       	mov    $0x0,%edx
c002e1ae:	89 c2                	mov    %eax,%edx
c002e1b0:	b8 00 00 00 00       	mov    $0x0,%eax
c002e1b5:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002e1b8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c002e1bb:	89 f0                	mov    %esi,%eax
c002e1bd:	0b 45 d0             	or     -0x30(%ebp),%eax
c002e1c0:	89 c1                	mov    %eax,%ecx
c002e1c2:	89 f8                	mov    %edi,%eax
c002e1c4:	0b 45 d4             	or     -0x2c(%ebp),%eax
c002e1c7:	89 c3                	mov    %eax,%ebx
c002e1c9:	89 c8                	mov    %ecx,%eax
c002e1cb:	89 da                	mov    %ebx,%edx
}
c002e1cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002e1d0:	5b                   	pop    %ebx
c002e1d1:	5e                   	pop    %esi
c002e1d2:	5f                   	pop    %edi
c002e1d3:	5d                   	pop    %ebp
c002e1d4:	c3                   	ret    

c002e1d5 <make_code_desc>:

/* Returns a descriptor for a readable code segment with base at
   0, a limit of 4 GB, and the given DPL. */
static uint64_t
make_code_desc (int dpl)
{
c002e1d5:	55                   	push   %ebp
c002e1d6:	89 e5                	mov    %esp,%ebp
c002e1d8:	83 ec 08             	sub    $0x8,%esp
  return make_seg_desc (0, 0xfffff, CLS_CODE_DATA, 10, dpl, GRAN_PAGE);
c002e1db:	83 ec 08             	sub    $0x8,%esp
c002e1de:	6a 01                	push   $0x1
c002e1e0:	ff 75 08             	pushl  0x8(%ebp)
c002e1e3:	6a 0a                	push   $0xa
c002e1e5:	6a 01                	push   $0x1
c002e1e7:	68 ff ff 0f 00       	push   $0xfffff
c002e1ec:	6a 00                	push   $0x0
c002e1ee:	e8 7d fe ff ff       	call   c002e070 <make_seg_desc>
c002e1f3:	83 c4 20             	add    $0x20,%esp
}
c002e1f6:	c9                   	leave  
c002e1f7:	c3                   	ret    

c002e1f8 <make_data_desc>:

/* Returns a descriptor for a writable data segment with base at
   0, a limit of 4 GB, and the given DPL. */
static uint64_t
make_data_desc (int dpl)
{
c002e1f8:	55                   	push   %ebp
c002e1f9:	89 e5                	mov    %esp,%ebp
c002e1fb:	83 ec 08             	sub    $0x8,%esp
  return make_seg_desc (0, 0xfffff, CLS_CODE_DATA, 2, dpl, GRAN_PAGE);
c002e1fe:	83 ec 08             	sub    $0x8,%esp
c002e201:	6a 01                	push   $0x1
c002e203:	ff 75 08             	pushl  0x8(%ebp)
c002e206:	6a 02                	push   $0x2
c002e208:	6a 01                	push   $0x1
c002e20a:	68 ff ff 0f 00       	push   $0xfffff
c002e20f:	6a 00                	push   $0x0
c002e211:	e8 5a fe ff ff       	call   c002e070 <make_seg_desc>
c002e216:	83 c4 20             	add    $0x20,%esp
}
c002e219:	c9                   	leave  
c002e21a:	c3                   	ret    

c002e21b <make_tss_desc>:
   Segment with its base at the given linear address, a limit of
   0x67 bytes (the size of a 32-bit TSS), and a DPL of 0.
   See [IA32-v3a] 6.2.2 "TSS Descriptor". */
static uint64_t
make_tss_desc (void *laddr)
{
c002e21b:	55                   	push   %ebp
c002e21c:	89 e5                	mov    %esp,%ebp
c002e21e:	83 ec 08             	sub    $0x8,%esp
  return make_seg_desc ((uint32_t) laddr, 0x67, CLS_SYSTEM, 9, 0, GRAN_BYTE);
c002e221:	8b 45 08             	mov    0x8(%ebp),%eax
c002e224:	83 ec 08             	sub    $0x8,%esp
c002e227:	6a 00                	push   $0x0
c002e229:	6a 00                	push   $0x0
c002e22b:	6a 09                	push   $0x9
c002e22d:	6a 00                	push   $0x0
c002e22f:	6a 67                	push   $0x67
c002e231:	50                   	push   %eax
c002e232:	e8 39 fe ff ff       	call   c002e070 <make_seg_desc>
c002e237:	83 c4 20             	add    $0x20,%esp
}
c002e23a:	c9                   	leave  
c002e23b:	c3                   	ret    

c002e23c <make_gdtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LGDT instruction. */
static uint64_t
make_gdtr_operand (uint16_t limit, void *base)
{
c002e23c:	55                   	push   %ebp
c002e23d:	89 e5                	mov    %esp,%ebp
c002e23f:	57                   	push   %edi
c002e240:	56                   	push   %esi
c002e241:	53                   	push   %ebx
c002e242:	83 ec 14             	sub    $0x14,%esp
c002e245:	8b 45 08             	mov    0x8(%ebp),%eax
c002e248:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c002e24c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c002e250:	89 c6                	mov    %eax,%esi
c002e252:	bf 00 00 00 00       	mov    $0x0,%edi
c002e257:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e25a:	ba 00 00 00 00       	mov    $0x0,%edx
c002e25f:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c002e263:	c1 e0 10             	shl    $0x10,%eax
c002e266:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002e269:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002e26c:	89 f0                	mov    %esi,%eax
c002e26e:	0b 45 e0             	or     -0x20(%ebp),%eax
c002e271:	89 c1                	mov    %eax,%ecx
c002e273:	89 f8                	mov    %edi,%eax
c002e275:	0b 45 e4             	or     -0x1c(%ebp),%eax
c002e278:	89 c3                	mov    %eax,%ebx
c002e27a:	89 c8                	mov    %ecx,%eax
c002e27c:	89 da                	mov    %ebx,%edx
}
c002e27e:	83 c4 14             	add    $0x14,%esp
c002e281:	5b                   	pop    %ebx
c002e282:	5e                   	pop    %esi
c002e283:	5f                   	pop    %edi
c002e284:	5d                   	pop    %ebp
c002e285:	c3                   	ret    

c002e286 <tss_init>:
static struct tss *tss;

/* Initializes the kernel TSS. */
void
tss_init (void) 
{
c002e286:	55                   	push   %ebp
c002e287:	89 e5                	mov    %esp,%ebp
c002e289:	83 ec 08             	sub    $0x8,%esp
  /* Our TSS is never used in a call gate or task gate, so only a
     few fields of it are ever referenced, and those are the only
     ones we initialize. */
  tss = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002e28c:	83 ec 0c             	sub    $0xc,%esp
c002e28f:	6a 03                	push   $0x3
c002e291:	e8 d9 54 ff ff       	call   c002376f <palloc_get_page>
c002e296:	83 c4 10             	add    $0x10,%esp
c002e299:	a3 90 a6 03 c0       	mov    %eax,0xc003a690
  tss->ss0 = SEL_KDSEG;
c002e29e:	a1 90 a6 03 c0       	mov    0xc003a690,%eax
c002e2a3:	66 c7 40 08 10 00    	movw   $0x10,0x8(%eax)
  tss->bitmap = 0xdfff;
c002e2a9:	a1 90 a6 03 c0       	mov    0xc003a690,%eax
c002e2ae:	66 c7 40 66 ff df    	movw   $0xdfff,0x66(%eax)
  tss_update ();
c002e2b4:	e8 37 00 00 00       	call   c002e2f0 <tss_update>
}
c002e2b9:	90                   	nop
c002e2ba:	c9                   	leave  
c002e2bb:	c3                   	ret    

c002e2bc <tss_get>:

/* Returns the kernel TSS. */
struct tss *
tss_get (void) 
{
c002e2bc:	55                   	push   %ebp
c002e2bd:	89 e5                	mov    %esp,%ebp
c002e2bf:	83 ec 08             	sub    $0x8,%esp
  ASSERT (tss != NULL);
c002e2c2:	a1 90 a6 03 c0       	mov    0xc003a690,%eax
c002e2c7:	85 c0                	test   %eax,%eax
c002e2c9:	75 1e                	jne    c002e2e9 <tss_get+0x2d>
c002e2cb:	83 ec 0c             	sub    $0xc,%esp
c002e2ce:	68 44 34 03 c0       	push   $0xc0033444
c002e2d3:	68 50 34 03 c0       	push   $0xc0033450
c002e2d8:	68 7c 34 03 c0       	push   $0xc003347c
c002e2dd:	6a 5f                	push   $0x5f
c002e2df:	68 67 34 03 c0       	push   $0xc0033467
c002e2e4:	e8 b4 b8 ff ff       	call   c0029b9d <debug_panic>
  return tss;
c002e2e9:	a1 90 a6 03 c0       	mov    0xc003a690,%eax
}
c002e2ee:	c9                   	leave  
c002e2ef:	c3                   	ret    

c002e2f0 <tss_update>:

/* Sets the ring 0 stack pointer in the TSS to point to the end
   of the thread stack. */
void
tss_update (void) 
{
c002e2f0:	55                   	push   %ebp
c002e2f1:	89 e5                	mov    %esp,%ebp
c002e2f3:	53                   	push   %ebx
c002e2f4:	83 ec 04             	sub    $0x4,%esp
  ASSERT (tss != NULL);
c002e2f7:	a1 90 a6 03 c0       	mov    0xc003a690,%eax
c002e2fc:	85 c0                	test   %eax,%eax
c002e2fe:	75 1e                	jne    c002e31e <tss_update+0x2e>
c002e300:	83 ec 0c             	sub    $0xc,%esp
c002e303:	68 44 34 03 c0       	push   $0xc0033444
c002e308:	68 50 34 03 c0       	push   $0xc0033450
c002e30d:	68 84 34 03 c0       	push   $0xc0033484
c002e312:	6a 68                	push   $0x68
c002e314:	68 67 34 03 c0       	push   $0xc0033467
c002e319:	e8 7f b8 ff ff       	call   c0029b9d <debug_panic>
  tss->esp0 = (uint8_t *) thread_current () + PGSIZE;
c002e31e:	8b 1d 90 a6 03 c0    	mov    0xc003a690,%ebx
c002e324:	e8 8d 2d ff ff       	call   c00210b6 <thread_current>
c002e329:	05 00 10 00 00       	add    $0x1000,%eax
c002e32e:	89 43 04             	mov    %eax,0x4(%ebx)
}
c002e331:	90                   	nop
c002e332:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e335:	c9                   	leave  
c002e336:	c3                   	ret    

c002e337 <filesys_init>:

/* Initializes the file system module.
   If FORMAT is true, reformats the file system. */
void
filesys_init (bool format) 
{
c002e337:	55                   	push   %ebp
c002e338:	89 e5                	mov    %esp,%ebp
c002e33a:	83 ec 18             	sub    $0x18,%esp
c002e33d:	8b 45 08             	mov    0x8(%ebp),%eax
c002e340:	88 45 f4             	mov    %al,-0xc(%ebp)
  fs_device = block_get_role (BLOCK_FILESYS);
c002e343:	83 ec 0c             	sub    $0xc,%esp
c002e346:	6a 01                	push   $0x1
c002e348:	e8 5c 70 ff ff       	call   c00253a9 <block_get_role>
c002e34d:	83 c4 10             	add    $0x10,%esp
c002e350:	a3 04 a9 03 c0       	mov    %eax,0xc003a904
  if (fs_device == NULL)
c002e355:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002e35a:	85 c0                	test   %eax,%eax
c002e35c:	75 16                	jne    c002e374 <filesys_init+0x3d>
    PANIC ("No file system device found, can't initialize file system.");
c002e35e:	68 90 34 03 c0       	push   $0xc0033490
c002e363:	68 28 35 03 c0       	push   $0xc0033528
c002e368:	6a 16                	push   $0x16
c002e36a:	68 cb 34 03 c0       	push   $0xc00334cb
c002e36f:	e8 29 b8 ff ff       	call   c0029b9d <debug_panic>

  inode_init ();
c002e374:	e8 9b 0c 00 00       	call   c002f014 <inode_init>
  free_map_init ();
c002e379:	e8 c5 01 00 00       	call   c002e543 <free_map_init>

  if (format) 
c002e37e:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002e382:	74 05                	je     c002e389 <filesys_init+0x52>
    do_format ();
c002e384:	e8 5b 01 00 00       	call   c002e4e4 <do_format>

  free_map_open ();
c002e389:	e8 15 03 00 00       	call   c002e6a3 <free_map_open>
}
c002e38e:	90                   	nop
c002e38f:	c9                   	leave  
c002e390:	c3                   	ret    

c002e391 <filesys_done>:

/* Shuts down the file system module, writing any unwritten data
   to disk. */
void
filesys_done (void) 
{
c002e391:	55                   	push   %ebp
c002e392:	89 e5                	mov    %esp,%ebp
c002e394:	83 ec 08             	sub    $0x8,%esp
  free_map_close ();
c002e397:	e8 82 03 00 00       	call   c002e71e <free_map_close>
}
c002e39c:	90                   	nop
c002e39d:	c9                   	leave  
c002e39e:	c3                   	ret    

c002e39f <filesys_create>:
   Returns true if successful, false otherwise.
   Fails if a file named NAME already exists,
   or if internal memory allocation fails. */
bool
filesys_create (const char *name, off_t initial_size) 
{
c002e39f:	55                   	push   %ebp
c002e3a0:	89 e5                	mov    %esp,%ebp
c002e3a2:	83 ec 18             	sub    $0x18,%esp
  block_sector_t inode_sector = 0;
c002e3a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  struct dir *dir = dir_open_root ();
c002e3ac:	e8 bb 07 00 00       	call   c002eb6c <dir_open_root>
c002e3b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bool success = (dir != NULL
                  && free_map_allocate (1, &inode_sector)
                  && inode_create (inode_sector, initial_size)
                  && dir_add (dir, name, inode_sector));
c002e3b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002e3b8:	74 4b                	je     c002e405 <filesys_create+0x66>
                  && free_map_allocate (1, &inode_sector)
c002e3ba:	83 ec 08             	sub    $0x8,%esp
c002e3bd:	8d 45 ec             	lea    -0x14(%ebp),%eax
c002e3c0:	50                   	push   %eax
c002e3c1:	6a 01                	push   $0x1
c002e3c3:	e8 eb 01 00 00       	call   c002e5b3 <free_map_allocate>
c002e3c8:	83 c4 10             	add    $0x10,%esp
c002e3cb:	84 c0                	test   %al,%al
c002e3cd:	74 36                	je     c002e405 <filesys_create+0x66>
                  && inode_create (inode_sector, initial_size)
c002e3cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e3d2:	83 ec 08             	sub    $0x8,%esp
c002e3d5:	ff 75 0c             	pushl  0xc(%ebp)
c002e3d8:	50                   	push   %eax
c002e3d9:	e8 4f 0c 00 00       	call   c002f02d <inode_create>
c002e3de:	83 c4 10             	add    $0x10,%esp
c002e3e1:	84 c0                	test   %al,%al
c002e3e3:	74 20                	je     c002e405 <filesys_create+0x66>
                  && dir_add (dir, name, inode_sector));
c002e3e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e3e8:	83 ec 04             	sub    $0x4,%esp
c002e3eb:	50                   	push   %eax
c002e3ec:	ff 75 08             	pushl  0x8(%ebp)
c002e3ef:	ff 75 f4             	pushl  -0xc(%ebp)
c002e3f2:	e8 58 09 00 00       	call   c002ed4f <dir_add>
c002e3f7:	83 c4 10             	add    $0x10,%esp
c002e3fa:	84 c0                	test   %al,%al
c002e3fc:	74 07                	je     c002e405 <filesys_create+0x66>
c002e3fe:	b8 01 00 00 00       	mov    $0x1,%eax
c002e403:	eb 05                	jmp    c002e40a <filesys_create+0x6b>
c002e405:	b8 00 00 00 00       	mov    $0x0,%eax
  bool success = (dir != NULL
c002e40a:	88 45 f3             	mov    %al,-0xd(%ebp)
c002e40d:	80 65 f3 01          	andb   $0x1,-0xd(%ebp)
  if (!success && inode_sector != 0) 
c002e411:	8a 45 f3             	mov    -0xd(%ebp),%al
c002e414:	83 f0 01             	xor    $0x1,%eax
c002e417:	84 c0                	test   %al,%al
c002e419:	74 18                	je     c002e433 <filesys_create+0x94>
c002e41b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e41e:	85 c0                	test   %eax,%eax
c002e420:	74 11                	je     c002e433 <filesys_create+0x94>
    free_map_release (inode_sector, 1);
c002e422:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e425:	83 ec 08             	sub    $0x8,%esp
c002e428:	6a 01                	push   $0x1
c002e42a:	50                   	push   %eax
c002e42b:	e8 03 02 00 00       	call   c002e633 <free_map_release>
c002e430:	83 c4 10             	add    $0x10,%esp
  dir_close (dir);
c002e433:	83 ec 0c             	sub    $0xc,%esp
c002e436:	ff 75 f4             	pushl  -0xc(%ebp)
c002e439:	e8 74 07 00 00       	call   c002ebb2 <dir_close>
c002e43e:	83 c4 10             	add    $0x10,%esp

  return success;
c002e441:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c002e444:	c9                   	leave  
c002e445:	c3                   	ret    

c002e446 <filesys_open>:
   otherwise.
   Fails if no file named NAME exists,
   or if an internal memory allocation fails. */
struct file *
filesys_open (const char *name)
{
c002e446:	55                   	push   %ebp
c002e447:	89 e5                	mov    %esp,%ebp
c002e449:	83 ec 18             	sub    $0x18,%esp
  struct dir *dir = dir_open_root ();
c002e44c:	e8 1b 07 00 00       	call   c002eb6c <dir_open_root>
c002e451:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct inode *inode = NULL;
c002e454:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if (dir != NULL)
c002e45b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002e45f:	74 15                	je     c002e476 <filesys_open+0x30>
    dir_lookup (dir, name, &inode);
c002e461:	83 ec 04             	sub    $0x4,%esp
c002e464:	8d 45 f0             	lea    -0x10(%ebp),%eax
c002e467:	50                   	push   %eax
c002e468:	ff 75 08             	pushl  0x8(%ebp)
c002e46b:	ff 75 f4             	pushl  -0xc(%ebp)
c002e46e:	e8 49 08 00 00       	call   c002ecbc <dir_lookup>
c002e473:	83 c4 10             	add    $0x10,%esp
  dir_close (dir);
c002e476:	83 ec 0c             	sub    $0xc,%esp
c002e479:	ff 75 f4             	pushl  -0xc(%ebp)
c002e47c:	e8 31 07 00 00       	call   c002ebb2 <dir_close>
c002e481:	83 c4 10             	add    $0x10,%esp

  return file_open (inode);
c002e484:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e487:	83 ec 0c             	sub    $0xc,%esp
c002e48a:	50                   	push   %eax
c002e48b:	e8 5f 03 00 00       	call   c002e7ef <file_open>
c002e490:	83 c4 10             	add    $0x10,%esp
}
c002e493:	c9                   	leave  
c002e494:	c3                   	ret    

c002e495 <filesys_remove>:
   Returns true if successful, false on failure.
   Fails if no file named NAME exists,
   or if an internal memory allocation fails. */
bool
filesys_remove (const char *name) 
{
c002e495:	55                   	push   %ebp
c002e496:	89 e5                	mov    %esp,%ebp
c002e498:	83 ec 18             	sub    $0x18,%esp
  struct dir *dir = dir_open_root ();
c002e49b:	e8 cc 06 00 00       	call   c002eb6c <dir_open_root>
c002e4a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bool success = dir != NULL && dir_remove (dir, name);
c002e4a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002e4a7:	74 1c                	je     c002e4c5 <filesys_remove+0x30>
c002e4a9:	83 ec 08             	sub    $0x8,%esp
c002e4ac:	ff 75 08             	pushl  0x8(%ebp)
c002e4af:	ff 75 f4             	pushl  -0xc(%ebp)
c002e4b2:	e8 ad 09 00 00       	call   c002ee64 <dir_remove>
c002e4b7:	83 c4 10             	add    $0x10,%esp
c002e4ba:	84 c0                	test   %al,%al
c002e4bc:	74 07                	je     c002e4c5 <filesys_remove+0x30>
c002e4be:	b8 01 00 00 00       	mov    $0x1,%eax
c002e4c3:	eb 05                	jmp    c002e4ca <filesys_remove+0x35>
c002e4c5:	b8 00 00 00 00       	mov    $0x0,%eax
c002e4ca:	88 45 f3             	mov    %al,-0xd(%ebp)
c002e4cd:	80 65 f3 01          	andb   $0x1,-0xd(%ebp)
  dir_close (dir); 
c002e4d1:	83 ec 0c             	sub    $0xc,%esp
c002e4d4:	ff 75 f4             	pushl  -0xc(%ebp)
c002e4d7:	e8 d6 06 00 00       	call   c002ebb2 <dir_close>
c002e4dc:	83 c4 10             	add    $0x10,%esp

  return success;
c002e4df:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c002e4e2:	c9                   	leave  
c002e4e3:	c3                   	ret    

c002e4e4 <do_format>:

/* Formats the file system. */
static void
do_format (void)
{
c002e4e4:	55                   	push   %ebp
c002e4e5:	89 e5                	mov    %esp,%ebp
c002e4e7:	83 ec 08             	sub    $0x8,%esp
  printf ("Formatting file system...");
c002e4ea:	83 ec 0c             	sub    $0xc,%esp
c002e4ed:	68 e3 34 03 c0       	push   $0xc00334e3
c002e4f2:	e8 e7 92 ff ff       	call   c00277de <printf>
c002e4f7:	83 c4 10             	add    $0x10,%esp
  free_map_create ();
c002e4fa:	e8 39 02 00 00       	call   c002e738 <free_map_create>
  if (!dir_create (ROOT_DIR_SECTOR, 16))
c002e4ff:	83 ec 08             	sub    $0x8,%esp
c002e502:	6a 10                	push   $0x10
c002e504:	6a 01                	push   $0x1
c002e506:	e8 df 05 00 00       	call   c002eaea <dir_create>
c002e50b:	83 c4 10             	add    $0x10,%esp
c002e50e:	83 f0 01             	xor    $0x1,%eax
c002e511:	84 c0                	test   %al,%al
c002e513:	74 16                	je     c002e52b <do_format+0x47>
    PANIC ("root directory creation failed");
c002e515:	68 00 35 03 c0       	push   $0xc0033500
c002e51a:	68 38 35 03 c0       	push   $0xc0033538
c002e51f:	6a 64                	push   $0x64
c002e521:	68 cb 34 03 c0       	push   $0xc00334cb
c002e526:	e8 72 b6 ff ff       	call   c0029b9d <debug_panic>
  free_map_close ();
c002e52b:	e8 ee 01 00 00       	call   c002e71e <free_map_close>
  printf ("done.\n");
c002e530:	83 ec 0c             	sub    $0xc,%esp
c002e533:	68 1f 35 03 c0       	push   $0xc003351f
c002e538:	e8 32 d9 ff ff       	call   c002be6f <puts>
c002e53d:	83 c4 10             	add    $0x10,%esp
}
c002e540:	90                   	nop
c002e541:	c9                   	leave  
c002e542:	c3                   	ret    

c002e543 <free_map_init>:
static struct bitmap *free_map;      /* Free map, one bit per sector. */

/* Initializes the free map. */
void
free_map_init (void) 
{
c002e543:	55                   	push   %ebp
c002e544:	89 e5                	mov    %esp,%ebp
c002e546:	83 ec 08             	sub    $0x8,%esp
  free_map = bitmap_create (block_size (fs_device));
c002e549:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002e54e:	83 ec 0c             	sub    $0xc,%esp
c002e551:	50                   	push   %eax
c002e552:	e8 90 70 ff ff       	call   c00255e7 <block_size>
c002e557:	83 c4 10             	add    $0x10,%esp
c002e55a:	83 ec 0c             	sub    $0xc,%esp
c002e55d:	50                   	push   %eax
c002e55e:	e8 b1 c6 ff ff       	call   c002ac14 <bitmap_create>
c002e563:	83 c4 10             	add    $0x10,%esp
c002e566:	a3 98 a6 03 c0       	mov    %eax,0xc003a698
  if (free_map == NULL)
c002e56b:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e570:	85 c0                	test   %eax,%eax
c002e572:	75 16                	jne    c002e58a <free_map_init+0x47>
    PANIC ("bitmap creation failed--file system device is too large");
c002e574:	68 44 35 03 c0       	push   $0xc0033544
c002e579:	68 28 36 03 c0       	push   $0xc0033628
c002e57e:	6a 11                	push   $0x11
c002e580:	68 7c 35 03 c0       	push   $0xc003357c
c002e585:	e8 13 b6 ff ff       	call   c0029b9d <debug_panic>
  bitmap_mark (free_map, FREE_MAP_SECTOR);
c002e58a:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e58f:	83 ec 08             	sub    $0x8,%esp
c002e592:	6a 00                	push   $0x0
c002e594:	50                   	push   %eax
c002e595:	e8 37 c8 ff ff       	call   c002add1 <bitmap_mark>
c002e59a:	83 c4 10             	add    $0x10,%esp
  bitmap_mark (free_map, ROOT_DIR_SECTOR);
c002e59d:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e5a2:	83 ec 08             	sub    $0x8,%esp
c002e5a5:	6a 01                	push   $0x1
c002e5a7:	50                   	push   %eax
c002e5a8:	e8 24 c8 ff ff       	call   c002add1 <bitmap_mark>
c002e5ad:	83 c4 10             	add    $0x10,%esp
}
c002e5b0:	90                   	nop
c002e5b1:	c9                   	leave  
c002e5b2:	c3                   	ret    

c002e5b3 <free_map_allocate>:
   Returns true if successful, false if not enough consecutive
   sectors were available or if the free_map file could not be
   written. */
bool
free_map_allocate (size_t cnt, block_sector_t *sectorp)
{
c002e5b3:	55                   	push   %ebp
c002e5b4:	89 e5                	mov    %esp,%ebp
c002e5b6:	83 ec 18             	sub    $0x18,%esp
  block_sector_t sector = bitmap_scan_and_flip (free_map, 0, cnt, false);
c002e5b9:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e5be:	6a 00                	push   $0x0
c002e5c0:	ff 75 08             	pushl  0x8(%ebp)
c002e5c3:	6a 00                	push   $0x0
c002e5c5:	50                   	push   %eax
c002e5c6:	e8 26 cd ff ff       	call   c002b2f1 <bitmap_scan_and_flip>
c002e5cb:	83 c4 10             	add    $0x10,%esp
c002e5ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sector != BITMAP_ERROR
c002e5d1:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002e5d5:	74 45                	je     c002e61c <free_map_allocate+0x69>
      && free_map_file != NULL
c002e5d7:	a1 94 a6 03 c0       	mov    0xc003a694,%eax
c002e5dc:	85 c0                	test   %eax,%eax
c002e5de:	74 3c                	je     c002e61c <free_map_allocate+0x69>
      && !bitmap_write (free_map, free_map_file))
c002e5e0:	8b 15 94 a6 03 c0    	mov    0xc003a694,%edx
c002e5e6:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e5eb:	83 ec 08             	sub    $0x8,%esp
c002e5ee:	52                   	push   %edx
c002e5ef:	50                   	push   %eax
c002e5f0:	e8 ff cd ff ff       	call   c002b3f4 <bitmap_write>
c002e5f5:	83 c4 10             	add    $0x10,%esp
c002e5f8:	83 f0 01             	xor    $0x1,%eax
c002e5fb:	84 c0                	test   %al,%al
c002e5fd:	74 1d                	je     c002e61c <free_map_allocate+0x69>
    {
      bitmap_set_multiple (free_map, sector, cnt, false); 
c002e5ff:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e604:	6a 00                	push   $0x0
c002e606:	ff 75 08             	pushl  0x8(%ebp)
c002e609:	ff 75 f4             	pushl  -0xc(%ebp)
c002e60c:	50                   	push   %eax
c002e60d:	e8 52 c9 ff ff       	call   c002af64 <bitmap_set_multiple>
c002e612:	83 c4 10             	add    $0x10,%esp
      sector = BITMAP_ERROR;
c002e615:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
    }
  if (sector != BITMAP_ERROR)
c002e61c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002e620:	74 08                	je     c002e62a <free_map_allocate+0x77>
    *sectorp = sector;
c002e622:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e625:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002e628:	89 10                	mov    %edx,(%eax)
  return sector != BITMAP_ERROR;
c002e62a:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002e62e:	0f 95 c0             	setne  %al
}
c002e631:	c9                   	leave  
c002e632:	c3                   	ret    

c002e633 <free_map_release>:

/* Makes CNT sectors starting at SECTOR available for use. */
void
free_map_release (block_sector_t sector, size_t cnt)
{
c002e633:	55                   	push   %ebp
c002e634:	89 e5                	mov    %esp,%ebp
c002e636:	83 ec 08             	sub    $0x8,%esp
  ASSERT (bitmap_all (free_map, sector, cnt));
c002e639:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e63e:	83 ec 04             	sub    $0x4,%esp
c002e641:	ff 75 0c             	pushl  0xc(%ebp)
c002e644:	ff 75 08             	pushl  0x8(%ebp)
c002e647:	50                   	push   %eax
c002e648:	e8 b8 cb ff ff       	call   c002b205 <bitmap_all>
c002e64d:	83 c4 10             	add    $0x10,%esp
c002e650:	84 c0                	test   %al,%al
c002e652:	75 1e                	jne    c002e672 <free_map_release+0x3f>
c002e654:	83 ec 0c             	sub    $0xc,%esp
c002e657:	68 98 35 03 c0       	push   $0xc0033598
c002e65c:	68 bb 35 03 c0       	push   $0xc00335bb
c002e661:	68 38 36 03 c0       	push   $0xc0033638
c002e666:	6a 2f                	push   $0x2f
c002e668:	68 7c 35 03 c0       	push   $0xc003357c
c002e66d:	e8 2b b5 ff ff       	call   c0029b9d <debug_panic>
  bitmap_set_multiple (free_map, sector, cnt, false);
c002e672:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e677:	6a 00                	push   $0x0
c002e679:	ff 75 0c             	pushl  0xc(%ebp)
c002e67c:	ff 75 08             	pushl  0x8(%ebp)
c002e67f:	50                   	push   %eax
c002e680:	e8 df c8 ff ff       	call   c002af64 <bitmap_set_multiple>
c002e685:	83 c4 10             	add    $0x10,%esp
  bitmap_write (free_map, free_map_file);
c002e688:	8b 15 94 a6 03 c0    	mov    0xc003a694,%edx
c002e68e:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e693:	83 ec 08             	sub    $0x8,%esp
c002e696:	52                   	push   %edx
c002e697:	50                   	push   %eax
c002e698:	e8 57 cd ff ff       	call   c002b3f4 <bitmap_write>
c002e69d:	83 c4 10             	add    $0x10,%esp
}
c002e6a0:	90                   	nop
c002e6a1:	c9                   	leave  
c002e6a2:	c3                   	ret    

c002e6a3 <free_map_open>:

/* Opens the free map file and reads it from disk. */
void
free_map_open (void) 
{
c002e6a3:	55                   	push   %ebp
c002e6a4:	89 e5                	mov    %esp,%ebp
c002e6a6:	83 ec 08             	sub    $0x8,%esp
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002e6a9:	83 ec 0c             	sub    $0xc,%esp
c002e6ac:	6a 00                	push   $0x0
c002e6ae:	e8 71 0a 00 00       	call   c002f124 <inode_open>
c002e6b3:	83 c4 10             	add    $0x10,%esp
c002e6b6:	83 ec 0c             	sub    $0xc,%esp
c002e6b9:	50                   	push   %eax
c002e6ba:	e8 30 01 00 00       	call   c002e7ef <file_open>
c002e6bf:	83 c4 10             	add    $0x10,%esp
c002e6c2:	a3 94 a6 03 c0       	mov    %eax,0xc003a694
  if (free_map_file == NULL)
c002e6c7:	a1 94 a6 03 c0       	mov    0xc003a694,%eax
c002e6cc:	85 c0                	test   %eax,%eax
c002e6ce:	75 16                	jne    c002e6e6 <free_map_open+0x43>
    PANIC ("can't open free map");
c002e6d0:	68 d2 35 03 c0       	push   $0xc00335d2
c002e6d5:	68 4c 36 03 c0       	push   $0xc003364c
c002e6da:	6a 3a                	push   $0x3a
c002e6dc:	68 7c 35 03 c0       	push   $0xc003357c
c002e6e1:	e8 b7 b4 ff ff       	call   c0029b9d <debug_panic>
  if (!bitmap_read (free_map, free_map_file))
c002e6e6:	8b 15 94 a6 03 c0    	mov    0xc003a694,%edx
c002e6ec:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e6f1:	83 ec 08             	sub    $0x8,%esp
c002e6f4:	52                   	push   %edx
c002e6f5:	50                   	push   %eax
c002e6f6:	e8 60 cc ff ff       	call   c002b35b <bitmap_read>
c002e6fb:	83 c4 10             	add    $0x10,%esp
c002e6fe:	83 f0 01             	xor    $0x1,%eax
c002e701:	84 c0                	test   %al,%al
c002e703:	74 16                	je     c002e71b <free_map_open+0x78>
    PANIC ("can't read free map");
c002e705:	68 e6 35 03 c0       	push   $0xc00335e6
c002e70a:	68 4c 36 03 c0       	push   $0xc003364c
c002e70f:	6a 3c                	push   $0x3c
c002e711:	68 7c 35 03 c0       	push   $0xc003357c
c002e716:	e8 82 b4 ff ff       	call   c0029b9d <debug_panic>
}
c002e71b:	90                   	nop
c002e71c:	c9                   	leave  
c002e71d:	c3                   	ret    

c002e71e <free_map_close>:

/* Writes the free map to disk and closes the free map file. */
void
free_map_close (void) 
{
c002e71e:	55                   	push   %ebp
c002e71f:	89 e5                	mov    %esp,%ebp
c002e721:	83 ec 08             	sub    $0x8,%esp
  file_close (free_map_file);
c002e724:	a1 94 a6 03 c0       	mov    0xc003a694,%eax
c002e729:	83 ec 0c             	sub    $0xc,%esp
c002e72c:	50                   	push   %eax
c002e72d:	e8 47 01 00 00       	call   c002e879 <file_close>
c002e732:	83 c4 10             	add    $0x10,%esp
}
c002e735:	90                   	nop
c002e736:	c9                   	leave  
c002e737:	c3                   	ret    

c002e738 <free_map_create>:

/* Creates a new free map file on disk and writes the free map to
   it. */
void
free_map_create (void) 
{
c002e738:	55                   	push   %ebp
c002e739:	89 e5                	mov    %esp,%ebp
c002e73b:	83 ec 08             	sub    $0x8,%esp
  /* Create inode. */
  if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map)))
c002e73e:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e743:	83 ec 0c             	sub    $0xc,%esp
c002e746:	50                   	push   %eax
c002e747:	e8 fc cb ff ff       	call   c002b348 <bitmap_file_size>
c002e74c:	83 c4 10             	add    $0x10,%esp
c002e74f:	83 ec 08             	sub    $0x8,%esp
c002e752:	50                   	push   %eax
c002e753:	6a 00                	push   $0x0
c002e755:	e8 d3 08 00 00       	call   c002f02d <inode_create>
c002e75a:	83 c4 10             	add    $0x10,%esp
c002e75d:	83 f0 01             	xor    $0x1,%eax
c002e760:	84 c0                	test   %al,%al
c002e762:	74 16                	je     c002e77a <free_map_create+0x42>
    PANIC ("free map creation failed");
c002e764:	68 fa 35 03 c0       	push   $0xc00335fa
c002e769:	68 5c 36 03 c0       	push   $0xc003365c
c002e76e:	6a 4d                	push   $0x4d
c002e770:	68 7c 35 03 c0       	push   $0xc003357c
c002e775:	e8 23 b4 ff ff       	call   c0029b9d <debug_panic>

  /* Write bitmap to file. */
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002e77a:	83 ec 0c             	sub    $0xc,%esp
c002e77d:	6a 00                	push   $0x0
c002e77f:	e8 a0 09 00 00       	call   c002f124 <inode_open>
c002e784:	83 c4 10             	add    $0x10,%esp
c002e787:	83 ec 0c             	sub    $0xc,%esp
c002e78a:	50                   	push   %eax
c002e78b:	e8 5f 00 00 00       	call   c002e7ef <file_open>
c002e790:	83 c4 10             	add    $0x10,%esp
c002e793:	a3 94 a6 03 c0       	mov    %eax,0xc003a694
  if (free_map_file == NULL)
c002e798:	a1 94 a6 03 c0       	mov    0xc003a694,%eax
c002e79d:	85 c0                	test   %eax,%eax
c002e79f:	75 16                	jne    c002e7b7 <free_map_create+0x7f>
    PANIC ("can't open free map");
c002e7a1:	68 d2 35 03 c0       	push   $0xc00335d2
c002e7a6:	68 5c 36 03 c0       	push   $0xc003365c
c002e7ab:	6a 52                	push   $0x52
c002e7ad:	68 7c 35 03 c0       	push   $0xc003357c
c002e7b2:	e8 e6 b3 ff ff       	call   c0029b9d <debug_panic>
  if (!bitmap_write (free_map, free_map_file))
c002e7b7:	8b 15 94 a6 03 c0    	mov    0xc003a694,%edx
c002e7bd:	a1 98 a6 03 c0       	mov    0xc003a698,%eax
c002e7c2:	83 ec 08             	sub    $0x8,%esp
c002e7c5:	52                   	push   %edx
c002e7c6:	50                   	push   %eax
c002e7c7:	e8 28 cc ff ff       	call   c002b3f4 <bitmap_write>
c002e7cc:	83 c4 10             	add    $0x10,%esp
c002e7cf:	83 f0 01             	xor    $0x1,%eax
c002e7d2:	84 c0                	test   %al,%al
c002e7d4:	74 16                	je     c002e7ec <free_map_create+0xb4>
    PANIC ("can't write free map");
c002e7d6:	68 13 36 03 c0       	push   $0xc0033613
c002e7db:	68 5c 36 03 c0       	push   $0xc003365c
c002e7e0:	6a 54                	push   $0x54
c002e7e2:	68 7c 35 03 c0       	push   $0xc003357c
c002e7e7:	e8 b1 b3 ff ff       	call   c0029b9d <debug_panic>
}
c002e7ec:	90                   	nop
c002e7ed:	c9                   	leave  
c002e7ee:	c3                   	ret    

c002e7ef <file_open>:
/* Opens a file for the given INODE, of which it takes ownership,
   and returns the new file.  Returns a null pointer if an
   allocation fails or if INODE is null. */
struct file *
file_open (struct inode *inode) 
{
c002e7ef:	55                   	push   %ebp
c002e7f0:	89 e5                	mov    %esp,%ebp
c002e7f2:	83 ec 18             	sub    $0x18,%esp
  struct file *file = calloc (1, sizeof *file);
c002e7f5:	83 ec 08             	sub    $0x8,%esp
c002e7f8:	6a 0c                	push   $0xc
c002e7fa:	6a 01                	push   $0x1
c002e7fc:	e8 8a 54 ff ff       	call   c0023c8b <calloc>
c002e801:	83 c4 10             	add    $0x10,%esp
c002e804:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (inode != NULL && file != NULL)
c002e807:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e80b:	74 24                	je     c002e831 <file_open+0x42>
c002e80d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002e811:	74 1e                	je     c002e831 <file_open+0x42>
    {
      file->inode = inode;
c002e813:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e816:	8b 55 08             	mov    0x8(%ebp),%edx
c002e819:	89 10                	mov    %edx,(%eax)
      file->pos = 0;
c002e81b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e81e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      file->deny_write = false;
c002e825:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e828:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      return file;
c002e82c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e82f:	eb 21                	jmp    c002e852 <file_open+0x63>
    }
  else
    {
      inode_close (inode);
c002e831:	83 ec 0c             	sub    $0xc,%esp
c002e834:	ff 75 08             	pushl  0x8(%ebp)
c002e837:	e8 fa 09 00 00       	call   c002f236 <inode_close>
c002e83c:	83 c4 10             	add    $0x10,%esp
      free (file);
c002e83f:	83 ec 0c             	sub    $0xc,%esp
c002e842:	ff 75 f4             	pushl  -0xc(%ebp)
c002e845:	e8 72 55 ff ff       	call   c0023dbc <free>
c002e84a:	83 c4 10             	add    $0x10,%esp
      return NULL; 
c002e84d:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
c002e852:	c9                   	leave  
c002e853:	c3                   	ret    

c002e854 <file_reopen>:

/* Opens and returns a new file for the same inode as FILE.
   Returns a null pointer if unsuccessful. */
struct file *
file_reopen (struct file *file) 
{
c002e854:	55                   	push   %ebp
c002e855:	89 e5                	mov    %esp,%ebp
c002e857:	83 ec 08             	sub    $0x8,%esp
  return file_open (inode_reopen (file->inode));
c002e85a:	8b 45 08             	mov    0x8(%ebp),%eax
c002e85d:	8b 00                	mov    (%eax),%eax
c002e85f:	83 ec 0c             	sub    $0xc,%esp
c002e862:	50                   	push   %eax
c002e863:	e8 a6 09 00 00       	call   c002f20e <inode_reopen>
c002e868:	83 c4 10             	add    $0x10,%esp
c002e86b:	83 ec 0c             	sub    $0xc,%esp
c002e86e:	50                   	push   %eax
c002e86f:	e8 7b ff ff ff       	call   c002e7ef <file_open>
c002e874:	83 c4 10             	add    $0x10,%esp
}
c002e877:	c9                   	leave  
c002e878:	c3                   	ret    

c002e879 <file_close>:

/* Closes FILE. */
void
file_close (struct file *file) 
{
c002e879:	55                   	push   %ebp
c002e87a:	89 e5                	mov    %esp,%ebp
c002e87c:	83 ec 08             	sub    $0x8,%esp
  if (file != NULL)
c002e87f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e883:	74 2d                	je     c002e8b2 <file_close+0x39>
    {
      file_allow_write (file);
c002e885:	83 ec 0c             	sub    $0xc,%esp
c002e888:	ff 75 08             	pushl  0x8(%ebp)
c002e88b:	e8 33 01 00 00       	call   c002e9c3 <file_allow_write>
c002e890:	83 c4 10             	add    $0x10,%esp
      inode_close (file->inode);
c002e893:	8b 45 08             	mov    0x8(%ebp),%eax
c002e896:	8b 00                	mov    (%eax),%eax
c002e898:	83 ec 0c             	sub    $0xc,%esp
c002e89b:	50                   	push   %eax
c002e89c:	e8 95 09 00 00       	call   c002f236 <inode_close>
c002e8a1:	83 c4 10             	add    $0x10,%esp
      free (file); 
c002e8a4:	83 ec 0c             	sub    $0xc,%esp
c002e8a7:	ff 75 08             	pushl  0x8(%ebp)
c002e8aa:	e8 0d 55 ff ff       	call   c0023dbc <free>
c002e8af:	83 c4 10             	add    $0x10,%esp
    }
}
c002e8b2:	90                   	nop
c002e8b3:	c9                   	leave  
c002e8b4:	c3                   	ret    

c002e8b5 <file_get_inode>:

/* Returns the inode encapsulated by FILE. */
struct inode *
file_get_inode (struct file *file) 
{
c002e8b5:	55                   	push   %ebp
c002e8b6:	89 e5                	mov    %esp,%ebp
  return file->inode;
c002e8b8:	8b 45 08             	mov    0x8(%ebp),%eax
c002e8bb:	8b 00                	mov    (%eax),%eax
}
c002e8bd:	5d                   	pop    %ebp
c002e8be:	c3                   	ret    

c002e8bf <file_read>:
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   Advances FILE's position by the number of bytes read. */
off_t
file_read (struct file *file, void *buffer, off_t size) 
{
c002e8bf:	55                   	push   %ebp
c002e8c0:	89 e5                	mov    %esp,%ebp
c002e8c2:	83 ec 18             	sub    $0x18,%esp
  off_t bytes_read = inode_read_at (file->inode, buffer, size, file->pos);
c002e8c5:	8b 45 08             	mov    0x8(%ebp),%eax
c002e8c8:	8b 50 04             	mov    0x4(%eax),%edx
c002e8cb:	8b 45 08             	mov    0x8(%ebp),%eax
c002e8ce:	8b 00                	mov    (%eax),%eax
c002e8d0:	52                   	push   %edx
c002e8d1:	ff 75 10             	pushl  0x10(%ebp)
c002e8d4:	ff 75 0c             	pushl  0xc(%ebp)
c002e8d7:	50                   	push   %eax
c002e8d8:	e8 1c 0a 00 00       	call   c002f2f9 <inode_read_at>
c002e8dd:	83 c4 10             	add    $0x10,%esp
c002e8e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  file->pos += bytes_read;
c002e8e3:	8b 45 08             	mov    0x8(%ebp),%eax
c002e8e6:	8b 50 04             	mov    0x4(%eax),%edx
c002e8e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e8ec:	01 c2                	add    %eax,%edx
c002e8ee:	8b 45 08             	mov    0x8(%ebp),%eax
c002e8f1:	89 50 04             	mov    %edx,0x4(%eax)
  return bytes_read;
c002e8f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002e8f7:	c9                   	leave  
c002e8f8:	c3                   	ret    

c002e8f9 <file_read_at>:
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   The file's current position is unaffected. */
off_t
file_read_at (struct file *file, void *buffer, off_t size, off_t file_ofs) 
{
c002e8f9:	55                   	push   %ebp
c002e8fa:	89 e5                	mov    %esp,%ebp
c002e8fc:	83 ec 08             	sub    $0x8,%esp
  return inode_read_at (file->inode, buffer, size, file_ofs);
c002e8ff:	8b 45 08             	mov    0x8(%ebp),%eax
c002e902:	8b 00                	mov    (%eax),%eax
c002e904:	ff 75 14             	pushl  0x14(%ebp)
c002e907:	ff 75 10             	pushl  0x10(%ebp)
c002e90a:	ff 75 0c             	pushl  0xc(%ebp)
c002e90d:	50                   	push   %eax
c002e90e:	e8 e6 09 00 00       	call   c002f2f9 <inode_read_at>
c002e913:	83 c4 10             	add    $0x10,%esp
}
c002e916:	c9                   	leave  
c002e917:	c3                   	ret    

c002e918 <file_write>:
   (Normally we'd grow the file in that case, but file growth is
   not yet implemented.)
   Advances FILE's position by the number of bytes read. */
off_t
file_write (struct file *file, const void *buffer, off_t size) 
{
c002e918:	55                   	push   %ebp
c002e919:	89 e5                	mov    %esp,%ebp
c002e91b:	83 ec 18             	sub    $0x18,%esp
  off_t bytes_written = inode_write_at (file->inode, buffer, size, file->pos);
c002e91e:	8b 45 08             	mov    0x8(%ebp),%eax
c002e921:	8b 50 04             	mov    0x4(%eax),%edx
c002e924:	8b 45 08             	mov    0x8(%ebp),%eax
c002e927:	8b 00                	mov    (%eax),%eax
c002e929:	52                   	push   %edx
c002e92a:	ff 75 10             	pushl  0x10(%ebp)
c002e92d:	ff 75 0c             	pushl  0xc(%ebp)
c002e930:	50                   	push   %eax
c002e931:	e8 11 0b 00 00       	call   c002f447 <inode_write_at>
c002e936:	83 c4 10             	add    $0x10,%esp
c002e939:	89 45 f4             	mov    %eax,-0xc(%ebp)
  file->pos += bytes_written;
c002e93c:	8b 45 08             	mov    0x8(%ebp),%eax
c002e93f:	8b 50 04             	mov    0x4(%eax),%edx
c002e942:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e945:	01 c2                	add    %eax,%edx
c002e947:	8b 45 08             	mov    0x8(%ebp),%eax
c002e94a:	89 50 04             	mov    %edx,0x4(%eax)
  return bytes_written;
c002e94d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002e950:	c9                   	leave  
c002e951:	c3                   	ret    

c002e952 <file_write_at>:
   not yet implemented.)
   The file's current position is unaffected. */
off_t
file_write_at (struct file *file, const void *buffer, off_t size,
               off_t file_ofs) 
{
c002e952:	55                   	push   %ebp
c002e953:	89 e5                	mov    %esp,%ebp
c002e955:	83 ec 08             	sub    $0x8,%esp
  return inode_write_at (file->inode, buffer, size, file_ofs);
c002e958:	8b 45 08             	mov    0x8(%ebp),%eax
c002e95b:	8b 00                	mov    (%eax),%eax
c002e95d:	ff 75 14             	pushl  0x14(%ebp)
c002e960:	ff 75 10             	pushl  0x10(%ebp)
c002e963:	ff 75 0c             	pushl  0xc(%ebp)
c002e966:	50                   	push   %eax
c002e967:	e8 db 0a 00 00       	call   c002f447 <inode_write_at>
c002e96c:	83 c4 10             	add    $0x10,%esp
}
c002e96f:	c9                   	leave  
c002e970:	c3                   	ret    

c002e971 <file_deny_write>:

/* Prevents write operations on FILE's underlying inode
   until file_allow_write() is called or FILE is closed. */
void
file_deny_write (struct file *file) 
{
c002e971:	55                   	push   %ebp
c002e972:	89 e5                	mov    %esp,%ebp
c002e974:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002e977:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e97b:	75 1e                	jne    c002e99b <file_deny_write+0x2a>
c002e97d:	83 ec 0c             	sub    $0xc,%esp
c002e980:	68 6c 36 03 c0       	push   $0xc003366c
c002e985:	68 79 36 03 c0       	push   $0xc0033679
c002e98a:	68 b4 36 03 c0       	push   $0xc00336b4
c002e98f:	6a 79                	push   $0x79
c002e991:	68 90 36 03 c0       	push   $0xc0033690
c002e996:	e8 02 b2 ff ff       	call   c0029b9d <debug_panic>
  if (!file->deny_write) 
c002e99b:	8b 45 08             	mov    0x8(%ebp),%eax
c002e99e:	8a 40 08             	mov    0x8(%eax),%al
c002e9a1:	83 f0 01             	xor    $0x1,%eax
c002e9a4:	84 c0                	test   %al,%al
c002e9a6:	74 18                	je     c002e9c0 <file_deny_write+0x4f>
    {
      file->deny_write = true;
c002e9a8:	8b 45 08             	mov    0x8(%ebp),%eax
c002e9ab:	c6 40 08 01          	movb   $0x1,0x8(%eax)
      inode_deny_write (file->inode);
c002e9af:	8b 45 08             	mov    0x8(%ebp),%eax
c002e9b2:	8b 00                	mov    (%eax),%eax
c002e9b4:	83 ec 0c             	sub    $0xc,%esp
c002e9b7:	50                   	push   %eax
c002e9b8:	e8 2e 0c 00 00       	call   c002f5eb <inode_deny_write>
c002e9bd:	83 c4 10             	add    $0x10,%esp
    }
}
c002e9c0:	90                   	nop
c002e9c1:	c9                   	leave  
c002e9c2:	c3                   	ret    

c002e9c3 <file_allow_write>:
/* Re-enables write operations on FILE's underlying inode.
   (Writes might still be denied by some other file that has the
   same inode open.) */
void
file_allow_write (struct file *file) 
{
c002e9c3:	55                   	push   %ebp
c002e9c4:	89 e5                	mov    %esp,%ebp
c002e9c6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002e9c9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e9cd:	75 21                	jne    c002e9f0 <file_allow_write+0x2d>
c002e9cf:	83 ec 0c             	sub    $0xc,%esp
c002e9d2:	68 6c 36 03 c0       	push   $0xc003366c
c002e9d7:	68 79 36 03 c0       	push   $0xc0033679
c002e9dc:	68 c4 36 03 c0       	push   $0xc00336c4
c002e9e1:	68 87 00 00 00       	push   $0x87
c002e9e6:	68 90 36 03 c0       	push   $0xc0033690
c002e9eb:	e8 ad b1 ff ff       	call   c0029b9d <debug_panic>
  if (file->deny_write) 
c002e9f0:	8b 45 08             	mov    0x8(%ebp),%eax
c002e9f3:	8a 40 08             	mov    0x8(%eax),%al
c002e9f6:	84 c0                	test   %al,%al
c002e9f8:	74 18                	je     c002ea12 <file_allow_write+0x4f>
    {
      file->deny_write = false;
c002e9fa:	8b 45 08             	mov    0x8(%ebp),%eax
c002e9fd:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      inode_allow_write (file->inode);
c002ea01:	8b 45 08             	mov    0x8(%ebp),%eax
c002ea04:	8b 00                	mov    (%eax),%eax
c002ea06:	83 ec 0c             	sub    $0xc,%esp
c002ea09:	50                   	push   %eax
c002ea0a:	e8 25 0c 00 00       	call   c002f634 <inode_allow_write>
c002ea0f:	83 c4 10             	add    $0x10,%esp
    }
}
c002ea12:	90                   	nop
c002ea13:	c9                   	leave  
c002ea14:	c3                   	ret    

c002ea15 <file_length>:

/* Returns the size of FILE in bytes. */
off_t
file_length (struct file *file) 
{
c002ea15:	55                   	push   %ebp
c002ea16:	89 e5                	mov    %esp,%ebp
c002ea18:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002ea1b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ea1f:	75 21                	jne    c002ea42 <file_length+0x2d>
c002ea21:	83 ec 0c             	sub    $0xc,%esp
c002ea24:	68 6c 36 03 c0       	push   $0xc003366c
c002ea29:	68 79 36 03 c0       	push   $0xc0033679
c002ea2e:	68 d8 36 03 c0       	push   $0xc00336d8
c002ea33:	68 93 00 00 00       	push   $0x93
c002ea38:	68 90 36 03 c0       	push   $0xc0033690
c002ea3d:	e8 5b b1 ff ff       	call   c0029b9d <debug_panic>
  return inode_length (file->inode);
c002ea42:	8b 45 08             	mov    0x8(%ebp),%eax
c002ea45:	8b 00                	mov    (%eax),%eax
c002ea47:	83 ec 0c             	sub    $0xc,%esp
c002ea4a:	50                   	push   %eax
c002ea4b:	e8 58 0c 00 00       	call   c002f6a8 <inode_length>
c002ea50:	83 c4 10             	add    $0x10,%esp
}
c002ea53:	c9                   	leave  
c002ea54:	c3                   	ret    

c002ea55 <file_seek>:

/* Sets the current position in FILE to NEW_POS bytes from the
   start of the file. */
void
file_seek (struct file *file, off_t new_pos)
{
c002ea55:	55                   	push   %ebp
c002ea56:	89 e5                	mov    %esp,%ebp
c002ea58:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002ea5b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ea5f:	75 21                	jne    c002ea82 <file_seek+0x2d>
c002ea61:	83 ec 0c             	sub    $0xc,%esp
c002ea64:	68 6c 36 03 c0       	push   $0xc003366c
c002ea69:	68 79 36 03 c0       	push   $0xc0033679
c002ea6e:	68 e4 36 03 c0       	push   $0xc00336e4
c002ea73:	68 9c 00 00 00       	push   $0x9c
c002ea78:	68 90 36 03 c0       	push   $0xc0033690
c002ea7d:	e8 1b b1 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (new_pos >= 0);
c002ea82:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ea86:	79 21                	jns    c002eaa9 <file_seek+0x54>
c002ea88:	83 ec 0c             	sub    $0xc,%esp
c002ea8b:	68 a5 36 03 c0       	push   $0xc00336a5
c002ea90:	68 79 36 03 c0       	push   $0xc0033679
c002ea95:	68 e4 36 03 c0       	push   $0xc00336e4
c002ea9a:	68 9d 00 00 00       	push   $0x9d
c002ea9f:	68 90 36 03 c0       	push   $0xc0033690
c002eaa4:	e8 f4 b0 ff ff       	call   c0029b9d <debug_panic>
  file->pos = new_pos;
c002eaa9:	8b 45 08             	mov    0x8(%ebp),%eax
c002eaac:	8b 55 0c             	mov    0xc(%ebp),%edx
c002eaaf:	89 50 04             	mov    %edx,0x4(%eax)
}
c002eab2:	90                   	nop
c002eab3:	c9                   	leave  
c002eab4:	c3                   	ret    

c002eab5 <file_tell>:

/* Returns the current position in FILE as a byte offset from the
   start of the file. */
off_t
file_tell (struct file *file) 
{
c002eab5:	55                   	push   %ebp
c002eab6:	89 e5                	mov    %esp,%ebp
c002eab8:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002eabb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002eabf:	75 21                	jne    c002eae2 <file_tell+0x2d>
c002eac1:	83 ec 0c             	sub    $0xc,%esp
c002eac4:	68 6c 36 03 c0       	push   $0xc003366c
c002eac9:	68 79 36 03 c0       	push   $0xc0033679
c002eace:	68 f0 36 03 c0       	push   $0xc00336f0
c002ead3:	68 a6 00 00 00       	push   $0xa6
c002ead8:	68 90 36 03 c0       	push   $0xc0033690
c002eadd:	e8 bb b0 ff ff       	call   c0029b9d <debug_panic>
  return file->pos;
c002eae2:	8b 45 08             	mov    0x8(%ebp),%eax
c002eae5:	8b 40 04             	mov    0x4(%eax),%eax
}
c002eae8:	c9                   	leave  
c002eae9:	c3                   	ret    

c002eaea <dir_create>:

/* Creates a directory with space for ENTRY_CNT entries in the
   given SECTOR.  Returns true if successful, false on failure. */
bool
dir_create (block_sector_t sector, size_t entry_cnt)
{
c002eaea:	55                   	push   %ebp
c002eaeb:	89 e5                	mov    %esp,%ebp
c002eaed:	83 ec 08             	sub    $0x8,%esp
  return inode_create (sector, entry_cnt * sizeof (struct dir_entry));
c002eaf0:	8b 55 0c             	mov    0xc(%ebp),%edx
c002eaf3:	89 d0                	mov    %edx,%eax
c002eaf5:	c1 e0 02             	shl    $0x2,%eax
c002eaf8:	01 d0                	add    %edx,%eax
c002eafa:	c1 e0 02             	shl    $0x2,%eax
c002eafd:	83 ec 08             	sub    $0x8,%esp
c002eb00:	50                   	push   %eax
c002eb01:	ff 75 08             	pushl  0x8(%ebp)
c002eb04:	e8 24 05 00 00       	call   c002f02d <inode_create>
c002eb09:	83 c4 10             	add    $0x10,%esp
}
c002eb0c:	c9                   	leave  
c002eb0d:	c3                   	ret    

c002eb0e <dir_open>:

/* Opens and returns the directory for the given INODE, of which
   it takes ownership.  Returns a null pointer on failure. */
struct dir *
dir_open (struct inode *inode) 
{
c002eb0e:	55                   	push   %ebp
c002eb0f:	89 e5                	mov    %esp,%ebp
c002eb11:	83 ec 18             	sub    $0x18,%esp
  struct dir *dir = calloc (1, sizeof *dir);
c002eb14:	83 ec 08             	sub    $0x8,%esp
c002eb17:	6a 08                	push   $0x8
c002eb19:	6a 01                	push   $0x1
c002eb1b:	e8 6b 51 ff ff       	call   c0023c8b <calloc>
c002eb20:	83 c4 10             	add    $0x10,%esp
c002eb23:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (inode != NULL && dir != NULL)
c002eb26:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002eb2a:	74 1d                	je     c002eb49 <dir_open+0x3b>
c002eb2c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002eb30:	74 17                	je     c002eb49 <dir_open+0x3b>
    {
      dir->inode = inode;
c002eb32:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002eb35:	8b 55 08             	mov    0x8(%ebp),%edx
c002eb38:	89 10                	mov    %edx,(%eax)
      dir->pos = 0;
c002eb3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002eb3d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      return dir;
c002eb44:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002eb47:	eb 21                	jmp    c002eb6a <dir_open+0x5c>
    }
  else
    {
      inode_close (inode);
c002eb49:	83 ec 0c             	sub    $0xc,%esp
c002eb4c:	ff 75 08             	pushl  0x8(%ebp)
c002eb4f:	e8 e2 06 00 00       	call   c002f236 <inode_close>
c002eb54:	83 c4 10             	add    $0x10,%esp
      free (dir);
c002eb57:	83 ec 0c             	sub    $0xc,%esp
c002eb5a:	ff 75 f4             	pushl  -0xc(%ebp)
c002eb5d:	e8 5a 52 ff ff       	call   c0023dbc <free>
c002eb62:	83 c4 10             	add    $0x10,%esp
      return NULL; 
c002eb65:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
c002eb6a:	c9                   	leave  
c002eb6b:	c3                   	ret    

c002eb6c <dir_open_root>:

/* Opens the root directory and returns a directory for it.
   Return true if successful, false on failure. */
struct dir *
dir_open_root (void)
{
c002eb6c:	55                   	push   %ebp
c002eb6d:	89 e5                	mov    %esp,%ebp
c002eb6f:	83 ec 08             	sub    $0x8,%esp
  return dir_open (inode_open (ROOT_DIR_SECTOR));
c002eb72:	83 ec 0c             	sub    $0xc,%esp
c002eb75:	6a 01                	push   $0x1
c002eb77:	e8 a8 05 00 00       	call   c002f124 <inode_open>
c002eb7c:	83 c4 10             	add    $0x10,%esp
c002eb7f:	83 ec 0c             	sub    $0xc,%esp
c002eb82:	50                   	push   %eax
c002eb83:	e8 86 ff ff ff       	call   c002eb0e <dir_open>
c002eb88:	83 c4 10             	add    $0x10,%esp
}
c002eb8b:	c9                   	leave  
c002eb8c:	c3                   	ret    

c002eb8d <dir_reopen>:

/* Opens and returns a new directory for the same inode as DIR.
   Returns a null pointer on failure. */
struct dir *
dir_reopen (struct dir *dir) 
{
c002eb8d:	55                   	push   %ebp
c002eb8e:	89 e5                	mov    %esp,%ebp
c002eb90:	83 ec 08             	sub    $0x8,%esp
  return dir_open (inode_reopen (dir->inode));
c002eb93:	8b 45 08             	mov    0x8(%ebp),%eax
c002eb96:	8b 00                	mov    (%eax),%eax
c002eb98:	83 ec 0c             	sub    $0xc,%esp
c002eb9b:	50                   	push   %eax
c002eb9c:	e8 6d 06 00 00       	call   c002f20e <inode_reopen>
c002eba1:	83 c4 10             	add    $0x10,%esp
c002eba4:	83 ec 0c             	sub    $0xc,%esp
c002eba7:	50                   	push   %eax
c002eba8:	e8 61 ff ff ff       	call   c002eb0e <dir_open>
c002ebad:	83 c4 10             	add    $0x10,%esp
}
c002ebb0:	c9                   	leave  
c002ebb1:	c3                   	ret    

c002ebb2 <dir_close>:

/* Destroys DIR and frees associated resources. */
void
dir_close (struct dir *dir) 
{
c002ebb2:	55                   	push   %ebp
c002ebb3:	89 e5                	mov    %esp,%ebp
c002ebb5:	83 ec 08             	sub    $0x8,%esp
  if (dir != NULL)
c002ebb8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ebbc:	74 1f                	je     c002ebdd <dir_close+0x2b>
    {
      inode_close (dir->inode);
c002ebbe:	8b 45 08             	mov    0x8(%ebp),%eax
c002ebc1:	8b 00                	mov    (%eax),%eax
c002ebc3:	83 ec 0c             	sub    $0xc,%esp
c002ebc6:	50                   	push   %eax
c002ebc7:	e8 6a 06 00 00       	call   c002f236 <inode_close>
c002ebcc:	83 c4 10             	add    $0x10,%esp
      free (dir);
c002ebcf:	83 ec 0c             	sub    $0xc,%esp
c002ebd2:	ff 75 08             	pushl  0x8(%ebp)
c002ebd5:	e8 e2 51 ff ff       	call   c0023dbc <free>
c002ebda:	83 c4 10             	add    $0x10,%esp
    }
}
c002ebdd:	90                   	nop
c002ebde:	c9                   	leave  
c002ebdf:	c3                   	ret    

c002ebe0 <dir_get_inode>:

/* Returns the inode encapsulated by DIR. */
struct inode *
dir_get_inode (struct dir *dir) 
{
c002ebe0:	55                   	push   %ebp
c002ebe1:	89 e5                	mov    %esp,%ebp
  return dir->inode;
c002ebe3:	8b 45 08             	mov    0x8(%ebp),%eax
c002ebe6:	8b 00                	mov    (%eax),%eax
}
c002ebe8:	5d                   	pop    %ebp
c002ebe9:	c3                   	ret    

c002ebea <lookup>:
   directory entry if OFSP is non-null.
   otherwise, returns false and ignores EP and OFSP. */
static bool
lookup (const struct dir *dir, const char *name,
        struct dir_entry *ep, off_t *ofsp) 
{
c002ebea:	55                   	push   %ebp
c002ebeb:	89 e5                	mov    %esp,%ebp
c002ebed:	57                   	push   %edi
c002ebee:	56                   	push   %esi
c002ebef:	53                   	push   %ebx
c002ebf0:	83 ec 2c             	sub    $0x2c,%esp
  struct dir_entry e;
  size_t ofs;
  
  ASSERT (dir != NULL);
c002ebf3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ebf7:	75 1e                	jne    c002ec17 <lookup+0x2d>
c002ebf9:	83 ec 0c             	sub    $0xc,%esp
c002ebfc:	68 fc 36 03 c0       	push   $0xc00336fc
c002ec01:	68 08 37 03 c0       	push   $0xc0033708
c002ec06:	68 48 37 03 c0       	push   $0xc0033748
c002ec0b:	6a 62                	push   $0x62
c002ec0d:	68 1f 37 03 c0       	push   $0xc003371f
c002ec12:	e8 86 af ff ff       	call   c0029b9d <debug_panic>
  ASSERT (name != NULL);
c002ec17:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ec1b:	75 1e                	jne    c002ec3b <lookup+0x51>
c002ec1d:	83 ec 0c             	sub    $0xc,%esp
c002ec20:	68 39 37 03 c0       	push   $0xc0033739
c002ec25:	68 08 37 03 c0       	push   $0xc0033708
c002ec2a:	68 48 37 03 c0       	push   $0xc0033748
c002ec2f:	6a 63                	push   $0x63
c002ec31:	68 1f 37 03 c0       	push   $0xc003371f
c002ec36:	e8 62 af ff ff       	call   c0029b9d <debug_panic>

  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002ec3b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c002ec42:	eb 51                	jmp    c002ec95 <lookup+0xab>
       ofs += sizeof e) 
    if (e.in_use && !strcmp (name, e.name)) 
c002ec44:	8a 45 e3             	mov    -0x1d(%ebp),%al
c002ec47:	84 c0                	test   %al,%al
c002ec49:	74 46                	je     c002ec91 <lookup+0xa7>
c002ec4b:	83 ec 08             	sub    $0x8,%esp
c002ec4e:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002ec51:	83 c0 04             	add    $0x4,%eax
c002ec54:	50                   	push   %eax
c002ec55:	ff 75 0c             	pushl  0xc(%ebp)
c002ec58:	e8 7d 9f ff ff       	call   c0028bda <strcmp>
c002ec5d:	83 c4 10             	add    $0x10,%esp
c002ec60:	85 c0                	test   %eax,%eax
c002ec62:	75 2d                	jne    c002ec91 <lookup+0xa7>
      {
        if (ep != NULL)
c002ec64:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002ec68:	74 15                	je     c002ec7f <lookup+0x95>
          *ep = e;
c002ec6a:	8b 45 10             	mov    0x10(%ebp),%eax
c002ec6d:	89 c3                	mov    %eax,%ebx
c002ec6f:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002ec72:	ba 05 00 00 00       	mov    $0x5,%edx
c002ec77:	89 df                	mov    %ebx,%edi
c002ec79:	89 c6                	mov    %eax,%esi
c002ec7b:	89 d1                	mov    %edx,%ecx
c002ec7d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        if (ofsp != NULL)
c002ec7f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002ec83:	74 08                	je     c002ec8d <lookup+0xa3>
          *ofsp = ofs;
c002ec85:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002ec88:	8b 45 14             	mov    0x14(%ebp),%eax
c002ec8b:	89 10                	mov    %edx,(%eax)
        return true;
c002ec8d:	b0 01                	mov    $0x1,%al
c002ec8f:	eb 23                	jmp    c002ecb4 <lookup+0xca>
       ofs += sizeof e) 
c002ec91:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002ec95:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002ec98:	8b 45 08             	mov    0x8(%ebp),%eax
c002ec9b:	8b 00                	mov    (%eax),%eax
c002ec9d:	52                   	push   %edx
c002ec9e:	6a 14                	push   $0x14
c002eca0:	8d 55 d0             	lea    -0x30(%ebp),%edx
c002eca3:	52                   	push   %edx
c002eca4:	50                   	push   %eax
c002eca5:	e8 4f 06 00 00       	call   c002f2f9 <inode_read_at>
c002ecaa:	83 c4 10             	add    $0x10,%esp
c002ecad:	83 f8 14             	cmp    $0x14,%eax
c002ecb0:	74 92                	je     c002ec44 <lookup+0x5a>
      }
  return false;
c002ecb2:	b0 00                	mov    $0x0,%al
}
c002ecb4:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002ecb7:	5b                   	pop    %ebx
c002ecb8:	5e                   	pop    %esi
c002ecb9:	5f                   	pop    %edi
c002ecba:	5d                   	pop    %ebp
c002ecbb:	c3                   	ret    

c002ecbc <dir_lookup>:
   On success, sets *INODE to an inode for the file, otherwise to
   a null pointer.  The caller must close *INODE. */
bool
dir_lookup (const struct dir *dir, const char *name,
            struct inode **inode) 
{
c002ecbc:	55                   	push   %ebp
c002ecbd:	89 e5                	mov    %esp,%ebp
c002ecbf:	83 ec 28             	sub    $0x28,%esp
  struct dir_entry e;

  ASSERT (dir != NULL);
c002ecc2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ecc6:	75 1e                	jne    c002ece6 <dir_lookup+0x2a>
c002ecc8:	83 ec 0c             	sub    $0xc,%esp
c002eccb:	68 fc 36 03 c0       	push   $0xc00336fc
c002ecd0:	68 08 37 03 c0       	push   $0xc0033708
c002ecd5:	68 50 37 03 c0       	push   $0xc0033750
c002ecda:	6a 7c                	push   $0x7c
c002ecdc:	68 1f 37 03 c0       	push   $0xc003371f
c002ece1:	e8 b7 ae ff ff       	call   c0029b9d <debug_panic>
  ASSERT (name != NULL);
c002ece6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ecea:	75 1e                	jne    c002ed0a <dir_lookup+0x4e>
c002ecec:	83 ec 0c             	sub    $0xc,%esp
c002ecef:	68 39 37 03 c0       	push   $0xc0033739
c002ecf4:	68 08 37 03 c0       	push   $0xc0033708
c002ecf9:	68 50 37 03 c0       	push   $0xc0033750
c002ecfe:	6a 7d                	push   $0x7d
c002ed00:	68 1f 37 03 c0       	push   $0xc003371f
c002ed05:	e8 93 ae ff ff       	call   c0029b9d <debug_panic>

  if (lookup (dir, name, &e, NULL))
c002ed0a:	6a 00                	push   $0x0
c002ed0c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002ed0f:	50                   	push   %eax
c002ed10:	ff 75 0c             	pushl  0xc(%ebp)
c002ed13:	ff 75 08             	pushl  0x8(%ebp)
c002ed16:	e8 cf fe ff ff       	call   c002ebea <lookup>
c002ed1b:	83 c4 10             	add    $0x10,%esp
c002ed1e:	84 c0                	test   %al,%al
c002ed20:	74 18                	je     c002ed3a <dir_lookup+0x7e>
    *inode = inode_open (e.inode_sector);
c002ed22:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002ed25:	83 ec 0c             	sub    $0xc,%esp
c002ed28:	50                   	push   %eax
c002ed29:	e8 f6 03 00 00       	call   c002f124 <inode_open>
c002ed2e:	83 c4 10             	add    $0x10,%esp
c002ed31:	89 c2                	mov    %eax,%edx
c002ed33:	8b 45 10             	mov    0x10(%ebp),%eax
c002ed36:	89 10                	mov    %edx,(%eax)
c002ed38:	eb 09                	jmp    c002ed43 <dir_lookup+0x87>
  else
    *inode = NULL;
c002ed3a:	8b 45 10             	mov    0x10(%ebp),%eax
c002ed3d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

  return *inode != NULL;
c002ed43:	8b 45 10             	mov    0x10(%ebp),%eax
c002ed46:	8b 00                	mov    (%eax),%eax
c002ed48:	85 c0                	test   %eax,%eax
c002ed4a:	0f 95 c0             	setne  %al
}
c002ed4d:	c9                   	leave  
c002ed4e:	c3                   	ret    

c002ed4f <dir_add>:
   Returns true if successful, false on failure.
   Fails if NAME is invalid (i.e. too long) or a disk or memory
   error occurs. */
bool
dir_add (struct dir *dir, const char *name, block_sector_t inode_sector)
{
c002ed4f:	55                   	push   %ebp
c002ed50:	89 e5                	mov    %esp,%ebp
c002ed52:	83 ec 28             	sub    $0x28,%esp
  struct dir_entry e;
  off_t ofs;
  bool success = false;
c002ed55:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)

  ASSERT (dir != NULL);
c002ed59:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ed5d:	75 21                	jne    c002ed80 <dir_add+0x31>
c002ed5f:	83 ec 0c             	sub    $0xc,%esp
c002ed62:	68 fc 36 03 c0       	push   $0xc00336fc
c002ed67:	68 08 37 03 c0       	push   $0xc0033708
c002ed6c:	68 5c 37 03 c0       	push   $0xc003375c
c002ed71:	68 94 00 00 00       	push   $0x94
c002ed76:	68 1f 37 03 c0       	push   $0xc003371f
c002ed7b:	e8 1d ae ff ff       	call   c0029b9d <debug_panic>
  ASSERT (name != NULL);
c002ed80:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ed84:	75 21                	jne    c002eda7 <dir_add+0x58>
c002ed86:	83 ec 0c             	sub    $0xc,%esp
c002ed89:	68 39 37 03 c0       	push   $0xc0033739
c002ed8e:	68 08 37 03 c0       	push   $0xc0033708
c002ed93:	68 5c 37 03 c0       	push   $0xc003375c
c002ed98:	68 95 00 00 00       	push   $0x95
c002ed9d:	68 1f 37 03 c0       	push   $0xc003371f
c002eda2:	e8 f6 ad ff ff       	call   c0029b9d <debug_panic>

  /* Check NAME for validity. */
  if (*name == '\0' || strlen (name) > NAME_MAX)
c002eda7:	8b 45 0c             	mov    0xc(%ebp),%eax
c002edaa:	8a 00                	mov    (%eax),%al
c002edac:	84 c0                	test   %al,%al
c002edae:	74 13                	je     c002edc3 <dir_add+0x74>
c002edb0:	83 ec 0c             	sub    $0xc,%esp
c002edb3:	ff 75 0c             	pushl  0xc(%ebp)
c002edb6:	e8 55 a2 ff ff       	call   c0029010 <strlen>
c002edbb:	83 c4 10             	add    $0x10,%esp
c002edbe:	83 f8 0e             	cmp    $0xe,%eax
c002edc1:	76 07                	jbe    c002edca <dir_add+0x7b>
    return false;
c002edc3:	b0 00                	mov    $0x0,%al
c002edc5:	e9 98 00 00 00       	jmp    c002ee62 <dir_add+0x113>

  /* Check that NAME is not in use. */
  if (lookup (dir, name, NULL, NULL))
c002edca:	6a 00                	push   $0x0
c002edcc:	6a 00                	push   $0x0
c002edce:	ff 75 0c             	pushl  0xc(%ebp)
c002edd1:	ff 75 08             	pushl  0x8(%ebp)
c002edd4:	e8 11 fe ff ff       	call   c002ebea <lookup>
c002edd9:	83 c4 10             	add    $0x10,%esp
c002eddc:	84 c0                	test   %al,%al
c002edde:	75 7e                	jne    c002ee5e <dir_add+0x10f>
     current end-of-file.
     
     inode_read_at() will only return a short read at end of file.
     Otherwise, we'd need to verify that we didn't get a short
     read due to something intermittent such as low memory. */
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002ede0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ede7:	eb 13                	jmp    c002edfc <dir_add+0xad>
       ofs += sizeof e) 
    if (!e.in_use)
c002ede9:	8a 45 ef             	mov    -0x11(%ebp),%al
c002edec:	83 f0 01             	xor    $0x1,%eax
c002edef:	84 c0                	test   %al,%al
c002edf1:	75 27                	jne    c002ee1a <dir_add+0xcb>
       ofs += sizeof e) 
c002edf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002edf6:	83 c0 14             	add    $0x14,%eax
c002edf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002edfc:	8b 45 08             	mov    0x8(%ebp),%eax
c002edff:	8b 00                	mov    (%eax),%eax
c002ee01:	ff 75 f4             	pushl  -0xc(%ebp)
c002ee04:	6a 14                	push   $0x14
c002ee06:	8d 55 dc             	lea    -0x24(%ebp),%edx
c002ee09:	52                   	push   %edx
c002ee0a:	50                   	push   %eax
c002ee0b:	e8 e9 04 00 00       	call   c002f2f9 <inode_read_at>
c002ee10:	83 c4 10             	add    $0x10,%esp
c002ee13:	83 f8 14             	cmp    $0x14,%eax
c002ee16:	74 d1                	je     c002ede9 <dir_add+0x9a>
c002ee18:	eb 01                	jmp    c002ee1b <dir_add+0xcc>
      break;
c002ee1a:	90                   	nop

  /* Write slot. */
  e.in_use = true;
c002ee1b:	c6 45 ef 01          	movb   $0x1,-0x11(%ebp)
  strlcpy (e.name, name, sizeof e.name);
c002ee1f:	83 ec 04             	sub    $0x4,%esp
c002ee22:	6a 0f                	push   $0xf
c002ee24:	ff 75 0c             	pushl  0xc(%ebp)
c002ee27:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002ee2a:	83 c0 04             	add    $0x4,%eax
c002ee2d:	50                   	push   %eax
c002ee2e:	e8 57 a2 ff ff       	call   c002908a <strlcpy>
c002ee33:	83 c4 10             	add    $0x10,%esp
  e.inode_sector = inode_sector;
c002ee36:	8b 45 10             	mov    0x10(%ebp),%eax
c002ee39:	89 45 dc             	mov    %eax,-0x24(%ebp)
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002ee3c:	8b 45 08             	mov    0x8(%ebp),%eax
c002ee3f:	8b 00                	mov    (%eax),%eax
c002ee41:	ff 75 f4             	pushl  -0xc(%ebp)
c002ee44:	6a 14                	push   $0x14
c002ee46:	8d 55 dc             	lea    -0x24(%ebp),%edx
c002ee49:	52                   	push   %edx
c002ee4a:	50                   	push   %eax
c002ee4b:	e8 f7 05 00 00       	call   c002f447 <inode_write_at>
c002ee50:	83 c4 10             	add    $0x10,%esp
c002ee53:	83 f8 14             	cmp    $0x14,%eax
c002ee56:	0f 94 c0             	sete   %al
c002ee59:	88 45 f3             	mov    %al,-0xd(%ebp)
c002ee5c:	eb 01                	jmp    c002ee5f <dir_add+0x110>
    goto done;
c002ee5e:	90                   	nop

 done:
  return success;
c002ee5f:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c002ee62:	c9                   	leave  
c002ee63:	c3                   	ret    

c002ee64 <dir_remove>:
/* Removes any entry for NAME in DIR.
   Returns true if successful, false on failure,
   which occurs only if there is no file with the given NAME. */
bool
dir_remove (struct dir *dir, const char *name) 
{
c002ee64:	55                   	push   %ebp
c002ee65:	89 e5                	mov    %esp,%ebp
c002ee67:	83 ec 28             	sub    $0x28,%esp
  struct dir_entry e;
  struct inode *inode = NULL;
c002ee6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  bool success = false;
c002ee71:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  off_t ofs;

  ASSERT (dir != NULL);
c002ee75:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ee79:	75 21                	jne    c002ee9c <dir_remove+0x38>
c002ee7b:	83 ec 0c             	sub    $0xc,%esp
c002ee7e:	68 fc 36 03 c0       	push   $0xc00336fc
c002ee83:	68 08 37 03 c0       	push   $0xc0033708
c002ee88:	68 64 37 03 c0       	push   $0xc0033764
c002ee8d:	68 c0 00 00 00       	push   $0xc0
c002ee92:	68 1f 37 03 c0       	push   $0xc003371f
c002ee97:	e8 01 ad ff ff       	call   c0029b9d <debug_panic>
  ASSERT (name != NULL);
c002ee9c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002eea0:	75 21                	jne    c002eec3 <dir_remove+0x5f>
c002eea2:	83 ec 0c             	sub    $0xc,%esp
c002eea5:	68 39 37 03 c0       	push   $0xc0033739
c002eeaa:	68 08 37 03 c0       	push   $0xc0033708
c002eeaf:	68 64 37 03 c0       	push   $0xc0033764
c002eeb4:	68 c1 00 00 00       	push   $0xc1
c002eeb9:	68 1f 37 03 c0       	push   $0xc003371f
c002eebe:	e8 da ac ff ff       	call   c0029b9d <debug_panic>

  /* Find directory entry. */
  if (!lookup (dir, name, &e, &ofs))
c002eec3:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002eec6:	50                   	push   %eax
c002eec7:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002eeca:	50                   	push   %eax
c002eecb:	ff 75 0c             	pushl  0xc(%ebp)
c002eece:	ff 75 08             	pushl  0x8(%ebp)
c002eed1:	e8 14 fd ff ff       	call   c002ebea <lookup>
c002eed6:	83 c4 10             	add    $0x10,%esp
c002eed9:	83 f0 01             	xor    $0x1,%eax
c002eedc:	84 c0                	test   %al,%al
c002eede:	75 4d                	jne    c002ef2d <dir_remove+0xc9>
    goto done;

  /* Open inode. */
  inode = inode_open (e.inode_sector);
c002eee0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002eee3:	83 ec 0c             	sub    $0xc,%esp
c002eee6:	50                   	push   %eax
c002eee7:	e8 38 02 00 00       	call   c002f124 <inode_open>
c002eeec:	83 c4 10             	add    $0x10,%esp
c002eeef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (inode == NULL)
c002eef2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002eef6:	74 38                	je     c002ef30 <dir_remove+0xcc>
    goto done;

  /* Erase directory entry. */
  e.in_use = false;
c002eef8:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if (inode_write_at (dir->inode, &e, sizeof e, ofs) != sizeof e) 
c002eefc:	8b 55 d8             	mov    -0x28(%ebp),%edx
c002eeff:	8b 45 08             	mov    0x8(%ebp),%eax
c002ef02:	8b 00                	mov    (%eax),%eax
c002ef04:	52                   	push   %edx
c002ef05:	6a 14                	push   $0x14
c002ef07:	8d 55 dc             	lea    -0x24(%ebp),%edx
c002ef0a:	52                   	push   %edx
c002ef0b:	50                   	push   %eax
c002ef0c:	e8 36 05 00 00       	call   c002f447 <inode_write_at>
c002ef11:	83 c4 10             	add    $0x10,%esp
c002ef14:	83 f8 14             	cmp    $0x14,%eax
c002ef17:	75 1a                	jne    c002ef33 <dir_remove+0xcf>
    goto done;

  /* Remove inode. */
  inode_remove (inode);
c002ef19:	83 ec 0c             	sub    $0xc,%esp
c002ef1c:	ff 75 f4             	pushl  -0xc(%ebp)
c002ef1f:	e8 9e 03 00 00       	call   c002f2c2 <inode_remove>
c002ef24:	83 c4 10             	add    $0x10,%esp
  success = true;
c002ef27:	c6 45 f3 01          	movb   $0x1,-0xd(%ebp)
c002ef2b:	eb 07                	jmp    c002ef34 <dir_remove+0xd0>
    goto done;
c002ef2d:	90                   	nop
c002ef2e:	eb 04                	jmp    c002ef34 <dir_remove+0xd0>
    goto done;
c002ef30:	90                   	nop
c002ef31:	eb 01                	jmp    c002ef34 <dir_remove+0xd0>
    goto done;
c002ef33:	90                   	nop

 done:
  inode_close (inode);
c002ef34:	83 ec 0c             	sub    $0xc,%esp
c002ef37:	ff 75 f4             	pushl  -0xc(%ebp)
c002ef3a:	e8 f7 02 00 00       	call   c002f236 <inode_close>
c002ef3f:	83 c4 10             	add    $0x10,%esp
  return success;
c002ef42:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c002ef45:	c9                   	leave  
c002ef46:	c3                   	ret    

c002ef47 <dir_readdir>:
/* Reads the next directory entry in DIR and stores the name in
   NAME.  Returns true if successful, false if the directory
   contains no more entries. */
bool
dir_readdir (struct dir *dir, char name[NAME_MAX + 1])
{
c002ef47:	55                   	push   %ebp
c002ef48:	89 e5                	mov    %esp,%ebp
c002ef4a:	83 ec 28             	sub    $0x28,%esp
  struct dir_entry e;

  while (inode_read_at (dir->inode, &e, sizeof e, dir->pos) == sizeof e) 
c002ef4d:	eb 33                	jmp    c002ef82 <dir_readdir+0x3b>
    {
      dir->pos += sizeof e;
c002ef4f:	8b 45 08             	mov    0x8(%ebp),%eax
c002ef52:	8b 40 04             	mov    0x4(%eax),%eax
c002ef55:	83 c0 14             	add    $0x14,%eax
c002ef58:	89 c2                	mov    %eax,%edx
c002ef5a:	8b 45 08             	mov    0x8(%ebp),%eax
c002ef5d:	89 50 04             	mov    %edx,0x4(%eax)
      if (e.in_use)
c002ef60:	8a 45 f7             	mov    -0x9(%ebp),%al
c002ef63:	84 c0                	test   %al,%al
c002ef65:	74 1b                	je     c002ef82 <dir_readdir+0x3b>
        {
          strlcpy (name, e.name, NAME_MAX + 1);
c002ef67:	83 ec 04             	sub    $0x4,%esp
c002ef6a:	6a 0f                	push   $0xf
c002ef6c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002ef6f:	83 c0 04             	add    $0x4,%eax
c002ef72:	50                   	push   %eax
c002ef73:	ff 75 0c             	pushl  0xc(%ebp)
c002ef76:	e8 0f a1 ff ff       	call   c002908a <strlcpy>
c002ef7b:	83 c4 10             	add    $0x10,%esp
          return true;
c002ef7e:	b0 01                	mov    $0x1,%al
c002ef80:	eb 22                	jmp    c002efa4 <dir_readdir+0x5d>
  while (inode_read_at (dir->inode, &e, sizeof e, dir->pos) == sizeof e) 
c002ef82:	8b 45 08             	mov    0x8(%ebp),%eax
c002ef85:	8b 50 04             	mov    0x4(%eax),%edx
c002ef88:	8b 45 08             	mov    0x8(%ebp),%eax
c002ef8b:	8b 00                	mov    (%eax),%eax
c002ef8d:	52                   	push   %edx
c002ef8e:	6a 14                	push   $0x14
c002ef90:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c002ef93:	52                   	push   %edx
c002ef94:	50                   	push   %eax
c002ef95:	e8 5f 03 00 00       	call   c002f2f9 <inode_read_at>
c002ef9a:	83 c4 10             	add    $0x10,%esp
c002ef9d:	83 f8 14             	cmp    $0x14,%eax
c002efa0:	74 ad                	je     c002ef4f <dir_readdir+0x8>
        } 
    }
  return false;
c002efa2:	b0 00                	mov    $0x0,%al
}
c002efa4:	c9                   	leave  
c002efa5:	c3                   	ret    

c002efa6 <bytes_to_sectors>:

/* Returns the number of sectors to allocate for an inode SIZE
   bytes long. */
static inline size_t
bytes_to_sectors (off_t size)
{
c002efa6:	55                   	push   %ebp
c002efa7:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (size, BLOCK_SECTOR_SIZE);
c002efa9:	8b 45 08             	mov    0x8(%ebp),%eax
c002efac:	05 ff 01 00 00       	add    $0x1ff,%eax
c002efb1:	85 c0                	test   %eax,%eax
c002efb3:	79 05                	jns    c002efba <bytes_to_sectors+0x14>
c002efb5:	05 ff 01 00 00       	add    $0x1ff,%eax
c002efba:	c1 f8 09             	sar    $0x9,%eax
}
c002efbd:	5d                   	pop    %ebp
c002efbe:	c3                   	ret    

c002efbf <byte_to_sector>:
   within INODE.
   Returns -1 if INODE does not contain data for a byte at offset
   POS. */
static block_sector_t
byte_to_sector (const struct inode *inode, off_t pos) 
{
c002efbf:	55                   	push   %ebp
c002efc0:	89 e5                	mov    %esp,%ebp
c002efc2:	83 ec 08             	sub    $0x8,%esp
  ASSERT (inode != NULL);
c002efc5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002efc9:	75 1e                	jne    c002efe9 <byte_to_sector+0x2a>
c002efcb:	83 ec 0c             	sub    $0xc,%esp
c002efce:	68 70 37 03 c0       	push   $0xc0033770
c002efd3:	68 7e 37 03 c0       	push   $0xc003377e
c002efd8:	68 fc 37 03 c0       	push   $0xc00337fc
c002efdd:	6a 31                	push   $0x31
c002efdf:	68 95 37 03 c0       	push   $0xc0033795
c002efe4:	e8 b4 ab ff ff       	call   c0029b9d <debug_panic>
  if (pos < inode->data.length)
c002efe9:	8b 45 08             	mov    0x8(%ebp),%eax
c002efec:	8b 40 1c             	mov    0x1c(%eax),%eax
c002efef:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002eff2:	7e 19                	jle    c002f00d <byte_to_sector+0x4e>
    return inode->data.start + pos / BLOCK_SECTOR_SIZE;
c002eff4:	8b 45 08             	mov    0x8(%ebp),%eax
c002eff7:	8b 50 18             	mov    0x18(%eax),%edx
c002effa:	8b 45 0c             	mov    0xc(%ebp),%eax
c002effd:	85 c0                	test   %eax,%eax
c002efff:	79 05                	jns    c002f006 <byte_to_sector+0x47>
c002f001:	05 ff 01 00 00       	add    $0x1ff,%eax
c002f006:	c1 f8 09             	sar    $0x9,%eax
c002f009:	01 d0                	add    %edx,%eax
c002f00b:	eb 05                	jmp    c002f012 <byte_to_sector+0x53>
  else
    return -1;
c002f00d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002f012:	c9                   	leave  
c002f013:	c3                   	ret    

c002f014 <inode_init>:
static struct list open_inodes;

/* Initializes the inode module. */
void
inode_init (void) 
{
c002f014:	55                   	push   %ebp
c002f015:	89 e5                	mov    %esp,%ebp
c002f017:	83 ec 08             	sub    $0x8,%esp
  list_init (&open_inodes);
c002f01a:	83 ec 0c             	sub    $0xc,%esp
c002f01d:	68 a0 a6 03 c0       	push   $0xc003a6a0
c002f022:	e8 e7 ad ff ff       	call   c0029e0e <list_init>
c002f027:	83 c4 10             	add    $0x10,%esp
}
c002f02a:	90                   	nop
c002f02b:	c9                   	leave  
c002f02c:	c3                   	ret    

c002f02d <inode_create>:
   device.
   Returns true if successful.
   Returns false if memory or disk allocation fails. */
bool
inode_create (block_sector_t sector, off_t length)
{
c002f02d:	55                   	push   %ebp
c002f02e:	89 e5                	mov    %esp,%ebp
c002f030:	83 ec 18             	sub    $0x18,%esp
  struct inode_disk *disk_inode = NULL;
c002f033:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  bool success = false;
c002f03a:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (length >= 0);
c002f03e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002f042:	79 1e                	jns    c002f062 <inode_create+0x35>
c002f044:	83 ec 0c             	sub    $0xc,%esp
c002f047:	68 ab 37 03 c0       	push   $0xc00337ab
c002f04c:	68 7e 37 03 c0       	push   $0xc003377e
c002f051:	68 0c 38 03 c0       	push   $0xc003380c
c002f056:	6a 4e                	push   $0x4e
c002f058:	68 95 37 03 c0       	push   $0xc0033795
c002f05d:	e8 3b ab ff ff       	call   c0029b9d <debug_panic>

  /* If this assertion fails, the inode structure is not exactly
     one sector in size, and you should fix that. */
  ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);

  disk_inode = calloc (1, sizeof *disk_inode);
c002f062:	83 ec 08             	sub    $0x8,%esp
c002f065:	68 00 02 00 00       	push   $0x200
c002f06a:	6a 01                	push   $0x1
c002f06c:	e8 1a 4c ff ff       	call   c0023c8b <calloc>
c002f071:	83 c4 10             	add    $0x10,%esp
c002f074:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (disk_inode != NULL)
c002f077:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002f07b:	0f 84 9e 00 00 00    	je     c002f11f <inode_create+0xf2>
    {
      size_t sectors = bytes_to_sectors (length);
c002f081:	83 ec 0c             	sub    $0xc,%esp
c002f084:	ff 75 0c             	pushl  0xc(%ebp)
c002f087:	e8 1a ff ff ff       	call   c002efa6 <bytes_to_sectors>
c002f08c:	83 c4 10             	add    $0x10,%esp
c002f08f:	89 45 e8             	mov    %eax,-0x18(%ebp)
      disk_inode->length = length;
c002f092:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002f095:	8b 55 0c             	mov    0xc(%ebp),%edx
c002f098:	89 50 04             	mov    %edx,0x4(%eax)
      disk_inode->magic = INODE_MAGIC;
c002f09b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002f09e:	c7 40 08 44 4f 4e 49 	movl   $0x494e4f44,0x8(%eax)
      if (free_map_allocate (sectors, &disk_inode->start)) 
c002f0a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002f0a8:	83 ec 08             	sub    $0x8,%esp
c002f0ab:	50                   	push   %eax
c002f0ac:	ff 75 e8             	pushl  -0x18(%ebp)
c002f0af:	e8 ff f4 ff ff       	call   c002e5b3 <free_map_allocate>
c002f0b4:	83 c4 10             	add    $0x10,%esp
c002f0b7:	84 c0                	test   %al,%al
c002f0b9:	74 56                	je     c002f111 <inode_create+0xe4>
        {
          block_write (fs_device, sector, disk_inode);
c002f0bb:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002f0c0:	83 ec 04             	sub    $0x4,%esp
c002f0c3:	ff 75 ec             	pushl  -0x14(%ebp)
c002f0c6:	ff 75 08             	pushl  0x8(%ebp)
c002f0c9:	50                   	push   %eax
c002f0ca:	e8 9c 64 ff ff       	call   c002556b <block_write>
c002f0cf:	83 c4 10             	add    $0x10,%esp
          if (sectors > 0) 
c002f0d2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002f0d6:	74 35                	je     c002f10d <inode_create+0xe0>
            {
              static char zeros[BLOCK_SECTOR_SIZE];
              size_t i;
              
              for (i = 0; i < sectors; i++) 
c002f0d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002f0df:	eb 24                	jmp    c002f105 <inode_create+0xd8>
                block_write (fs_device, disk_inode->start + i, zeros);
c002f0e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002f0e4:	8b 10                	mov    (%eax),%edx
c002f0e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f0e9:	01 c2                	add    %eax,%edx
c002f0eb:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002f0f0:	83 ec 04             	sub    $0x4,%esp
c002f0f3:	68 c0 a6 03 c0       	push   $0xc003a6c0
c002f0f8:	52                   	push   %edx
c002f0f9:	50                   	push   %eax
c002f0fa:	e8 6c 64 ff ff       	call   c002556b <block_write>
c002f0ff:	83 c4 10             	add    $0x10,%esp
              for (i = 0; i < sectors; i++) 
c002f102:	ff 45 f0             	incl   -0x10(%ebp)
c002f105:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f108:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002f10b:	72 d4                	jb     c002f0e1 <inode_create+0xb4>
            }
          success = true; 
c002f10d:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
        } 
      free (disk_inode);
c002f111:	83 ec 0c             	sub    $0xc,%esp
c002f114:	ff 75 ec             	pushl  -0x14(%ebp)
c002f117:	e8 a0 4c ff ff       	call   c0023dbc <free>
c002f11c:	83 c4 10             	add    $0x10,%esp
    }
  return success;
c002f11f:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c002f122:	c9                   	leave  
c002f123:	c3                   	ret    

c002f124 <inode_open>:
/* Reads an inode from SECTOR
   and returns a `struct inode' that contains it.
   Returns a null pointer if memory allocation fails. */
struct inode *
inode_open (block_sector_t sector)
{
c002f124:	55                   	push   %ebp
c002f125:	89 e5                	mov    %esp,%ebp
c002f127:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  struct inode *inode;

  /* Check whether this inode is already open. */
  for (e = list_begin (&open_inodes); e != list_end (&open_inodes);
c002f12a:	83 ec 0c             	sub    $0xc,%esp
c002f12d:	68 a0 a6 03 c0       	push   $0xc003a6a0
c002f132:	e8 2c ad ff ff       	call   c0029e63 <list_begin>
c002f137:	83 c4 10             	add    $0x10,%esp
c002f13a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002f13d:	eb 3e                	jmp    c002f17d <inode_open+0x59>
       e = list_next (e)) 
    {
      inode = list_entry (e, struct inode, elem);
c002f13f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f142:	83 c0 04             	add    $0x4,%eax
c002f145:	83 e8 04             	sub    $0x4,%eax
c002f148:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (inode->sector == sector) 
c002f14b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f14e:	8b 40 08             	mov    0x8(%eax),%eax
c002f151:	3b 45 08             	cmp    0x8(%ebp),%eax
c002f154:	75 16                	jne    c002f16c <inode_open+0x48>
        {
          inode_reopen (inode);
c002f156:	83 ec 0c             	sub    $0xc,%esp
c002f159:	ff 75 f0             	pushl  -0x10(%ebp)
c002f15c:	e8 ad 00 00 00       	call   c002f20e <inode_reopen>
c002f161:	83 c4 10             	add    $0x10,%esp
          return inode; 
c002f164:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f167:	e9 a0 00 00 00       	jmp    c002f20c <inode_open+0xe8>
       e = list_next (e)) 
c002f16c:	83 ec 0c             	sub    $0xc,%esp
c002f16f:	ff 75 f4             	pushl  -0xc(%ebp)
c002f172:	e8 1e ad ff ff       	call   c0029e95 <list_next>
c002f177:	83 c4 10             	add    $0x10,%esp
c002f17a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&open_inodes); e != list_end (&open_inodes);
c002f17d:	83 ec 0c             	sub    $0xc,%esp
c002f180:	68 a0 a6 03 c0       	push   $0xc003a6a0
c002f185:	e8 55 ad ff ff       	call   c0029edf <list_end>
c002f18a:	83 c4 10             	add    $0x10,%esp
c002f18d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002f190:	75 ad                	jne    c002f13f <inode_open+0x1b>
        }
    }

  /* Allocate memory. */
  inode = malloc (sizeof *inode);
c002f192:	83 ec 0c             	sub    $0xc,%esp
c002f195:	68 18 02 00 00       	push   $0x218
c002f19a:	e8 1b 49 ff ff       	call   c0023aba <malloc>
c002f19f:	83 c4 10             	add    $0x10,%esp
c002f1a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (inode == NULL)
c002f1a5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002f1a9:	75 07                	jne    c002f1b2 <inode_open+0x8e>
    return NULL;
c002f1ab:	b8 00 00 00 00       	mov    $0x0,%eax
c002f1b0:	eb 5a                	jmp    c002f20c <inode_open+0xe8>

  /* Initialize. */
  list_push_front (&open_inodes, &inode->elem);
c002f1b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f1b5:	83 ec 08             	sub    $0x8,%esp
c002f1b8:	50                   	push   %eax
c002f1b9:	68 a0 a6 03 c0       	push   $0xc003a6a0
c002f1be:	e8 05 b0 ff ff       	call   c002a1c8 <list_push_front>
c002f1c3:	83 c4 10             	add    $0x10,%esp
  inode->sector = sector;
c002f1c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f1c9:	8b 55 08             	mov    0x8(%ebp),%edx
c002f1cc:	89 50 08             	mov    %edx,0x8(%eax)
  inode->open_cnt = 1;
c002f1cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f1d2:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
  inode->deny_write_cnt = 0;
c002f1d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f1dc:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  inode->removed = false;
c002f1e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f1e6:	c6 40 10 00          	movb   $0x0,0x10(%eax)
  block_read (fs_device, inode->sector, &inode->data);
c002f1ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f1ed:	8d 48 18             	lea    0x18(%eax),%ecx
c002f1f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002f1f3:	8b 50 08             	mov    0x8(%eax),%edx
c002f1f6:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002f1fb:	83 ec 04             	sub    $0x4,%esp
c002f1fe:	51                   	push   %ecx
c002f1ff:	52                   	push   %edx
c002f200:	50                   	push   %eax
c002f201:	e8 16 63 ff ff       	call   c002551c <block_read>
c002f206:	83 c4 10             	add    $0x10,%esp
  return inode;
c002f209:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002f20c:	c9                   	leave  
c002f20d:	c3                   	ret    

c002f20e <inode_reopen>:

/* Reopens and returns INODE. */
struct inode *
inode_reopen (struct inode *inode)
{
c002f20e:	55                   	push   %ebp
c002f20f:	89 e5                	mov    %esp,%ebp
  if (inode != NULL)
c002f211:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002f215:	74 0f                	je     c002f226 <inode_reopen+0x18>
    inode->open_cnt++;
c002f217:	8b 45 08             	mov    0x8(%ebp),%eax
c002f21a:	8b 40 0c             	mov    0xc(%eax),%eax
c002f21d:	8d 50 01             	lea    0x1(%eax),%edx
c002f220:	8b 45 08             	mov    0x8(%ebp),%eax
c002f223:	89 50 0c             	mov    %edx,0xc(%eax)
  return inode;
c002f226:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002f229:	5d                   	pop    %ebp
c002f22a:	c3                   	ret    

c002f22b <inode_get_inumber>:

/* Returns INODE's inode number. */
block_sector_t
inode_get_inumber (const struct inode *inode)
{
c002f22b:	55                   	push   %ebp
c002f22c:	89 e5                	mov    %esp,%ebp
  return inode->sector;
c002f22e:	8b 45 08             	mov    0x8(%ebp),%eax
c002f231:	8b 40 08             	mov    0x8(%eax),%eax
}
c002f234:	5d                   	pop    %ebp
c002f235:	c3                   	ret    

c002f236 <inode_close>:
/* Closes INODE and writes it to disk.
   If this was the last reference to INODE, frees its memory.
   If INODE was also a removed inode, frees its blocks. */
void
inode_close (struct inode *inode) 
{
c002f236:	55                   	push   %ebp
c002f237:	89 e5                	mov    %esp,%ebp
c002f239:	83 ec 08             	sub    $0x8,%esp
  /* Ignore null pointer. */
  if (inode == NULL)
c002f23c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002f240:	74 7d                	je     c002f2bf <inode_close+0x89>
    return;

  /* Release resources if this was the last opener. */
  if (--inode->open_cnt == 0)
c002f242:	8b 45 08             	mov    0x8(%ebp),%eax
c002f245:	8b 40 0c             	mov    0xc(%eax),%eax
c002f248:	8d 50 ff             	lea    -0x1(%eax),%edx
c002f24b:	8b 45 08             	mov    0x8(%ebp),%eax
c002f24e:	89 50 0c             	mov    %edx,0xc(%eax)
c002f251:	8b 45 08             	mov    0x8(%ebp),%eax
c002f254:	8b 40 0c             	mov    0xc(%eax),%eax
c002f257:	85 c0                	test   %eax,%eax
c002f259:	75 65                	jne    c002f2c0 <inode_close+0x8a>
    {
      /* Remove from inode list and release lock. */
      list_remove (&inode->elem);
c002f25b:	8b 45 08             	mov    0x8(%ebp),%eax
c002f25e:	83 ec 0c             	sub    $0xc,%esp
c002f261:	50                   	push   %eax
c002f262:	e8 ad af ff ff       	call   c002a214 <list_remove>
c002f267:	83 c4 10             	add    $0x10,%esp
 
      /* Deallocate blocks if removed. */
      if (inode->removed) 
c002f26a:	8b 45 08             	mov    0x8(%ebp),%eax
c002f26d:	8a 40 10             	mov    0x10(%eax),%al
c002f270:	84 c0                	test   %al,%al
c002f272:	74 3b                	je     c002f2af <inode_close+0x79>
        {
          free_map_release (inode->sector, 1);
c002f274:	8b 45 08             	mov    0x8(%ebp),%eax
c002f277:	8b 40 08             	mov    0x8(%eax),%eax
c002f27a:	83 ec 08             	sub    $0x8,%esp
c002f27d:	6a 01                	push   $0x1
c002f27f:	50                   	push   %eax
c002f280:	e8 ae f3 ff ff       	call   c002e633 <free_map_release>
c002f285:	83 c4 10             	add    $0x10,%esp
          free_map_release (inode->data.start,
c002f288:	8b 45 08             	mov    0x8(%ebp),%eax
c002f28b:	8b 40 1c             	mov    0x1c(%eax),%eax
c002f28e:	83 ec 0c             	sub    $0xc,%esp
c002f291:	50                   	push   %eax
c002f292:	e8 0f fd ff ff       	call   c002efa6 <bytes_to_sectors>
c002f297:	83 c4 10             	add    $0x10,%esp
c002f29a:	89 c2                	mov    %eax,%edx
c002f29c:	8b 45 08             	mov    0x8(%ebp),%eax
c002f29f:	8b 40 18             	mov    0x18(%eax),%eax
c002f2a2:	83 ec 08             	sub    $0x8,%esp
c002f2a5:	52                   	push   %edx
c002f2a6:	50                   	push   %eax
c002f2a7:	e8 87 f3 ff ff       	call   c002e633 <free_map_release>
c002f2ac:	83 c4 10             	add    $0x10,%esp
                            bytes_to_sectors (inode->data.length)); 
        }

      free (inode); 
c002f2af:	83 ec 0c             	sub    $0xc,%esp
c002f2b2:	ff 75 08             	pushl  0x8(%ebp)
c002f2b5:	e8 02 4b ff ff       	call   c0023dbc <free>
c002f2ba:	83 c4 10             	add    $0x10,%esp
c002f2bd:	eb 01                	jmp    c002f2c0 <inode_close+0x8a>
    return;
c002f2bf:	90                   	nop
    }
}
c002f2c0:	c9                   	leave  
c002f2c1:	c3                   	ret    

c002f2c2 <inode_remove>:

/* Marks INODE to be deleted when it is closed by the last caller who
   has it open. */
void
inode_remove (struct inode *inode) 
{
c002f2c2:	55                   	push   %ebp
c002f2c3:	89 e5                	mov    %esp,%ebp
c002f2c5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (inode != NULL);
c002f2c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002f2cc:	75 21                	jne    c002f2ef <inode_remove+0x2d>
c002f2ce:	83 ec 0c             	sub    $0xc,%esp
c002f2d1:	68 70 37 03 c0       	push   $0xc0033770
c002f2d6:	68 7e 37 03 c0       	push   $0xc003377e
c002f2db:	68 1c 38 03 c0       	push   $0xc003381c
c002f2e0:	68 c1 00 00 00       	push   $0xc1
c002f2e5:	68 95 37 03 c0       	push   $0xc0033795
c002f2ea:	e8 ae a8 ff ff       	call   c0029b9d <debug_panic>
  inode->removed = true;
c002f2ef:	8b 45 08             	mov    0x8(%ebp),%eax
c002f2f2:	c6 40 10 01          	movb   $0x1,0x10(%eax)
}
c002f2f6:	90                   	nop
c002f2f7:	c9                   	leave  
c002f2f8:	c3                   	ret    

c002f2f9 <inode_read_at>:
/* Reads SIZE bytes from INODE into BUFFER, starting at position OFFSET.
   Returns the number of bytes actually read, which may be less
   than SIZE if an error occurs or end of file is reached. */
off_t
inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset) 
{
c002f2f9:	55                   	push   %ebp
c002f2fa:	89 e5                	mov    %esp,%ebp
c002f2fc:	53                   	push   %ebx
c002f2fd:	83 ec 34             	sub    $0x34,%esp
  uint8_t *buffer = buffer_;
c002f300:	8b 45 0c             	mov    0xc(%ebp),%eax
c002f303:	89 45 ec             	mov    %eax,-0x14(%ebp)
  off_t bytes_read = 0;
c002f306:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  uint8_t *bounce = NULL;
c002f30d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  while (size > 0) 
c002f314:	e9 08 01 00 00       	jmp    c002f421 <inode_read_at+0x128>
    {
      /* Disk sector to read, starting byte offset within sector. */
      block_sector_t sector_idx = byte_to_sector (inode, offset);
c002f319:	83 ec 08             	sub    $0x8,%esp
c002f31c:	ff 75 14             	pushl  0x14(%ebp)
c002f31f:	ff 75 08             	pushl  0x8(%ebp)
c002f322:	e8 98 fc ff ff       	call   c002efbf <byte_to_sector>
c002f327:	83 c4 10             	add    $0x10,%esp
c002f32a:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002f32d:	8b 45 14             	mov    0x14(%ebp),%eax
c002f330:	25 ff 01 00 80       	and    $0x800001ff,%eax
c002f335:	85 c0                	test   %eax,%eax
c002f337:	79 07                	jns    c002f340 <inode_read_at+0x47>
c002f339:	48                   	dec    %eax
c002f33a:	0d 00 fe ff ff       	or     $0xfffffe00,%eax
c002f33f:	40                   	inc    %eax
c002f340:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /* Bytes left in inode, bytes left in sector, lesser of the two. */
      off_t inode_left = inode_length (inode) - offset;
c002f343:	83 ec 0c             	sub    $0xc,%esp
c002f346:	ff 75 08             	pushl  0x8(%ebp)
c002f349:	e8 5a 03 00 00       	call   c002f6a8 <inode_length>
c002f34e:	83 c4 10             	add    $0x10,%esp
c002f351:	2b 45 14             	sub    0x14(%ebp),%eax
c002f354:	89 45 e0             	mov    %eax,-0x20(%ebp)
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002f357:	b8 00 02 00 00       	mov    $0x200,%eax
c002f35c:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002f35f:	89 45 dc             	mov    %eax,-0x24(%ebp)
      int min_left = inode_left < sector_left ? inode_left : sector_left;
c002f362:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002f365:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f368:	39 d0                	cmp    %edx,%eax
c002f36a:	7e 02                	jle    c002f36e <inode_read_at+0x75>
c002f36c:	89 d0                	mov    %edx,%eax
c002f36e:	89 45 d8             	mov    %eax,-0x28(%ebp)

      /* Number of bytes to actually copy out of this sector. */
      int chunk_size = size < min_left ? size : min_left;
c002f371:	8b 55 10             	mov    0x10(%ebp),%edx
c002f374:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002f377:	39 d0                	cmp    %edx,%eax
c002f379:	7e 02                	jle    c002f37d <inode_read_at+0x84>
c002f37b:	89 d0                	mov    %edx,%eax
c002f37d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (chunk_size <= 0)
c002f380:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002f384:	0f 8e a3 00 00 00    	jle    c002f42d <inode_read_at+0x134>
        break;

      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002f38a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002f38e:	75 28                	jne    c002f3b8 <inode_read_at+0xbf>
c002f390:	81 7d d4 00 02 00 00 	cmpl   $0x200,-0x2c(%ebp)
c002f397:	75 1f                	jne    c002f3b8 <inode_read_at+0xbf>
        {
          /* Read full sector directly into caller's buffer. */
          block_read (fs_device, sector_idx, buffer + bytes_read);
c002f399:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002f39c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002f39f:	01 c2                	add    %eax,%edx
c002f3a1:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002f3a6:	83 ec 04             	sub    $0x4,%esp
c002f3a9:	52                   	push   %edx
c002f3aa:	ff 75 e8             	pushl  -0x18(%ebp)
c002f3ad:	50                   	push   %eax
c002f3ae:	e8 69 61 ff ff       	call   c002551c <block_read>
c002f3b3:	83 c4 10             	add    $0x10,%esp
c002f3b6:	eb 57                	jmp    c002f40f <inode_read_at+0x116>
        }
      else 
        {
          /* Read sector into bounce buffer, then partially copy
             into caller's buffer. */
          if (bounce == NULL) 
c002f3b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002f3bc:	75 19                	jne    c002f3d7 <inode_read_at+0xde>
            {
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002f3be:	83 ec 0c             	sub    $0xc,%esp
c002f3c1:	68 00 02 00 00       	push   $0x200
c002f3c6:	e8 ef 46 ff ff       	call   c0023aba <malloc>
c002f3cb:	83 c4 10             	add    $0x10,%esp
c002f3ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
              if (bounce == NULL)
c002f3d1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002f3d5:	74 59                	je     c002f430 <inode_read_at+0x137>
                break;
            }
          block_read (fs_device, sector_idx, bounce);
c002f3d7:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002f3dc:	83 ec 04             	sub    $0x4,%esp
c002f3df:	ff 75 f0             	pushl  -0x10(%ebp)
c002f3e2:	ff 75 e8             	pushl  -0x18(%ebp)
c002f3e5:	50                   	push   %eax
c002f3e6:	e8 31 61 ff ff       	call   c002551c <block_read>
c002f3eb:	83 c4 10             	add    $0x10,%esp
          memcpy (buffer + bytes_read, bounce + sector_ofs, chunk_size);
c002f3ee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f3f1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002f3f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002f3f7:	01 d1                	add    %edx,%ecx
c002f3f9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c002f3fc:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002f3ff:	01 da                	add    %ebx,%edx
c002f401:	83 ec 04             	sub    $0x4,%esp
c002f404:	50                   	push   %eax
c002f405:	51                   	push   %ecx
c002f406:	52                   	push   %edx
c002f407:	e8 d1 95 ff ff       	call   c00289dd <memcpy>
c002f40c:	83 c4 10             	add    $0x10,%esp
        }
      
      /* Advance. */
      size -= chunk_size;
c002f40f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f412:	29 45 10             	sub    %eax,0x10(%ebp)
      offset += chunk_size;
c002f415:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f418:	01 45 14             	add    %eax,0x14(%ebp)
      bytes_read += chunk_size;
c002f41b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f41e:	01 45 f4             	add    %eax,-0xc(%ebp)
  while (size > 0) 
c002f421:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002f425:	0f 8f ee fe ff ff    	jg     c002f319 <inode_read_at+0x20>
c002f42b:	eb 04                	jmp    c002f431 <inode_read_at+0x138>
        break;
c002f42d:	90                   	nop
c002f42e:	eb 01                	jmp    c002f431 <inode_read_at+0x138>
                break;
c002f430:	90                   	nop
    }
  free (bounce);
c002f431:	83 ec 0c             	sub    $0xc,%esp
c002f434:	ff 75 f0             	pushl  -0x10(%ebp)
c002f437:	e8 80 49 ff ff       	call   c0023dbc <free>
c002f43c:	83 c4 10             	add    $0x10,%esp

  return bytes_read;
c002f43f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002f442:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f445:	c9                   	leave  
c002f446:	c3                   	ret    

c002f447 <inode_write_at>:
   (Normally a write at end of file would extend the inode, but
   growth is not yet implemented.) */
off_t
inode_write_at (struct inode *inode, const void *buffer_, off_t size,
                off_t offset) 
{
c002f447:	55                   	push   %ebp
c002f448:	89 e5                	mov    %esp,%ebp
c002f44a:	53                   	push   %ebx
c002f44b:	83 ec 34             	sub    $0x34,%esp
  const uint8_t *buffer = buffer_;
c002f44e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002f451:	89 45 ec             	mov    %eax,-0x14(%ebp)
  off_t bytes_written = 0;
c002f454:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  uint8_t *bounce = NULL;
c002f45b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if (inode->deny_write_cnt)
c002f462:	8b 45 08             	mov    0x8(%ebp),%eax
c002f465:	8b 40 14             	mov    0x14(%eax),%eax
c002f468:	85 c0                	test   %eax,%eax
c002f46a:	0f 84 55 01 00 00    	je     c002f5c5 <inode_write_at+0x17e>
    return 0;
c002f470:	b8 00 00 00 00       	mov    $0x0,%eax
c002f475:	e9 6c 01 00 00       	jmp    c002f5e6 <inode_write_at+0x19f>

  while (size > 0) 
    {
      /* Sector to write, starting byte offset within sector. */
      block_sector_t sector_idx = byte_to_sector (inode, offset);
c002f47a:	83 ec 08             	sub    $0x8,%esp
c002f47d:	ff 75 14             	pushl  0x14(%ebp)
c002f480:	ff 75 08             	pushl  0x8(%ebp)
c002f483:	e8 37 fb ff ff       	call   c002efbf <byte_to_sector>
c002f488:	83 c4 10             	add    $0x10,%esp
c002f48b:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002f48e:	8b 45 14             	mov    0x14(%ebp),%eax
c002f491:	25 ff 01 00 80       	and    $0x800001ff,%eax
c002f496:	85 c0                	test   %eax,%eax
c002f498:	79 07                	jns    c002f4a1 <inode_write_at+0x5a>
c002f49a:	48                   	dec    %eax
c002f49b:	0d 00 fe ff ff       	or     $0xfffffe00,%eax
c002f4a0:	40                   	inc    %eax
c002f4a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /* Bytes left in inode, bytes left in sector, lesser of the two. */
      off_t inode_left = inode_length (inode) - offset;
c002f4a4:	83 ec 0c             	sub    $0xc,%esp
c002f4a7:	ff 75 08             	pushl  0x8(%ebp)
c002f4aa:	e8 f9 01 00 00       	call   c002f6a8 <inode_length>
c002f4af:	83 c4 10             	add    $0x10,%esp
c002f4b2:	2b 45 14             	sub    0x14(%ebp),%eax
c002f4b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002f4b8:	b8 00 02 00 00       	mov    $0x200,%eax
c002f4bd:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002f4c0:	89 45 dc             	mov    %eax,-0x24(%ebp)
      int min_left = inode_left < sector_left ? inode_left : sector_left;
c002f4c3:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002f4c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f4c9:	39 d0                	cmp    %edx,%eax
c002f4cb:	7e 02                	jle    c002f4cf <inode_write_at+0x88>
c002f4cd:	89 d0                	mov    %edx,%eax
c002f4cf:	89 45 d8             	mov    %eax,-0x28(%ebp)

      /* Number of bytes to actually write into this sector. */
      int chunk_size = size < min_left ? size : min_left;
c002f4d2:	8b 55 10             	mov    0x10(%ebp),%edx
c002f4d5:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002f4d8:	39 d0                	cmp    %edx,%eax
c002f4da:	7e 02                	jle    c002f4de <inode_write_at+0x97>
c002f4dc:	89 d0                	mov    %edx,%eax
c002f4de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (chunk_size <= 0)
c002f4e1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002f4e5:	0f 8e e6 00 00 00    	jle    c002f5d1 <inode_write_at+0x18a>
        break;

      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002f4eb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002f4ef:	75 2b                	jne    c002f51c <inode_write_at+0xd5>
c002f4f1:	81 7d d4 00 02 00 00 	cmpl   $0x200,-0x2c(%ebp)
c002f4f8:	75 22                	jne    c002f51c <inode_write_at+0xd5>
        {
          /* Write full sector directly to disk. */
          block_write (fs_device, sector_idx, buffer + bytes_written);
c002f4fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002f4fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002f500:	01 c2                	add    %eax,%edx
c002f502:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002f507:	83 ec 04             	sub    $0x4,%esp
c002f50a:	52                   	push   %edx
c002f50b:	ff 75 e8             	pushl  -0x18(%ebp)
c002f50e:	50                   	push   %eax
c002f50f:	e8 57 60 ff ff       	call   c002556b <block_write>
c002f514:	83 c4 10             	add    $0x10,%esp
c002f517:	e9 97 00 00 00       	jmp    c002f5b3 <inode_write_at+0x16c>
        }
      else 
        {
          /* We need a bounce buffer. */
          if (bounce == NULL) 
c002f51c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002f520:	75 1d                	jne    c002f53f <inode_write_at+0xf8>
            {
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002f522:	83 ec 0c             	sub    $0xc,%esp
c002f525:	68 00 02 00 00       	push   $0x200
c002f52a:	e8 8b 45 ff ff       	call   c0023aba <malloc>
c002f52f:	83 c4 10             	add    $0x10,%esp
c002f532:	89 45 f0             	mov    %eax,-0x10(%ebp)
              if (bounce == NULL)
c002f535:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002f539:	0f 84 95 00 00 00    	je     c002f5d4 <inode_write_at+0x18d>
            }

          /* If the sector contains data before or after the chunk
             we're writing, then we need to read in the sector
             first.  Otherwise we start with a sector of all zeros. */
          if (sector_ofs > 0 || chunk_size < sector_left) 
c002f53f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002f543:	7f 08                	jg     c002f54d <inode_write_at+0x106>
c002f545:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f548:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c002f54b:	7d 19                	jge    c002f566 <inode_write_at+0x11f>
            block_read (fs_device, sector_idx, bounce);
c002f54d:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002f552:	83 ec 04             	sub    $0x4,%esp
c002f555:	ff 75 f0             	pushl  -0x10(%ebp)
c002f558:	ff 75 e8             	pushl  -0x18(%ebp)
c002f55b:	50                   	push   %eax
c002f55c:	e8 bb 5f ff ff       	call   c002551c <block_read>
c002f561:	83 c4 10             	add    $0x10,%esp
c002f564:	eb 15                	jmp    c002f57b <inode_write_at+0x134>
          else
            memset (bounce, 0, BLOCK_SECTOR_SIZE);
c002f566:	83 ec 04             	sub    $0x4,%esp
c002f569:	68 00 02 00 00       	push   $0x200
c002f56e:	6a 00                	push   $0x0
c002f570:	ff 75 f0             	pushl  -0x10(%ebp)
c002f573:	e8 3f 9a ff ff       	call   c0028fb7 <memset>
c002f578:	83 c4 10             	add    $0x10,%esp
          memcpy (bounce + sector_ofs, buffer + bytes_written, chunk_size);
c002f57b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f57e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c002f581:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002f584:	01 d1                	add    %edx,%ecx
c002f586:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002f589:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002f58c:	01 da                	add    %ebx,%edx
c002f58e:	83 ec 04             	sub    $0x4,%esp
c002f591:	50                   	push   %eax
c002f592:	51                   	push   %ecx
c002f593:	52                   	push   %edx
c002f594:	e8 44 94 ff ff       	call   c00289dd <memcpy>
c002f599:	83 c4 10             	add    $0x10,%esp
          block_write (fs_device, sector_idx, bounce);
c002f59c:	a1 04 a9 03 c0       	mov    0xc003a904,%eax
c002f5a1:	83 ec 04             	sub    $0x4,%esp
c002f5a4:	ff 75 f0             	pushl  -0x10(%ebp)
c002f5a7:	ff 75 e8             	pushl  -0x18(%ebp)
c002f5aa:	50                   	push   %eax
c002f5ab:	e8 bb 5f ff ff       	call   c002556b <block_write>
c002f5b0:	83 c4 10             	add    $0x10,%esp
        }

      /* Advance. */
      size -= chunk_size;
c002f5b3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f5b6:	29 45 10             	sub    %eax,0x10(%ebp)
      offset += chunk_size;
c002f5b9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f5bc:	01 45 14             	add    %eax,0x14(%ebp)
      bytes_written += chunk_size;
c002f5bf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f5c2:	01 45 f4             	add    %eax,-0xc(%ebp)
  while (size > 0) 
c002f5c5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002f5c9:	0f 8f ab fe ff ff    	jg     c002f47a <inode_write_at+0x33>
c002f5cf:	eb 04                	jmp    c002f5d5 <inode_write_at+0x18e>
        break;
c002f5d1:	90                   	nop
c002f5d2:	eb 01                	jmp    c002f5d5 <inode_write_at+0x18e>
                break;
c002f5d4:	90                   	nop
    }
  free (bounce);
c002f5d5:	83 ec 0c             	sub    $0xc,%esp
c002f5d8:	ff 75 f0             	pushl  -0x10(%ebp)
c002f5db:	e8 dc 47 ff ff       	call   c0023dbc <free>
c002f5e0:	83 c4 10             	add    $0x10,%esp

  return bytes_written;
c002f5e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002f5e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002f5e9:	c9                   	leave  
c002f5ea:	c3                   	ret    

c002f5eb <inode_deny_write>:

/* Disables writes to INODE.
   May be called at most once per inode opener. */
void
inode_deny_write (struct inode *inode) 
{
c002f5eb:	55                   	push   %ebp
c002f5ec:	89 e5                	mov    %esp,%ebp
c002f5ee:	83 ec 08             	sub    $0x8,%esp
  inode->deny_write_cnt++;
c002f5f1:	8b 45 08             	mov    0x8(%ebp),%eax
c002f5f4:	8b 40 14             	mov    0x14(%eax),%eax
c002f5f7:	8d 50 01             	lea    0x1(%eax),%edx
c002f5fa:	8b 45 08             	mov    0x8(%ebp),%eax
c002f5fd:	89 50 14             	mov    %edx,0x14(%eax)
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002f600:	8b 45 08             	mov    0x8(%ebp),%eax
c002f603:	8b 50 14             	mov    0x14(%eax),%edx
c002f606:	8b 45 08             	mov    0x8(%ebp),%eax
c002f609:	8b 40 0c             	mov    0xc(%eax),%eax
c002f60c:	39 c2                	cmp    %eax,%edx
c002f60e:	7e 21                	jle    c002f631 <inode_deny_write+0x46>
c002f610:	83 ec 0c             	sub    $0xc,%esp
c002f613:	68 b8 37 03 c0       	push   $0xc00337b8
c002f618:	68 7e 37 03 c0       	push   $0xc003377e
c002f61d:	68 2c 38 03 c0       	push   $0xc003382c
c002f622:	68 46 01 00 00       	push   $0x146
c002f627:	68 95 37 03 c0       	push   $0xc0033795
c002f62c:	e8 6c a5 ff ff       	call   c0029b9d <debug_panic>
}
c002f631:	90                   	nop
c002f632:	c9                   	leave  
c002f633:	c3                   	ret    

c002f634 <inode_allow_write>:
/* Re-enables writes to INODE.
   Must be called once by each inode opener who has called
   inode_deny_write() on the inode, before closing the inode. */
void
inode_allow_write (struct inode *inode) 
{
c002f634:	55                   	push   %ebp
c002f635:	89 e5                	mov    %esp,%ebp
c002f637:	83 ec 08             	sub    $0x8,%esp
  ASSERT (inode->deny_write_cnt > 0);
c002f63a:	8b 45 08             	mov    0x8(%ebp),%eax
c002f63d:	8b 40 14             	mov    0x14(%eax),%eax
c002f640:	85 c0                	test   %eax,%eax
c002f642:	7f 21                	jg     c002f665 <inode_allow_write+0x31>
c002f644:	83 ec 0c             	sub    $0xc,%esp
c002f647:	68 e1 37 03 c0       	push   $0xc00337e1
c002f64c:	68 7e 37 03 c0       	push   $0xc003377e
c002f651:	68 40 38 03 c0       	push   $0xc0033840
c002f656:	68 4f 01 00 00       	push   $0x14f
c002f65b:	68 95 37 03 c0       	push   $0xc0033795
c002f660:	e8 38 a5 ff ff       	call   c0029b9d <debug_panic>
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002f665:	8b 45 08             	mov    0x8(%ebp),%eax
c002f668:	8b 50 14             	mov    0x14(%eax),%edx
c002f66b:	8b 45 08             	mov    0x8(%ebp),%eax
c002f66e:	8b 40 0c             	mov    0xc(%eax),%eax
c002f671:	39 c2                	cmp    %eax,%edx
c002f673:	7e 21                	jle    c002f696 <inode_allow_write+0x62>
c002f675:	83 ec 0c             	sub    $0xc,%esp
c002f678:	68 b8 37 03 c0       	push   $0xc00337b8
c002f67d:	68 7e 37 03 c0       	push   $0xc003377e
c002f682:	68 40 38 03 c0       	push   $0xc0033840
c002f687:	68 50 01 00 00       	push   $0x150
c002f68c:	68 95 37 03 c0       	push   $0xc0033795
c002f691:	e8 07 a5 ff ff       	call   c0029b9d <debug_panic>
  inode->deny_write_cnt--;
c002f696:	8b 45 08             	mov    0x8(%ebp),%eax
c002f699:	8b 40 14             	mov    0x14(%eax),%eax
c002f69c:	8d 50 ff             	lea    -0x1(%eax),%edx
c002f69f:	8b 45 08             	mov    0x8(%ebp),%eax
c002f6a2:	89 50 14             	mov    %edx,0x14(%eax)
}
c002f6a5:	90                   	nop
c002f6a6:	c9                   	leave  
c002f6a7:	c3                   	ret    

c002f6a8 <inode_length>:

/* Returns the length, in bytes, of INODE's data. */
off_t
inode_length (const struct inode *inode)
{
c002f6a8:	55                   	push   %ebp
c002f6a9:	89 e5                	mov    %esp,%ebp
  return inode->data.length;
c002f6ab:	8b 45 08             	mov    0x8(%ebp),%eax
c002f6ae:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002f6b1:	5d                   	pop    %ebp
c002f6b2:	c3                   	ret    

c002f6b3 <fsutil_ls>:
#include "threads/vaddr.h"

/* List files in the root directory. */
void
fsutil_ls (char **argv UNUSED) 
{
c002f6b3:	55                   	push   %ebp
c002f6b4:	89 e5                	mov    %esp,%ebp
c002f6b6:	83 ec 28             	sub    $0x28,%esp
  struct dir *dir;
  char name[NAME_MAX + 1];
  
  printf ("Files in the root directory:\n");
c002f6b9:	83 ec 0c             	sub    $0xc,%esp
c002f6bc:	68 54 38 03 c0       	push   $0xc0033854
c002f6c1:	e8 a9 c7 ff ff       	call   c002be6f <puts>
c002f6c6:	83 c4 10             	add    $0x10,%esp
  dir = dir_open_root ();
c002f6c9:	e8 9e f4 ff ff       	call   c002eb6c <dir_open_root>
c002f6ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (dir == NULL)
c002f6d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002f6d5:	75 25                	jne    c002f6fc <fsutil_ls+0x49>
    PANIC ("root dir open failed");
c002f6d7:	68 71 38 03 c0       	push   $0xc0033871
c002f6dc:	68 fc 3a 03 c0       	push   $0xc0033afc
c002f6e1:	6a 18                	push   $0x18
c002f6e3:	68 86 38 03 c0       	push   $0xc0033886
c002f6e8:	e8 b0 a4 ff ff       	call   c0029b9d <debug_panic>
  while (dir_readdir (dir, name))
    printf ("%s\n", name);
c002f6ed:	83 ec 0c             	sub    $0xc,%esp
c002f6f0:	8d 45 e5             	lea    -0x1b(%ebp),%eax
c002f6f3:	50                   	push   %eax
c002f6f4:	e8 76 c7 ff ff       	call   c002be6f <puts>
c002f6f9:	83 c4 10             	add    $0x10,%esp
  while (dir_readdir (dir, name))
c002f6fc:	83 ec 08             	sub    $0x8,%esp
c002f6ff:	8d 45 e5             	lea    -0x1b(%ebp),%eax
c002f702:	50                   	push   %eax
c002f703:	ff 75 f4             	pushl  -0xc(%ebp)
c002f706:	e8 3c f8 ff ff       	call   c002ef47 <dir_readdir>
c002f70b:	83 c4 10             	add    $0x10,%esp
c002f70e:	84 c0                	test   %al,%al
c002f710:	75 db                	jne    c002f6ed <fsutil_ls+0x3a>
  dir_close (dir);
c002f712:	83 ec 0c             	sub    $0xc,%esp
c002f715:	ff 75 f4             	pushl  -0xc(%ebp)
c002f718:	e8 95 f4 ff ff       	call   c002ebb2 <dir_close>
c002f71d:	83 c4 10             	add    $0x10,%esp
  printf ("End of listing.\n");
c002f720:	83 ec 0c             	sub    $0xc,%esp
c002f723:	68 9d 38 03 c0       	push   $0xc003389d
c002f728:	e8 42 c7 ff ff       	call   c002be6f <puts>
c002f72d:	83 c4 10             	add    $0x10,%esp
}
c002f730:	90                   	nop
c002f731:	c9                   	leave  
c002f732:	c3                   	ret    

c002f733 <fsutil_cat>:

/* Prints the contents of file ARGV[1] to the system console as
   hex and ASCII. */
void
fsutil_cat (char **argv)
{
c002f733:	55                   	push   %ebp
c002f734:	89 e5                	mov    %esp,%ebp
c002f736:	83 ec 28             	sub    $0x28,%esp
  const char *file_name = argv[1];
c002f739:	8b 45 08             	mov    0x8(%ebp),%eax
c002f73c:	8b 40 04             	mov    0x4(%eax),%eax
c002f73f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  struct file *file;
  char *buffer;

  printf ("Printing '%s' to the console...\n", file_name);
c002f742:	83 ec 08             	sub    $0x8,%esp
c002f745:	ff 75 f4             	pushl  -0xc(%ebp)
c002f748:	68 b0 38 03 c0       	push   $0xc00338b0
c002f74d:	e8 8c 80 ff ff       	call   c00277de <printf>
c002f752:	83 c4 10             	add    $0x10,%esp
  file = filesys_open (file_name);
c002f755:	83 ec 0c             	sub    $0xc,%esp
c002f758:	ff 75 f4             	pushl  -0xc(%ebp)
c002f75b:	e8 e6 ec ff ff       	call   c002e446 <filesys_open>
c002f760:	83 c4 10             	add    $0x10,%esp
c002f763:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (file == NULL)
c002f766:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002f76a:	75 1c                	jne    c002f788 <fsutil_cat+0x55>
    PANIC ("%s: open failed", file_name);
c002f76c:	83 ec 0c             	sub    $0xc,%esp
c002f76f:	ff 75 f4             	pushl  -0xc(%ebp)
c002f772:	68 d1 38 03 c0       	push   $0xc00338d1
c002f777:	68 08 3b 03 c0       	push   $0xc0033b08
c002f77c:	6a 2c                	push   $0x2c
c002f77e:	68 86 38 03 c0       	push   $0xc0033886
c002f783:	e8 15 a4 ff ff       	call   c0029b9d <debug_panic>
  buffer = palloc_get_page (PAL_ASSERT);
c002f788:	83 ec 0c             	sub    $0xc,%esp
c002f78b:	6a 01                	push   $0x1
c002f78d:	e8 dd 3f ff ff       	call   c002376f <palloc_get_page>
c002f792:	83 c4 10             	add    $0x10,%esp
c002f795:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for (;;) 
    {
      off_t pos = file_tell (file);
c002f798:	83 ec 0c             	sub    $0xc,%esp
c002f79b:	ff 75 f0             	pushl  -0x10(%ebp)
c002f79e:	e8 12 f3 ff ff       	call   c002eab5 <file_tell>
c002f7a3:	83 c4 10             	add    $0x10,%esp
c002f7a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
      off_t n = file_read (file, buffer, PGSIZE);
c002f7a9:	83 ec 04             	sub    $0x4,%esp
c002f7ac:	68 00 10 00 00       	push   $0x1000
c002f7b1:	ff 75 ec             	pushl  -0x14(%ebp)
c002f7b4:	ff 75 f0             	pushl  -0x10(%ebp)
c002f7b7:	e8 03 f1 ff ff       	call   c002e8bf <file_read>
c002f7bc:	83 c4 10             	add    $0x10,%esp
c002f7bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if (n == 0)
c002f7c2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002f7c6:	74 17                	je     c002f7df <fsutil_cat+0xac>
        break;

      hex_dump (pos, buffer, n, true); 
c002f7c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002f7cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002f7ce:	6a 01                	push   $0x1
c002f7d0:	52                   	push   %edx
c002f7d1:	ff 75 ec             	pushl  -0x14(%ebp)
c002f7d4:	50                   	push   %eax
c002f7d5:	e8 3b 8b ff ff       	call   c0028315 <hex_dump>
c002f7da:	83 c4 10             	add    $0x10,%esp
    {
c002f7dd:	eb b9                	jmp    c002f798 <fsutil_cat+0x65>
        break;
c002f7df:	90                   	nop
    }
  palloc_free_page (buffer);
c002f7e0:	83 ec 0c             	sub    $0xc,%esp
c002f7e3:	ff 75 ec             	pushl  -0x14(%ebp)
c002f7e6:	e8 dc 40 ff ff       	call   c00238c7 <palloc_free_page>
c002f7eb:	83 c4 10             	add    $0x10,%esp
  file_close (file);
c002f7ee:	83 ec 0c             	sub    $0xc,%esp
c002f7f1:	ff 75 f0             	pushl  -0x10(%ebp)
c002f7f4:	e8 80 f0 ff ff       	call   c002e879 <file_close>
c002f7f9:	83 c4 10             	add    $0x10,%esp
}
c002f7fc:	90                   	nop
c002f7fd:	c9                   	leave  
c002f7fe:	c3                   	ret    

c002f7ff <fsutil_rm>:

/* Deletes file ARGV[1]. */
void
fsutil_rm (char **argv) 
{
c002f7ff:	55                   	push   %ebp
c002f800:	89 e5                	mov    %esp,%ebp
c002f802:	83 ec 18             	sub    $0x18,%esp
  const char *file_name = argv[1];
c002f805:	8b 45 08             	mov    0x8(%ebp),%eax
c002f808:	8b 40 04             	mov    0x4(%eax),%eax
c002f80b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Deleting '%s'...\n", file_name);
c002f80e:	83 ec 08             	sub    $0x8,%esp
c002f811:	ff 75 f4             	pushl  -0xc(%ebp)
c002f814:	68 e1 38 03 c0       	push   $0xc00338e1
c002f819:	e8 c0 7f ff ff       	call   c00277de <printf>
c002f81e:	83 c4 10             	add    $0x10,%esp
  if (!filesys_remove (file_name))
c002f821:	83 ec 0c             	sub    $0xc,%esp
c002f824:	ff 75 f4             	pushl  -0xc(%ebp)
c002f827:	e8 69 ec ff ff       	call   c002e495 <filesys_remove>
c002f82c:	83 c4 10             	add    $0x10,%esp
c002f82f:	83 f0 01             	xor    $0x1,%eax
c002f832:	84 c0                	test   %al,%al
c002f834:	74 1c                	je     c002f852 <fsutil_rm+0x53>
    PANIC ("%s: delete failed\n", file_name);
c002f836:	83 ec 0c             	sub    $0xc,%esp
c002f839:	ff 75 f4             	pushl  -0xc(%ebp)
c002f83c:	68 f3 38 03 c0       	push   $0xc00338f3
c002f841:	68 14 3b 03 c0       	push   $0xc0033b14
c002f846:	6a 43                	push   $0x43
c002f848:	68 86 38 03 c0       	push   $0xc0033886
c002f84d:	e8 4b a3 ff ff       	call   c0029b9d <debug_panic>
}
c002f852:	90                   	nop
c002f853:	c9                   	leave  
c002f854:	c3                   	ret    

c002f855 <fsutil_extract>:

/* Extracts a ustar-format tar archive from the scratch block
   device into the Pintos file system. */
void
fsutil_extract (char **argv UNUSED) 
{
c002f855:	55                   	push   %ebp
c002f856:	89 e5                	mov    %esp,%ebp
c002f858:	83 ec 38             	sub    $0x38,%esp

  struct block *src;
  void *header, *data;

  /* Allocate buffers. */
  header = malloc (BLOCK_SECTOR_SIZE);
c002f85b:	83 ec 0c             	sub    $0xc,%esp
c002f85e:	68 00 02 00 00       	push   $0x200
c002f863:	e8 52 42 ff ff       	call   c0023aba <malloc>
c002f868:	83 c4 10             	add    $0x10,%esp
c002f86b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  data = malloc (BLOCK_SECTOR_SIZE);
c002f86e:	83 ec 0c             	sub    $0xc,%esp
c002f871:	68 00 02 00 00       	push   $0x200
c002f876:	e8 3f 42 ff ff       	call   c0023aba <malloc>
c002f87b:	83 c4 10             	add    $0x10,%esp
c002f87e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (header == NULL || data == NULL)
c002f881:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002f885:	74 06                	je     c002f88d <fsutil_extract+0x38>
c002f887:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002f88b:	75 16                	jne    c002f8a3 <fsutil_extract+0x4e>
    PANIC ("couldn't allocate buffers");
c002f88d:	68 06 39 03 c0       	push   $0xc0033906
c002f892:	68 20 3b 03 c0       	push   $0xc0033b20
c002f897:	6a 54                	push   $0x54
c002f899:	68 86 38 03 c0       	push   $0xc0033886
c002f89e:	e8 fa a2 ff ff       	call   c0029b9d <debug_panic>

  /* Open source block device. */
  src = block_get_role (BLOCK_SCRATCH);
c002f8a3:	83 ec 0c             	sub    $0xc,%esp
c002f8a6:	6a 02                	push   $0x2
c002f8a8:	e8 fc 5a ff ff       	call   c00253a9 <block_get_role>
c002f8ad:	83 c4 10             	add    $0x10,%esp
c002f8b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (src == NULL)
c002f8b3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002f8b7:	75 16                	jne    c002f8cf <fsutil_extract+0x7a>
    PANIC ("couldn't open scratch device");
c002f8b9:	68 20 39 03 c0       	push   $0xc0033920
c002f8be:	68 20 3b 03 c0       	push   $0xc0033b20
c002f8c3:	6a 59                	push   $0x59
c002f8c5:	68 86 38 03 c0       	push   $0xc0033886
c002f8ca:	e8 ce a2 ff ff       	call   c0029b9d <debug_panic>

  printf ("Extracting ustar archive from scratch device "
c002f8cf:	83 ec 0c             	sub    $0xc,%esp
c002f8d2:	68 40 39 03 c0       	push   $0xc0033940
c002f8d7:	e8 93 c5 ff ff       	call   c002be6f <puts>
c002f8dc:	83 c4 10             	add    $0x10,%esp
      const char *error;
      enum ustar_type type;
      int size;

      /* Read and parse ustar header. */
      block_read (src, sector++, header);
c002f8df:	a1 c0 a8 03 c0       	mov    0xc003a8c0,%eax
c002f8e4:	8d 50 01             	lea    0x1(%eax),%edx
c002f8e7:	89 15 c0 a8 03 c0    	mov    %edx,0xc003a8c0
c002f8ed:	83 ec 04             	sub    $0x4,%esp
c002f8f0:	ff 75 f4             	pushl  -0xc(%ebp)
c002f8f3:	50                   	push   %eax
c002f8f4:	ff 75 ec             	pushl  -0x14(%ebp)
c002f8f7:	e8 20 5c ff ff       	call   c002551c <block_read>
c002f8fc:	83 c4 10             	add    $0x10,%esp
      error = ustar_parse_header (header, &file_name, &type, &size);
c002f8ff:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002f902:	50                   	push   %eax
c002f903:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002f906:	50                   	push   %eax
c002f907:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002f90a:	50                   	push   %eax
c002f90b:	ff 75 f4             	pushl  -0xc(%ebp)
c002f90e:	e8 e9 a0 ff ff       	call   c00299fc <ustar_parse_header>
c002f913:	83 c4 10             	add    $0x10,%esp
c002f916:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (error != NULL)
c002f919:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002f91d:	74 23                	je     c002f942 <fsutil_extract+0xed>
        PANIC ("bad ustar header in sector %"PRDSNu" (%s)", sector - 1, error);
c002f91f:	a1 c0 a8 03 c0       	mov    0xc003a8c0,%eax
c002f924:	48                   	dec    %eax
c002f925:	83 ec 08             	sub    $0x8,%esp
c002f928:	ff 75 e8             	pushl  -0x18(%ebp)
c002f92b:	50                   	push   %eax
c002f92c:	68 84 39 03 c0       	push   $0xc0033984
c002f931:	68 20 3b 03 c0       	push   $0xc0033b20
c002f936:	6a 69                	push   $0x69
c002f938:	68 86 38 03 c0       	push   $0xc0033886
c002f93d:	e8 5b a2 ff ff       	call   c0029b9d <debug_panic>

      if (type == USTAR_EOF)
c002f942:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002f945:	83 f8 ff             	cmp    $0xffffffff,%eax
c002f948:	75 6c                	jne    c002f9b6 <fsutil_extract+0x161>

  /* Erase the ustar header from the start of the block device,
     so that the extraction operation is idempotent.  We erase
     two blocks because two blocks of zeros are the ustar
     end-of-archive marker. */
  printf ("Erasing ustar archive...\n");
c002f94a:	83 ec 0c             	sub    $0xc,%esp
c002f94d:	68 a7 39 03 c0       	push   $0xc00339a7
c002f952:	e8 18 c5 ff ff       	call   c002be6f <puts>
c002f957:	83 c4 10             	add    $0x10,%esp
  memset (header, 0, BLOCK_SECTOR_SIZE);
c002f95a:	83 ec 04             	sub    $0x4,%esp
c002f95d:	68 00 02 00 00       	push   $0x200
c002f962:	6a 00                	push   $0x0
c002f964:	ff 75 f4             	pushl  -0xc(%ebp)
c002f967:	e8 4b 96 ff ff       	call   c0028fb7 <memset>
c002f96c:	83 c4 10             	add    $0x10,%esp
  block_write (src, 0, header);
c002f96f:	83 ec 04             	sub    $0x4,%esp
c002f972:	ff 75 f4             	pushl  -0xc(%ebp)
c002f975:	6a 00                	push   $0x0
c002f977:	ff 75 ec             	pushl  -0x14(%ebp)
c002f97a:	e8 ec 5b ff ff       	call   c002556b <block_write>
c002f97f:	83 c4 10             	add    $0x10,%esp
  block_write (src, 1, header);
c002f982:	83 ec 04             	sub    $0x4,%esp
c002f985:	ff 75 f4             	pushl  -0xc(%ebp)
c002f988:	6a 01                	push   $0x1
c002f98a:	ff 75 ec             	pushl  -0x14(%ebp)
c002f98d:	e8 d9 5b ff ff       	call   c002556b <block_write>
c002f992:	83 c4 10             	add    $0x10,%esp

  free (data);
c002f995:	83 ec 0c             	sub    $0xc,%esp
c002f998:	ff 75 f0             	pushl  -0x10(%ebp)
c002f99b:	e8 1c 44 ff ff       	call   c0023dbc <free>
c002f9a0:	83 c4 10             	add    $0x10,%esp
  free (header);
c002f9a3:	83 ec 0c             	sub    $0xc,%esp
c002f9a6:	ff 75 f4             	pushl  -0xc(%ebp)
c002f9a9:	e8 0e 44 ff ff       	call   c0023dbc <free>
c002f9ae:	83 c4 10             	add    $0x10,%esp
}
c002f9b1:	e9 43 01 00 00       	jmp    c002faf9 <fsutil_extract+0x2a4>
      else if (type == USTAR_DIRECTORY)
c002f9b6:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002f9b9:	83 f8 35             	cmp    $0x35,%eax
c002f9bc:	75 19                	jne    c002f9d7 <fsutil_extract+0x182>
        printf ("ignoring directory %s\n", file_name);
c002f9be:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f9c1:	83 ec 08             	sub    $0x8,%esp
c002f9c4:	50                   	push   %eax
c002f9c5:	68 c0 39 03 c0       	push   $0xc00339c0
c002f9ca:	e8 0f 7e ff ff       	call   c00277de <printf>
c002f9cf:	83 c4 10             	add    $0x10,%esp
c002f9d2:	e9 08 ff ff ff       	jmp    c002f8df <fsutil_extract+0x8a>
      else if (type == USTAR_REGULAR)
c002f9d7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002f9da:	83 f8 30             	cmp    $0x30,%eax
c002f9dd:	0f 85 fc fe ff ff    	jne    c002f8df <fsutil_extract+0x8a>
          printf ("Putting '%s' into the file system...\n", file_name);
c002f9e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f9e6:	83 ec 08             	sub    $0x8,%esp
c002f9e9:	50                   	push   %eax
c002f9ea:	68 d8 39 03 c0       	push   $0xc00339d8
c002f9ef:	e8 ea 7d ff ff       	call   c00277de <printf>
c002f9f4:	83 c4 10             	add    $0x10,%esp
          if (!filesys_create (file_name, size))
c002f9f7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002f9fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f9fd:	83 ec 08             	sub    $0x8,%esp
c002fa00:	52                   	push   %edx
c002fa01:	50                   	push   %eax
c002fa02:	e8 98 e9 ff ff       	call   c002e39f <filesys_create>
c002fa07:	83 c4 10             	add    $0x10,%esp
c002fa0a:	83 f0 01             	xor    $0x1,%eax
c002fa0d:	84 c0                	test   %al,%al
c002fa0f:	74 1d                	je     c002fa2e <fsutil_extract+0x1d9>
            PANIC ("%s: create failed", file_name);
c002fa11:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002fa14:	83 ec 0c             	sub    $0xc,%esp
c002fa17:	50                   	push   %eax
c002fa18:	68 fe 39 03 c0       	push   $0xc00339fe
c002fa1d:	68 20 3b 03 c0       	push   $0xc0033b20
c002fa22:	6a 7a                	push   $0x7a
c002fa24:	68 86 38 03 c0       	push   $0xc0033886
c002fa29:	e8 6f a1 ff ff       	call   c0029b9d <debug_panic>
          dst = filesys_open (file_name);
c002fa2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002fa31:	83 ec 0c             	sub    $0xc,%esp
c002fa34:	50                   	push   %eax
c002fa35:	e8 0c ea ff ff       	call   c002e446 <filesys_open>
c002fa3a:	83 c4 10             	add    $0x10,%esp
c002fa3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          if (dst == NULL)
c002fa40:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002fa44:	0f 85 95 00 00 00    	jne    c002fadf <fsutil_extract+0x28a>
            PANIC ("%s: open failed", file_name);
c002fa4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002fa4d:	83 ec 0c             	sub    $0xc,%esp
c002fa50:	50                   	push   %eax
c002fa51:	68 d1 38 03 c0       	push   $0xc00338d1
c002fa56:	68 20 3b 03 c0       	push   $0xc0033b20
c002fa5b:	6a 7d                	push   $0x7d
c002fa5d:	68 86 38 03 c0       	push   $0xc0033886
c002fa62:	e8 36 a1 ff ff       	call   c0029b9d <debug_panic>
                                : size);
c002fa67:	8b 45 d4             	mov    -0x2c(%ebp),%eax
              int chunk_size = (size > BLOCK_SECTOR_SIZE
c002fa6a:	3d 00 02 00 00       	cmp    $0x200,%eax
c002fa6f:	7e 05                	jle    c002fa76 <fsutil_extract+0x221>
c002fa71:	b8 00 02 00 00       	mov    $0x200,%eax
c002fa76:	89 45 e0             	mov    %eax,-0x20(%ebp)
              block_read (src, sector++, data);
c002fa79:	a1 c0 a8 03 c0       	mov    0xc003a8c0,%eax
c002fa7e:	8d 50 01             	lea    0x1(%eax),%edx
c002fa81:	89 15 c0 a8 03 c0    	mov    %edx,0xc003a8c0
c002fa87:	83 ec 04             	sub    $0x4,%esp
c002fa8a:	ff 75 f0             	pushl  -0x10(%ebp)
c002fa8d:	50                   	push   %eax
c002fa8e:	ff 75 ec             	pushl  -0x14(%ebp)
c002fa91:	e8 86 5a ff ff       	call   c002551c <block_read>
c002fa96:	83 c4 10             	add    $0x10,%esp
              if (file_write (dst, data, chunk_size) != chunk_size)
c002fa99:	83 ec 04             	sub    $0x4,%esp
c002fa9c:	ff 75 e0             	pushl  -0x20(%ebp)
c002fa9f:	ff 75 f0             	pushl  -0x10(%ebp)
c002faa2:	ff 75 e4             	pushl  -0x1c(%ebp)
c002faa5:	e8 6e ee ff ff       	call   c002e918 <file_write>
c002faaa:	83 c4 10             	add    $0x10,%esp
c002faad:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c002fab0:	74 24                	je     c002fad6 <fsutil_extract+0x281>
                PANIC ("%s: write failed with %d bytes unwritten",
c002fab2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002fab5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002fab8:	83 ec 08             	sub    $0x8,%esp
c002fabb:	52                   	push   %edx
c002fabc:	50                   	push   %eax
c002fabd:	68 10 3a 03 c0       	push   $0xc0033a10
c002fac2:	68 20 3b 03 c0       	push   $0xc0033b20
c002fac7:	68 88 00 00 00       	push   $0x88
c002facc:	68 86 38 03 c0       	push   $0xc0033886
c002fad1:	e8 c7 a0 ff ff       	call   c0029b9d <debug_panic>
              size -= chunk_size;
c002fad6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002fad9:	2b 45 e0             	sub    -0x20(%ebp),%eax
c002fadc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          while (size > 0)
c002fadf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002fae2:	85 c0                	test   %eax,%eax
c002fae4:	7f 81                	jg     c002fa67 <fsutil_extract+0x212>
          file_close (dst);
c002fae6:	83 ec 0c             	sub    $0xc,%esp
c002fae9:	ff 75 e4             	pushl  -0x1c(%ebp)
c002faec:	e8 88 ed ff ff       	call   c002e879 <file_close>
c002faf1:	83 c4 10             	add    $0x10,%esp
    {
c002faf4:	e9 e6 fd ff ff       	jmp    c002f8df <fsutil_extract+0x8a>
}
c002faf9:	c9                   	leave  
c002fafa:	c3                   	ret    

c002fafb <fsutil_append>:
   the device.  This position is independent of that used for
   fsutil_extract(), so `extract' should precede all
   `append's. */
void
fsutil_append (char **argv)
{
c002fafb:	55                   	push   %ebp
c002fafc:	89 e5                	mov    %esp,%ebp
c002fafe:	83 ec 28             	sub    $0x28,%esp
  static block_sector_t sector = 0;

  const char *file_name = argv[1];
c002fb01:	8b 45 08             	mov    0x8(%ebp),%eax
c002fb04:	8b 40 04             	mov    0x4(%eax),%eax
c002fb07:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *buffer;
  struct file *src;
  struct block *dst;
  off_t size;

  printf ("Appending '%s' to ustar archive on scratch device...\n", file_name);
c002fb0a:	83 ec 08             	sub    $0x8,%esp
c002fb0d:	ff 75 f0             	pushl  -0x10(%ebp)
c002fb10:	68 3c 3a 03 c0       	push   $0xc0033a3c
c002fb15:	e8 c4 7c ff ff       	call   c00277de <printf>
c002fb1a:	83 c4 10             	add    $0x10,%esp

  /* Allocate buffer. */
  buffer = malloc (BLOCK_SECTOR_SIZE);
c002fb1d:	83 ec 0c             	sub    $0xc,%esp
c002fb20:	68 00 02 00 00       	push   $0x200
c002fb25:	e8 90 3f ff ff       	call   c0023aba <malloc>
c002fb2a:	83 c4 10             	add    $0x10,%esp
c002fb2d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (buffer == NULL)
c002fb30:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002fb34:	75 19                	jne    c002fb4f <fsutil_append+0x54>
    PANIC ("couldn't allocate buffer");
c002fb36:	68 72 3a 03 c0       	push   $0xc0033a72
c002fb3b:	68 30 3b 03 c0       	push   $0xc0033b30
c002fb40:	68 b6 00 00 00       	push   $0xb6
c002fb45:	68 86 38 03 c0       	push   $0xc0033886
c002fb4a:	e8 4e a0 ff ff       	call   c0029b9d <debug_panic>

  /* Open source file. */
  src = filesys_open (file_name);
c002fb4f:	83 ec 0c             	sub    $0xc,%esp
c002fb52:	ff 75 f0             	pushl  -0x10(%ebp)
c002fb55:	e8 ec e8 ff ff       	call   c002e446 <filesys_open>
c002fb5a:	83 c4 10             	add    $0x10,%esp
c002fb5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if (src == NULL)
c002fb60:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002fb64:	75 1f                	jne    c002fb85 <fsutil_append+0x8a>
    PANIC ("%s: open failed", file_name);
c002fb66:	83 ec 0c             	sub    $0xc,%esp
c002fb69:	ff 75 f0             	pushl  -0x10(%ebp)
c002fb6c:	68 d1 38 03 c0       	push   $0xc00338d1
c002fb71:	68 30 3b 03 c0       	push   $0xc0033b30
c002fb76:	68 bb 00 00 00       	push   $0xbb
c002fb7b:	68 86 38 03 c0       	push   $0xc0033886
c002fb80:	e8 18 a0 ff ff       	call   c0029b9d <debug_panic>
  size = file_length (src);
c002fb85:	83 ec 0c             	sub    $0xc,%esp
c002fb88:	ff 75 e8             	pushl  -0x18(%ebp)
c002fb8b:	e8 85 ee ff ff       	call   c002ea15 <file_length>
c002fb90:	83 c4 10             	add    $0x10,%esp
c002fb93:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Open target block device. */
  dst = block_get_role (BLOCK_SCRATCH);
c002fb96:	83 ec 0c             	sub    $0xc,%esp
c002fb99:	6a 02                	push   $0x2
c002fb9b:	e8 09 58 ff ff       	call   c00253a9 <block_get_role>
c002fba0:	83 c4 10             	add    $0x10,%esp
c002fba3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (dst == NULL)
c002fba6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002fbaa:	75 19                	jne    c002fbc5 <fsutil_append+0xca>
    PANIC ("couldn't open scratch device");
c002fbac:	68 20 39 03 c0       	push   $0xc0033920
c002fbb1:	68 30 3b 03 c0       	push   $0xc0033b30
c002fbb6:	68 c1 00 00 00       	push   $0xc1
c002fbbb:	68 86 38 03 c0       	push   $0xc0033886
c002fbc0:	e8 d8 9f ff ff       	call   c0029b9d <debug_panic>
  
  /* Write ustar header to first sector. */
  if (!ustar_make_header (file_name, USTAR_REGULAR, size, buffer))
c002fbc5:	ff 75 ec             	pushl  -0x14(%ebp)
c002fbc8:	ff 75 f4             	pushl  -0xc(%ebp)
c002fbcb:	6a 30                	push   $0x30
c002fbcd:	ff 75 f0             	pushl  -0x10(%ebp)
c002fbd0:	e8 a8 9b ff ff       	call   c002977d <ustar_make_header>
c002fbd5:	83 c4 10             	add    $0x10,%esp
c002fbd8:	83 f0 01             	xor    $0x1,%eax
c002fbdb:	84 c0                	test   %al,%al
c002fbdd:	74 1f                	je     c002fbfe <fsutil_append+0x103>
    PANIC ("%s: name too long for ustar format", file_name);
c002fbdf:	83 ec 0c             	sub    $0xc,%esp
c002fbe2:	ff 75 f0             	pushl  -0x10(%ebp)
c002fbe5:	68 8c 3a 03 c0       	push   $0xc0033a8c
c002fbea:	68 30 3b 03 c0       	push   $0xc0033b30
c002fbef:	68 c5 00 00 00       	push   $0xc5
c002fbf4:	68 86 38 03 c0       	push   $0xc0033886
c002fbf9:	e8 9f 9f ff ff       	call   c0029b9d <debug_panic>
  block_write (dst, sector++, buffer);
c002fbfe:	a1 c4 a8 03 c0       	mov    0xc003a8c4,%eax
c002fc03:	8d 50 01             	lea    0x1(%eax),%edx
c002fc06:	89 15 c4 a8 03 c0    	mov    %edx,0xc003a8c4
c002fc0c:	83 ec 04             	sub    $0x4,%esp
c002fc0f:	ff 75 ec             	pushl  -0x14(%ebp)
c002fc12:	50                   	push   %eax
c002fc13:	ff 75 e4             	pushl  -0x1c(%ebp)
c002fc16:	e8 50 59 ff ff       	call   c002556b <block_write>
c002fc1b:	83 c4 10             	add    $0x10,%esp

  /* Do copy. */
  while (size > 0) 
c002fc1e:	e9 cc 00 00 00       	jmp    c002fcef <fsutil_append+0x1f4>
    {
      int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
c002fc23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002fc26:	3d 00 02 00 00       	cmp    $0x200,%eax
c002fc2b:	7e 05                	jle    c002fc32 <fsutil_append+0x137>
c002fc2d:	b8 00 02 00 00       	mov    $0x200,%eax
c002fc32:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (sector >= block_size (dst))
c002fc35:	83 ec 0c             	sub    $0xc,%esp
c002fc38:	ff 75 e4             	pushl  -0x1c(%ebp)
c002fc3b:	e8 a7 59 ff ff       	call   c00255e7 <block_size>
c002fc40:	83 c4 10             	add    $0x10,%esp
c002fc43:	89 c2                	mov    %eax,%edx
c002fc45:	a1 c4 a8 03 c0       	mov    0xc003a8c4,%eax
c002fc4a:	39 c2                	cmp    %eax,%edx
c002fc4c:	77 1f                	ja     c002fc6d <fsutil_append+0x172>
        PANIC ("%s: out of space on scratch device", file_name);
c002fc4e:	83 ec 0c             	sub    $0xc,%esp
c002fc51:	ff 75 f0             	pushl  -0x10(%ebp)
c002fc54:	68 b0 3a 03 c0       	push   $0xc0033ab0
c002fc59:	68 30 3b 03 c0       	push   $0xc0033b30
c002fc5e:	68 cd 00 00 00       	push   $0xcd
c002fc63:	68 86 38 03 c0       	push   $0xc0033886
c002fc68:	e8 30 9f ff ff       	call   c0029b9d <debug_panic>
      if (file_read (src, buffer, chunk_size) != chunk_size)
c002fc6d:	83 ec 04             	sub    $0x4,%esp
c002fc70:	ff 75 e0             	pushl  -0x20(%ebp)
c002fc73:	ff 75 ec             	pushl  -0x14(%ebp)
c002fc76:	ff 75 e8             	pushl  -0x18(%ebp)
c002fc79:	e8 41 ec ff ff       	call   c002e8bf <file_read>
c002fc7e:	83 c4 10             	add    $0x10,%esp
c002fc81:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c002fc84:	74 22                	je     c002fca8 <fsutil_append+0x1ad>
        PANIC ("%s: read failed with %"PROTd" bytes unread", file_name, size);
c002fc86:	83 ec 08             	sub    $0x8,%esp
c002fc89:	ff 75 f4             	pushl  -0xc(%ebp)
c002fc8c:	ff 75 f0             	pushl  -0x10(%ebp)
c002fc8f:	68 d4 3a 03 c0       	push   $0xc0033ad4
c002fc94:	68 30 3b 03 c0       	push   $0xc0033b30
c002fc99:	68 cf 00 00 00       	push   $0xcf
c002fc9e:	68 86 38 03 c0       	push   $0xc0033886
c002fca3:	e8 f5 9e ff ff       	call   c0029b9d <debug_panic>
      memset (buffer + chunk_size, 0, BLOCK_SECTOR_SIZE - chunk_size);
c002fca8:	b8 00 02 00 00       	mov    $0x200,%eax
c002fcad:	2b 45 e0             	sub    -0x20(%ebp),%eax
c002fcb0:	89 c2                	mov    %eax,%edx
c002fcb2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002fcb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002fcb8:	01 c8                	add    %ecx,%eax
c002fcba:	83 ec 04             	sub    $0x4,%esp
c002fcbd:	52                   	push   %edx
c002fcbe:	6a 00                	push   $0x0
c002fcc0:	50                   	push   %eax
c002fcc1:	e8 f1 92 ff ff       	call   c0028fb7 <memset>
c002fcc6:	83 c4 10             	add    $0x10,%esp
      block_write (dst, sector++, buffer);
c002fcc9:	a1 c4 a8 03 c0       	mov    0xc003a8c4,%eax
c002fcce:	8d 50 01             	lea    0x1(%eax),%edx
c002fcd1:	89 15 c4 a8 03 c0    	mov    %edx,0xc003a8c4
c002fcd7:	83 ec 04             	sub    $0x4,%esp
c002fcda:	ff 75 ec             	pushl  -0x14(%ebp)
c002fcdd:	50                   	push   %eax
c002fcde:	ff 75 e4             	pushl  -0x1c(%ebp)
c002fce1:	e8 85 58 ff ff       	call   c002556b <block_write>
c002fce6:	83 c4 10             	add    $0x10,%esp
      size -= chunk_size;
c002fce9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002fcec:	29 45 f4             	sub    %eax,-0xc(%ebp)
  while (size > 0) 
c002fcef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002fcf3:	0f 8f 2a ff ff ff    	jg     c002fc23 <fsutil_append+0x128>
    }

  /* Write ustar end-of-archive marker, which is two consecutive
     sectors full of zeros.  Don't advance our position past
     them, though, in case we have more files to append. */
  memset (buffer, 0, BLOCK_SECTOR_SIZE);
c002fcf9:	83 ec 04             	sub    $0x4,%esp
c002fcfc:	68 00 02 00 00       	push   $0x200
c002fd01:	6a 00                	push   $0x0
c002fd03:	ff 75 ec             	pushl  -0x14(%ebp)
c002fd06:	e8 ac 92 ff ff       	call   c0028fb7 <memset>
c002fd0b:	83 c4 10             	add    $0x10,%esp
  block_write (dst, sector, buffer);
c002fd0e:	a1 c4 a8 03 c0       	mov    0xc003a8c4,%eax
c002fd13:	83 ec 04             	sub    $0x4,%esp
c002fd16:	ff 75 ec             	pushl  -0x14(%ebp)
c002fd19:	50                   	push   %eax
c002fd1a:	ff 75 e4             	pushl  -0x1c(%ebp)
c002fd1d:	e8 49 58 ff ff       	call   c002556b <block_write>
c002fd22:	83 c4 10             	add    $0x10,%esp
  block_write (dst, sector, buffer + 1);
c002fd25:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002fd28:	8d 50 01             	lea    0x1(%eax),%edx
c002fd2b:	a1 c4 a8 03 c0       	mov    0xc003a8c4,%eax
c002fd30:	83 ec 04             	sub    $0x4,%esp
c002fd33:	52                   	push   %edx
c002fd34:	50                   	push   %eax
c002fd35:	ff 75 e4             	pushl  -0x1c(%ebp)
c002fd38:	e8 2e 58 ff ff       	call   c002556b <block_write>
c002fd3d:	83 c4 10             	add    $0x10,%esp

  /* Finish up. */
  file_close (src);
c002fd40:	83 ec 0c             	sub    $0xc,%esp
c002fd43:	ff 75 e8             	pushl  -0x18(%ebp)
c002fd46:	e8 2e eb ff ff       	call   c002e879 <file_close>
c002fd4b:	83 c4 10             	add    $0x10,%esp
  free (buffer);
c002fd4e:	83 ec 0c             	sub    $0xc,%esp
c002fd51:	ff 75 ec             	pushl  -0x14(%ebp)
c002fd54:	e8 63 40 ff ff       	call   c0023dbc <free>
c002fd59:	83 c4 10             	add    $0x10,%esp
}
c002fd5c:	90                   	nop
c002fd5d:	c9                   	leave  
c002fd5e:	c3                   	ret    
